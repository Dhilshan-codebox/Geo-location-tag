(function(){"use strict";try{if(typeof document<"u"){var l=document.createElement("style");l.appendChild(document.createTextNode(`.maplibregl-map{font:12px/20px Helvetica Neue,Arial,Helvetica,sans-serif;overflow:hidden;position:relative;-webkit-tap-highlight-color:rgb(0,0,0,0)}.maplibregl-canvas{left:0;position:absolute;top:0}.maplibregl-map:fullscreen{height:100%;width:100%}.maplibregl-ctrl-group button.maplibregl-ctrl-compass{touch-action:none}.maplibregl-canvas-container.maplibregl-interactive,.maplibregl-ctrl-group button.maplibregl-ctrl-compass{cursor:grab;-webkit-user-select:none;-moz-user-select:none;user-select:none}.maplibregl-canvas-container.maplibregl-interactive.maplibregl-track-pointer{cursor:pointer}.maplibregl-canvas-container.maplibregl-interactive:active,.maplibregl-ctrl-group button.maplibregl-ctrl-compass:active{cursor:grabbing}.maplibregl-canvas-container.maplibregl-touch-zoom-rotate,.maplibregl-canvas-container.maplibregl-touch-zoom-rotate .maplibregl-canvas{touch-action:pan-x pan-y}.maplibregl-canvas-container.maplibregl-touch-drag-pan,.maplibregl-canvas-container.maplibregl-touch-drag-pan .maplibregl-canvas{touch-action:pinch-zoom}.maplibregl-canvas-container.maplibregl-touch-zoom-rotate.maplibregl-touch-drag-pan,.maplibregl-canvas-container.maplibregl-touch-zoom-rotate.maplibregl-touch-drag-pan .maplibregl-canvas{touch-action:none}.maplibregl-canvas-container.maplibregl-touch-drag-pan.maplibregl-cooperative-gestures,.maplibregl-canvas-container.maplibregl-touch-drag-pan.maplibregl-cooperative-gestures .maplibregl-canvas{touch-action:pan-x pan-y}.maplibregl-ctrl-bottom-left,.maplibregl-ctrl-bottom-right,.maplibregl-ctrl-top-left,.maplibregl-ctrl-top-right{pointer-events:none;position:absolute;z-index:2}.maplibregl-ctrl-top-left{left:0;top:0}.maplibregl-ctrl-top-right{right:0;top:0}.maplibregl-ctrl-bottom-left{bottom:0;left:0}.maplibregl-ctrl-bottom-right{bottom:0;right:0}.maplibregl-ctrl{clear:both;pointer-events:auto;transform:translate(0)}.maplibregl-ctrl-top-left .maplibregl-ctrl{float:left;margin:10px 0 0 10px}.maplibregl-ctrl-top-right .maplibregl-ctrl{float:right;margin:10px 10px 0 0}.maplibregl-ctrl-bottom-left .maplibregl-ctrl{float:left;margin:0 0 10px 10px}.maplibregl-ctrl-bottom-right .maplibregl-ctrl{float:right;margin:0 10px 10px 0}.maplibregl-ctrl-group{background:#fff;border-radius:4px}.maplibregl-ctrl-group:not(:empty){box-shadow:0 0 0 2px #0000001a}@media (forced-colors:active){.maplibregl-ctrl-group:not(:empty){box-shadow:0 0 0 2px ButtonText}}.maplibregl-ctrl-group button{background-color:transparent;border:0;box-sizing:border-box;cursor:pointer;display:block;height:29px;outline:none;padding:0;width:29px}.maplibregl-ctrl-group button+button{border-top:1px solid #ddd}.maplibregl-ctrl button .maplibregl-ctrl-icon{background-position:50%;background-repeat:no-repeat;display:block;height:100%;width:100%}@media (forced-colors:active){.maplibregl-ctrl-icon{background-color:transparent}.maplibregl-ctrl-group button+button{border-top:1px solid ButtonText}}.maplibregl-ctrl button::-moz-focus-inner{border:0;padding:0}.maplibregl-ctrl-attrib-button:focus,.maplibregl-ctrl-group button:focus{box-shadow:0 0 2px 2px #0096ff}.maplibregl-ctrl button:disabled{cursor:not-allowed}.maplibregl-ctrl button:disabled .maplibregl-ctrl-icon{opacity:.25}@media (hover:hover){.maplibregl-ctrl button:not(:disabled):hover{background-color:#0000000d}}.maplibregl-ctrl button:not(:disabled):active{background-color:#0000000d}.maplibregl-ctrl-group button:focus:focus-visible{box-shadow:0 0 2px 2px #0096ff}.maplibregl-ctrl-group button:focus:not(:focus-visible){box-shadow:none}.maplibregl-ctrl-group button:focus:first-child{border-radius:4px 4px 0 0}.maplibregl-ctrl-group button:focus:last-child{border-radius:0 0 4px 4px}.maplibregl-ctrl-group button:focus:only-child{border-radius:inherit}.maplibregl-ctrl button.maplibregl-ctrl-zoom-out .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23333' viewBox='0 0 29 29'%3E%3Cpath d='M10 13c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h9c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13z'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-zoom-in .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23333' viewBox='0 0 29 29'%3E%3Cpath d='M14.5 8.5c-.75 0-1.5.75-1.5 1.5v3h-3c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h3v3c0 .75.75 1.5 1.5 1.5S16 19.75 16 19v-3h3c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13h-3v-3c0-.75-.75-1.5-1.5-1.5'/%3E%3C/svg%3E")}@media (forced-colors:active){.maplibregl-ctrl button.maplibregl-ctrl-zoom-out .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23fff' viewBox='0 0 29 29'%3E%3Cpath d='M10 13c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h9c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13z'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-zoom-in .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23fff' viewBox='0 0 29 29'%3E%3Cpath d='M14.5 8.5c-.75 0-1.5.75-1.5 1.5v3h-3c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h3v3c0 .75.75 1.5 1.5 1.5S16 19.75 16 19v-3h3c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13h-3v-3c0-.75-.75-1.5-1.5-1.5'/%3E%3C/svg%3E")}}@media (forced-colors:active) and (prefers-color-scheme:light){.maplibregl-ctrl button.maplibregl-ctrl-zoom-out .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' viewBox='0 0 29 29'%3E%3Cpath d='M10 13c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h9c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13z'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-zoom-in .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' viewBox='0 0 29 29'%3E%3Cpath d='M14.5 8.5c-.75 0-1.5.75-1.5 1.5v3h-3c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h3v3c0 .75.75 1.5 1.5 1.5S16 19.75 16 19v-3h3c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13h-3v-3c0-.75-.75-1.5-1.5-1.5'/%3E%3C/svg%3E")}}.maplibregl-ctrl button.maplibregl-ctrl-fullscreen .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23333' viewBox='0 0 29 29'%3E%3Cpath d='M24 16v5.5c0 1.75-.75 2.5-2.5 2.5H16v-1l3-1.5-4-5.5 1-1 5.5 4 1.5-3zM6 16l1.5 3 5.5-4 1 1-4 5.5 3 1.5v1H7.5C5.75 24 5 23.25 5 21.5V16zm7-11v1l-3 1.5 4 5.5-1 1-5.5-4L6 13H5V7.5C5 5.75 5.75 5 7.5 5zm11 2.5c0-1.75-.75-2.5-2.5-2.5H16v1l3 1.5-4 5.5 1 1 5.5-4 1.5 3h1z'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-shrink .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' viewBox='0 0 29 29'%3E%3Cpath d='M18.5 16c-1.75 0-2.5.75-2.5 2.5V24h1l1.5-3 5.5 4 1-1-4-5.5 3-1.5v-1zM13 18.5c0-1.75-.75-2.5-2.5-2.5H5v1l3 1.5L4 24l1 1 5.5-4 1.5 3h1zm3-8c0 1.75.75 2.5 2.5 2.5H24v-1l-3-1.5L25 5l-1-1-5.5 4L17 5h-1zM10.5 13c1.75 0 2.5-.75 2.5-2.5V5h-1l-1.5 3L5 4 4 5l4 5.5L5 12v1z'/%3E%3C/svg%3E")}@media (forced-colors:active){.maplibregl-ctrl button.maplibregl-ctrl-fullscreen .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23fff' viewBox='0 0 29 29'%3E%3Cpath d='M24 16v5.5c0 1.75-.75 2.5-2.5 2.5H16v-1l3-1.5-4-5.5 1-1 5.5 4 1.5-3zM6 16l1.5 3 5.5-4 1 1-4 5.5 3 1.5v1H7.5C5.75 24 5 23.25 5 21.5V16zm7-11v1l-3 1.5 4 5.5-1 1-5.5-4L6 13H5V7.5C5 5.75 5.75 5 7.5 5zm11 2.5c0-1.75-.75-2.5-2.5-2.5H16v1l3 1.5-4 5.5 1 1 5.5-4 1.5 3h1z'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-shrink .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23fff' viewBox='0 0 29 29'%3E%3Cpath d='M18.5 16c-1.75 0-2.5.75-2.5 2.5V24h1l1.5-3 5.5 4 1-1-4-5.5 3-1.5v-1zM13 18.5c0-1.75-.75-2.5-2.5-2.5H5v1l3 1.5L4 24l1 1 5.5-4 1.5 3h1zm3-8c0 1.75.75 2.5 2.5 2.5H24v-1l-3-1.5L25 5l-1-1-5.5 4L17 5h-1zM10.5 13c1.75 0 2.5-.75 2.5-2.5V5h-1l-1.5 3L5 4 4 5l4 5.5L5 12v1z'/%3E%3C/svg%3E")}}@media (forced-colors:active) and (prefers-color-scheme:light){.maplibregl-ctrl button.maplibregl-ctrl-fullscreen .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' viewBox='0 0 29 29'%3E%3Cpath d='M24 16v5.5c0 1.75-.75 2.5-2.5 2.5H16v-1l3-1.5-4-5.5 1-1 5.5 4 1.5-3zM6 16l1.5 3 5.5-4 1 1-4 5.5 3 1.5v1H7.5C5.75 24 5 23.25 5 21.5V16zm7-11v1l-3 1.5 4 5.5-1 1-5.5-4L6 13H5V7.5C5 5.75 5.75 5 7.5 5zm11 2.5c0-1.75-.75-2.5-2.5-2.5H16v1l3 1.5-4 5.5 1 1 5.5-4 1.5 3h1z'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-shrink .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' viewBox='0 0 29 29'%3E%3Cpath d='M18.5 16c-1.75 0-2.5.75-2.5 2.5V24h1l1.5-3 5.5 4 1-1-4-5.5 3-1.5v-1zM13 18.5c0-1.75-.75-2.5-2.5-2.5H5v1l3 1.5L4 24l1 1 5.5-4 1.5 3h1zm3-8c0 1.75.75 2.5 2.5 2.5H24v-1l-3-1.5L25 5l-1-1-5.5 4L17 5h-1zM10.5 13c1.75 0 2.5-.75 2.5-2.5V5h-1l-1.5 3L5 4 4 5l4 5.5L5 12v1z'/%3E%3C/svg%3E")}}.maplibregl-ctrl button.maplibregl-ctrl-compass .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23333' viewBox='0 0 29 29'%3E%3Cpath d='m10.5 14 4-8 4 8z'/%3E%3Cpath fill='%23ccc' d='m10.5 16 4 8 4-8z'/%3E%3C/svg%3E")}@media (forced-colors:active){.maplibregl-ctrl button.maplibregl-ctrl-compass .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23fff' viewBox='0 0 29 29'%3E%3Cpath d='m10.5 14 4-8 4 8z'/%3E%3Cpath fill='%23ccc' d='m10.5 16 4 8 4-8z'/%3E%3C/svg%3E")}}@media (forced-colors:active) and (prefers-color-scheme:light){.maplibregl-ctrl button.maplibregl-ctrl-compass .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' viewBox='0 0 29 29'%3E%3Cpath d='m10.5 14 4-8 4 8z'/%3E%3Cpath fill='%23ccc' d='m10.5 16 4 8 4-8z'/%3E%3C/svg%3E")}}.maplibregl-ctrl button.maplibregl-ctrl-globe .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='22' height='22' fill='none' stroke='%23333' viewBox='0 0 22 22'%3E%3Ccircle cx='11' cy='11' r='8.5'/%3E%3Cpath d='M17.5 11c0 4.819-3.02 8.5-6.5 8.5S4.5 15.819 4.5 11 7.52 2.5 11 2.5s6.5 3.681 6.5 8.5Z'/%3E%3Cpath d='M13.5 11c0 2.447-.331 4.64-.853 6.206-.262.785-.562 1.384-.872 1.777-.314.399-.58.517-.775.517s-.461-.118-.775-.517c-.31-.393-.61-.992-.872-1.777C8.831 15.64 8.5 13.446 8.5 11s.331-4.64.853-6.206c.262-.785.562-1.384.872-1.777.314-.399.58-.517.775-.517s.461.118.775.517c.31.393.61.992.872 1.777.522 1.565.853 3.76.853 6.206Z'/%3E%3Cpath d='M11 7.5c-1.909 0-3.622-.166-4.845-.428-.616-.132-1.08-.283-1.379-.434a1.3 1.3 0 0 1-.224-.138q.07-.058.224-.138c.299-.151.763-.302 1.379-.434C7.378 5.666 9.091 5.5 11 5.5s3.622.166 4.845.428c.616.132 1.08.283 1.379.434.105.053.177.1.224.138q-.07.058-.224.138c-.299.151-.763.302-1.379.434-1.223.262-2.936.428-4.845.428ZM4.486 6.436ZM11 16.5c-1.909 0-3.622-.166-4.845-.428-.616-.132-1.08-.283-1.379-.434a1.3 1.3 0 0 1-.224-.138 1.3 1.3 0 0 1 .224-.138c.299-.151.763-.302 1.379-.434C7.378 14.666 9.091 14.5 11 14.5s3.622.166 4.845.428c.616.132 1.08.283 1.379.434.105.053.177.1.224.138a1.3 1.3 0 0 1-.224.138c-.299.151-.763.302-1.379.434-1.223.262-2.936.428-4.845.428Zm-6.514-1.064ZM11 12.5c-2.46 0-4.672-.222-6.255-.574-.796-.177-1.406-.38-1.805-.59a1.5 1.5 0 0 1-.39-.272.3.3 0 0 1-.047-.064.3.3 0 0 1 .048-.064c.066-.073.189-.167.389-.272.399-.21 1.009-.413 1.805-.59C6.328 9.722 8.54 9.5 11 9.5s4.672.222 6.256.574c.795.177 1.405.38 1.804.59.2.105.323.2.39.272a.3.3 0 0 1 .047.064.3.3 0 0 1-.048.064 1.4 1.4 0 0 1-.389.272c-.399.21-1.009.413-1.804.59-1.584.352-3.796.574-6.256.574Zm-8.501-1.51v.002zm0 .018v.002zm17.002.002v-.002zm0-.018v-.002z'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-globe-enabled .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='22' height='22' fill='none' stroke='%2333b5e5' viewBox='0 0 22 22'%3E%3Ccircle cx='11' cy='11' r='8.5'/%3E%3Cpath d='M17.5 11c0 4.819-3.02 8.5-6.5 8.5S4.5 15.819 4.5 11 7.52 2.5 11 2.5s6.5 3.681 6.5 8.5Z'/%3E%3Cpath d='M13.5 11c0 2.447-.331 4.64-.853 6.206-.262.785-.562 1.384-.872 1.777-.314.399-.58.517-.775.517s-.461-.118-.775-.517c-.31-.393-.61-.992-.872-1.777C8.831 15.64 8.5 13.446 8.5 11s.331-4.64.853-6.206c.262-.785.562-1.384.872-1.777.314-.399.58-.517.775-.517s.461.118.775.517c.31.393.61.992.872 1.777.522 1.565.853 3.76.853 6.206Z'/%3E%3Cpath d='M11 7.5c-1.909 0-3.622-.166-4.845-.428-.616-.132-1.08-.283-1.379-.434a1.3 1.3 0 0 1-.224-.138q.07-.058.224-.138c.299-.151.763-.302 1.379-.434C7.378 5.666 9.091 5.5 11 5.5s3.622.166 4.845.428c.616.132 1.08.283 1.379.434.105.053.177.1.224.138q-.07.058-.224.138c-.299.151-.763.302-1.379.434-1.223.262-2.936.428-4.845.428ZM4.486 6.436ZM11 16.5c-1.909 0-3.622-.166-4.845-.428-.616-.132-1.08-.283-1.379-.434a1.3 1.3 0 0 1-.224-.138 1.3 1.3 0 0 1 .224-.138c.299-.151.763-.302 1.379-.434C7.378 14.666 9.091 14.5 11 14.5s3.622.166 4.845.428c.616.132 1.08.283 1.379.434.105.053.177.1.224.138a1.3 1.3 0 0 1-.224.138c-.299.151-.763.302-1.379.434-1.223.262-2.936.428-4.845.428Zm-6.514-1.064ZM11 12.5c-2.46 0-4.672-.222-6.255-.574-.796-.177-1.406-.38-1.805-.59a1.5 1.5 0 0 1-.39-.272.3.3 0 0 1-.047-.064.3.3 0 0 1 .048-.064c.066-.073.189-.167.389-.272.399-.21 1.009-.413 1.805-.59C6.328 9.722 8.54 9.5 11 9.5s4.672.222 6.256.574c.795.177 1.405.38 1.804.59.2.105.323.2.39.272a.3.3 0 0 1 .047.064.3.3 0 0 1-.048.064 1.4 1.4 0 0 1-.389.272c-.399.21-1.009.413-1.804.59-1.584.352-3.796.574-6.256.574Zm-8.501-1.51v.002zm0 .018v.002zm17.002.002v-.002zm0-.018v-.002z'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-terrain .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='22' height='22' fill='%23333' viewBox='0 0 22 22'%3E%3Cpath d='m1.754 13.406 4.453-4.851 3.09 3.09 3.281 3.277.969-.969-3.309-3.312 3.844-4.121 6.148 6.886h1.082v-.855l-7.207-8.07-4.84 5.187L6.169 6.57l-5.48 5.965v.871ZM.688 16.844h20.625v1.375H.688Zm0 0'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-terrain-enabled .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='22' height='22' fill='%2333b5e5' viewBox='0 0 22 22'%3E%3Cpath d='m1.754 13.406 4.453-4.851 3.09 3.09 3.281 3.277.969-.969-3.309-3.312 3.844-4.121 6.148 6.886h1.082v-.855l-7.207-8.07-4.84 5.187L6.169 6.57l-5.48 5.965v.871ZM.688 16.844h20.625v1.375H.688Zm0 0'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-geolocate .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23333' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1m0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-geolocate:disabled .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23aaa' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1m0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3Cpath fill='red' d='m14 5 1 1-9 9-1-1z'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-active .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%2333b5e5' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1m0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-active-error .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23e58978' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1m0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-background .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%2333b5e5' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1m0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-background-error .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23e54e33' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1m0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-waiting .maplibregl-ctrl-icon{animation:maplibregl-spin 2s linear infinite}@media (forced-colors:active){.maplibregl-ctrl button.maplibregl-ctrl-geolocate .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23fff' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1m0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-geolocate:disabled .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23999' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1m0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3Cpath fill='red' d='m14 5 1 1-9 9-1-1z'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-active .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%2333b5e5' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1m0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-active-error .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23e58978' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1m0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-background .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%2333b5e5' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1m0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-background-error .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23e54e33' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1m0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7'/%3E%3C/svg%3E")}}@media (forced-colors:active) and (prefers-color-scheme:light){.maplibregl-ctrl button.maplibregl-ctrl-geolocate .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1m0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-geolocate:disabled .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23666' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1m0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3Cpath fill='red' d='m14 5 1 1-9 9-1-1z'/%3E%3C/svg%3E")}}@keyframes maplibregl-spin{0%{transform:rotate(0)}to{transform:rotate(1turn)}}a.maplibregl-ctrl-logo{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='88' height='23' fill='none'%3E%3Cpath fill='%23000' fill-opacity='.4' fill-rule='evenodd' d='M17.408 16.796h-1.827l2.501-12.095h.198l3.324 6.533.988 2.19.988-2.19 3.258-6.533h.181l2.6 12.095h-1.81l-1.218-5.644-.362-1.71-.658 1.71-2.929 5.644h-.098l-2.914-5.644-.757-1.71-.345 1.71zm1.958-3.42-.726 3.663a1.255 1.255 0 0 1-1.232 1.011h-1.827a1.255 1.255 0 0 1-1.229-1.509l2.501-12.095a1.255 1.255 0 0 1 1.23-1.001h.197a1.25 1.25 0 0 1 1.12.685l3.19 6.273 3.125-6.263a1.25 1.25 0 0 1 1.123-.695h.181a1.255 1.255 0 0 1 1.227.991l1.443 6.71a5 5 0 0 1 .314-.787l.009-.016a4.6 4.6 0 0 1 1.777-1.887c.782-.46 1.668-.667 2.611-.667a4.6 4.6 0 0 1 1.7.32l.306.134c.21-.16.474-.256.759-.256h1.694a1.255 1.255 0 0 1 1.212.925 1.255 1.255 0 0 1 1.212-.925h1.711c.284 0 .545.094.755.252.613-.3 1.312-.45 2.075-.45 1.356 0 2.557.445 3.482 1.4q.47.48.763 1.064V4.701a1.255 1.255 0 0 1 1.255-1.255h1.86A1.255 1.255 0 0 1 54.44 4.7v9.194h2.217c.19 0 .37.043.532.118v-4.77c0-.356.147-.678.385-.906a2.42 2.42 0 0 1-.682-1.71c0-.665.267-1.253.735-1.7a2.45 2.45 0 0 1 1.722-.674 2.43 2.43 0 0 1 1.705.675q.318.302.504.683V4.7a1.255 1.255 0 0 1 1.255-1.255h1.744A1.255 1.255 0 0 1 65.812 4.7v3.335a4.8 4.8 0 0 1 1.526-.246c.938 0 1.817.214 2.59.69a4.47 4.47 0 0 1 1.67 1.743v-.98a1.255 1.255 0 0 1 1.256-1.256h1.777c.233 0 .451.064.639.174a3.4 3.4 0 0 1 1.567-.372c.346 0 .861.02 1.285.232a1.25 1.25 0 0 1 .689 1.004 4.7 4.7 0 0 1 .853-.588c.795-.44 1.675-.647 2.61-.647 1.385 0 2.65.39 3.525 1.396.836.938 1.168 2.173 1.168 3.528q-.001.515-.056 1.051a1.255 1.255 0 0 1-.947 1.09l.408.952a1.255 1.255 0 0 1-.477 1.552c-.418.268-.92.463-1.458.612-.613.171-1.304.244-2.049.244-1.06 0-2.043-.207-2.886-.698l-.015-.008c-.798-.48-1.419-1.135-1.818-1.963l-.004-.008a5.8 5.8 0 0 1-.548-2.512q0-.429.053-.843a1.3 1.3 0 0 1-.333-.086l-.166-.004c-.223 0-.426.062-.643.228-.03.024-.142.139-.142.59v3.883a1.255 1.255 0 0 1-1.256 1.256h-1.777a1.255 1.255 0 0 1-1.256-1.256V15.69l-.032.057a4.8 4.8 0 0 1-1.86 1.833 5.04 5.04 0 0 1-2.484.634 4.5 4.5 0 0 1-1.935-.424 1.25 1.25 0 0 1-.764.258h-1.71a1.255 1.255 0 0 1-1.256-1.255V7.687a2.4 2.4 0 0 1-.428.625c.253.23.412.561.412.93v7.553a1.255 1.255 0 0 1-1.256 1.255h-1.843a1.25 1.25 0 0 1-.894-.373c-.228.23-.544.373-.894.373H51.32a1.255 1.255 0 0 1-1.256-1.255v-1.251l-.061.117a4.7 4.7 0 0 1-1.782 1.884 4.77 4.77 0 0 1-2.485.67 5.6 5.6 0 0 1-1.485-.188l.009 2.764a1.255 1.255 0 0 1-1.255 1.259h-1.729a1.255 1.255 0 0 1-1.255-1.255v-3.537a1.255 1.255 0 0 1-1.167.793h-1.679a1.25 1.25 0 0 1-.77-.263 4.5 4.5 0 0 1-1.945.429c-.885 0-1.724-.21-2.495-.632l-.017-.01a5 5 0 0 1-1.081-.836 1.255 1.255 0 0 1-1.254 1.312h-1.81a1.255 1.255 0 0 1-1.228-.99l-.782-3.625-2.044 3.939a1.25 1.25 0 0 1-1.115.676h-.098a1.25 1.25 0 0 1-1.116-.68l-2.061-3.994zM35.92 16.63l.207-.114.223-.15q.493-.356.735-.785l.061-.118.033 1.332h1.678V9.242h-1.694l-.033 1.267q-.133-.329-.526-.658l-.032-.028a3.2 3.2 0 0 0-.668-.428l-.27-.12a3.3 3.3 0 0 0-1.235-.23q-1.136-.001-1.974.493a3.36 3.36 0 0 0-1.3 1.382q-.445.89-.444 2.074 0 1.2.51 2.107a3.8 3.8 0 0 0 1.382 1.381 3.9 3.9 0 0 0 1.893.477q.795 0 1.455-.33zm-2.789-5.38q-.576.675-.575 1.762 0 1.102.559 1.794.576.675 1.645.675a2.25 2.25 0 0 0 .934-.19 2.2 2.2 0 0 0 .468-.29l.178-.161a2.2 2.2 0 0 0 .397-.561q.244-.5.244-1.15v-.115q0-.708-.296-1.267l-.043-.077a2.2 2.2 0 0 0-.633-.709l-.13-.086-.047-.028a2.1 2.1 0 0 0-1.073-.285q-1.052 0-1.629.692zm2.316 2.706c.163-.17.28-.407.28-.83v-.114c0-.292-.06-.508-.15-.68a.96.96 0 0 0-.353-.389.85.85 0 0 0-.464-.127c-.4 0-.56.114-.664.239l-.01.012c-.148.174-.275.45-.275.945 0 .506.122.801.27.99.097.11.266.224.68.224.303 0 .504-.09.687-.269zm7.545 1.705a2.6 2.6 0 0 0 .331.423q.319.33.755.548l.173.074q.65.255 1.49.255 1.02 0 1.844-.493a3.45 3.45 0 0 0 1.316-1.4q.493-.904.493-2.089 0-1.909-.988-2.913-.988-1.02-2.584-1.02-.898 0-1.575.347a3 3 0 0 0-.415.262l-.199.166a3.4 3.4 0 0 0-.64.82V9.242h-1.712v11.553h1.729l-.017-5.134zm.53-1.138q.206.29.48.5l.155.11.053.034q.51.296 1.119.297 1.07 0 1.645-.675.577-.69.576-1.762 0-1.119-.576-1.777-.558-.675-1.645-.675-.435 0-.835.16a2 2 0 0 0-.284.136 2 2 0 0 0-.363.254 2.2 2.2 0 0 0-.46.569l-.082.162a2.6 2.6 0 0 0-.213 1.072v.115q0 .707.296 1.267l.135.211zm.964-.818a1.1 1.1 0 0 0 .367.385.94.94 0 0 0 .476.118c.423 0 .59-.117.687-.23.159-.194.28-.478.28-.95 0-.53-.133-.8-.266-.952l-.021-.025c-.078-.094-.231-.221-.68-.221a1 1 0 0 0-.503.135l-.012.007a.86.86 0 0 0-.335.343c-.073.133-.132.324-.132.614v.115a1.4 1.4 0 0 0 .14.66zm15.7-6.222q.347-.346.346-.856a1.05 1.05 0 0 0-.345-.79 1.18 1.18 0 0 0-.84-.329q-.51 0-.855.33a1.05 1.05 0 0 0-.346.79q0 .51.346.855.345.346.856.346.51 0 .839-.346zm4.337 9.314.033-1.332q.191.403.59.747l.098.081a4 4 0 0 0 .316.224l.223.122a3.2 3.2 0 0 0 1.44.322 3.8 3.8 0 0 0 1.875-.477 3.5 3.5 0 0 0 1.382-1.366q.527-.89.526-2.09 0-1.184-.444-2.073a3.24 3.24 0 0 0-1.283-1.399q-.823-.51-1.942-.51a3.5 3.5 0 0 0-1.527.344l-.086.043-.165.09a3 3 0 0 0-.33.214q-.432.315-.656.707a2 2 0 0 0-.099.198l.082-1.283V4.701h-1.744v12.095zm.473-2.509a2.5 2.5 0 0 0 .566.7q.117.098.245.18l.144.08a2.1 2.1 0 0 0 .975.232q1.07 0 1.645-.675.576-.69.576-1.778 0-1.102-.576-1.777-.56-.691-1.645-.692a2.2 2.2 0 0 0-1.015.235q-.22.113-.415.282l-.15.142a2.1 2.1 0 0 0-.42.594q-.223.479-.223 1.1v.115q0 .705.293 1.26zm2.616-.293c.157-.191.28-.479.28-.967 0-.51-.13-.79-.276-.961l-.021-.026c-.082-.1-.232-.225-.67-.225a.87.87 0 0 0-.681.279l-.012.011c-.154.155-.274.38-.274.807v.115c0 .285.057.499.144.669a1.1 1.1 0 0 0 .367.405c.137.082.28.123.455.123.423 0 .59-.118.686-.23zm8.266-3.013q.345-.13.724-.14l.069-.002q.493 0 .642.099l.247-1.794q-.196-.099-.717-.099a2.3 2.3 0 0 0-.545.063 2 2 0 0 0-.411.148 2.2 2.2 0 0 0-.4.249 2.5 2.5 0 0 0-.485.499 2.7 2.7 0 0 0-.32.581l-.05.137v-1.48h-1.778v7.553h1.777v-3.884q0-.546.159-.943a1.5 1.5 0 0 1 .466-.636 2.5 2.5 0 0 1 .399-.253 2 2 0 0 1 .224-.099zm9.784 2.656.05-.922q0-1.743-.856-2.698-.838-.97-2.584-.97-1.119-.001-2.007.493a3.46 3.46 0 0 0-1.4 1.382q-.493.906-.493 2.106 0 1.07.428 1.975.428.89 1.332 1.432.906.526 2.255.526.973 0 1.668-.185l.044-.012.135-.04q.613-.184.984-.421l-.542-1.267q-.3.162-.642.274l-.297.087q-.51.131-1.3.131-.954 0-1.497-.444a1.6 1.6 0 0 1-.192-.193q-.366-.44-.512-1.234l-.004-.021zm-5.427-1.256-.003.022h3.752v-.138q-.011-.727-.288-1.118a1 1 0 0 0-.156-.176q-.46-.428-1.316-.428-.986 0-1.494.604-.379.45-.494 1.234zm-27.053 2.77V4.7h-1.86v12.095h5.333V15.15zm7.103-5.908v7.553h-1.843V9.242h1.843z'/%3E%3Cpath fill='%23fff' d='m19.63 11.151-.757-1.71-.345 1.71-1.12 5.644h-1.827L18.083 4.7h.197l3.325 6.533.988 2.19.988-2.19L26.839 4.7h.181l2.6 12.095h-1.81l-1.218-5.644-.362-1.71-.658 1.71-2.93 5.644h-.098l-2.913-5.644zm14.836 5.81q-1.02 0-1.893-.478a3.8 3.8 0 0 1-1.381-1.382q-.51-.906-.51-2.106 0-1.185.444-2.074a3.36 3.36 0 0 1 1.3-1.382q.839-.494 1.974-.494a3.3 3.3 0 0 1 1.234.231 3.3 3.3 0 0 1 .97.575q.396.33.527.659l.033-1.267h1.694v7.553H37.18l-.033-1.332q-.279.593-1.02 1.053a3.17 3.17 0 0 1-1.662.444zm.296-1.482q.938 0 1.58-.642.642-.66.642-1.711v-.115q0-.708-.296-1.267a2.2 2.2 0 0 0-.807-.872 2.1 2.1 0 0 0-1.119-.313q-1.053 0-1.629.692-.575.675-.575 1.76 0 1.103.559 1.795.577.675 1.645.675zm6.521-6.237h1.711v1.4q.906-1.597 2.83-1.597 1.596 0 2.584 1.02.988 1.005.988 2.914 0 1.185-.493 2.09a3.46 3.46 0 0 1-1.316 1.399 3.5 3.5 0 0 1-1.844.493q-.954 0-1.662-.329a2.67 2.67 0 0 1-1.086-.97l.017 5.134h-1.728zm4.048 6.22q1.07 0 1.645-.674.577-.69.576-1.762 0-1.119-.576-1.777-.558-.675-1.645-.675-.592 0-1.12.296-.51.28-.822.823-.296.527-.296 1.234v.115q0 .708.296 1.267.313.543.823.855.51.296 1.119.297z'/%3E%3Cpath fill='%23e1e3e9' d='M51.325 4.7h1.86v10.45h3.473v1.646h-5.333zm7.12 4.542h1.843v7.553h-1.843zm.905-1.415a1.16 1.16 0 0 1-.856-.346 1.17 1.17 0 0 1-.346-.856 1.05 1.05 0 0 1 .346-.79q.346-.329.856-.329.494 0 .839.33a1.05 1.05 0 0 1 .345.79 1.16 1.16 0 0 1-.345.855q-.33.346-.84.346zm7.875 9.133a3.17 3.17 0 0 1-1.662-.444q-.723-.46-1.004-1.053l-.033 1.332h-1.71V4.701h1.743v4.657l-.082 1.283q.279-.658 1.086-1.119a3.5 3.5 0 0 1 1.778-.477q1.119 0 1.942.51a3.24 3.24 0 0 1 1.283 1.4q.445.888.444 2.072 0 1.201-.526 2.09a3.5 3.5 0 0 1-1.382 1.366 3.8 3.8 0 0 1-1.876.477zm-.296-1.481q1.069 0 1.645-.675.577-.69.577-1.778 0-1.102-.577-1.776-.56-.691-1.645-.692a2.12 2.12 0 0 0-1.58.659q-.642.641-.642 1.694v.115q0 .71.296 1.267a2.4 2.4 0 0 0 .807.872 2.1 2.1 0 0 0 1.119.313zm5.927-6.237h1.777v1.481q.263-.757.856-1.217a2.14 2.14 0 0 1 1.349-.46q.527 0 .724.098l-.247 1.794q-.149-.099-.642-.099-.774 0-1.416.494-.626.493-.626 1.58v3.883h-1.777V9.242zm9.534 7.718q-1.35 0-2.255-.526-.904-.543-1.332-1.432a4.6 4.6 0 0 1-.428-1.975q0-1.2.493-2.106a3.46 3.46 0 0 1 1.4-1.382q.889-.495 2.007-.494 1.744 0 2.584.97.855.956.856 2.7 0 .444-.05.92h-5.43q.18 1.005.708 1.45.542.443 1.497.443.79 0 1.3-.131a4 4 0 0 0 .938-.362l.542 1.267q-.411.263-1.119.46-.708.198-1.711.197zm1.596-4.558q.016-1.02-.444-1.432-.46-.428-1.316-.428-1.728 0-1.991 1.86z'/%3E%3Cpath d='M5.074 15.948a.484.657 0 0 0-.486.659v1.84a.484.657 0 0 0 .486.659h4.101a.484.657 0 0 0 .486-.659v-1.84a.484.657 0 0 0-.486-.659zm3.56 1.16H5.617v.838h3.017z' style='fill:%23fff;fill-rule:evenodd;stroke-width:1.03600001'/%3E%3Cg style='stroke-width:1.12603545'%3E%3Cpath d='M-9.408-1.416c-3.833-.025-7.056 2.912-7.08 6.615-.02 3.08 1.653 4.832 3.107 6.268.903.892 1.721 1.74 2.32 2.902l-.525-.004c-.543-.003-.992.304-1.24.639a1.87 1.87 0 0 0-.362 1.121l-.011 1.877c-.003.402.104.787.347 1.125.244.338.688.653 1.23.656l4.142.028c.542.003.99-.306 1.238-.641a1.87 1.87 0 0 0 .363-1.121l.012-1.875a1.87 1.87 0 0 0-.348-1.127c-.243-.338-.688-.653-1.23-.656l-.518-.004c.597-1.145 1.425-1.983 2.348-2.87 1.473-1.414 3.18-3.149 3.2-6.226-.016-3.59-2.923-6.684-6.993-6.707m-.006 1.1v.002c3.274.02 5.92 2.532 5.9 5.6-.017 2.706-1.39 4.026-2.863 5.44-1.034.994-2.118 2.033-2.814 3.633-.018.041-.052.055-.075.065q-.013.004-.02.01a.34.34 0 0 1-.226.084.34.34 0 0 1-.224-.086l-.092-.077c-.699-1.615-1.768-2.669-2.781-3.67-1.454-1.435-2.797-2.762-2.78-5.478.02-3.067 2.7-5.545 5.975-5.523m-.02 2.826c-1.62-.01-2.944 1.315-2.955 2.96-.01 1.646 1.295 2.988 2.916 2.999h.002c1.621.01 2.943-1.316 2.953-2.961.011-1.646-1.294-2.988-2.916-2.998m-.005 1.1c1.017.006 1.829.83 1.822 1.89s-.83 1.874-1.848 1.867c-1.018-.006-1.829-.83-1.822-1.89s.83-1.874 1.848-1.868m-2.155 11.857 4.14.025c.271.002.49.305.487.676l-.013 1.875c-.003.37-.224.67-.495.668l-4.14-.025c-.27-.002-.487-.306-.485-.676l.012-1.875c.003-.37.224-.67.494-.668' style='color:%23000;font-style:normal;font-variant:normal;font-weight:400;font-stretch:normal;font-size:medium;line-height:normal;font-family:sans-serif;font-variant-ligatures:normal;font-variant-position:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-feature-settings:normal;text-indent:0;text-align:start;text-decoration:none;text-decoration-line:none;text-decoration-style:solid;text-decoration-color:%23000;letter-spacing:normal;word-spacing:normal;text-transform:none;writing-mode:lr-tb;direction:ltr;text-orientation:mixed;dominant-baseline:auto;baseline-shift:baseline;text-anchor:start;white-space:normal;shape-padding:0;clip-rule:evenodd;display:inline;overflow:visible;visibility:visible;opacity:1;isolation:auto;mix-blend-mode:normal;color-interpolation:sRGB;color-interpolation-filters:linearRGB;solid-color:%23000;solid-opacity:1;vector-effect:none;fill:%23000;fill-opacity:.4;fill-rule:evenodd;stroke:none;stroke-width:2.47727823;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;color-rendering:auto;image-rendering:auto;shape-rendering:auto;text-rendering:auto' transform='translate(15.553 2.85)scale(.88807)'/%3E%3Cpath d='M-9.415-.316C-12.69-.338-15.37 2.14-15.39 5.207c-.017 2.716 1.326 4.041 2.78 5.477 1.013 1 2.081 2.055 2.78 3.67l.092.076a.34.34 0 0 0 .225.086.34.34 0 0 0 .227-.083l.019-.01c.022-.009.057-.024.074-.064.697-1.6 1.78-2.64 2.814-3.634 1.473-1.414 2.847-2.733 2.864-5.44.02-3.067-2.627-5.58-5.901-5.601m-.057 8.784c1.621.011 2.944-1.315 2.955-2.96.01-1.646-1.295-2.988-2.916-2.999-1.622-.01-2.945 1.315-2.955 2.96s1.295 2.989 2.916 3' style='clip-rule:evenodd;fill:%23e1e3e9;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:2.47727823;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:.4' transform='translate(15.553 2.85)scale(.88807)'/%3E%3Cpath d='M-11.594 15.465c-.27-.002-.492.297-.494.668l-.012 1.876c-.003.371.214.673.485.675l4.14.027c.271.002.492-.298.495-.668l.012-1.877c.003-.37-.215-.672-.485-.674z' style='clip-rule:evenodd;fill:%23fff;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:2.47727823;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:.4' transform='translate(15.553 2.85)scale(.88807)'/%3E%3C/g%3E%3C/svg%3E");background-repeat:no-repeat;cursor:pointer;display:block;height:23px;margin:0 0 -4px -4px;overflow:hidden;width:88px}a.maplibregl-ctrl-logo.maplibregl-compact{width:14px}@media (forced-colors:active){a.maplibregl-ctrl-logo{background-color:transparent;background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='88' height='23' fill='none'%3E%3Cpath fill='%23000' fill-opacity='.4' fill-rule='evenodd' d='M17.408 16.796h-1.827l2.501-12.095h.198l3.324 6.533.988 2.19.988-2.19 3.258-6.533h.181l2.6 12.095h-1.81l-1.218-5.644-.362-1.71-.658 1.71-2.929 5.644h-.098l-2.914-5.644-.757-1.71-.345 1.71zm1.958-3.42-.726 3.663a1.255 1.255 0 0 1-1.232 1.011h-1.827a1.255 1.255 0 0 1-1.229-1.509l2.501-12.095a1.255 1.255 0 0 1 1.23-1.001h.197a1.25 1.25 0 0 1 1.12.685l3.19 6.273 3.125-6.263a1.25 1.25 0 0 1 1.123-.695h.181a1.255 1.255 0 0 1 1.227.991l1.443 6.71a5 5 0 0 1 .314-.787l.009-.016a4.6 4.6 0 0 1 1.777-1.887c.782-.46 1.668-.667 2.611-.667a4.6 4.6 0 0 1 1.7.32l.306.134c.21-.16.474-.256.759-.256h1.694a1.255 1.255 0 0 1 1.212.925 1.255 1.255 0 0 1 1.212-.925h1.711c.284 0 .545.094.755.252.613-.3 1.312-.45 2.075-.45 1.356 0 2.557.445 3.482 1.4q.47.48.763 1.064V4.701a1.255 1.255 0 0 1 1.255-1.255h1.86A1.255 1.255 0 0 1 54.44 4.7v9.194h2.217c.19 0 .37.043.532.118v-4.77c0-.356.147-.678.385-.906a2.42 2.42 0 0 1-.682-1.71c0-.665.267-1.253.735-1.7a2.45 2.45 0 0 1 1.722-.674 2.43 2.43 0 0 1 1.705.675q.318.302.504.683V4.7a1.255 1.255 0 0 1 1.255-1.255h1.744A1.255 1.255 0 0 1 65.812 4.7v3.335a4.8 4.8 0 0 1 1.526-.246c.938 0 1.817.214 2.59.69a4.47 4.47 0 0 1 1.67 1.743v-.98a1.255 1.255 0 0 1 1.256-1.256h1.777c.233 0 .451.064.639.174a3.4 3.4 0 0 1 1.567-.372c.346 0 .861.02 1.285.232a1.25 1.25 0 0 1 .689 1.004 4.7 4.7 0 0 1 .853-.588c.795-.44 1.675-.647 2.61-.647 1.385 0 2.65.39 3.525 1.396.836.938 1.168 2.173 1.168 3.528q-.001.515-.056 1.051a1.255 1.255 0 0 1-.947 1.09l.408.952a1.255 1.255 0 0 1-.477 1.552c-.418.268-.92.463-1.458.612-.613.171-1.304.244-2.049.244-1.06 0-2.043-.207-2.886-.698l-.015-.008c-.798-.48-1.419-1.135-1.818-1.963l-.004-.008a5.8 5.8 0 0 1-.548-2.512q0-.429.053-.843a1.3 1.3 0 0 1-.333-.086l-.166-.004c-.223 0-.426.062-.643.228-.03.024-.142.139-.142.59v3.883a1.255 1.255 0 0 1-1.256 1.256h-1.777a1.255 1.255 0 0 1-1.256-1.256V15.69l-.032.057a4.8 4.8 0 0 1-1.86 1.833 5.04 5.04 0 0 1-2.484.634 4.5 4.5 0 0 1-1.935-.424 1.25 1.25 0 0 1-.764.258h-1.71a1.255 1.255 0 0 1-1.256-1.255V7.687a2.4 2.4 0 0 1-.428.625c.253.23.412.561.412.93v7.553a1.255 1.255 0 0 1-1.256 1.255h-1.843a1.25 1.25 0 0 1-.894-.373c-.228.23-.544.373-.894.373H51.32a1.255 1.255 0 0 1-1.256-1.255v-1.251l-.061.117a4.7 4.7 0 0 1-1.782 1.884 4.77 4.77 0 0 1-2.485.67 5.6 5.6 0 0 1-1.485-.188l.009 2.764a1.255 1.255 0 0 1-1.255 1.259h-1.729a1.255 1.255 0 0 1-1.255-1.255v-3.537a1.255 1.255 0 0 1-1.167.793h-1.679a1.25 1.25 0 0 1-.77-.263 4.5 4.5 0 0 1-1.945.429c-.885 0-1.724-.21-2.495-.632l-.017-.01a5 5 0 0 1-1.081-.836 1.255 1.255 0 0 1-1.254 1.312h-1.81a1.255 1.255 0 0 1-1.228-.99l-.782-3.625-2.044 3.939a1.25 1.25 0 0 1-1.115.676h-.098a1.25 1.25 0 0 1-1.116-.68l-2.061-3.994zM35.92 16.63l.207-.114.223-.15q.493-.356.735-.785l.061-.118.033 1.332h1.678V9.242h-1.694l-.033 1.267q-.133-.329-.526-.658l-.032-.028a3.2 3.2 0 0 0-.668-.428l-.27-.12a3.3 3.3 0 0 0-1.235-.23q-1.136-.001-1.974.493a3.36 3.36 0 0 0-1.3 1.382q-.445.89-.444 2.074 0 1.2.51 2.107a3.8 3.8 0 0 0 1.382 1.381 3.9 3.9 0 0 0 1.893.477q.795 0 1.455-.33zm-2.789-5.38q-.576.675-.575 1.762 0 1.102.559 1.794.576.675 1.645.675a2.25 2.25 0 0 0 .934-.19 2.2 2.2 0 0 0 .468-.29l.178-.161a2.2 2.2 0 0 0 .397-.561q.244-.5.244-1.15v-.115q0-.708-.296-1.267l-.043-.077a2.2 2.2 0 0 0-.633-.709l-.13-.086-.047-.028a2.1 2.1 0 0 0-1.073-.285q-1.052 0-1.629.692zm2.316 2.706c.163-.17.28-.407.28-.83v-.114c0-.292-.06-.508-.15-.68a.96.96 0 0 0-.353-.389.85.85 0 0 0-.464-.127c-.4 0-.56.114-.664.239l-.01.012c-.148.174-.275.45-.275.945 0 .506.122.801.27.99.097.11.266.224.68.224.303 0 .504-.09.687-.269zm7.545 1.705a2.6 2.6 0 0 0 .331.423q.319.33.755.548l.173.074q.65.255 1.49.255 1.02 0 1.844-.493a3.45 3.45 0 0 0 1.316-1.4q.493-.904.493-2.089 0-1.909-.988-2.913-.988-1.02-2.584-1.02-.898 0-1.575.347a3 3 0 0 0-.415.262l-.199.166a3.4 3.4 0 0 0-.64.82V9.242h-1.712v11.553h1.729l-.017-5.134zm.53-1.138q.206.29.48.5l.155.11.053.034q.51.296 1.119.297 1.07 0 1.645-.675.577-.69.576-1.762 0-1.119-.576-1.777-.558-.675-1.645-.675-.435 0-.835.16a2 2 0 0 0-.284.136 2 2 0 0 0-.363.254 2.2 2.2 0 0 0-.46.569l-.082.162a2.6 2.6 0 0 0-.213 1.072v.115q0 .707.296 1.267l.135.211zm.964-.818a1.1 1.1 0 0 0 .367.385.94.94 0 0 0 .476.118c.423 0 .59-.117.687-.23.159-.194.28-.478.28-.95 0-.53-.133-.8-.266-.952l-.021-.025c-.078-.094-.231-.221-.68-.221a1 1 0 0 0-.503.135l-.012.007a.86.86 0 0 0-.335.343c-.073.133-.132.324-.132.614v.115a1.4 1.4 0 0 0 .14.66zm15.7-6.222q.347-.346.346-.856a1.05 1.05 0 0 0-.345-.79 1.18 1.18 0 0 0-.84-.329q-.51 0-.855.33a1.05 1.05 0 0 0-.346.79q0 .51.346.855.345.346.856.346.51 0 .839-.346zm4.337 9.314.033-1.332q.191.403.59.747l.098.081a4 4 0 0 0 .316.224l.223.122a3.2 3.2 0 0 0 1.44.322 3.8 3.8 0 0 0 1.875-.477 3.5 3.5 0 0 0 1.382-1.366q.527-.89.526-2.09 0-1.184-.444-2.073a3.24 3.24 0 0 0-1.283-1.399q-.823-.51-1.942-.51a3.5 3.5 0 0 0-1.527.344l-.086.043-.165.09a3 3 0 0 0-.33.214q-.432.315-.656.707a2 2 0 0 0-.099.198l.082-1.283V4.701h-1.744v12.095zm.473-2.509a2.5 2.5 0 0 0 .566.7q.117.098.245.18l.144.08a2.1 2.1 0 0 0 .975.232q1.07 0 1.645-.675.576-.69.576-1.778 0-1.102-.576-1.777-.56-.691-1.645-.692a2.2 2.2 0 0 0-1.015.235q-.22.113-.415.282l-.15.142a2.1 2.1 0 0 0-.42.594q-.223.479-.223 1.1v.115q0 .705.293 1.26zm2.616-.293c.157-.191.28-.479.28-.967 0-.51-.13-.79-.276-.961l-.021-.026c-.082-.1-.232-.225-.67-.225a.87.87 0 0 0-.681.279l-.012.011c-.154.155-.274.38-.274.807v.115c0 .285.057.499.144.669a1.1 1.1 0 0 0 .367.405c.137.082.28.123.455.123.423 0 .59-.118.686-.23zm8.266-3.013q.345-.13.724-.14l.069-.002q.493 0 .642.099l.247-1.794q-.196-.099-.717-.099a2.3 2.3 0 0 0-.545.063 2 2 0 0 0-.411.148 2.2 2.2 0 0 0-.4.249 2.5 2.5 0 0 0-.485.499 2.7 2.7 0 0 0-.32.581l-.05.137v-1.48h-1.778v7.553h1.777v-3.884q0-.546.159-.943a1.5 1.5 0 0 1 .466-.636 2.5 2.5 0 0 1 .399-.253 2 2 0 0 1 .224-.099zm9.784 2.656.05-.922q0-1.743-.856-2.698-.838-.97-2.584-.97-1.119-.001-2.007.493a3.46 3.46 0 0 0-1.4 1.382q-.493.906-.493 2.106 0 1.07.428 1.975.428.89 1.332 1.432.906.526 2.255.526.973 0 1.668-.185l.044-.012.135-.04q.613-.184.984-.421l-.542-1.267q-.3.162-.642.274l-.297.087q-.51.131-1.3.131-.954 0-1.497-.444a1.6 1.6 0 0 1-.192-.193q-.366-.44-.512-1.234l-.004-.021zm-5.427-1.256-.003.022h3.752v-.138q-.011-.727-.288-1.118a1 1 0 0 0-.156-.176q-.46-.428-1.316-.428-.986 0-1.494.604-.379.45-.494 1.234zm-27.053 2.77V4.7h-1.86v12.095h5.333V15.15zm7.103-5.908v7.553h-1.843V9.242h1.843z'/%3E%3Cpath fill='%23fff' d='m19.63 11.151-.757-1.71-.345 1.71-1.12 5.644h-1.827L18.083 4.7h.197l3.325 6.533.988 2.19.988-2.19L26.839 4.7h.181l2.6 12.095h-1.81l-1.218-5.644-.362-1.71-.658 1.71-2.93 5.644h-.098l-2.913-5.644zm14.836 5.81q-1.02 0-1.893-.478a3.8 3.8 0 0 1-1.381-1.382q-.51-.906-.51-2.106 0-1.185.444-2.074a3.36 3.36 0 0 1 1.3-1.382q.839-.494 1.974-.494a3.3 3.3 0 0 1 1.234.231 3.3 3.3 0 0 1 .97.575q.396.33.527.659l.033-1.267h1.694v7.553H37.18l-.033-1.332q-.279.593-1.02 1.053a3.17 3.17 0 0 1-1.662.444zm.296-1.482q.938 0 1.58-.642.642-.66.642-1.711v-.115q0-.708-.296-1.267a2.2 2.2 0 0 0-.807-.872 2.1 2.1 0 0 0-1.119-.313q-1.053 0-1.629.692-.575.675-.575 1.76 0 1.103.559 1.795.577.675 1.645.675zm6.521-6.237h1.711v1.4q.906-1.597 2.83-1.597 1.596 0 2.584 1.02.988 1.005.988 2.914 0 1.185-.493 2.09a3.46 3.46 0 0 1-1.316 1.399 3.5 3.5 0 0 1-1.844.493q-.954 0-1.662-.329a2.67 2.67 0 0 1-1.086-.97l.017 5.134h-1.728zm4.048 6.22q1.07 0 1.645-.674.577-.69.576-1.762 0-1.119-.576-1.777-.558-.675-1.645-.675-.592 0-1.12.296-.51.28-.822.823-.296.527-.296 1.234v.115q0 .708.296 1.267.313.543.823.855.51.296 1.119.297z'/%3E%3Cpath fill='%23e1e3e9' d='M51.325 4.7h1.86v10.45h3.473v1.646h-5.333zm7.12 4.542h1.843v7.553h-1.843zm.905-1.415a1.16 1.16 0 0 1-.856-.346 1.17 1.17 0 0 1-.346-.856 1.05 1.05 0 0 1 .346-.79q.346-.329.856-.329.494 0 .839.33a1.05 1.05 0 0 1 .345.79 1.16 1.16 0 0 1-.345.855q-.33.346-.84.346zm7.875 9.133a3.17 3.17 0 0 1-1.662-.444q-.723-.46-1.004-1.053l-.033 1.332h-1.71V4.701h1.743v4.657l-.082 1.283q.279-.658 1.086-1.119a3.5 3.5 0 0 1 1.778-.477q1.119 0 1.942.51a3.24 3.24 0 0 1 1.283 1.4q.445.888.444 2.072 0 1.201-.526 2.09a3.5 3.5 0 0 1-1.382 1.366 3.8 3.8 0 0 1-1.876.477zm-.296-1.481q1.069 0 1.645-.675.577-.69.577-1.778 0-1.102-.577-1.776-.56-.691-1.645-.692a2.12 2.12 0 0 0-1.58.659q-.642.641-.642 1.694v.115q0 .71.296 1.267a2.4 2.4 0 0 0 .807.872 2.1 2.1 0 0 0 1.119.313zm5.927-6.237h1.777v1.481q.263-.757.856-1.217a2.14 2.14 0 0 1 1.349-.46q.527 0 .724.098l-.247 1.794q-.149-.099-.642-.099-.774 0-1.416.494-.626.493-.626 1.58v3.883h-1.777V9.242zm9.534 7.718q-1.35 0-2.255-.526-.904-.543-1.332-1.432a4.6 4.6 0 0 1-.428-1.975q0-1.2.493-2.106a3.46 3.46 0 0 1 1.4-1.382q.889-.495 2.007-.494 1.744 0 2.584.97.855.956.856 2.7 0 .444-.05.92h-5.43q.18 1.005.708 1.45.542.443 1.497.443.79 0 1.3-.131a4 4 0 0 0 .938-.362l.542 1.267q-.411.263-1.119.46-.708.198-1.711.197zm1.596-4.558q.016-1.02-.444-1.432-.46-.428-1.316-.428-1.728 0-1.991 1.86z'/%3E%3Cpath d='M5.074 15.948a.484.657 0 0 0-.486.659v1.84a.484.657 0 0 0 .486.659h4.101a.484.657 0 0 0 .486-.659v-1.84a.484.657 0 0 0-.486-.659zm3.56 1.16H5.617v.838h3.017z' style='fill:%23fff;fill-rule:evenodd;stroke-width:1.03600001'/%3E%3Cg style='stroke-width:1.12603545'%3E%3Cpath d='M-9.408-1.416c-3.833-.025-7.056 2.912-7.08 6.615-.02 3.08 1.653 4.832 3.107 6.268.903.892 1.721 1.74 2.32 2.902l-.525-.004c-.543-.003-.992.304-1.24.639a1.87 1.87 0 0 0-.362 1.121l-.011 1.877c-.003.402.104.787.347 1.125.244.338.688.653 1.23.656l4.142.028c.542.003.99-.306 1.238-.641a1.87 1.87 0 0 0 .363-1.121l.012-1.875a1.87 1.87 0 0 0-.348-1.127c-.243-.338-.688-.653-1.23-.656l-.518-.004c.597-1.145 1.425-1.983 2.348-2.87 1.473-1.414 3.18-3.149 3.2-6.226-.016-3.59-2.923-6.684-6.993-6.707m-.006 1.1v.002c3.274.02 5.92 2.532 5.9 5.6-.017 2.706-1.39 4.026-2.863 5.44-1.034.994-2.118 2.033-2.814 3.633-.018.041-.052.055-.075.065q-.013.004-.02.01a.34.34 0 0 1-.226.084.34.34 0 0 1-.224-.086l-.092-.077c-.699-1.615-1.768-2.669-2.781-3.67-1.454-1.435-2.797-2.762-2.78-5.478.02-3.067 2.7-5.545 5.975-5.523m-.02 2.826c-1.62-.01-2.944 1.315-2.955 2.96-.01 1.646 1.295 2.988 2.916 2.999h.002c1.621.01 2.943-1.316 2.953-2.961.011-1.646-1.294-2.988-2.916-2.998m-.005 1.1c1.017.006 1.829.83 1.822 1.89s-.83 1.874-1.848 1.867c-1.018-.006-1.829-.83-1.822-1.89s.83-1.874 1.848-1.868m-2.155 11.857 4.14.025c.271.002.49.305.487.676l-.013 1.875c-.003.37-.224.67-.495.668l-4.14-.025c-.27-.002-.487-.306-.485-.676l.012-1.875c.003-.37.224-.67.494-.668' style='color:%23000;font-style:normal;font-variant:normal;font-weight:400;font-stretch:normal;font-size:medium;line-height:normal;font-family:sans-serif;font-variant-ligatures:normal;font-variant-position:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-feature-settings:normal;text-indent:0;text-align:start;text-decoration:none;text-decoration-line:none;text-decoration-style:solid;text-decoration-color:%23000;letter-spacing:normal;word-spacing:normal;text-transform:none;writing-mode:lr-tb;direction:ltr;text-orientation:mixed;dominant-baseline:auto;baseline-shift:baseline;text-anchor:start;white-space:normal;shape-padding:0;clip-rule:evenodd;display:inline;overflow:visible;visibility:visible;opacity:1;isolation:auto;mix-blend-mode:normal;color-interpolation:sRGB;color-interpolation-filters:linearRGB;solid-color:%23000;solid-opacity:1;vector-effect:none;fill:%23000;fill-opacity:.4;fill-rule:evenodd;stroke:none;stroke-width:2.47727823;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;color-rendering:auto;image-rendering:auto;shape-rendering:auto;text-rendering:auto' transform='translate(15.553 2.85)scale(.88807)'/%3E%3Cpath d='M-9.415-.316C-12.69-.338-15.37 2.14-15.39 5.207c-.017 2.716 1.326 4.041 2.78 5.477 1.013 1 2.081 2.055 2.78 3.67l.092.076a.34.34 0 0 0 .225.086.34.34 0 0 0 .227-.083l.019-.01c.022-.009.057-.024.074-.064.697-1.6 1.78-2.64 2.814-3.634 1.473-1.414 2.847-2.733 2.864-5.44.02-3.067-2.627-5.58-5.901-5.601m-.057 8.784c1.621.011 2.944-1.315 2.955-2.96.01-1.646-1.295-2.988-2.916-2.999-1.622-.01-2.945 1.315-2.955 2.96s1.295 2.989 2.916 3' style='clip-rule:evenodd;fill:%23e1e3e9;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:2.47727823;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:.4' transform='translate(15.553 2.85)scale(.88807)'/%3E%3Cpath d='M-11.594 15.465c-.27-.002-.492.297-.494.668l-.012 1.876c-.003.371.214.673.485.675l4.14.027c.271.002.492-.298.495-.668l.012-1.877c.003-.37-.215-.672-.485-.674z' style='clip-rule:evenodd;fill:%23fff;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:2.47727823;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:.4' transform='translate(15.553 2.85)scale(.88807)'/%3E%3C/g%3E%3C/svg%3E")}}@media (forced-colors:active) and (prefers-color-scheme:light){a.maplibregl-ctrl-logo{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='88' height='23' fill='none'%3E%3Cpath fill='%23000' fill-opacity='.4' fill-rule='evenodd' d='M17.408 16.796h-1.827l2.501-12.095h.198l3.324 6.533.988 2.19.988-2.19 3.258-6.533h.181l2.6 12.095h-1.81l-1.218-5.644-.362-1.71-.658 1.71-2.929 5.644h-.098l-2.914-5.644-.757-1.71-.345 1.71zm1.958-3.42-.726 3.663a1.255 1.255 0 0 1-1.232 1.011h-1.827a1.255 1.255 0 0 1-1.229-1.509l2.501-12.095a1.255 1.255 0 0 1 1.23-1.001h.197a1.25 1.25 0 0 1 1.12.685l3.19 6.273 3.125-6.263a1.25 1.25 0 0 1 1.123-.695h.181a1.255 1.255 0 0 1 1.227.991l1.443 6.71a5 5 0 0 1 .314-.787l.009-.016a4.6 4.6 0 0 1 1.777-1.887c.782-.46 1.668-.667 2.611-.667a4.6 4.6 0 0 1 1.7.32l.306.134c.21-.16.474-.256.759-.256h1.694a1.255 1.255 0 0 1 1.212.925 1.255 1.255 0 0 1 1.212-.925h1.711c.284 0 .545.094.755.252.613-.3 1.312-.45 2.075-.45 1.356 0 2.557.445 3.482 1.4q.47.48.763 1.064V4.701a1.255 1.255 0 0 1 1.255-1.255h1.86A1.255 1.255 0 0 1 54.44 4.7v9.194h2.217c.19 0 .37.043.532.118v-4.77c0-.356.147-.678.385-.906a2.42 2.42 0 0 1-.682-1.71c0-.665.267-1.253.735-1.7a2.45 2.45 0 0 1 1.722-.674 2.43 2.43 0 0 1 1.705.675q.318.302.504.683V4.7a1.255 1.255 0 0 1 1.255-1.255h1.744A1.255 1.255 0 0 1 65.812 4.7v3.335a4.8 4.8 0 0 1 1.526-.246c.938 0 1.817.214 2.59.69a4.47 4.47 0 0 1 1.67 1.743v-.98a1.255 1.255 0 0 1 1.256-1.256h1.777c.233 0 .451.064.639.174a3.4 3.4 0 0 1 1.567-.372c.346 0 .861.02 1.285.232a1.25 1.25 0 0 1 .689 1.004 4.7 4.7 0 0 1 .853-.588c.795-.44 1.675-.647 2.61-.647 1.385 0 2.65.39 3.525 1.396.836.938 1.168 2.173 1.168 3.528q-.001.515-.056 1.051a1.255 1.255 0 0 1-.947 1.09l.408.952a1.255 1.255 0 0 1-.477 1.552c-.418.268-.92.463-1.458.612-.613.171-1.304.244-2.049.244-1.06 0-2.043-.207-2.886-.698l-.015-.008c-.798-.48-1.419-1.135-1.818-1.963l-.004-.008a5.8 5.8 0 0 1-.548-2.512q0-.429.053-.843a1.3 1.3 0 0 1-.333-.086l-.166-.004c-.223 0-.426.062-.643.228-.03.024-.142.139-.142.59v3.883a1.255 1.255 0 0 1-1.256 1.256h-1.777a1.255 1.255 0 0 1-1.256-1.256V15.69l-.032.057a4.8 4.8 0 0 1-1.86 1.833 5.04 5.04 0 0 1-2.484.634 4.5 4.5 0 0 1-1.935-.424 1.25 1.25 0 0 1-.764.258h-1.71a1.255 1.255 0 0 1-1.256-1.255V7.687a2.4 2.4 0 0 1-.428.625c.253.23.412.561.412.93v7.553a1.255 1.255 0 0 1-1.256 1.255h-1.843a1.25 1.25 0 0 1-.894-.373c-.228.23-.544.373-.894.373H51.32a1.255 1.255 0 0 1-1.256-1.255v-1.251l-.061.117a4.7 4.7 0 0 1-1.782 1.884 4.77 4.77 0 0 1-2.485.67 5.6 5.6 0 0 1-1.485-.188l.009 2.764a1.255 1.255 0 0 1-1.255 1.259h-1.729a1.255 1.255 0 0 1-1.255-1.255v-3.537a1.255 1.255 0 0 1-1.167.793h-1.679a1.25 1.25 0 0 1-.77-.263 4.5 4.5 0 0 1-1.945.429c-.885 0-1.724-.21-2.495-.632l-.017-.01a5 5 0 0 1-1.081-.836 1.255 1.255 0 0 1-1.254 1.312h-1.81a1.255 1.255 0 0 1-1.228-.99l-.782-3.625-2.044 3.939a1.25 1.25 0 0 1-1.115.676h-.098a1.25 1.25 0 0 1-1.116-.68l-2.061-3.994zM35.92 16.63l.207-.114.223-.15q.493-.356.735-.785l.061-.118.033 1.332h1.678V9.242h-1.694l-.033 1.267q-.133-.329-.526-.658l-.032-.028a3.2 3.2 0 0 0-.668-.428l-.27-.12a3.3 3.3 0 0 0-1.235-.23q-1.136-.001-1.974.493a3.36 3.36 0 0 0-1.3 1.382q-.445.89-.444 2.074 0 1.2.51 2.107a3.8 3.8 0 0 0 1.382 1.381 3.9 3.9 0 0 0 1.893.477q.795 0 1.455-.33zm-2.789-5.38q-.576.675-.575 1.762 0 1.102.559 1.794.576.675 1.645.675a2.25 2.25 0 0 0 .934-.19 2.2 2.2 0 0 0 .468-.29l.178-.161a2.2 2.2 0 0 0 .397-.561q.244-.5.244-1.15v-.115q0-.708-.296-1.267l-.043-.077a2.2 2.2 0 0 0-.633-.709l-.13-.086-.047-.028a2.1 2.1 0 0 0-1.073-.285q-1.052 0-1.629.692zm2.316 2.706c.163-.17.28-.407.28-.83v-.114c0-.292-.06-.508-.15-.68a.96.96 0 0 0-.353-.389.85.85 0 0 0-.464-.127c-.4 0-.56.114-.664.239l-.01.012c-.148.174-.275.45-.275.945 0 .506.122.801.27.99.097.11.266.224.68.224.303 0 .504-.09.687-.269zm7.545 1.705a2.6 2.6 0 0 0 .331.423q.319.33.755.548l.173.074q.65.255 1.49.255 1.02 0 1.844-.493a3.45 3.45 0 0 0 1.316-1.4q.493-.904.493-2.089 0-1.909-.988-2.913-.988-1.02-2.584-1.02-.898 0-1.575.347a3 3 0 0 0-.415.262l-.199.166a3.4 3.4 0 0 0-.64.82V9.242h-1.712v11.553h1.729l-.017-5.134zm.53-1.138q.206.29.48.5l.155.11.053.034q.51.296 1.119.297 1.07 0 1.645-.675.577-.69.576-1.762 0-1.119-.576-1.777-.558-.675-1.645-.675-.435 0-.835.16a2 2 0 0 0-.284.136 2 2 0 0 0-.363.254 2.2 2.2 0 0 0-.46.569l-.082.162a2.6 2.6 0 0 0-.213 1.072v.115q0 .707.296 1.267l.135.211zm.964-.818a1.1 1.1 0 0 0 .367.385.94.94 0 0 0 .476.118c.423 0 .59-.117.687-.23.159-.194.28-.478.28-.95 0-.53-.133-.8-.266-.952l-.021-.025c-.078-.094-.231-.221-.68-.221a1 1 0 0 0-.503.135l-.012.007a.86.86 0 0 0-.335.343c-.073.133-.132.324-.132.614v.115a1.4 1.4 0 0 0 .14.66zm15.7-6.222q.347-.346.346-.856a1.05 1.05 0 0 0-.345-.79 1.18 1.18 0 0 0-.84-.329q-.51 0-.855.33a1.05 1.05 0 0 0-.346.79q0 .51.346.855.345.346.856.346.51 0 .839-.346zm4.337 9.314.033-1.332q.191.403.59.747l.098.081a4 4 0 0 0 .316.224l.223.122a3.2 3.2 0 0 0 1.44.322 3.8 3.8 0 0 0 1.875-.477 3.5 3.5 0 0 0 1.382-1.366q.527-.89.526-2.09 0-1.184-.444-2.073a3.24 3.24 0 0 0-1.283-1.399q-.823-.51-1.942-.51a3.5 3.5 0 0 0-1.527.344l-.086.043-.165.09a3 3 0 0 0-.33.214q-.432.315-.656.707a2 2 0 0 0-.099.198l.082-1.283V4.701h-1.744v12.095zm.473-2.509a2.5 2.5 0 0 0 .566.7q.117.098.245.18l.144.08a2.1 2.1 0 0 0 .975.232q1.07 0 1.645-.675.576-.69.576-1.778 0-1.102-.576-1.777-.56-.691-1.645-.692a2.2 2.2 0 0 0-1.015.235q-.22.113-.415.282l-.15.142a2.1 2.1 0 0 0-.42.594q-.223.479-.223 1.1v.115q0 .705.293 1.26zm2.616-.293c.157-.191.28-.479.28-.967 0-.51-.13-.79-.276-.961l-.021-.026c-.082-.1-.232-.225-.67-.225a.87.87 0 0 0-.681.279l-.012.011c-.154.155-.274.38-.274.807v.115c0 .285.057.499.144.669a1.1 1.1 0 0 0 .367.405c.137.082.28.123.455.123.423 0 .59-.118.686-.23zm8.266-3.013q.345-.13.724-.14l.069-.002q.493 0 .642.099l.247-1.794q-.196-.099-.717-.099a2.3 2.3 0 0 0-.545.063 2 2 0 0 0-.411.148 2.2 2.2 0 0 0-.4.249 2.5 2.5 0 0 0-.485.499 2.7 2.7 0 0 0-.32.581l-.05.137v-1.48h-1.778v7.553h1.777v-3.884q0-.546.159-.943a1.5 1.5 0 0 1 .466-.636 2.5 2.5 0 0 1 .399-.253 2 2 0 0 1 .224-.099zm9.784 2.656.05-.922q0-1.743-.856-2.698-.838-.97-2.584-.97-1.119-.001-2.007.493a3.46 3.46 0 0 0-1.4 1.382q-.493.906-.493 2.106 0 1.07.428 1.975.428.89 1.332 1.432.906.526 2.255.526.973 0 1.668-.185l.044-.012.135-.04q.613-.184.984-.421l-.542-1.267q-.3.162-.642.274l-.297.087q-.51.131-1.3.131-.954 0-1.497-.444a1.6 1.6 0 0 1-.192-.193q-.366-.44-.512-1.234l-.004-.021zm-5.427-1.256-.003.022h3.752v-.138q-.011-.727-.288-1.118a1 1 0 0 0-.156-.176q-.46-.428-1.316-.428-.986 0-1.494.604-.379.45-.494 1.234zm-27.053 2.77V4.7h-1.86v12.095h5.333V15.15zm7.103-5.908v7.553h-1.843V9.242h1.843z'/%3E%3Cpath fill='%23fff' d='m19.63 11.151-.757-1.71-.345 1.71-1.12 5.644h-1.827L18.083 4.7h.197l3.325 6.533.988 2.19.988-2.19L26.839 4.7h.181l2.6 12.095h-1.81l-1.218-5.644-.362-1.71-.658 1.71-2.93 5.644h-.098l-2.913-5.644zm14.836 5.81q-1.02 0-1.893-.478a3.8 3.8 0 0 1-1.381-1.382q-.51-.906-.51-2.106 0-1.185.444-2.074a3.36 3.36 0 0 1 1.3-1.382q.839-.494 1.974-.494a3.3 3.3 0 0 1 1.234.231 3.3 3.3 0 0 1 .97.575q.396.33.527.659l.033-1.267h1.694v7.553H37.18l-.033-1.332q-.279.593-1.02 1.053a3.17 3.17 0 0 1-1.662.444zm.296-1.482q.938 0 1.58-.642.642-.66.642-1.711v-.115q0-.708-.296-1.267a2.2 2.2 0 0 0-.807-.872 2.1 2.1 0 0 0-1.119-.313q-1.053 0-1.629.692-.575.675-.575 1.76 0 1.103.559 1.795.577.675 1.645.675zm6.521-6.237h1.711v1.4q.906-1.597 2.83-1.597 1.596 0 2.584 1.02.988 1.005.988 2.914 0 1.185-.493 2.09a3.46 3.46 0 0 1-1.316 1.399 3.5 3.5 0 0 1-1.844.493q-.954 0-1.662-.329a2.67 2.67 0 0 1-1.086-.97l.017 5.134h-1.728zm4.048 6.22q1.07 0 1.645-.674.577-.69.576-1.762 0-1.119-.576-1.777-.558-.675-1.645-.675-.592 0-1.12.296-.51.28-.822.823-.296.527-.296 1.234v.115q0 .708.296 1.267.313.543.823.855.51.296 1.119.297z'/%3E%3Cpath fill='%23e1e3e9' d='M51.325 4.7h1.86v10.45h3.473v1.646h-5.333zm7.12 4.542h1.843v7.553h-1.843zm.905-1.415a1.16 1.16 0 0 1-.856-.346 1.17 1.17 0 0 1-.346-.856 1.05 1.05 0 0 1 .346-.79q.346-.329.856-.329.494 0 .839.33a1.05 1.05 0 0 1 .345.79 1.16 1.16 0 0 1-.345.855q-.33.346-.84.346zm7.875 9.133a3.17 3.17 0 0 1-1.662-.444q-.723-.46-1.004-1.053l-.033 1.332h-1.71V4.701h1.743v4.657l-.082 1.283q.279-.658 1.086-1.119a3.5 3.5 0 0 1 1.778-.477q1.119 0 1.942.51a3.24 3.24 0 0 1 1.283 1.4q.445.888.444 2.072 0 1.201-.526 2.09a3.5 3.5 0 0 1-1.382 1.366 3.8 3.8 0 0 1-1.876.477zm-.296-1.481q1.069 0 1.645-.675.577-.69.577-1.778 0-1.102-.577-1.776-.56-.691-1.645-.692a2.12 2.12 0 0 0-1.58.659q-.642.641-.642 1.694v.115q0 .71.296 1.267a2.4 2.4 0 0 0 .807.872 2.1 2.1 0 0 0 1.119.313zm5.927-6.237h1.777v1.481q.263-.757.856-1.217a2.14 2.14 0 0 1 1.349-.46q.527 0 .724.098l-.247 1.794q-.149-.099-.642-.099-.774 0-1.416.494-.626.493-.626 1.58v3.883h-1.777V9.242zm9.534 7.718q-1.35 0-2.255-.526-.904-.543-1.332-1.432a4.6 4.6 0 0 1-.428-1.975q0-1.2.493-2.106a3.46 3.46 0 0 1 1.4-1.382q.889-.495 2.007-.494 1.744 0 2.584.97.855.956.856 2.7 0 .444-.05.92h-5.43q.18 1.005.708 1.45.542.443 1.497.443.79 0 1.3-.131a4 4 0 0 0 .938-.362l.542 1.267q-.411.263-1.119.46-.708.198-1.711.197zm1.596-4.558q.016-1.02-.444-1.432-.46-.428-1.316-.428-1.728 0-1.991 1.86z'/%3E%3Cpath d='M5.074 15.948a.484.657 0 0 0-.486.659v1.84a.484.657 0 0 0 .486.659h4.101a.484.657 0 0 0 .486-.659v-1.84a.484.657 0 0 0-.486-.659zm3.56 1.16H5.617v.838h3.017z' style='fill:%23fff;fill-rule:evenodd;stroke-width:1.03600001'/%3E%3Cg style='stroke-width:1.12603545'%3E%3Cpath d='M-9.408-1.416c-3.833-.025-7.056 2.912-7.08 6.615-.02 3.08 1.653 4.832 3.107 6.268.903.892 1.721 1.74 2.32 2.902l-.525-.004c-.543-.003-.992.304-1.24.639a1.87 1.87 0 0 0-.362 1.121l-.011 1.877c-.003.402.104.787.347 1.125.244.338.688.653 1.23.656l4.142.028c.542.003.99-.306 1.238-.641a1.87 1.87 0 0 0 .363-1.121l.012-1.875a1.87 1.87 0 0 0-.348-1.127c-.243-.338-.688-.653-1.23-.656l-.518-.004c.597-1.145 1.425-1.983 2.348-2.87 1.473-1.414 3.18-3.149 3.2-6.226-.016-3.59-2.923-6.684-6.993-6.707m-.006 1.1v.002c3.274.02 5.92 2.532 5.9 5.6-.017 2.706-1.39 4.026-2.863 5.44-1.034.994-2.118 2.033-2.814 3.633-.018.041-.052.055-.075.065q-.013.004-.02.01a.34.34 0 0 1-.226.084.34.34 0 0 1-.224-.086l-.092-.077c-.699-1.615-1.768-2.669-2.781-3.67-1.454-1.435-2.797-2.762-2.78-5.478.02-3.067 2.7-5.545 5.975-5.523m-.02 2.826c-1.62-.01-2.944 1.315-2.955 2.96-.01 1.646 1.295 2.988 2.916 2.999h.002c1.621.01 2.943-1.316 2.953-2.961.011-1.646-1.294-2.988-2.916-2.998m-.005 1.1c1.017.006 1.829.83 1.822 1.89s-.83 1.874-1.848 1.867c-1.018-.006-1.829-.83-1.822-1.89s.83-1.874 1.848-1.868m-2.155 11.857 4.14.025c.271.002.49.305.487.676l-.013 1.875c-.003.37-.224.67-.495.668l-4.14-.025c-.27-.002-.487-.306-.485-.676l.012-1.875c.003-.37.224-.67.494-.668' style='color:%23000;font-style:normal;font-variant:normal;font-weight:400;font-stretch:normal;font-size:medium;line-height:normal;font-family:sans-serif;font-variant-ligatures:normal;font-variant-position:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-feature-settings:normal;text-indent:0;text-align:start;text-decoration:none;text-decoration-line:none;text-decoration-style:solid;text-decoration-color:%23000;letter-spacing:normal;word-spacing:normal;text-transform:none;writing-mode:lr-tb;direction:ltr;text-orientation:mixed;dominant-baseline:auto;baseline-shift:baseline;text-anchor:start;white-space:normal;shape-padding:0;clip-rule:evenodd;display:inline;overflow:visible;visibility:visible;opacity:1;isolation:auto;mix-blend-mode:normal;color-interpolation:sRGB;color-interpolation-filters:linearRGB;solid-color:%23000;solid-opacity:1;vector-effect:none;fill:%23000;fill-opacity:.4;fill-rule:evenodd;stroke:none;stroke-width:2.47727823;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;color-rendering:auto;image-rendering:auto;shape-rendering:auto;text-rendering:auto' transform='translate(15.553 2.85)scale(.88807)'/%3E%3Cpath d='M-9.415-.316C-12.69-.338-15.37 2.14-15.39 5.207c-.017 2.716 1.326 4.041 2.78 5.477 1.013 1 2.081 2.055 2.78 3.67l.092.076a.34.34 0 0 0 .225.086.34.34 0 0 0 .227-.083l.019-.01c.022-.009.057-.024.074-.064.697-1.6 1.78-2.64 2.814-3.634 1.473-1.414 2.847-2.733 2.864-5.44.02-3.067-2.627-5.58-5.901-5.601m-.057 8.784c1.621.011 2.944-1.315 2.955-2.96.01-1.646-1.295-2.988-2.916-2.999-1.622-.01-2.945 1.315-2.955 2.96s1.295 2.989 2.916 3' style='clip-rule:evenodd;fill:%23e1e3e9;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:2.47727823;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:.4' transform='translate(15.553 2.85)scale(.88807)'/%3E%3Cpath d='M-11.594 15.465c-.27-.002-.492.297-.494.668l-.012 1.876c-.003.371.214.673.485.675l4.14.027c.271.002.492-.298.495-.668l.012-1.877c.003-.37-.215-.672-.485-.674z' style='clip-rule:evenodd;fill:%23fff;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:2.47727823;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:.4' transform='translate(15.553 2.85)scale(.88807)'/%3E%3C/g%3E%3C/svg%3E")}}.maplibregl-ctrl.maplibregl-ctrl-attrib{background-color:#ffffff80;margin:0;padding:0 5px}@media screen{.maplibregl-ctrl-attrib.maplibregl-compact{background-color:#fff;border-radius:12px;box-sizing:content-box;color:#000;margin:10px;min-height:20px;padding:2px 24px 2px 0;position:relative}.maplibregl-ctrl-attrib.maplibregl-compact-show{padding:2px 28px 2px 8px;visibility:visible}.maplibregl-ctrl-bottom-left>.maplibregl-ctrl-attrib.maplibregl-compact-show,.maplibregl-ctrl-top-left>.maplibregl-ctrl-attrib.maplibregl-compact-show{border-radius:12px;padding:2px 8px 2px 28px}.maplibregl-ctrl-attrib.maplibregl-compact .maplibregl-ctrl-attrib-inner{display:none}.maplibregl-ctrl-attrib-button{background-color:#ffffff80;background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' fill-rule='evenodd' viewBox='0 0 20 20'%3E%3Cpath d='M4 10a6 6 0 1 0 12 0 6 6 0 1 0-12 0m5-3a1 1 0 1 0 2 0 1 1 0 1 0-2 0m0 3a1 1 0 1 1 2 0v3a1 1 0 1 1-2 0'/%3E%3C/svg%3E");border:0;border-radius:12px;box-sizing:border-box;cursor:pointer;display:none;height:24px;outline:none;position:absolute;right:0;top:0;width:24px}.maplibregl-ctrl-attrib summary.maplibregl-ctrl-attrib-button{-webkit-appearance:none;-moz-appearance:none;appearance:none;list-style:none}.maplibregl-ctrl-attrib summary.maplibregl-ctrl-attrib-button::-webkit-details-marker{display:none}.maplibregl-ctrl-bottom-left .maplibregl-ctrl-attrib-button,.maplibregl-ctrl-top-left .maplibregl-ctrl-attrib-button{left:0}.maplibregl-ctrl-attrib.maplibregl-compact .maplibregl-ctrl-attrib-button,.maplibregl-ctrl-attrib.maplibregl-compact-show .maplibregl-ctrl-attrib-inner{display:block}.maplibregl-ctrl-attrib.maplibregl-compact-show .maplibregl-ctrl-attrib-button{background-color:#0000000d}.maplibregl-ctrl-bottom-right>.maplibregl-ctrl-attrib.maplibregl-compact:after{bottom:0;right:0}.maplibregl-ctrl-top-right>.maplibregl-ctrl-attrib.maplibregl-compact:after{right:0;top:0}.maplibregl-ctrl-top-left>.maplibregl-ctrl-attrib.maplibregl-compact:after{left:0;top:0}.maplibregl-ctrl-bottom-left>.maplibregl-ctrl-attrib.maplibregl-compact:after{bottom:0;left:0}}@media screen and (forced-colors:active){.maplibregl-ctrl-attrib.maplibregl-compact:after{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' fill='%23fff' fill-rule='evenodd' viewBox='0 0 20 20'%3E%3Cpath d='M4 10a6 6 0 1 0 12 0 6 6 0 1 0-12 0m5-3a1 1 0 1 0 2 0 1 1 0 1 0-2 0m0 3a1 1 0 1 1 2 0v3a1 1 0 1 1-2 0'/%3E%3C/svg%3E")}}@media screen and (forced-colors:active) and (prefers-color-scheme:light){.maplibregl-ctrl-attrib.maplibregl-compact:after{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' fill-rule='evenodd' viewBox='0 0 20 20'%3E%3Cpath d='M4 10a6 6 0 1 0 12 0 6 6 0 1 0-12 0m5-3a1 1 0 1 0 2 0 1 1 0 1 0-2 0m0 3a1 1 0 1 1 2 0v3a1 1 0 1 1-2 0'/%3E%3C/svg%3E")}}.maplibregl-ctrl-attrib a{color:#000000bf;text-decoration:none}.maplibregl-ctrl-attrib a:hover{color:inherit;text-decoration:underline}.maplibregl-attrib-empty{display:none}.maplibregl-ctrl-scale{background-color:#ffffffbf;border:2px solid #333;border-top:#333;box-sizing:border-box;color:#333;font-size:10px;padding:0 5px}.maplibregl-popup{display:flex;left:0;pointer-events:none;position:absolute;top:0;will-change:transform}.maplibregl-popup-anchor-top,.maplibregl-popup-anchor-top-left,.maplibregl-popup-anchor-top-right{flex-direction:column}.maplibregl-popup-anchor-bottom,.maplibregl-popup-anchor-bottom-left,.maplibregl-popup-anchor-bottom-right{flex-direction:column-reverse}.maplibregl-popup-anchor-left{flex-direction:row}.maplibregl-popup-anchor-right{flex-direction:row-reverse}.maplibregl-popup-tip{border:10px solid transparent;height:0;width:0;z-index:1}.maplibregl-popup-anchor-top .maplibregl-popup-tip{align-self:center;border-bottom-color:#fff;border-top:none}.maplibregl-popup-anchor-top-left .maplibregl-popup-tip{align-self:flex-start;border-bottom-color:#fff;border-left:none;border-top:none}.maplibregl-popup-anchor-top-right .maplibregl-popup-tip{align-self:flex-end;border-bottom-color:#fff;border-right:none;border-top:none}.maplibregl-popup-anchor-bottom .maplibregl-popup-tip{align-self:center;border-bottom:none;border-top-color:#fff}.maplibregl-popup-anchor-bottom-left .maplibregl-popup-tip{align-self:flex-start;border-bottom:none;border-left:none;border-top-color:#fff}.maplibregl-popup-anchor-bottom-right .maplibregl-popup-tip{align-self:flex-end;border-bottom:none;border-right:none;border-top-color:#fff}.maplibregl-popup-anchor-left .maplibregl-popup-tip{align-self:center;border-left:none;border-right-color:#fff}.maplibregl-popup-anchor-right .maplibregl-popup-tip{align-self:center;border-left-color:#fff;border-right:none}.maplibregl-popup-close-button{background-color:transparent;border:0;border-radius:0 3px 0 0;cursor:pointer;position:absolute;right:0;top:0}.maplibregl-popup-close-button:hover{background-color:#0000000d}.maplibregl-popup-content{background:#fff;border-radius:3px;box-shadow:0 1px 2px #0000001a;padding:15px 10px;pointer-events:auto;position:relative}.maplibregl-popup-anchor-top-left .maplibregl-popup-content{border-top-left-radius:0}.maplibregl-popup-anchor-top-right .maplibregl-popup-content{border-top-right-radius:0}.maplibregl-popup-anchor-bottom-left .maplibregl-popup-content{border-bottom-left-radius:0}.maplibregl-popup-anchor-bottom-right .maplibregl-popup-content{border-bottom-right-radius:0}.maplibregl-popup-track-pointer{display:none}.maplibregl-popup-track-pointer *{pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.maplibregl-map:hover .maplibregl-popup-track-pointer{display:flex}.maplibregl-map:active .maplibregl-popup-track-pointer{display:none}.maplibregl-marker{left:0;position:absolute;top:0;transition:opacity .2s;will-change:transform}.maplibregl-user-location-dot,.maplibregl-user-location-dot:before{background-color:#1da1f2;border-radius:50%;height:15px;width:15px}.maplibregl-user-location-dot:before{animation:maplibregl-user-location-dot-pulse 2s infinite;content:"";position:absolute}.maplibregl-user-location-dot:after{border:2px solid #fff;border-radius:50%;box-shadow:0 0 3px #00000059;box-sizing:border-box;content:"";height:19px;left:-2px;position:absolute;top:-2px;width:19px}@keyframes maplibregl-user-location-dot-pulse{0%{opacity:1;transform:scale(1)}70%{opacity:0;transform:scale(3)}to{opacity:0;transform:scale(1)}}.maplibregl-user-location-dot-stale{background-color:#aaa}.maplibregl-user-location-dot-stale:after{display:none}.maplibregl-user-location-accuracy-circle{background-color:#1da1f233;border-radius:100%;height:1px;width:1px}.maplibregl-crosshair,.maplibregl-crosshair .maplibregl-interactive,.maplibregl-crosshair .maplibregl-interactive:active{cursor:crosshair}.maplibregl-boxzoom{background:#fff;border:2px dotted #202020;height:0;left:0;opacity:.5;position:absolute;top:0;width:0}.maplibregl-cooperative-gesture-screen{align-items:center;background:#0006;color:#fff;display:flex;font-size:1.4em;inset:0;justify-content:center;line-height:1.2;opacity:0;padding:1rem;pointer-events:none;position:absolute;transition:opacity 1s ease 1s;z-index:99999}.maplibregl-cooperative-gesture-screen.maplibregl-show{opacity:1;transition:opacity .05s}.maplibregl-cooperative-gesture-screen .maplibregl-mobile-message{display:none}@media (hover:none),(pointer:coarse){.maplibregl-cooperative-gesture-screen .maplibregl-desktop-message{display:none}.maplibregl-cooperative-gesture-screen .maplibregl-mobile-message{display:block}}.maplibregl-pseudo-fullscreen{height:100%!important;left:0!important;position:fixed!important;top:0!important;width:100%!important;z-index:99999}.psv-navbar{display:none!important}`)),document.head.appendChild(l)}}catch(a){console.error("vite-plugin-css-injected-by-js",a)}})();
function Y1(t, e) {
  for (var i = 0; i < e.length; i++) {
    const s = e[i];
    if (typeof s != "string" && !Array.isArray(s)) {
      for (const o in s)
        if (o !== "default" && !(o in t)) {
          const u = Object.getOwnPropertyDescriptor(s, o);
          u && Object.defineProperty(t, o, u.get ? u : {
            enumerable: !0,
            get: () => s[o]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }));
}
function J1(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var Kf = { exports: {} };
/**
 * MapLibre GL JS
 * @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v5.6.2/LICENSE.txt
 */
var cC = Kf.exports, N0;
function hC() {
  return N0 || (N0 = 1, (function(t, e) {
    (function(i, s) {
      t.exports = s();
    })(cC, (function() {
      var i = {}, s = {};
      function o(d, a, w) {
        if (s[d] = w, d === "index") {
          var S = "var sharedModule = {}; (" + s.shared + ")(sharedModule); (" + s.worker + ")(sharedModule);", M = {};
          return s.shared(M), s.index(i, M), typeof window < "u" && i.setWorkerUrl(window.URL.createObjectURL(new Blob([S], { type: "text/javascript" }))), i;
        }
      }
      o("shared", ["exports"], (function(d) {
        function a(c, n, l, f) {
          return new (l || (l = Promise))((function(_, b) {
            function v(I) {
              try {
                A(f.next(I));
              } catch (P) {
                b(P);
              }
            }
            function T(I) {
              try {
                A(f.throw(I));
              } catch (P) {
                b(P);
              }
            }
            function A(I) {
              var P;
              I.done ? _(I.value) : (P = I.value, P instanceof l ? P : new l((function(D) {
                D(P);
              }))).then(v, T);
            }
            A((f = f.apply(c, n || [])).next());
          }));
        }
        function w(c, n) {
          this.x = c, this.y = n;
        }
        function S(c) {
          return c && c.__esModule && Object.prototype.hasOwnProperty.call(c, "default") ? c.default : c;
        }
        var M, F;
        typeof SuppressedError == "function" && SuppressedError, w.prototype = { clone() {
          return new w(this.x, this.y);
        }, add(c) {
          return this.clone()._add(c);
        }, sub(c) {
          return this.clone()._sub(c);
        }, multByPoint(c) {
          return this.clone()._multByPoint(c);
        }, divByPoint(c) {
          return this.clone()._divByPoint(c);
        }, mult(c) {
          return this.clone()._mult(c);
        }, div(c) {
          return this.clone()._div(c);
        }, rotate(c) {
          return this.clone()._rotate(c);
        }, rotateAround(c, n) {
          return this.clone()._rotateAround(c, n);
        }, matMult(c) {
          return this.clone()._matMult(c);
        }, unit() {
          return this.clone()._unit();
        }, perp() {
          return this.clone()._perp();
        }, round() {
          return this.clone()._round();
        }, mag() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }, equals(c) {
          return this.x === c.x && this.y === c.y;
        }, dist(c) {
          return Math.sqrt(this.distSqr(c));
        }, distSqr(c) {
          const n = c.x - this.x, l = c.y - this.y;
          return n * n + l * l;
        }, angle() {
          return Math.atan2(this.y, this.x);
        }, angleTo(c) {
          return Math.atan2(this.y - c.y, this.x - c.x);
        }, angleWith(c) {
          return this.angleWithSep(c.x, c.y);
        }, angleWithSep(c, n) {
          return Math.atan2(this.x * n - this.y * c, this.x * c + this.y * n);
        }, _matMult(c) {
          const n = c[2] * this.x + c[3] * this.y;
          return this.x = c[0] * this.x + c[1] * this.y, this.y = n, this;
        }, _add(c) {
          return this.x += c.x, this.y += c.y, this;
        }, _sub(c) {
          return this.x -= c.x, this.y -= c.y, this;
        }, _mult(c) {
          return this.x *= c, this.y *= c, this;
        }, _div(c) {
          return this.x /= c, this.y /= c, this;
        }, _multByPoint(c) {
          return this.x *= c.x, this.y *= c.y, this;
        }, _divByPoint(c) {
          return this.x /= c.x, this.y /= c.y, this;
        }, _unit() {
          return this._div(this.mag()), this;
        }, _perp() {
          const c = this.y;
          return this.y = this.x, this.x = -c, this;
        }, _rotate(c) {
          const n = Math.cos(c), l = Math.sin(c), f = l * this.x + n * this.y;
          return this.x = n * this.x - l * this.y, this.y = f, this;
        }, _rotateAround(c, n) {
          const l = Math.cos(c), f = Math.sin(c), _ = n.y + f * (this.x - n.x) + l * (this.y - n.y);
          return this.x = n.x + l * (this.x - n.x) - f * (this.y - n.y), this.y = _, this;
        }, _round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        }, constructor: w }, w.convert = function(c) {
          if (c instanceof w) return c;
          if (Array.isArray(c)) return new w(+c[0], +c[1]);
          if (c.x !== void 0 && c.y !== void 0) return new w(+c.x, +c.y);
          throw new Error("Expected [x, y] or {x, y} point format");
        };
        var N = (function() {
          if (F) return M;
          function c(n, l, f, _) {
            this.cx = 3 * n, this.bx = 3 * (f - n) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * l, this.by = 3 * (_ - l) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = n, this.p1y = l, this.p2x = f, this.p2y = _;
          }
          return F = 1, M = c, c.prototype = { sampleCurveX: function(n) {
            return ((this.ax * n + this.bx) * n + this.cx) * n;
          }, sampleCurveY: function(n) {
            return ((this.ay * n + this.by) * n + this.cy) * n;
          }, sampleCurveDerivativeX: function(n) {
            return (3 * this.ax * n + 2 * this.bx) * n + this.cx;
          }, solveCurveX: function(n, l) {
            if (l === void 0 && (l = 1e-6), n < 0) return 0;
            if (n > 1) return 1;
            for (var f = n, _ = 0; _ < 8; _++) {
              var b = this.sampleCurveX(f) - n;
              if (Math.abs(b) < l) return f;
              var v = this.sampleCurveDerivativeX(f);
              if (Math.abs(v) < 1e-6) break;
              f -= b / v;
            }
            var T = 0, A = 1;
            for (f = n, _ = 0; _ < 20 && (b = this.sampleCurveX(f), !(Math.abs(b - n) < l)); _++) n > b ? T = f : A = f, f = 0.5 * (A - T) + T;
            return f;
          }, solve: function(n, l) {
            return this.sampleCurveY(this.solveCurveX(n, l));
          } }, M;
        })(), L = S(N);
        let re, ne;
        function we() {
          return re == null && (re = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), re;
        }
        function Se() {
          if (ne == null && (ne = !1, we())) {
            const n = new OffscreenCanvas(5, 5).getContext("2d", { willReadFrequently: !0 });
            if (n) {
              for (let f = 0; f < 25; f++) {
                const _ = 4 * f;
                n.fillStyle = `rgb(${_},${_ + 1},${_ + 2})`, n.fillRect(f % 5, Math.floor(f / 5), 1, 1);
              }
              const l = n.getImageData(0, 0, 5, 5).data;
              for (let f = 0; f < 100; f++) if (f % 4 != 3 && l[f] !== f) {
                ne = !0;
                break;
              }
            }
          }
          return ne || !1;
        }
        var Ee = 1e-6, Ce = typeof Float32Array < "u" ? Float32Array : Array;
        function Le() {
          var c = new Ce(9);
          return Ce != Float32Array && (c[1] = 0, c[2] = 0, c[3] = 0, c[5] = 0, c[6] = 0, c[7] = 0), c[0] = 1, c[4] = 1, c[8] = 1, c;
        }
        function Ze(c) {
          return c[0] = 1, c[1] = 0, c[2] = 0, c[3] = 0, c[4] = 0, c[5] = 1, c[6] = 0, c[7] = 0, c[8] = 0, c[9] = 0, c[10] = 1, c[11] = 0, c[12] = 0, c[13] = 0, c[14] = 0, c[15] = 1, c;
        }
        function Ke() {
          var c = new Ce(3);
          return Ce != Float32Array && (c[0] = 0, c[1] = 0, c[2] = 0), c;
        }
        function ct(c) {
          return Math.hypot(c[0], c[1], c[2]);
        }
        function _t(c, n, l) {
          var f = new Ce(3);
          return f[0] = c, f[1] = n, f[2] = l, f;
        }
        function st(c, n, l) {
          return c[0] = n[0] + l[0], c[1] = n[1] + l[1], c[2] = n[2] + l[2], c;
        }
        function ot(c, n, l) {
          return c[0] = n[0] * l, c[1] = n[1] * l, c[2] = n[2] * l, c;
        }
        function bt(c, n, l) {
          var f = n[0], _ = n[1], b = n[2], v = l[0], T = l[1], A = l[2];
          return c[0] = _ * A - b * T, c[1] = b * v - f * A, c[2] = f * T - _ * v, c;
        }
        Math.hypot || (Math.hypot = function() {
          for (var c = 0, n = arguments.length; n--; ) c += arguments[n] * arguments[n];
          return Math.sqrt(c);
        });
        var Ft, jt = ct;
        function Et(c, n, l) {
          var f = n[0], _ = n[1], b = n[2], v = n[3];
          return c[0] = l[0] * f + l[4] * _ + l[8] * b + l[12] * v, c[1] = l[1] * f + l[5] * _ + l[9] * b + l[13] * v, c[2] = l[2] * f + l[6] * _ + l[10] * b + l[14] * v, c[3] = l[3] * f + l[7] * _ + l[11] * b + l[15] * v, c;
        }
        function bi() {
          var c = new Ce(4);
          return Ce != Float32Array && (c[0] = 0, c[1] = 0, c[2] = 0), c[3] = 1, c;
        }
        function Dr(c, n, l, f) {
          var _ = 0.5 * Math.PI / 180;
          n *= _, l *= _, f *= _;
          var b = Math.sin(n), v = Math.cos(n), T = Math.sin(l), A = Math.cos(l), I = Math.sin(f), P = Math.cos(f);
          return c[0] = b * A * P - v * T * I, c[1] = v * T * P + b * A * I, c[2] = v * A * I - b * T * P, c[3] = v * A * P + b * T * I, c;
        }
        function gr() {
          var c = new Ce(2);
          return Ce != Float32Array && (c[0] = 0, c[1] = 0), c;
        }
        function Ln(c, n) {
          var l = new Ce(2);
          return l[0] = c, l[1] = n, l;
        }
        Ke(), Ft = new Ce(4), Ce != Float32Array && (Ft[0] = 0, Ft[1] = 0, Ft[2] = 0, Ft[3] = 0), Ke(), _t(1, 0, 0), _t(0, 1, 0), bi(), bi(), Le(), gr();
        const Ht = 8192;
        function rr(c, n, l) {
          return n * (Ht / (c.tileSize * Math.pow(2, l - c.tileID.overscaledZ)));
        }
        function wi(c, n) {
          return (c % n + n) % n;
        }
        function sr(c, n, l) {
          return c * (1 - l) + n * l;
        }
        function cs(c) {
          if (c <= 0) return 0;
          if (c >= 1) return 1;
          const n = c * c, l = n * c;
          return 4 * (c < 0.5 ? l : 3 * (c - n) + l - 0.75);
        }
        function hs(c, n, l, f) {
          const _ = new L(c, n, l, f);
          return (b) => _.solve(b);
        }
        const pn = hs(0.25, 0.1, 0.25, 1);
        function Er(c, n, l) {
          return Math.min(l, Math.max(n, c));
        }
        function Ri(c, n, l) {
          const f = l - n, _ = ((c - n) % f + f) % f + n;
          return _ === n ? l : _;
        }
        function ji(c, ...n) {
          for (const l of n) for (const f in l) c[f] = l[f];
          return c;
        }
        let qt = 1;
        function Fi(c, n, l) {
          const f = {};
          for (const _ in c) f[_] = n.call(this, c[_], _, c);
          return f;
        }
        function ws(c, n, l) {
          const f = {};
          for (const _ in c) n.call(this, c[_], _, c) && (f[_] = c[_]);
          return f;
        }
        function Ji(c) {
          return Array.isArray(c) ? c.map(Ji) : typeof c == "object" && c ? Fi(c, Ji) : c;
        }
        const ni = {};
        function ai(c) {
          ni[c] || (typeof console < "u" && console.warn(c), ni[c] = !0);
        }
        function mr(c, n, l) {
          return (l.y - c.y) * (n.x - c.x) > (n.y - c.y) * (l.x - c.x);
        }
        function ki(c) {
          return typeof WorkerGlobalScope < "u" && c !== void 0 && c instanceof WorkerGlobalScope;
        }
        let Or = null;
        function es(c) {
          return typeof ImageBitmap < "u" && c instanceof ImageBitmap;
        }
        const ts = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        function Ts(c, n, l, f, _) {
          return a(this, void 0, void 0, (function* () {
            if (typeof VideoFrame > "u") throw new Error("VideoFrame not supported");
            const b = new VideoFrame(c, { timestamp: 0 });
            try {
              const v = b?.format;
              if (!v || !v.startsWith("BGR") && !v.startsWith("RGB")) throw new Error(`Unrecognized format ${v}`);
              const T = v.startsWith("BGR"), A = new Uint8ClampedArray(f * _ * 4);
              if (yield b.copyTo(A, (function(I, P, D, U, V) {
                const j = 4 * Math.max(-P, 0), G = (Math.max(0, D) - D) * U * 4 + j, Z = 4 * U, te = Math.max(0, P), me = Math.max(0, D);
                return { rect: { x: te, y: me, width: Math.min(I.width, P + U) - te, height: Math.min(I.height, D + V) - me }, layout: [{ offset: G, stride: Z }] };
              })(c, n, l, f, _)), T) for (let I = 0; I < A.length; I += 4) {
                const P = A[I];
                A[I] = A[I + 2], A[I + 2] = P;
              }
              return A;
            } finally {
              b.close();
            }
          }));
        }
        let Ni, Ks;
        function Ys(c, n, l, f) {
          return c.addEventListener(n, l, f), { unsubscribe: () => {
            c.removeEventListener(n, l, f);
          } };
        }
        function _n(c) {
          return c * Math.PI / 180;
        }
        function Js(c) {
          return c / Math.PI * 180;
        }
        const Qs = { touchstart: !0, touchmove: !0, touchmoveWindow: !0, touchend: !0, touchcancel: !0 }, As = { dblclick: !0, click: !0, mouseover: !0, mouseout: !0, mousedown: !0, mousemove: !0, mousemoveWindow: !0, mouseup: !0, mouseupWindow: !0, contextmenu: !0, wheel: !0 }, gn = "AbortError";
        function _e() {
          return new Error(gn);
        }
        const $ = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
        function W(c) {
          return $.REGISTERED_PROTOCOLS[c.substring(0, c.indexOf("://"))];
        }
        const q = "global-dispatcher";
        class ae extends Error {
          constructor(n, l, f, _) {
            super(`AJAXError: ${l} (${n}): ${f}`), this.status = n, this.statusText = l, this.url = f, this.body = _;
          }
        }
        const pe = () => ki(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href, ge = function(c, n) {
          if (/:\/\//.test(c.url) && !/^https?:|^file:/.test(c.url)) {
            const f = W(c.url);
            if (f) return f(c, n);
            if (ki(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: c, targetMapId: q }, n);
          }
          if (!(/^file:/.test(l = c.url) || /^file:/.test(pe()) && !/^\w+:/.test(l))) {
            if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return (function(f, _) {
              return a(this, void 0, void 0, (function* () {
                const b = new Request(f.url, { method: f.method || "GET", body: f.body, credentials: f.credentials, headers: f.headers, cache: f.cache, referrer: pe(), signal: _.signal });
                let v, T;
                f.type !== "json" || b.headers.has("Accept") || b.headers.set("Accept", "application/json");
                try {
                  v = yield fetch(b);
                } catch (I) {
                  throw new ae(0, I.message, f.url, new Blob());
                }
                if (!v.ok) {
                  const I = yield v.blob();
                  throw new ae(v.status, v.statusText, f.url, I);
                }
                T = f.type === "arrayBuffer" || f.type === "image" ? v.arrayBuffer() : f.type === "json" ? v.json() : v.text();
                const A = yield T;
                if (_.signal.aborted) throw _e();
                return { data: A, cacheControl: v.headers.get("Cache-Control"), expires: v.headers.get("Expires") };
              }));
            })(c, n);
            if (ki(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: c, mustQueue: !0, targetMapId: q }, n);
          }
          var l;
          return (function(f, _) {
            return new Promise(((b, v) => {
              var T;
              const A = new XMLHttpRequest();
              A.open(f.method || "GET", f.url, !0), f.type !== "arrayBuffer" && f.type !== "image" || (A.responseType = "arraybuffer");
              for (const I in f.headers) A.setRequestHeader(I, f.headers[I]);
              f.type === "json" && (A.responseType = "text", !((T = f.headers) === null || T === void 0) && T.Accept || A.setRequestHeader("Accept", "application/json")), A.withCredentials = f.credentials === "include", A.onerror = () => {
                v(new Error(A.statusText));
              }, A.onload = () => {
                if (!_.signal.aborted) if ((A.status >= 200 && A.status < 300 || A.status === 0) && A.response !== null) {
                  let I = A.response;
                  if (f.type === "json") try {
                    I = JSON.parse(A.response);
                  } catch (P) {
                    return void v(P);
                  }
                  b({ data: I, cacheControl: A.getResponseHeader("Cache-Control"), expires: A.getResponseHeader("Expires") });
                } else {
                  const I = new Blob([A.response], { type: A.getResponseHeader("Content-Type") });
                  v(new ae(A.status, A.statusText, f.url, I));
                }
              }, _.signal.addEventListener("abort", (() => {
                A.abort(), v(_e());
              })), A.send(f.body);
            }));
          })(c, n);
        };
        function Pe(c) {
          if (!c || c.indexOf("://") <= 0 || c.indexOf("data:image/") === 0 || c.indexOf("blob:") === 0) return !0;
          const n = new URL(c), l = window.location;
          return n.protocol === l.protocol && n.host === l.host;
        }
        function ye(c, n, l) {
          l[c] && l[c].indexOf(n) !== -1 || (l[c] = l[c] || [], l[c].push(n));
        }
        function Ne(c, n, l) {
          if (l && l[c]) {
            const f = l[c].indexOf(n);
            f !== -1 && l[c].splice(f, 1);
          }
        }
        class He {
          constructor(n, l = {}) {
            ji(this, l), this.type = n;
          }
        }
        class ze extends He {
          constructor(n, l = {}) {
            super("error", ji({ error: n }, l));
          }
        }
        class lt {
          on(n, l) {
            return this._listeners = this._listeners || {}, ye(n, l, this._listeners), { unsubscribe: () => {
              this.off(n, l);
            } };
          }
          off(n, l) {
            return Ne(n, l, this._listeners), Ne(n, l, this._oneTimeListeners), this;
          }
          once(n, l) {
            return l ? (this._oneTimeListeners = this._oneTimeListeners || {}, ye(n, l, this._oneTimeListeners), this) : new Promise(((f) => this.once(n, f)));
          }
          fire(n, l) {
            typeof n == "string" && (n = new He(n, l || {}));
            const f = n.type;
            if (this.listens(f)) {
              n.target = this;
              const _ = this._listeners && this._listeners[f] ? this._listeners[f].slice() : [];
              for (const T of _) T.call(this, n);
              const b = this._oneTimeListeners && this._oneTimeListeners[f] ? this._oneTimeListeners[f].slice() : [];
              for (const T of b) Ne(f, T, this._oneTimeListeners), T.call(this, n);
              const v = this._eventedParent;
              v && (ji(n, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), v.fire(n));
            } else n instanceof ze && console.error(n.error);
            return this;
          }
          listens(n) {
            return this._listeners && this._listeners[n] && this._listeners[n].length > 0 || this._oneTimeListeners && this._oneTimeListeners[n] && this._oneTimeListeners[n].length > 0 || this._eventedParent && this._eventedParent.listens(n);
          }
          setEventedParent(n, l) {
            return this._eventedParent = n, this._eventedParentData = l, this;
          }
        }
        var ve = { $version: 8, $root: { version: { required: !0, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, centerAltitude: { type: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, roll: { type: "number", default: 0, units: "degrees" }, state: { type: "state", default: {} }, light: { type: "light" }, sky: { type: "sky" }, projection: { type: "projection" }, terrain: { type: "terrain" }, sources: { required: !0, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: !0, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: !0, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster: { type: { required: !0, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster_dem: { type: { required: !0, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_geojson: { type: { required: !0, type: "enum", values: { geojson: {} } }, data: { required: !0, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: !1 }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: !1 }, generateId: { type: "boolean", default: !1 }, promoteId: { type: "promoteId" } }, source_video: { type: { required: !0, type: "enum", values: { video: {} } }, urls: { required: !0, type: "array", value: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: !0, type: "enum", values: { image: {} } }, url: { required: !0, type: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: !0 }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, "color-relief": {}, background: {} }, required: !0 }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_color-relief", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: !1, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: !1, requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: !1, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: !0, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: !0, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: !1, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: !1, requires: ["text-field", "icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_color-relief": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: !1 } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: !1, expression: { interpolated: !1, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, sky: { "sky-color": { type: "color", "property-type": "data-constant", default: "#88C6FC", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-ground-blend": { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-fog-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "sky-horizon-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "atmosphere-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, terrain: { source: { type: "string", required: !0 }, exaggeration: { type: "number", minimum: 0, default: 1 } }, projection: { type: { type: "projectionDefinition", default: "mercator", "property-type": "data-constant", transition: !1, expression: { interpolated: !0, parameters: ["zoom"] } } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_color-relief", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: !0, requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, requires: ["fill-extrusion-height"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: !0, transition: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "line-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: !0, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: !1, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: !0 } }], expression: { interpolated: !0, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: !1, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: !1, expression: { interpolated: !0, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: !0, overridable: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: !0, units: "degrees", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: !1, units: "milliseconds", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "numberArray", default: 335, minimum: 0, maximum: 359, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-altitude": { type: "numberArray", default: 45, minimum: 0, maximum: 90, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "colorArray", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "colorArray", default: "#FFFFFF", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-method": { type: "enum", values: { standard: {}, basic: {}, combined: {}, igor: {}, multidirectional: {} }, default: "standard", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, "paint_color-relief": { "color-relief-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "color-relief-color": { type: "color", transition: !1, expression: { interpolated: !0, parameters: ["elevation"] }, "property-type": "color-ramp" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "background-pattern" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
        const wt = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
        function Ot(c, n) {
          const l = {};
          for (const f in c) f !== "ref" && (l[f] = c[f]);
          return wt.forEach(((f) => {
            f in n && (l[f] = n[f]);
          })), l;
        }
        function ft(c, n) {
          if (Array.isArray(c)) {
            if (!Array.isArray(n) || c.length !== n.length) return !1;
            for (let l = 0; l < c.length; l++) if (!ft(c[l], n[l])) return !1;
            return !0;
          }
          if (typeof c == "object" && c !== null && n !== null) {
            if (typeof n != "object" || Object.keys(c).length !== Object.keys(n).length) return !1;
            for (const l in c) if (!ft(c[l], n[l])) return !1;
            return !0;
          }
          return c === n;
        }
        function St(c, n) {
          c.push(n);
        }
        function Kt(c, n, l) {
          St(l, { command: "addSource", args: [c, n[c]] });
        }
        function Li(c, n, l) {
          St(n, { command: "removeSource", args: [c] }), l[c] = !0;
        }
        function Ui(c, n, l, f) {
          Li(c, l, f), Kt(c, n, l);
        }
        function Ti(c, n, l) {
          let f;
          for (f in c[l]) if (Object.prototype.hasOwnProperty.call(c[l], f) && f !== "data" && !ft(c[l][f], n[l][f])) return !1;
          for (f in n[l]) if (Object.prototype.hasOwnProperty.call(n[l], f) && f !== "data" && !ft(c[l][f], n[l][f])) return !1;
          return !0;
        }
        function Pt(c, n, l, f, _, b) {
          c = c || {}, n = n || {};
          for (const v in c) Object.prototype.hasOwnProperty.call(c, v) && (ft(c[v], n[v]) || l.push({ command: b, args: [f, v, n[v], _] }));
          for (const v in n) Object.prototype.hasOwnProperty.call(n, v) && !Object.prototype.hasOwnProperty.call(c, v) && (ft(c[v], n[v]) || l.push({ command: b, args: [f, v, n[v], _] }));
        }
        function Nt(c) {
          return c.id;
        }
        function Pi(c, n) {
          return c[n.id] = n, c;
        }
        class Ge {
          constructor(n, l, f, _) {
            this.message = (n ? `${n}: ` : "") + f, _ && (this.identifier = _), l != null && l.__line__ && (this.line = l.__line__);
          }
        }
        function Hi(c, ...n) {
          for (const l of n) for (const f in l) c[f] = l[f];
          return c;
        }
        class _i extends Error {
          constructor(n, l) {
            super(l), this.message = l, this.key = n;
          }
        }
        class Es {
          constructor(n, l = []) {
            this.parent = n, this.bindings = {};
            for (const [f, _] of l) this.bindings[f] = _;
          }
          concat(n) {
            return new Es(this, n);
          }
          get(n) {
            if (this.bindings[n]) return this.bindings[n];
            if (this.parent) return this.parent.get(n);
            throw new Error(`${n} not found in scope.`);
          }
          has(n) {
            return !!this.bindings[n] || !!this.parent && this.parent.has(n);
          }
        }
        const Un = { kind: "null" }, tt = { kind: "number" }, Dt = { kind: "string" }, Ct = { kind: "boolean" }, $i = { kind: "color" }, Ss = { kind: "projectionDefinition" }, Sr = { kind: "object" }, Tt = { kind: "value" }, en = { kind: "collator" }, is = { kind: "formatted" }, zn = { kind: "padding" }, us = { kind: "colorArray" }, Vn = { kind: "numberArray" }, li = { kind: "resolvedImage" }, yr = { kind: "variableAnchorOffsetCollection" };
        function zi(c, n) {
          return { kind: "array", itemType: c, N: n };
        }
        function zt(c) {
          if (c.kind === "array") {
            const n = zt(c.itemType);
            return typeof c.N == "number" ? `array<${n}, ${c.N}>` : c.itemType.kind === "value" ? "array" : `array<${n}>`;
          }
          return c.kind;
        }
        const ds = [Un, tt, Dt, Ct, $i, Ss, is, Sr, zi(Tt), zn, Vn, us, li, yr];
        function Cs(c, n) {
          if (n.kind === "error") return null;
          if (c.kind === "array") {
            if (n.kind === "array" && (n.N === 0 && n.itemType.kind === "value" || !Cs(c.itemType, n.itemType)) && (typeof c.N != "number" || c.N === n.N)) return null;
          } else {
            if (c.kind === n.kind) return null;
            if (c.kind === "value") {
              for (const l of ds) if (!Cs(l, n)) return null;
            }
          }
          return `Expected ${zt(c)} but found ${zt(n)} instead.`;
        }
        function $r(c, n) {
          return n.some(((l) => l.kind === c.kind));
        }
        function nr(c, n) {
          return n.some(((l) => l === "null" ? c === null : l === "array" ? Array.isArray(c) : l === "object" ? c && !Array.isArray(c) && typeof c == "object" : l === typeof c));
        }
        function Is(c, n) {
          return c.kind === "array" && n.kind === "array" ? c.itemType.kind === n.itemType.kind && typeof c.N == "number" : c.kind === n.kind;
        }
        const Uo = 0.96422, ho = 0.82521, Gr = 4 / 29, Ms = 6 / 29, zo = 3 * Ms * Ms, Ba = Ms * Ms * Ms, Da = Math.PI / 180, Oa = 180 / Math.PI;
        function jn(c) {
          return (c %= 360) < 0 && (c += 360), c;
        }
        function Fr([c, n, l, f]) {
          let _, b;
          const v = Vo((0.2225045 * (c = Fa(c)) + 0.7168786 * (n = Fa(n)) + 0.0606169 * (l = Fa(l))) / 1);
          c === n && n === l ? _ = b = v : (_ = Vo((0.4360747 * c + 0.3850649 * n + 0.1430804 * l) / Uo), b = Vo((0.0139322 * c + 0.0971045 * n + 0.7141733 * l) / ho));
          const T = 116 * v - 16;
          return [T < 0 ? 0 : T, 500 * (_ - v), 200 * (v - b), f];
        }
        function Fa(c) {
          return c <= 0.04045 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
        }
        function Vo(c) {
          return c > Ba ? Math.pow(c, 1 / 3) : c / zo + Gr;
        }
        function tn([c, n, l, f]) {
          let _ = (c + 16) / 116, b = isNaN(n) ? _ : _ + n / 500, v = isNaN(l) ? _ : _ - l / 200;
          return _ = 1 * ka(_), b = Uo * ka(b), v = ho * ka(v), [jo(3.1338561 * b - 1.6168667 * _ - 0.4906146 * v), jo(-0.9787684 * b + 1.9161415 * _ + 0.033454 * v), jo(0.0719453 * b - 0.2289914 * _ + 1.4052427 * v), f];
        }
        function jo(c) {
          return (c = c <= 304e-5 ? 12.92 * c : 1.055 * Math.pow(c, 1 / 2.4) - 0.055) < 0 ? 0 : c > 1 ? 1 : c;
        }
        function ka(c) {
          return c > Ms ? c * c * c : zo * (c - Gr);
        }
        const yh = Object.hasOwn || function(c, n) {
          return Object.prototype.hasOwnProperty.call(c, n);
        };
        function X(c, n) {
          return yh(c, n) ? c[n] : void 0;
        }
        function Q(c) {
          return parseInt(c.padEnd(2, c), 16) / 255;
        }
        function ue(c, n) {
          return xe(n ? c / 100 : c, 0, 1);
        }
        function xe(c, n, l) {
          return Math.min(Math.max(n, c), l);
        }
        function $e(c) {
          return !c.some(Number.isNaN);
        }
        const at = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
        function It(c, n, l) {
          return c + l * (n - c);
        }
        function hi(c, n, l) {
          return c.map(((f, _) => It(f, n[_], l)));
        }
        class mt {
          constructor(n, l, f, _ = 1, b = !0) {
            this.r = n, this.g = l, this.b = f, this.a = _, b || (this.r *= _, this.g *= _, this.b *= _, _ || this.overwriteGetter("rgb", [n, l, f, _]));
          }
          static parse(n) {
            if (n instanceof mt) return n;
            if (typeof n != "string") return;
            const l = (function(f) {
              if ((f = f.toLowerCase().trim()) === "transparent") return [0, 0, 0, 0];
              const _ = X(at, f);
              if (_) {
                const [v, T, A] = _;
                return [v / 255, T / 255, A / 255, 1];
              }
              if (f.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(f)) {
                const v = f.length < 6 ? 1 : 2;
                let T = 1;
                return [Q(f.slice(T, T += v)), Q(f.slice(T, T += v)), Q(f.slice(T, T += v)), Q(f.slice(T, T + v) || "ff")];
              }
              if (f.startsWith("rgb")) {
                const v = f.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                if (v) {
                  const [T, A, I, P, D, U, V, j, G, Z, te, me] = v, ce = [P || " ", V || " ", Z].join("");
                  if (ce === "  " || ce === "  /" || ce === ",," || ce === ",,,") {
                    const de = [I, U, G].join(""), Re = de === "%%%" ? 100 : de === "" ? 255 : 0;
                    if (Re) {
                      const ke = [xe(+A / Re, 0, 1), xe(+D / Re, 0, 1), xe(+j / Re, 0, 1), te ? ue(+te, me) : 1];
                      if ($e(ke)) return ke;
                    }
                  }
                  return;
                }
              }
              const b = f.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (b) {
                const [v, T, A, I, P, D, U, V, j] = b, G = [A || " ", P || " ", U].join("");
                if (G === "  " || G === "  /" || G === ",," || G === ",,,") {
                  const Z = [+T, xe(+I, 0, 100), xe(+D, 0, 100), V ? ue(+V, j) : 1];
                  if ($e(Z)) return (function([te, me, ce, de]) {
                    function Re(ke) {
                      const je = (ke + te / 30) % 12, it = me * Math.min(ce, 1 - ce);
                      return ce - it * Math.max(-1, Math.min(je - 3, 9 - je, 1));
                    }
                    return te = jn(te), me /= 100, ce /= 100, [Re(0), Re(8), Re(4), de];
                  })(Z);
                }
              }
            })(n);
            return l ? new mt(...l, !1) : void 0;
          }
          get rgb() {
            const { r: n, g: l, b: f, a: _ } = this, b = _ || 1 / 0;
            return this.overwriteGetter("rgb", [n / b, l / b, f / b, _]);
          }
          get hcl() {
            return this.overwriteGetter("hcl", (function(n) {
              const [l, f, _, b] = Fr(n), v = Math.sqrt(f * f + _ * _);
              return [Math.round(1e4 * v) ? jn(Math.atan2(_, f) * Oa) : NaN, v, l, b];
            })(this.rgb));
          }
          get lab() {
            return this.overwriteGetter("lab", Fr(this.rgb));
          }
          overwriteGetter(n, l) {
            return Object.defineProperty(this, n, { value: l }), l;
          }
          toString() {
            const [n, l, f, _] = this.rgb;
            return `rgba(${[n, l, f].map(((b) => Math.round(255 * b))).join(",")},${_})`;
          }
          static interpolate(n, l, f, _ = "rgb") {
            switch (_) {
              case "rgb": {
                const [b, v, T, A] = hi(n.rgb, l.rgb, f);
                return new mt(b, v, T, A, !1);
              }
              case "hcl": {
                const [b, v, T, A] = n.hcl, [I, P, D, U] = l.hcl;
                let V, j;
                if (isNaN(b) || isNaN(I)) isNaN(b) ? isNaN(I) ? V = NaN : (V = I, T !== 1 && T !== 0 || (j = P)) : (V = b, D !== 1 && D !== 0 || (j = v));
                else {
                  let ce = I - b;
                  I > b && ce > 180 ? ce -= 360 : I < b && b - I > 180 && (ce += 360), V = b + f * ce;
                }
                const [G, Z, te, me] = (function([ce, de, Re, ke]) {
                  return ce = isNaN(ce) ? 0 : ce * Da, tn([Re, Math.cos(ce) * de, Math.sin(ce) * de, ke]);
                })([V, j ?? It(v, P, f), It(T, D, f), It(A, U, f)]);
                return new mt(G, Z, te, me, !1);
              }
              case "lab": {
                const [b, v, T, A] = tn(hi(n.lab, l.lab, f));
                return new mt(b, v, T, A, !1);
              }
            }
          }
        }
        mt.black = new mt(0, 0, 0, 1), mt.white = new mt(1, 1, 1, 1), mt.transparent = new mt(0, 0, 0, 0), mt.red = new mt(1, 0, 0, 1);
        class Ai {
          constructor(n, l, f) {
            this.sensitivity = n ? l ? "variant" : "case" : l ? "accent" : "base", this.locale = f, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
          }
          compare(n, l) {
            return this.collator.compare(n, l);
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
          }
        }
        const kr = ["bottom", "center", "top"];
        class Fl {
          constructor(n, l, f, _, b, v) {
            this.text = n, this.image = l, this.scale = f, this.fontStack = _, this.textColor = b, this.verticalAlign = v;
          }
        }
        class Nr {
          constructor(n) {
            this.sections = n;
          }
          static fromString(n) {
            return new Nr([new Fl(n, null, null, null, null, null)]);
          }
          isEmpty() {
            return this.sections.length === 0 || !this.sections.some(((n) => n.text.length !== 0 || n.image && n.image.name.length !== 0));
          }
          static factory(n) {
            return n instanceof Nr ? n : Nr.fromString(n);
          }
          toString() {
            return this.sections.length === 0 ? "" : this.sections.map(((n) => n.text)).join("");
          }
        }
        class or {
          constructor(n) {
            this.values = n.slice();
          }
          static parse(n) {
            if (n instanceof or) return n;
            if (typeof n == "number") return new or([n, n, n, n]);
            if (Array.isArray(n) && !(n.length < 1 || n.length > 4)) {
              for (const l of n) if (typeof l != "number") return;
              switch (n.length) {
                case 1:
                  n = [n[0], n[0], n[0], n[0]];
                  break;
                case 2:
                  n = [n[0], n[1], n[0], n[1]];
                  break;
                case 3:
                  n = [n[0], n[1], n[2], n[1]];
              }
              return new or(n);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(n, l, f) {
            return new or(hi(n.values, l.values, f));
          }
        }
        class Lr {
          constructor(n) {
            this.values = n.slice();
          }
          static parse(n) {
            if (n instanceof Lr) return n;
            if (typeof n == "number") return new Lr([n]);
            if (Array.isArray(n)) {
              for (const l of n) if (typeof l != "number") return;
              return new Lr(n);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(n, l, f) {
            return new Lr(hi(n.values, l.values, f));
          }
        }
        class Gi {
          constructor(n) {
            this.values = n.slice();
          }
          static parse(n) {
            if (n instanceof Gi) return n;
            if (typeof n == "string") {
              const f = mt.parse(n);
              return f ? new Gi([f]) : void 0;
            }
            if (!Array.isArray(n)) return;
            const l = [];
            for (const f of n) {
              if (typeof f != "string") return;
              const _ = mt.parse(f);
              if (!_) return;
              l.push(_);
            }
            return new Gi(l);
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(n, l, f, _ = "rgb") {
            const b = [];
            if (n.values.length != l.values.length) throw new Error(`colorArray: Arrays have mismatched length (${n.values.length} vs. ${l.values.length}), cannot interpolate.`);
            for (let v = 0; v < n.values.length; v++) b.push(mt.interpolate(n.values[v], l.values[v], f, _));
            return new Gi(b);
          }
        }
        class oi extends Error {
          constructor(n) {
            super(n), this.name = "RuntimeError";
          }
          toJSON() {
            return this.message;
          }
        }
        const fd = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
        class Ur {
          constructor(n) {
            this.values = n.slice();
          }
          static parse(n) {
            if (n instanceof Ur) return n;
            if (Array.isArray(n) && !(n.length < 1) && n.length % 2 == 0) {
              for (let l = 0; l < n.length; l += 2) {
                const f = n[l], _ = n[l + 1];
                if (typeof f != "string" || !fd.has(f) || !Array.isArray(_) || _.length !== 2 || typeof _[0] != "number" || typeof _[1] != "number") return;
              }
              return new Ur(n);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(n, l, f) {
            const _ = n.values, b = l.values;
            if (_.length !== b.length) throw new oi(`Cannot interpolate values of different length. from: ${n.toString()}, to: ${l.toString()}`);
            const v = [];
            for (let T = 0; T < _.length; T += 2) {
              if (_[T] !== b[T]) throw new oi(`Cannot interpolate values containing mismatched anchors. from[${T}]: ${_[T]}, to[${T}]: ${b[T]}`);
              v.push(_[T]);
              const [A, I] = _[T + 1], [P, D] = b[T + 1];
              v.push([It(A, P, f), It(I, D, f)]);
            }
            return new Ur(v);
          }
        }
        class rs {
          constructor(n) {
            this.name = n.name, this.available = n.available;
          }
          toString() {
            return this.name;
          }
          static fromString(n) {
            return n ? new rs({ name: n, available: !1 }) : null;
          }
        }
        class Cr {
          constructor(n, l, f) {
            this.from = n, this.to = l, this.transition = f;
          }
          static interpolate(n, l, f) {
            return new Cr(n, l, f);
          }
          static parse(n) {
            return n instanceof Cr ? n : Array.isArray(n) && n.length === 3 && typeof n[0] == "string" && typeof n[1] == "string" && typeof n[2] == "number" ? new Cr(n[0], n[1], n[2]) : typeof n == "object" && typeof n.from == "string" && typeof n.to == "string" && typeof n.transition == "number" ? new Cr(n.from, n.to, n.transition) : typeof n == "string" ? new Cr(n, n, 1) : void 0;
          }
        }
        function ui(c, n, l, f) {
          return typeof c == "number" && c >= 0 && c <= 255 && typeof n == "number" && n >= 0 && n <= 255 && typeof l == "number" && l >= 0 && l <= 255 ? f === void 0 || typeof f == "number" && f >= 0 && f <= 1 ? null : `Invalid rgba value [${[c, n, l, f].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof f == "number" ? [c, n, l, f] : [c, n, l]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
        }
        function uo(c) {
          if (c === null || typeof c == "string" || typeof c == "boolean" || typeof c == "number" || c instanceof Cr || c instanceof mt || c instanceof Ai || c instanceof Nr || c instanceof or || c instanceof Lr || c instanceof Gi || c instanceof Ur || c instanceof rs) return !0;
          if (Array.isArray(c)) {
            for (const n of c) if (!uo(n)) return !1;
            return !0;
          }
          if (typeof c == "object") {
            for (const n in c) if (!uo(c[n])) return !1;
            return !0;
          }
          return !1;
        }
        function vt(c) {
          if (c === null) return Un;
          if (typeof c == "string") return Dt;
          if (typeof c == "boolean") return Ct;
          if (typeof c == "number") return tt;
          if (c instanceof mt) return $i;
          if (c instanceof Cr) return Ss;
          if (c instanceof Ai) return en;
          if (c instanceof Nr) return is;
          if (c instanceof or) return zn;
          if (c instanceof Lr) return Vn;
          if (c instanceof Gi) return us;
          if (c instanceof Ur) return yr;
          if (c instanceof rs) return li;
          if (Array.isArray(c)) {
            const n = c.length;
            let l;
            for (const f of c) {
              const _ = vt(f);
              if (l) {
                if (l === _) continue;
                l = Tt;
                break;
              }
              l = _;
            }
            return zi(l || Tt, n);
          }
          return Sr;
        }
        function Mt(c) {
          const n = typeof c;
          return c === null ? "" : n === "string" || n === "number" || n === "boolean" ? String(c) : c instanceof mt || c instanceof Cr || c instanceof Nr || c instanceof or || c instanceof Lr || c instanceof Gi || c instanceof Ur || c instanceof rs ? c.toString() : JSON.stringify(c);
        }
        class mn {
          constructor(n, l) {
            this.type = n, this.value = l;
          }
          static parse(n, l) {
            if (n.length !== 2) return l.error(`'literal' expression requires exactly one argument, but found ${n.length - 1} instead.`);
            if (!uo(n[1])) return l.error("invalid value");
            const f = n[1];
            let _ = vt(f);
            const b = l.expectedType;
            return _.kind !== "array" || _.N !== 0 || !b || b.kind !== "array" || typeof b.N == "number" && b.N !== 0 || (_ = b), new mn(_, f);
          }
          evaluate() {
            return this.value;
          }
          eachChild() {
          }
          outputDefined() {
            return !0;
          }
        }
        const Vt = { string: Dt, number: tt, boolean: Ct, object: Sr };
        class ss {
          constructor(n, l) {
            this.type = n, this.args = l;
          }
          static parse(n, l) {
            if (n.length < 2) return l.error("Expected at least one argument.");
            let f, _ = 1;
            const b = n[0];
            if (b === "array") {
              let T, A;
              if (n.length > 2) {
                const I = n[1];
                if (typeof I != "string" || !(I in Vt) || I === "object") return l.error('The item type argument of "array" must be one of string, number, boolean', 1);
                T = Vt[I], _++;
              } else T = Tt;
              if (n.length > 3) {
                if (n[2] !== null && (typeof n[2] != "number" || n[2] < 0 || n[2] !== Math.floor(n[2]))) return l.error('The length argument to "array" must be a positive integer literal', 2);
                A = n[2], _++;
              }
              f = zi(T, A);
            } else {
              if (!Vt[b]) throw new Error(`Types doesn't contain name = ${b}`);
              f = Vt[b];
            }
            const v = [];
            for (; _ < n.length; _++) {
              const T = l.parse(n[_], _, Tt);
              if (!T) return null;
              v.push(T);
            }
            return new ss(f, v);
          }
          evaluate(n) {
            for (let l = 0; l < this.args.length; l++) {
              const f = this.args[l].evaluate(n);
              if (!Cs(this.type, vt(f))) return f;
              if (l === this.args.length - 1) throw new oi(`Expected value to be of type ${zt(this.type)}, but found ${zt(vt(f))} instead.`);
            }
            throw new Error();
          }
          eachChild(n) {
            this.args.forEach(n);
          }
          outputDefined() {
            return this.args.every(((n) => n.outputDefined()));
          }
        }
        const rn = { "to-boolean": Ct, "to-color": $i, "to-number": tt, "to-string": Dt };
        class sn {
          constructor(n, l) {
            this.type = n, this.args = l;
          }
          static parse(n, l) {
            if (n.length < 2) return l.error("Expected at least one argument.");
            const f = n[0];
            if (!rn[f]) throw new Error(`Can't parse ${f} as it is not part of the known types`);
            if ((f === "to-boolean" || f === "to-string") && n.length !== 2) return l.error("Expected one argument.");
            const _ = rn[f], b = [];
            for (let v = 1; v < n.length; v++) {
              const T = l.parse(n[v], v, Tt);
              if (!T) return null;
              b.push(T);
            }
            return new sn(_, b);
          }
          evaluate(n) {
            switch (this.type.kind) {
              case "boolean":
                return !!this.args[0].evaluate(n);
              case "color": {
                let l, f;
                for (const _ of this.args) {
                  if (l = _.evaluate(n), f = null, l instanceof mt) return l;
                  if (typeof l == "string") {
                    const b = n.parseColor(l);
                    if (b) return b;
                  } else if (Array.isArray(l) && (f = l.length < 3 || l.length > 4 ? `Invalid rgba value ${JSON.stringify(l)}: expected an array containing either three or four numeric values.` : ui(l[0], l[1], l[2], l[3]), !f)) return new mt(l[0] / 255, l[1] / 255, l[2] / 255, l[3]);
                }
                throw new oi(f || `Could not parse color from value '${typeof l == "string" ? l : JSON.stringify(l)}'`);
              }
              case "padding": {
                let l;
                for (const f of this.args) {
                  l = f.evaluate(n);
                  const _ = or.parse(l);
                  if (_) return _;
                }
                throw new oi(`Could not parse padding from value '${typeof l == "string" ? l : JSON.stringify(l)}'`);
              }
              case "numberArray": {
                let l;
                for (const f of this.args) {
                  l = f.evaluate(n);
                  const _ = Lr.parse(l);
                  if (_) return _;
                }
                throw new oi(`Could not parse numberArray from value '${typeof l == "string" ? l : JSON.stringify(l)}'`);
              }
              case "colorArray": {
                let l;
                for (const f of this.args) {
                  l = f.evaluate(n);
                  const _ = Gi.parse(l);
                  if (_) return _;
                }
                throw new oi(`Could not parse colorArray from value '${typeof l == "string" ? l : JSON.stringify(l)}'`);
              }
              case "variableAnchorOffsetCollection": {
                let l;
                for (const f of this.args) {
                  l = f.evaluate(n);
                  const _ = Ur.parse(l);
                  if (_) return _;
                }
                throw new oi(`Could not parse variableAnchorOffsetCollection from value '${typeof l == "string" ? l : JSON.stringify(l)}'`);
              }
              case "number": {
                let l = null;
                for (const f of this.args) {
                  if (l = f.evaluate(n), l === null) return 0;
                  const _ = Number(l);
                  if (!isNaN(_)) return _;
                }
                throw new oi(`Could not convert ${JSON.stringify(l)} to number.`);
              }
              case "formatted":
                return Nr.fromString(Mt(this.args[0].evaluate(n)));
              case "resolvedImage":
                return rs.fromString(Mt(this.args[0].evaluate(n)));
              case "projectionDefinition":
                return this.args[0].evaluate(n);
              default:
                return Mt(this.args[0].evaluate(n));
            }
          }
          eachChild(n) {
            this.args.forEach(n);
          }
          outputDefined() {
            return this.args.every(((n) => n.outputDefined()));
          }
        }
        const kl = ["Unknown", "Point", "LineString", "Polygon"];
        class bh {
          constructor() {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = /* @__PURE__ */ new Map(), this.availableImages = null, this.canonical = null;
          }
          id() {
            return this.feature && "id" in this.feature ? this.feature.id : null;
          }
          geometryType() {
            return this.feature ? typeof this.feature.type == "number" ? kl[this.feature.type] : this.feature.type : null;
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
          }
          canonicalID() {
            return this.canonical;
          }
          properties() {
            return this.feature && this.feature.properties || {};
          }
          parseColor(n) {
            let l = this._parseColorCache.get(n);
            return l || (l = mt.parse(n), this._parseColorCache.set(n, l)), l;
          }
        }
        class Ho {
          constructor(n, l, f = [], _, b = new Es(), v = []) {
            this.registry = n, this.path = f, this.key = f.map(((T) => `[${T}]`)).join(""), this.scope = b, this.errors = v, this.expectedType = _, this._isConstant = l;
          }
          parse(n, l, f, _, b = {}) {
            return l ? this.concat(l, f, _)._parse(n, b) : this._parse(n, b);
          }
          _parse(n, l) {
            function f(_, b, v) {
              return v === "assert" ? new ss(b, [_]) : v === "coerce" ? new sn(b, [_]) : _;
            }
            if (n !== null && typeof n != "string" && typeof n != "boolean" && typeof n != "number" || (n = ["literal", n]), Array.isArray(n)) {
              if (n.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              const _ = n[0];
              if (typeof _ != "string") return this.error(`Expression name must be a string, but found ${typeof _} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
              const b = this.registry[_];
              if (b) {
                let v = b.parse(n, this);
                if (!v) return null;
                if (this.expectedType) {
                  const T = this.expectedType, A = v.type;
                  if (T.kind !== "string" && T.kind !== "number" && T.kind !== "boolean" && T.kind !== "object" && T.kind !== "array" || A.kind !== "value") {
                    if (T.kind === "projectionDefinition" && ["string", "array"].includes(A.kind) || ["color", "formatted", "resolvedImage"].includes(T.kind) && ["value", "string"].includes(A.kind) || ["padding", "numberArray"].includes(T.kind) && ["value", "number", "array"].includes(A.kind) || T.kind === "colorArray" && ["value", "string", "array"].includes(A.kind) || T.kind === "variableAnchorOffsetCollection" && ["value", "array"].includes(A.kind)) v = f(v, T, l.typeAnnotation || "coerce");
                    else if (this.checkSubtype(T, A)) return null;
                  } else v = f(v, T, l.typeAnnotation || "assert");
                }
                if (!(v instanceof mn) && v.type.kind !== "resolvedImage" && this._isConstant(v)) {
                  const T = new bh();
                  try {
                    v = new mn(v.type, v.evaluate(T));
                  } catch (A) {
                    return this.error(A.message), null;
                  }
                }
                return v;
              }
              return this.error(`Unknown expression "${_}". If you wanted a literal array, use ["literal", [...]].`, 0);
            }
            return this.error(n === void 0 ? "'undefined' value invalid. Use null instead." : typeof n == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof n} instead.`);
          }
          concat(n, l, f) {
            const _ = typeof n == "number" ? this.path.concat(n) : this.path, b = f ? this.scope.concat(f) : this.scope;
            return new Ho(this.registry, this._isConstant, _, l || null, b, this.errors);
          }
          error(n, ...l) {
            const f = `${this.key}${l.map(((_) => `[${_}]`)).join("")}`;
            this.errors.push(new _i(f, n));
          }
          checkSubtype(n, l) {
            const f = Cs(n, l);
            return f && this.error(f), f;
          }
        }
        class Na {
          constructor(n, l) {
            this.type = l.type, this.bindings = [].concat(n), this.result = l;
          }
          evaluate(n) {
            return this.result.evaluate(n);
          }
          eachChild(n) {
            for (const l of this.bindings) n(l[1]);
            n(this.result);
          }
          static parse(n, l) {
            if (n.length < 4) return l.error(`Expected at least 3 arguments, but found ${n.length - 1} instead.`);
            const f = [];
            for (let b = 1; b < n.length - 1; b += 2) {
              const v = n[b];
              if (typeof v != "string") return l.error(`Expected string, but found ${typeof v} instead.`, b);
              if (/[^a-zA-Z0-9_]/.test(v)) return l.error("Variable names must contain only alphanumeric characters or '_'.", b);
              const T = l.parse(n[b + 1], b + 1);
              if (!T) return null;
              f.push([v, T]);
            }
            const _ = l.parse(n[n.length - 1], n.length - 1, l.expectedType, f);
            return _ ? new Na(f, _) : null;
          }
          outputDefined() {
            return this.result.outputDefined();
          }
        }
        class Nl {
          constructor(n, l) {
            this.type = l.type, this.name = n, this.boundExpression = l;
          }
          static parse(n, l) {
            if (n.length !== 2 || typeof n[1] != "string") return l.error("'var' expression requires exactly one string literal argument.");
            const f = n[1];
            return l.scope.has(f) ? new Nl(f, l.scope.get(f)) : l.error(`Unknown variable "${f}". Make sure "${f}" has been bound in an enclosing "let" expression before using it.`, 1);
          }
          evaluate(n) {
            return this.boundExpression.evaluate(n);
          }
          eachChild() {
          }
          outputDefined() {
            return !1;
          }
        }
        class Ll {
          constructor(n, l, f) {
            this.type = n, this.index = l, this.input = f;
          }
          static parse(n, l) {
            if (n.length !== 3) return l.error(`Expected 2 arguments, but found ${n.length - 1} instead.`);
            const f = l.parse(n[1], 1, tt), _ = l.parse(n[2], 2, zi(l.expectedType || Tt));
            return f && _ ? new Ll(_.type.itemType, f, _) : null;
          }
          evaluate(n) {
            const l = this.index.evaluate(n), f = this.input.evaluate(n);
            if (l < 0) throw new oi(`Array index out of bounds: ${l} < 0.`);
            if (l >= f.length) throw new oi(`Array index out of bounds: ${l} > ${f.length - 1}.`);
            if (l !== Math.floor(l)) throw new oi(`Array index must be an integer, but found ${l} instead.`);
            return f[l];
          }
          eachChild(n) {
            n(this.index), n(this.input);
          }
          outputDefined() {
            return !1;
          }
        }
        class Ul {
          constructor(n, l) {
            this.type = Ct, this.needle = n, this.haystack = l;
          }
          static parse(n, l) {
            if (n.length !== 3) return l.error(`Expected 2 arguments, but found ${n.length - 1} instead.`);
            const f = l.parse(n[1], 1, Tt), _ = l.parse(n[2], 2, Tt);
            return f && _ ? $r(f.type, [Ct, Dt, tt, Un, Tt]) ? new Ul(f, _) : l.error(`Expected first argument to be of type boolean, string, number or null, but found ${zt(f.type)} instead`) : null;
          }
          evaluate(n) {
            const l = this.needle.evaluate(n), f = this.haystack.evaluate(n);
            if (!f) return !1;
            if (!nr(l, ["boolean", "string", "number", "null"])) throw new oi(`Expected first argument to be of type boolean, string, number or null, but found ${zt(vt(l))} instead.`);
            if (!nr(f, ["string", "array"])) throw new oi(`Expected second argument to be of type array or string, but found ${zt(vt(f))} instead.`);
            return f.indexOf(l) >= 0;
          }
          eachChild(n) {
            n(this.needle), n(this.haystack);
          }
          outputDefined() {
            return !0;
          }
        }
        class Rs {
          constructor(n, l, f) {
            this.type = tt, this.needle = n, this.haystack = l, this.fromIndex = f;
          }
          static parse(n, l) {
            if (n.length <= 2 || n.length >= 5) return l.error(`Expected 3 or 4 arguments, but found ${n.length - 1} instead.`);
            const f = l.parse(n[1], 1, Tt), _ = l.parse(n[2], 2, Tt);
            if (!f || !_) return null;
            if (!$r(f.type, [Ct, Dt, tt, Un, Tt])) return l.error(`Expected first argument to be of type boolean, string, number or null, but found ${zt(f.type)} instead`);
            if (n.length === 4) {
              const b = l.parse(n[3], 3, tt);
              return b ? new Rs(f, _, b) : null;
            }
            return new Rs(f, _);
          }
          evaluate(n) {
            const l = this.needle.evaluate(n), f = this.haystack.evaluate(n);
            if (!nr(l, ["boolean", "string", "number", "null"])) throw new oi(`Expected first argument to be of type boolean, string, number or null, but found ${zt(vt(l))} instead.`);
            let _;
            if (this.fromIndex && (_ = this.fromIndex.evaluate(n)), nr(f, ["string"])) {
              const b = f.indexOf(l, _);
              return b === -1 ? -1 : [...f.slice(0, b)].length;
            }
            if (nr(f, ["array"])) return f.indexOf(l, _);
            throw new oi(`Expected second argument to be of type array or string, but found ${zt(vt(f))} instead.`);
          }
          eachChild(n) {
            n(this.needle), n(this.haystack), this.fromIndex && n(this.fromIndex);
          }
          outputDefined() {
            return !1;
          }
        }
        class ar {
          constructor(n, l, f, _, b, v) {
            this.inputType = n, this.type = l, this.input = f, this.cases = _, this.outputs = b, this.otherwise = v;
          }
          static parse(n, l) {
            if (n.length < 5) return l.error(`Expected at least 4 arguments, but found only ${n.length - 1}.`);
            if (n.length % 2 != 1) return l.error("Expected an even number of arguments.");
            let f, _;
            l.expectedType && l.expectedType.kind !== "value" && (_ = l.expectedType);
            const b = {}, v = [];
            for (let I = 2; I < n.length - 1; I += 2) {
              let P = n[I];
              const D = n[I + 1];
              Array.isArray(P) || (P = [P]);
              const U = l.concat(I);
              if (P.length === 0) return U.error("Expected at least one branch label.");
              for (const j of P) {
                if (typeof j != "number" && typeof j != "string") return U.error("Branch labels must be numbers or strings.");
                if (typeof j == "number" && Math.abs(j) > Number.MAX_SAFE_INTEGER) return U.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                if (typeof j == "number" && Math.floor(j) !== j) return U.error("Numeric branch labels must be integer values.");
                if (f) {
                  if (U.checkSubtype(f, vt(j))) return null;
                } else f = vt(j);
                if (b[String(j)] !== void 0) return U.error("Branch labels must be unique.");
                b[String(j)] = v.length;
              }
              const V = l.parse(D, I, _);
              if (!V) return null;
              _ = _ || V.type, v.push(V);
            }
            const T = l.parse(n[1], 1, Tt);
            if (!T) return null;
            const A = l.parse(n[n.length - 1], n.length - 1, _);
            return A ? T.type.kind !== "value" && l.concat(1).checkSubtype(f, T.type) ? null : new ar(f, _, T, b, v, A) : null;
          }
          evaluate(n) {
            const l = this.input.evaluate(n);
            return (vt(l) === this.inputType && this.outputs[this.cases[l]] || this.otherwise).evaluate(n);
          }
          eachChild(n) {
            n(this.input), this.outputs.forEach(n), n(this.otherwise);
          }
          outputDefined() {
            return this.outputs.every(((n) => n.outputDefined())) && this.otherwise.outputDefined();
          }
        }
        class $o {
          constructor(n, l, f) {
            this.type = n, this.branches = l, this.otherwise = f;
          }
          static parse(n, l) {
            if (n.length < 4) return l.error(`Expected at least 3 arguments, but found only ${n.length - 1}.`);
            if (n.length % 2 != 0) return l.error("Expected an odd number of arguments.");
            let f;
            l.expectedType && l.expectedType.kind !== "value" && (f = l.expectedType);
            const _ = [];
            for (let v = 1; v < n.length - 1; v += 2) {
              const T = l.parse(n[v], v, Ct);
              if (!T) return null;
              const A = l.parse(n[v + 1], v + 1, f);
              if (!A) return null;
              _.push([T, A]), f = f || A.type;
            }
            const b = l.parse(n[n.length - 1], n.length - 1, f);
            if (!b) return null;
            if (!f) throw new Error("Can't infer output type");
            return new $o(f, _, b);
          }
          evaluate(n) {
            for (const [l, f] of this.branches) if (l.evaluate(n)) return f.evaluate(n);
            return this.otherwise.evaluate(n);
          }
          eachChild(n) {
            for (const [l, f] of this.branches) n(l), n(f);
            n(this.otherwise);
          }
          outputDefined() {
            return this.branches.every((([n, l]) => l.outputDefined())) && this.otherwise.outputDefined();
          }
        }
        class La {
          constructor(n, l, f, _) {
            this.type = n, this.input = l, this.beginIndex = f, this.endIndex = _;
          }
          static parse(n, l) {
            if (n.length <= 2 || n.length >= 5) return l.error(`Expected 3 or 4 arguments, but found ${n.length - 1} instead.`);
            const f = l.parse(n[1], 1, Tt), _ = l.parse(n[2], 2, tt);
            if (!f || !_) return null;
            if (!$r(f.type, [zi(Tt), Dt, Tt])) return l.error(`Expected first argument to be of type array or string, but found ${zt(f.type)} instead`);
            if (n.length === 4) {
              const b = l.parse(n[3], 3, tt);
              return b ? new La(f.type, f, _, b) : null;
            }
            return new La(f.type, f, _);
          }
          evaluate(n) {
            const l = this.input.evaluate(n), f = this.beginIndex.evaluate(n);
            let _;
            if (this.endIndex && (_ = this.endIndex.evaluate(n)), nr(l, ["string"])) return [...l].slice(f, _).join("");
            if (nr(l, ["array"])) return l.slice(f, _);
            throw new oi(`Expected first argument to be of type array or string, but found ${zt(vt(l))} instead.`);
          }
          eachChild(n) {
            n(this.input), n(this.beginIndex), this.endIndex && n(this.endIndex);
          }
          outputDefined() {
            return !1;
          }
        }
        function fo(c, n) {
          const l = c.length - 1;
          let f, _, b = 0, v = l, T = 0;
          for (; b <= v; ) if (T = Math.floor((b + v) / 2), f = c[T], _ = c[T + 1], f <= n) {
            if (T === l || n < _) return T;
            b = T + 1;
          } else {
            if (!(f > n)) throw new oi("Input is not a number.");
            v = T - 1;
          }
          return 0;
        }
        class Bi {
          constructor(n, l, f) {
            this.type = n, this.input = l, this.labels = [], this.outputs = [];
            for (const [_, b] of f) this.labels.push(_), this.outputs.push(b);
          }
          static parse(n, l) {
            if (n.length - 1 < 4) return l.error(`Expected at least 4 arguments, but found only ${n.length - 1}.`);
            if ((n.length - 1) % 2 != 0) return l.error("Expected an even number of arguments.");
            const f = l.parse(n[1], 1, tt);
            if (!f) return null;
            const _ = [];
            let b = null;
            l.expectedType && l.expectedType.kind !== "value" && (b = l.expectedType);
            for (let v = 1; v < n.length; v += 2) {
              const T = v === 1 ? -1 / 0 : n[v], A = n[v + 1], I = v, P = v + 1;
              if (typeof T != "number") return l.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', I);
              if (_.length && _[_.length - 1][0] >= T) return l.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', I);
              const D = l.parse(A, P, b);
              if (!D) return null;
              b = b || D.type, _.push([T, D]);
            }
            return new Bi(b, f, _);
          }
          evaluate(n) {
            const l = this.labels, f = this.outputs;
            if (l.length === 1) return f[0].evaluate(n);
            const _ = this.input.evaluate(n);
            if (_ <= l[0]) return f[0].evaluate(n);
            const b = l.length;
            return _ >= l[b - 1] ? f[b - 1].evaluate(n) : f[fo(l, _)].evaluate(n);
          }
          eachChild(n) {
            n(this.input);
            for (const l of this.outputs) n(l);
          }
          outputDefined() {
            return this.outputs.every(((n) => n.outputDefined()));
          }
        }
        function pd(c) {
          return c && c.__esModule && Object.prototype.hasOwnProperty.call(c, "default") ? c.default : c;
        }
        var Ua, vh, $p = (function() {
          if (vh) return Ua;
          function c(n, l, f, _) {
            this.cx = 3 * n, this.bx = 3 * (f - n) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * l, this.by = 3 * (_ - l) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = n, this.p1y = l, this.p2x = f, this.p2y = _;
          }
          return vh = 1, Ua = c, c.prototype = { sampleCurveX: function(n) {
            return ((this.ax * n + this.bx) * n + this.cx) * n;
          }, sampleCurveY: function(n) {
            return ((this.ay * n + this.by) * n + this.cy) * n;
          }, sampleCurveDerivativeX: function(n) {
            return (3 * this.ax * n + 2 * this.bx) * n + this.cx;
          }, solveCurveX: function(n, l) {
            if (l === void 0 && (l = 1e-6), n < 0) return 0;
            if (n > 1) return 1;
            for (var f = n, _ = 0; _ < 8; _++) {
              var b = this.sampleCurveX(f) - n;
              if (Math.abs(b) < l) return f;
              var v = this.sampleCurveDerivativeX(f);
              if (Math.abs(v) < 1e-6) break;
              f -= b / v;
            }
            var T = 0, A = 1;
            for (f = n, _ = 0; _ < 20 && (b = this.sampleCurveX(f), !(Math.abs(b - n) < l)); _++) n > b ? T = f : A = f, f = 0.5 * (A - T) + T;
            return f;
          }, solve: function(n, l) {
            return this.sampleCurveY(this.solveCurveX(n, l));
          } }, Ua;
        })(), Go = pd($p);
        class br {
          constructor(n, l, f, _, b) {
            this.type = n, this.operator = l, this.interpolation = f, this.input = _, this.labels = [], this.outputs = [];
            for (const [v, T] of b) this.labels.push(v), this.outputs.push(T);
          }
          static interpolationFactor(n, l, f, _) {
            let b = 0;
            if (n.name === "exponential") b = za(l, n.base, f, _);
            else if (n.name === "linear") b = za(l, 1, f, _);
            else if (n.name === "cubic-bezier") {
              const v = n.controlPoints;
              b = new Go(v[0], v[1], v[2], v[3]).solve(za(l, 1, f, _));
            }
            return b;
          }
          static parse(n, l) {
            let [f, _, b, ...v] = n;
            if (!Array.isArray(_) || _.length === 0) return l.error("Expected an interpolation type expression.", 1);
            if (_[0] === "linear") _ = { name: "linear" };
            else if (_[0] === "exponential") {
              const I = _[1];
              if (typeof I != "number") return l.error("Exponential interpolation requires a numeric base.", 1, 1);
              _ = { name: "exponential", base: I };
            } else {
              if (_[0] !== "cubic-bezier") return l.error(`Unknown interpolation type ${String(_[0])}`, 1, 0);
              {
                const I = _.slice(1);
                if (I.length !== 4 || I.some(((P) => typeof P != "number" || P < 0 || P > 1))) return l.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                _ = { name: "cubic-bezier", controlPoints: I };
              }
            }
            if (n.length - 1 < 4) return l.error(`Expected at least 4 arguments, but found only ${n.length - 1}.`);
            if ((n.length - 1) % 2 != 0) return l.error("Expected an even number of arguments.");
            if (b = l.parse(b, 2, tt), !b) return null;
            const T = [];
            let A = null;
            f !== "interpolate-hcl" && f !== "interpolate-lab" || l.expectedType == us ? l.expectedType && l.expectedType.kind !== "value" && (A = l.expectedType) : A = $i;
            for (let I = 0; I < v.length; I += 2) {
              const P = v[I], D = v[I + 1], U = I + 3, V = I + 4;
              if (typeof P != "number") return l.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', U);
              if (T.length && T[T.length - 1][0] >= P) return l.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', U);
              const j = l.parse(D, V, A);
              if (!j) return null;
              A = A || j.type, T.push([P, j]);
            }
            return Is(A, tt) || Is(A, Ss) || Is(A, $i) || Is(A, zn) || Is(A, Vn) || Is(A, us) || Is(A, yr) || Is(A, zi(tt)) ? new br(A, f, _, b, T) : l.error(`Type ${zt(A)} is not interpolatable.`);
          }
          evaluate(n) {
            const l = this.labels, f = this.outputs;
            if (l.length === 1) return f[0].evaluate(n);
            const _ = this.input.evaluate(n);
            if (_ <= l[0]) return f[0].evaluate(n);
            const b = l.length;
            if (_ >= l[b - 1]) return f[b - 1].evaluate(n);
            const v = fo(l, _), T = br.interpolationFactor(this.interpolation, _, l[v], l[v + 1]), A = f[v].evaluate(n), I = f[v + 1].evaluate(n);
            switch (this.operator) {
              case "interpolate":
                switch (this.type.kind) {
                  case "number":
                    return It(A, I, T);
                  case "color":
                    return mt.interpolate(A, I, T);
                  case "padding":
                    return or.interpolate(A, I, T);
                  case "colorArray":
                    return Gi.interpolate(A, I, T);
                  case "numberArray":
                    return Lr.interpolate(A, I, T);
                  case "variableAnchorOffsetCollection":
                    return Ur.interpolate(A, I, T);
                  case "array":
                    return hi(A, I, T);
                  case "projectionDefinition":
                    return Cr.interpolate(A, I, T);
                }
              case "interpolate-hcl":
                switch (this.type.kind) {
                  case "color":
                    return mt.interpolate(A, I, T, "hcl");
                  case "colorArray":
                    return Gi.interpolate(A, I, T, "hcl");
                }
              case "interpolate-lab":
                switch (this.type.kind) {
                  case "color":
                    return mt.interpolate(A, I, T, "lab");
                  case "colorArray":
                    return Gi.interpolate(A, I, T, "lab");
                }
            }
          }
          eachChild(n) {
            n(this.input);
            for (const l of this.outputs) n(l);
          }
          outputDefined() {
            return this.outputs.every(((n) => n.outputDefined()));
          }
        }
        function za(c, n, l, f) {
          const _ = f - l, b = c - l;
          return _ === 0 ? 0 : n === 1 ? b / _ : (Math.pow(n, b) - 1) / (Math.pow(n, _) - 1);
        }
        const nn = { color: mt.interpolate, number: It, padding: or.interpolate, numberArray: Lr.interpolate, colorArray: Gi.interpolate, variableAnchorOffsetCollection: Ur.interpolate, array: hi };
        class Va {
          constructor(n, l) {
            this.type = n, this.args = l;
          }
          static parse(n, l) {
            if (n.length < 2) return l.error("Expected at least one argument.");
            let f = null;
            const _ = l.expectedType;
            _ && _.kind !== "value" && (f = _);
            const b = [];
            for (const T of n.slice(1)) {
              const A = l.parse(T, 1 + b.length, f, void 0, { typeAnnotation: "omit" });
              if (!A) return null;
              f = f || A.type, b.push(A);
            }
            if (!f) throw new Error("No output type");
            const v = _ && b.some(((T) => Cs(_, T.type)));
            return new Va(v ? Tt : f, b);
          }
          evaluate(n) {
            let l, f = null, _ = 0;
            for (const b of this.args) if (_++, f = b.evaluate(n), f && f instanceof rs && !f.available && (l || (l = f.name), f = null, _ === this.args.length && (f = l)), f !== null) break;
            return f;
          }
          eachChild(n) {
            this.args.forEach(n);
          }
          outputDefined() {
            return this.args.every(((n) => n.outputDefined()));
          }
        }
        function ja(c, n) {
          return c === "==" || c === "!=" ? n.kind === "boolean" || n.kind === "string" || n.kind === "number" || n.kind === "null" || n.kind === "value" : n.kind === "string" || n.kind === "number" || n.kind === "value";
        }
        function Ha(c, n, l, f) {
          return f.compare(n, l) === 0;
        }
        function Ir(c, n, l) {
          const f = c !== "==" && c !== "!=";
          return class Q1 {
            constructor(b, v, T) {
              this.type = Ct, this.lhs = b, this.rhs = v, this.collator = T, this.hasUntypedArgument = b.type.kind === "value" || v.type.kind === "value";
            }
            static parse(b, v) {
              if (b.length !== 3 && b.length !== 4) return v.error("Expected two or three arguments.");
              const T = b[0];
              let A = v.parse(b[1], 1, Tt);
              if (!A) return null;
              if (!ja(T, A.type)) return v.concat(1).error(`"${T}" comparisons are not supported for type '${zt(A.type)}'.`);
              let I = v.parse(b[2], 2, Tt);
              if (!I) return null;
              if (!ja(T, I.type)) return v.concat(2).error(`"${T}" comparisons are not supported for type '${zt(I.type)}'.`);
              if (A.type.kind !== I.type.kind && A.type.kind !== "value" && I.type.kind !== "value") return v.error(`Cannot compare types '${zt(A.type)}' and '${zt(I.type)}'.`);
              f && (A.type.kind === "value" && I.type.kind !== "value" ? A = new ss(I.type, [A]) : A.type.kind !== "value" && I.type.kind === "value" && (I = new ss(A.type, [I])));
              let P = null;
              if (b.length === 4) {
                if (A.type.kind !== "string" && I.type.kind !== "string" && A.type.kind !== "value" && I.type.kind !== "value") return v.error("Cannot use collator to compare non-string types.");
                if (P = v.parse(b[3], 3, en), !P) return null;
              }
              return new Q1(A, I, P);
            }
            evaluate(b) {
              const v = this.lhs.evaluate(b), T = this.rhs.evaluate(b);
              if (f && this.hasUntypedArgument) {
                const A = vt(v), I = vt(T);
                if (A.kind !== I.kind || A.kind !== "string" && A.kind !== "number") throw new oi(`Expected arguments for "${c}" to be (string, string) or (number, number), but found (${A.kind}, ${I.kind}) instead.`);
              }
              if (this.collator && !f && this.hasUntypedArgument) {
                const A = vt(v), I = vt(T);
                if (A.kind !== "string" || I.kind !== "string") return n(b, v, T);
              }
              return this.collator ? l(b, v, T, this.collator.evaluate(b)) : n(b, v, T);
            }
            eachChild(b) {
              b(this.lhs), b(this.rhs), this.collator && b(this.collator);
            }
            outputDefined() {
              return !0;
            }
          };
        }
        const _d = Ir("==", (function(c, n, l) {
          return n === l;
        }), Ha), zl = Ir("!=", (function(c, n, l) {
          return n !== l;
        }), (function(c, n, l, f) {
          return !Ha(0, n, l, f);
        })), Gp = Ir("<", (function(c, n, l) {
          return n < l;
        }), (function(c, n, l, f) {
          return f.compare(n, l) < 0;
        })), xh = Ir(">", (function(c, n, l) {
          return n > l;
        }), (function(c, n, l, f) {
          return f.compare(n, l) > 0;
        })), Wp = Ir("<=", (function(c, n, l) {
          return n <= l;
        }), (function(c, n, l, f) {
          return f.compare(n, l) <= 0;
        })), Xp = Ir(">=", (function(c, n, l) {
          return n >= l;
        }), (function(c, n, l, f) {
          return f.compare(n, l) >= 0;
        }));
        class Vl {
          constructor(n, l, f) {
            this.type = en, this.locale = f, this.caseSensitive = n, this.diacriticSensitive = l;
          }
          static parse(n, l) {
            if (n.length !== 2) return l.error("Expected one argument.");
            const f = n[1];
            if (typeof f != "object" || Array.isArray(f)) return l.error("Collator options argument must be an object.");
            const _ = l.parse(f["case-sensitive"] !== void 0 && f["case-sensitive"], 1, Ct);
            if (!_) return null;
            const b = l.parse(f["diacritic-sensitive"] !== void 0 && f["diacritic-sensitive"], 1, Ct);
            if (!b) return null;
            let v = null;
            return f.locale && (v = l.parse(f.locale, 1, Dt), !v) ? null : new Vl(_, b, v);
          }
          evaluate(n) {
            return new Ai(this.caseSensitive.evaluate(n), this.diacriticSensitive.evaluate(n), this.locale ? this.locale.evaluate(n) : null);
          }
          eachChild(n) {
            n(this.caseSensitive), n(this.diacriticSensitive), this.locale && n(this.locale);
          }
          outputDefined() {
            return !1;
          }
        }
        class wh {
          constructor(n, l, f, _, b) {
            this.type = Dt, this.number = n, this.locale = l, this.currency = f, this.minFractionDigits = _, this.maxFractionDigits = b;
          }
          static parse(n, l) {
            if (n.length !== 3) return l.error("Expected two arguments.");
            const f = l.parse(n[1], 1, tt);
            if (!f) return null;
            const _ = n[2];
            if (typeof _ != "object" || Array.isArray(_)) return l.error("NumberFormat options argument must be an object.");
            let b = null;
            if (_.locale && (b = l.parse(_.locale, 1, Dt), !b)) return null;
            let v = null;
            if (_.currency && (v = l.parse(_.currency, 1, Dt), !v)) return null;
            let T = null;
            if (_["min-fraction-digits"] && (T = l.parse(_["min-fraction-digits"], 1, tt), !T)) return null;
            let A = null;
            return _["max-fraction-digits"] && (A = l.parse(_["max-fraction-digits"], 1, tt), !A) ? null : new wh(f, b, v, T, A);
          }
          evaluate(n) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(n) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(n) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(n) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(n) : void 0 }).format(this.number.evaluate(n));
          }
          eachChild(n) {
            n(this.number), this.locale && n(this.locale), this.currency && n(this.currency), this.minFractionDigits && n(this.minFractionDigits), this.maxFractionDigits && n(this.maxFractionDigits);
          }
          outputDefined() {
            return !1;
          }
        }
        class po {
          constructor(n) {
            this.type = is, this.sections = n;
          }
          static parse(n, l) {
            if (n.length < 2) return l.error("Expected at least one argument.");
            const f = n[1];
            if (!Array.isArray(f) && typeof f == "object") return l.error("First argument must be an image or text section.");
            const _ = [];
            let b = !1;
            for (let v = 1; v <= n.length - 1; ++v) {
              const T = n[v];
              if (b && typeof T == "object" && !Array.isArray(T)) {
                b = !1;
                let A = null;
                if (T["font-scale"] && (A = l.parse(T["font-scale"], 1, tt), !A)) return null;
                let I = null;
                if (T["text-font"] && (I = l.parse(T["text-font"], 1, zi(Dt)), !I)) return null;
                let P = null;
                if (T["text-color"] && (P = l.parse(T["text-color"], 1, $i), !P)) return null;
                let D = null;
                if (T["vertical-align"]) {
                  if (typeof T["vertical-align"] == "string" && !kr.includes(T["vertical-align"])) return l.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${T["vertical-align"]}' instead.`);
                  if (D = l.parse(T["vertical-align"], 1, Dt), !D) return null;
                }
                const U = _[_.length - 1];
                U.scale = A, U.font = I, U.textColor = P, U.verticalAlign = D;
              } else {
                const A = l.parse(n[v], 1, Tt);
                if (!A) return null;
                const I = A.type.kind;
                if (I !== "string" && I !== "value" && I !== "null" && I !== "resolvedImage") return l.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                b = !0, _.push({ content: A, scale: null, font: null, textColor: null, verticalAlign: null });
              }
            }
            return new po(_);
          }
          evaluate(n) {
            return new Nr(this.sections.map(((l) => {
              const f = l.content.evaluate(n);
              return vt(f) === li ? new Fl("", f, null, null, null, l.verticalAlign ? l.verticalAlign.evaluate(n) : null) : new Fl(Mt(f), null, l.scale ? l.scale.evaluate(n) : null, l.font ? l.font.evaluate(n).join(",") : null, l.textColor ? l.textColor.evaluate(n) : null, l.verticalAlign ? l.verticalAlign.evaluate(n) : null);
            })));
          }
          eachChild(n) {
            for (const l of this.sections) n(l.content), l.scale && n(l.scale), l.font && n(l.font), l.textColor && n(l.textColor), l.verticalAlign && n(l.verticalAlign);
          }
          outputDefined() {
            return !1;
          }
        }
        class Th {
          constructor(n) {
            this.type = li, this.input = n;
          }
          static parse(n, l) {
            if (n.length !== 2) return l.error("Expected two arguments.");
            const f = l.parse(n[1], 1, Dt);
            return f ? new Th(f) : l.error("No image name provided.");
          }
          evaluate(n) {
            const l = this.input.evaluate(n), f = rs.fromString(l);
            return f && n.availableImages && (f.available = n.availableImages.indexOf(l) > -1), f;
          }
          eachChild(n) {
            n(this.input);
          }
          outputDefined() {
            return !1;
          }
        }
        class jl {
          constructor(n) {
            this.type = tt, this.input = n;
          }
          static parse(n, l) {
            if (n.length !== 2) return l.error(`Expected 1 argument, but found ${n.length - 1} instead.`);
            const f = l.parse(n[1], 1);
            return f ? f.type.kind !== "array" && f.type.kind !== "string" && f.type.kind !== "value" ? l.error(`Expected argument of type string or array, but found ${zt(f.type)} instead.`) : new jl(f) : null;
          }
          evaluate(n) {
            const l = this.input.evaluate(n);
            if (typeof l == "string") return [...l].length;
            if (Array.isArray(l)) return l.length;
            throw new oi(`Expected value to be of type string or array, but found ${zt(vt(l))} instead.`);
          }
          eachChild(n) {
            n(this.input);
          }
          outputDefined() {
            return !1;
          }
        }
        const Ps = 8192;
        function qp(c, n) {
          const l = (180 + c[0]) / 360, f = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + c[1] * Math.PI / 360))) / 360, _ = Math.pow(2, n.z);
          return [Math.round(l * _ * Ps), Math.round(f * _ * Ps)];
        }
        function Hl(c, n) {
          const l = Math.pow(2, n.z);
          return [(_ = (c[0] / Ps + n.x) / l, 360 * _ - 180), (f = (c[1] / Ps + n.y) / l, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * f) * Math.PI / 180)) - 90)];
          var f, _;
        }
        function $a(c, n) {
          c[0] = Math.min(c[0], n[0]), c[1] = Math.min(c[1], n[1]), c[2] = Math.max(c[2], n[0]), c[3] = Math.max(c[3], n[1]);
        }
        function Ga(c, n) {
          return !(c[0] <= n[0] || c[2] >= n[2] || c[1] <= n[1] || c[3] >= n[3]);
        }
        function Zp(c, n, l) {
          const f = c[0] - n[0], _ = c[1] - n[1], b = c[0] - l[0], v = c[1] - l[1];
          return f * v - b * _ == 0 && f * b <= 0 && _ * v <= 0;
        }
        function $l(c, n, l, f) {
          return (_ = [f[0] - l[0], f[1] - l[1]])[0] * (b = [n[0] - c[0], n[1] - c[1]])[1] - _[1] * b[0] != 0 && !(!md(c, n, l, f) || !md(l, f, c, n));
          var _, b;
        }
        function Kp(c, n, l) {
          for (const f of l) for (let _ = 0; _ < f.length - 1; ++_) if ($l(c, n, f[_], f[_ + 1])) return !0;
          return !1;
        }
        function _o(c, n, l = !1) {
          let f = !1;
          for (const T of n) for (let A = 0; A < T.length - 1; A++) {
            if (Zp(c, T[A], T[A + 1])) return l;
            (b = T[A])[1] > (_ = c)[1] != (v = T[A + 1])[1] > _[1] && _[0] < (v[0] - b[0]) * (_[1] - b[1]) / (v[1] - b[1]) + b[0] && (f = !f);
          }
          var _, b, v;
          return f;
        }
        function gd(c, n) {
          for (const l of n) if (_o(c, l)) return !0;
          return !1;
        }
        function Ah(c, n) {
          for (const l of c) if (!_o(l, n)) return !1;
          for (let l = 0; l < c.length - 1; ++l) if (Kp(c[l], c[l + 1], n)) return !1;
          return !0;
        }
        function Yp(c, n) {
          for (const l of n) if (Ah(c, l)) return !0;
          return !1;
        }
        function md(c, n, l, f) {
          const _ = f[0] - l[0], b = f[1] - l[1], v = (c[0] - l[0]) * b - _ * (c[1] - l[1]), T = (n[0] - l[0]) * b - _ * (n[1] - l[1]);
          return v > 0 && T < 0 || v < 0 && T > 0;
        }
        function Eh(c, n, l) {
          const f = [];
          for (let _ = 0; _ < c.length; _++) {
            const b = [];
            for (let v = 0; v < c[_].length; v++) {
              const T = qp(c[_][v], l);
              $a(n, T), b.push(T);
            }
            f.push(b);
          }
          return f;
        }
        function yd(c, n, l) {
          const f = [];
          for (let _ = 0; _ < c.length; _++) {
            const b = Eh(c[_], n, l);
            f.push(b);
          }
          return f;
        }
        function Gl(c, n, l, f) {
          if (c[0] < l[0] || c[0] > l[2]) {
            const _ = 0.5 * f;
            let b = c[0] - l[0] > _ ? -f : l[0] - c[0] > _ ? f : 0;
            b === 0 && (b = c[0] - l[2] > _ ? -f : l[2] - c[0] > _ ? f : 0), c[0] += b;
          }
          $a(n, c);
        }
        function bd(c, n, l, f) {
          const _ = Math.pow(2, f.z) * Ps, b = [f.x * Ps, f.y * Ps], v = [];
          for (const T of c) for (const A of T) {
            const I = [A.x + b[0], A.y + b[1]];
            Gl(I, n, l, _), v.push(I);
          }
          return v;
        }
        function vd(c, n, l, f) {
          const _ = Math.pow(2, f.z) * Ps, b = [f.x * Ps, f.y * Ps], v = [];
          for (const A of c) {
            const I = [];
            for (const P of A) {
              const D = [P.x + b[0], P.y + b[1]];
              $a(n, D), I.push(D);
            }
            v.push(I);
          }
          if (n[2] - n[0] <= _ / 2) {
            (T = n)[0] = T[1] = 1 / 0, T[2] = T[3] = -1 / 0;
            for (const A of v) for (const I of A) Gl(I, n, l, _);
          }
          var T;
          return v;
        }
        class go {
          constructor(n, l) {
            this.type = Ct, this.geojson = n, this.geometries = l;
          }
          static parse(n, l) {
            if (n.length !== 2) return l.error(`'within' expression requires exactly one argument, but found ${n.length - 1} instead.`);
            if (uo(n[1])) {
              const f = n[1];
              if (f.type === "FeatureCollection") {
                const _ = [];
                for (const b of f.features) {
                  const { type: v, coordinates: T } = b.geometry;
                  v === "Polygon" && _.push(T), v === "MultiPolygon" && _.push(...T);
                }
                if (_.length) return new go(f, { type: "MultiPolygon", coordinates: _ });
              } else if (f.type === "Feature") {
                const _ = f.geometry.type;
                if (_ === "Polygon" || _ === "MultiPolygon") return new go(f, f.geometry);
              } else if (f.type === "Polygon" || f.type === "MultiPolygon") return new go(f, f);
            }
            return l.error("'within' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(n) {
            if (n.geometry() != null && n.canonicalID() != null) {
              if (n.geometryType() === "Point") return (function(l, f) {
                const _ = [1 / 0, 1 / 0, -1 / 0, -1 / 0], b = [1 / 0, 1 / 0, -1 / 0, -1 / 0], v = l.canonicalID();
                if (f.type === "Polygon") {
                  const T = Eh(f.coordinates, b, v), A = bd(l.geometry(), _, b, v);
                  if (!Ga(_, b)) return !1;
                  for (const I of A) if (!_o(I, T)) return !1;
                }
                if (f.type === "MultiPolygon") {
                  const T = yd(f.coordinates, b, v), A = bd(l.geometry(), _, b, v);
                  if (!Ga(_, b)) return !1;
                  for (const I of A) if (!gd(I, T)) return !1;
                }
                return !0;
              })(n, this.geometries);
              if (n.geometryType() === "LineString") return (function(l, f) {
                const _ = [1 / 0, 1 / 0, -1 / 0, -1 / 0], b = [1 / 0, 1 / 0, -1 / 0, -1 / 0], v = l.canonicalID();
                if (f.type === "Polygon") {
                  const T = Eh(f.coordinates, b, v), A = vd(l.geometry(), _, b, v);
                  if (!Ga(_, b)) return !1;
                  for (const I of A) if (!Ah(I, T)) return !1;
                }
                if (f.type === "MultiPolygon") {
                  const T = yd(f.coordinates, b, v), A = vd(l.geometry(), _, b, v);
                  if (!Ga(_, b)) return !1;
                  for (const I of A) if (!Yp(I, T)) return !1;
                }
                return !0;
              })(n, this.geometries);
            }
            return !1;
          }
          eachChild() {
          }
          outputDefined() {
            return !0;
          }
        }
        let Sh = class {
          constructor(c = [], n = (l, f) => l < f ? -1 : l > f ? 1 : 0) {
            if (this.data = c, this.length = this.data.length, this.compare = n, this.length > 0) for (let l = (this.length >> 1) - 1; l >= 0; l--) this._down(l);
          }
          push(c) {
            this.data.push(c), this._up(this.length++);
          }
          pop() {
            if (this.length === 0) return;
            const c = this.data[0], n = this.data.pop();
            return --this.length > 0 && (this.data[0] = n, this._down(0)), c;
          }
          peek() {
            return this.data[0];
          }
          _up(c) {
            const { data: n, compare: l } = this, f = n[c];
            for (; c > 0; ) {
              const _ = c - 1 >> 1, b = n[_];
              if (l(f, b) >= 0) break;
              n[c] = b, c = _;
            }
            n[c] = f;
          }
          _down(c) {
            const { data: n, compare: l } = this, f = this.length >> 1, _ = n[c];
            for (; c < f; ) {
              let b = 1 + (c << 1);
              const v = b + 1;
              if (v < this.length && l(n[v], n[b]) < 0 && (b = v), l(n[b], _) >= 0) break;
              n[c] = n[b], c = b;
            }
            n[c] = _;
          }
        };
        function Ch(c, n, l = 0, f = c.length - 1, _ = Jp) {
          for (; f > l; ) {
            if (f - l > 600) {
              const A = f - l + 1, I = n - l + 1, P = Math.log(A), D = 0.5 * Math.exp(2 * P / 3), U = 0.5 * Math.sqrt(P * D * (A - D) / A) * (I - A / 2 < 0 ? -1 : 1);
              Ch(c, n, Math.max(l, Math.floor(n - I * D / A + U)), Math.min(f, Math.floor(n + (A - I) * D / A + U)), _);
            }
            const b = c[n];
            let v = l, T = f;
            for (Wa(c, l, n), _(c[f], b) > 0 && Wa(c, l, f); v < T; ) {
              for (Wa(c, v, T), v++, T--; _(c[v], b) < 0; ) v++;
              for (; _(c[T], b) > 0; ) T--;
            }
            _(c[l], b) === 0 ? Wa(c, l, T) : (T++, Wa(c, T, f)), T <= n && (l = T + 1), n <= T && (f = T - 1);
          }
        }
        function Wa(c, n, l) {
          const f = c[n];
          c[n] = c[l], c[l] = f;
        }
        function Jp(c, n) {
          return c < n ? -1 : c > n ? 1 : 0;
        }
        function Xa(c, n) {
          if (c.length <= 1) return [c];
          const l = [];
          let f, _;
          for (const b of c) {
            const v = Qp(b);
            v !== 0 && (b.area = Math.abs(v), _ === void 0 && (_ = v < 0), _ === v < 0 ? (f && l.push(f), f = [b]) : f.push(b));
          }
          if (f && l.push(f), n > 1) for (let b = 0; b < l.length; b++) l[b].length <= n || (Ch(l[b], n, 1, l[b].length - 1, xd), l[b] = l[b].slice(0, n));
          return l;
        }
        function xd(c, n) {
          return n.area - c.area;
        }
        function Qp(c) {
          let n = 0;
          for (let l, f, _ = 0, b = c.length, v = b - 1; _ < b; v = _++) l = c[_], f = c[v], n += (f.x - l.x) * (l.y + f.y);
          return n;
        }
        const wd = 1 / 298.257223563, Td = wd * (2 - wd), Ih = Math.PI / 180;
        class Mh {
          constructor(n) {
            const l = 6378.137 * Ih * 1e3, f = Math.cos(n * Ih), _ = 1 / (1 - Td * (1 - f * f)), b = Math.sqrt(_);
            this.kx = l * b * f, this.ky = l * b * _ * (1 - Td);
          }
          distance(n, l) {
            const f = this.wrap(n[0] - l[0]) * this.kx, _ = (n[1] - l[1]) * this.ky;
            return Math.sqrt(f * f + _ * _);
          }
          pointOnLine(n, l) {
            let f, _, b, v, T = 1 / 0;
            for (let A = 0; A < n.length - 1; A++) {
              let I = n[A][0], P = n[A][1], D = this.wrap(n[A + 1][0] - I) * this.kx, U = (n[A + 1][1] - P) * this.ky, V = 0;
              D === 0 && U === 0 || (V = (this.wrap(l[0] - I) * this.kx * D + (l[1] - P) * this.ky * U) / (D * D + U * U), V > 1 ? (I = n[A + 1][0], P = n[A + 1][1]) : V > 0 && (I += D / this.kx * V, P += U / this.ky * V)), D = this.wrap(l[0] - I) * this.kx, U = (l[1] - P) * this.ky;
              const j = D * D + U * U;
              j < T && (T = j, f = I, _ = P, b = A, v = V);
            }
            return { point: [f, _], index: b, t: Math.max(0, Math.min(1, v)) };
          }
          wrap(n) {
            for (; n < -180; ) n += 360;
            for (; n > 180; ) n -= 360;
            return n;
          }
        }
        function Ad(c, n) {
          return n[0] - c[0];
        }
        function Wl(c) {
          return c[1] - c[0] + 1;
        }
        function yn(c, n) {
          return c[1] >= c[0] && c[1] < n;
        }
        function $t(c, n) {
          if (c[0] > c[1]) return [null, null];
          const l = Wl(c);
          if (n) {
            if (l === 2) return [c, null];
            const _ = Math.floor(l / 2);
            return [[c[0], c[0] + _], [c[0] + _, c[1]]];
          }
          if (l === 1) return [c, null];
          const f = Math.floor(l / 2) - 1;
          return [[c[0], c[0] + f], [c[0] + f + 1, c[1]]];
        }
        function Rh(c, n) {
          if (!yn(n, c.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          const l = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (let f = n[0]; f <= n[1]; ++f) $a(l, c[f]);
          return l;
        }
        function Ph(c) {
          const n = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (const l of c) for (const f of l) $a(n, f);
          return n;
        }
        function Ed(c) {
          return c[0] !== -1 / 0 && c[1] !== -1 / 0 && c[2] !== 1 / 0 && c[3] !== 1 / 0;
        }
        function Bh(c, n, l) {
          if (!Ed(c) || !Ed(n)) return NaN;
          let f = 0, _ = 0;
          return c[2] < n[0] && (f = n[0] - c[2]), c[0] > n[2] && (f = c[0] - n[2]), c[1] > n[3] && (_ = c[1] - n[3]), c[3] < n[1] && (_ = n[1] - c[3]), l.distance([0, 0], [f, _]);
        }
        function mo(c, n, l) {
          const f = l.pointOnLine(n, c);
          return l.distance(c, f.point);
        }
        function Dh(c, n, l, f, _) {
          const b = Math.min(mo(c, [l, f], _), mo(n, [l, f], _)), v = Math.min(mo(l, [c, n], _), mo(f, [c, n], _));
          return Math.min(b, v);
        }
        function e_(c, n, l, f, _) {
          if (!yn(n, c.length) || !yn(f, l.length)) return 1 / 0;
          let b = 1 / 0;
          for (let v = n[0]; v < n[1]; ++v) {
            const T = c[v], A = c[v + 1];
            for (let I = f[0]; I < f[1]; ++I) {
              const P = l[I], D = l[I + 1];
              if ($l(T, A, P, D)) return 0;
              b = Math.min(b, Dh(T, A, P, D, _));
            }
          }
          return b;
        }
        function t_(c, n, l, f, _) {
          if (!yn(n, c.length) || !yn(f, l.length)) return NaN;
          let b = 1 / 0;
          for (let v = n[0]; v <= n[1]; ++v) for (let T = f[0]; T <= f[1]; ++T) if (b = Math.min(b, _.distance(c[v], l[T])), b === 0) return b;
          return b;
        }
        function i_(c, n, l) {
          if (_o(c, n, !0)) return 0;
          let f = 1 / 0;
          for (const _ of n) {
            const b = _[0], v = _[_.length - 1];
            if (b !== v && (f = Math.min(f, mo(c, [v, b], l)), f === 0)) return f;
            const T = l.pointOnLine(_, c);
            if (f = Math.min(f, l.distance(c, T.point)), f === 0) return f;
          }
          return f;
        }
        function r_(c, n, l, f) {
          if (!yn(n, c.length)) return NaN;
          for (let b = n[0]; b <= n[1]; ++b) if (_o(c[b], l, !0)) return 0;
          let _ = 1 / 0;
          for (let b = n[0]; b < n[1]; ++b) {
            const v = c[b], T = c[b + 1];
            for (const A of l) for (let I = 0, P = A.length, D = P - 1; I < P; D = I++) {
              const U = A[D], V = A[I];
              if ($l(v, T, U, V)) return 0;
              _ = Math.min(_, Dh(v, T, U, V, f));
            }
          }
          return _;
        }
        function Sd(c, n) {
          for (const l of c) for (const f of l) if (_o(f, n, !0)) return !0;
          return !1;
        }
        function s_(c, n, l, f = 1 / 0) {
          const _ = Ph(c), b = Ph(n);
          if (f !== 1 / 0 && Bh(_, b, l) >= f) return f;
          if (Ga(_, b)) {
            if (Sd(c, n)) return 0;
          } else if (Sd(n, c)) return 0;
          let v = 1 / 0;
          for (const T of c) for (let A = 0, I = T.length, P = I - 1; A < I; P = A++) {
            const D = T[P], U = T[A];
            for (const V of n) for (let j = 0, G = V.length, Z = G - 1; j < G; Z = j++) {
              const te = V[Z], me = V[j];
              if ($l(D, U, te, me)) return 0;
              v = Math.min(v, Dh(D, U, te, me, l));
            }
          }
          return v;
        }
        function Cd(c, n, l, f, _, b) {
          if (!b) return;
          const v = Bh(Rh(f, b), _, l);
          v < n && c.push([v, b, [0, 0]]);
        }
        function Xl(c, n, l, f, _, b, v) {
          if (!b || !v) return;
          const T = Bh(Rh(f, b), Rh(_, v), l);
          T < n && c.push([T, b, v]);
        }
        function ql(c, n, l, f, _ = 1 / 0) {
          let b = Math.min(f.distance(c[0], l[0][0]), _);
          if (b === 0) return b;
          const v = new Sh([[0, [0, c.length - 1], [0, 0]]], Ad), T = Ph(l);
          for (; v.length > 0; ) {
            const A = v.pop();
            if (A[0] >= b) continue;
            const I = A[1], P = n ? 50 : 100;
            if (Wl(I) <= P) {
              if (!yn(I, c.length)) return NaN;
              if (n) {
                const D = r_(c, I, l, f);
                if (isNaN(D) || D === 0) return D;
                b = Math.min(b, D);
              } else for (let D = I[0]; D <= I[1]; ++D) {
                const U = i_(c[D], l, f);
                if (b = Math.min(b, U), b === 0) return 0;
              }
            } else {
              const D = $t(I, n);
              Cd(v, b, f, c, T, D[0]), Cd(v, b, f, c, T, D[1]);
            }
          }
          return b;
        }
        function Zl(c, n, l, f, _, b = 1 / 0) {
          let v = Math.min(b, _.distance(c[0], l[0]));
          if (v === 0) return v;
          const T = new Sh([[0, [0, c.length - 1], [0, l.length - 1]]], Ad);
          for (; T.length > 0; ) {
            const A = T.pop();
            if (A[0] >= v) continue;
            const I = A[1], P = A[2], D = n ? 50 : 100, U = f ? 50 : 100;
            if (Wl(I) <= D && Wl(P) <= U) {
              if (!yn(I, c.length) && yn(P, l.length)) return NaN;
              let V;
              if (n && f) V = e_(c, I, l, P, _), v = Math.min(v, V);
              else if (n && !f) {
                const j = c.slice(I[0], I[1] + 1);
                for (let G = P[0]; G <= P[1]; ++G) if (V = mo(l[G], j, _), v = Math.min(v, V), v === 0) return v;
              } else if (!n && f) {
                const j = l.slice(P[0], P[1] + 1);
                for (let G = I[0]; G <= I[1]; ++G) if (V = mo(c[G], j, _), v = Math.min(v, V), v === 0) return v;
              } else V = t_(c, I, l, P, _), v = Math.min(v, V);
            } else {
              const V = $t(I, n), j = $t(P, f);
              Xl(T, v, _, c, l, V[0], j[0]), Xl(T, v, _, c, l, V[0], j[1]), Xl(T, v, _, c, l, V[1], j[0]), Xl(T, v, _, c, l, V[1], j[1]);
            }
          }
          return v;
        }
        function Oh(c) {
          return c.type === "MultiPolygon" ? c.coordinates.map(((n) => ({ type: "Polygon", coordinates: n }))) : c.type === "MultiLineString" ? c.coordinates.map(((n) => ({ type: "LineString", coordinates: n }))) : c.type === "MultiPoint" ? c.coordinates.map(((n) => ({ type: "Point", coordinates: n }))) : [c];
        }
        class yo {
          constructor(n, l) {
            this.type = tt, this.geojson = n, this.geometries = l;
          }
          static parse(n, l) {
            if (n.length !== 2) return l.error(`'distance' expression requires exactly one argument, but found ${n.length - 1} instead.`);
            if (uo(n[1])) {
              const f = n[1];
              if (f.type === "FeatureCollection") return new yo(f, f.features.map(((_) => Oh(_.geometry))).flat());
              if (f.type === "Feature") return new yo(f, Oh(f.geometry));
              if ("type" in f && "coordinates" in f) return new yo(f, Oh(f));
            }
            return l.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(n) {
            if (n.geometry() != null && n.canonicalID() != null) {
              if (n.geometryType() === "Point") return (function(l, f) {
                const _ = l.geometry(), b = _.flat().map(((A) => Hl([A.x, A.y], l.canonical)));
                if (_.length === 0) return NaN;
                const v = new Mh(b[0][1]);
                let T = 1 / 0;
                for (const A of f) {
                  switch (A.type) {
                    case "Point":
                      T = Math.min(T, Zl(b, !1, [A.coordinates], !1, v, T));
                      break;
                    case "LineString":
                      T = Math.min(T, Zl(b, !1, A.coordinates, !0, v, T));
                      break;
                    case "Polygon":
                      T = Math.min(T, ql(b, !1, A.coordinates, v, T));
                  }
                  if (T === 0) return T;
                }
                return T;
              })(n, this.geometries);
              if (n.geometryType() === "LineString") return (function(l, f) {
                const _ = l.geometry(), b = _.flat().map(((A) => Hl([A.x, A.y], l.canonical)));
                if (_.length === 0) return NaN;
                const v = new Mh(b[0][1]);
                let T = 1 / 0;
                for (const A of f) {
                  switch (A.type) {
                    case "Point":
                      T = Math.min(T, Zl(b, !0, [A.coordinates], !1, v, T));
                      break;
                    case "LineString":
                      T = Math.min(T, Zl(b, !0, A.coordinates, !0, v, T));
                      break;
                    case "Polygon":
                      T = Math.min(T, ql(b, !0, A.coordinates, v, T));
                  }
                  if (T === 0) return T;
                }
                return T;
              })(n, this.geometries);
              if (n.geometryType() === "Polygon") return (function(l, f) {
                const _ = l.geometry();
                if (_.length === 0 || _[0].length === 0) return NaN;
                const b = Xa(_, 0).map(((A) => A.map(((I) => I.map(((P) => Hl([P.x, P.y], l.canonical))))))), v = new Mh(b[0][0][0][1]);
                let T = 1 / 0;
                for (const A of f) for (const I of b) {
                  switch (A.type) {
                    case "Point":
                      T = Math.min(T, ql([A.coordinates], !1, I, v, T));
                      break;
                    case "LineString":
                      T = Math.min(T, ql(A.coordinates, !0, I, v, T));
                      break;
                    case "Polygon":
                      T = Math.min(T, s_(I, A.coordinates, v, T));
                  }
                  if (T === 0) return T;
                }
                return T;
              })(n, this.geometries);
            }
            return NaN;
          }
          eachChild() {
          }
          outputDefined() {
            return !0;
          }
        }
        class qa {
          constructor(n) {
            this.type = Tt, this.key = n;
          }
          static parse(n, l) {
            if (n.length !== 2) return l.error(`Expected 1 argument, but found ${n.length - 1} instead.`);
            const f = n[1];
            return f == null ? l.error("Global state property must be defined.") : typeof f != "string" ? l.error(`Global state property must be string, but found ${typeof n[1]} instead.`) : new qa(f);
          }
          evaluate(n) {
            var l;
            const f = (l = n.globals) === null || l === void 0 ? void 0 : l.globalState;
            return f && Object.keys(f).length !== 0 ? X(f, this.key) : null;
          }
          eachChild() {
          }
          outputDefined() {
            return !1;
          }
        }
        const Wo = { "==": _d, "!=": zl, ">": xh, "<": Gp, ">=": Xp, "<=": Wp, array: ss, at: Ll, boolean: ss, case: $o, coalesce: Va, collator: Vl, format: po, image: Th, in: Ul, "index-of": Rs, interpolate: br, "interpolate-hcl": br, "interpolate-lab": br, length: jl, let: Na, literal: mn, match: ar, number: ss, "number-format": wh, object: ss, slice: La, step: Bi, string: ss, "to-boolean": sn, "to-color": sn, "to-number": sn, "to-string": sn, var: Nl, within: go, distance: yo, "global-state": qa };
        class fs {
          constructor(n, l, f, _) {
            this.name = n, this.type = l, this._evaluate = f, this.args = _;
          }
          evaluate(n) {
            return this._evaluate(n, this.args);
          }
          eachChild(n) {
            this.args.forEach(n);
          }
          outputDefined() {
            return !1;
          }
          static parse(n, l) {
            const f = n[0], _ = fs.definitions[f];
            if (!_) return l.error(`Unknown expression "${f}". If you wanted a literal array, use ["literal", [...]].`, 0);
            const b = Array.isArray(_) ? _[0] : _.type, v = Array.isArray(_) ? [[_[1], _[2]]] : _.overloads, T = v.filter((([I]) => !Array.isArray(I) || I.length === n.length - 1));
            let A = null;
            for (const [I, P] of T) {
              A = new Ho(l.registry, Kl, l.path, null, l.scope);
              const D = [];
              let U = !1;
              for (let V = 1; V < n.length; V++) {
                const j = n[V], G = Array.isArray(I) ? I[V - 1] : I.type, Z = A.parse(j, 1 + D.length, G);
                if (!Z) {
                  U = !0;
                  break;
                }
                D.push(Z);
              }
              if (!U) if (Array.isArray(I) && I.length !== D.length) A.error(`Expected ${I.length} arguments, but found ${D.length} instead.`);
              else {
                for (let V = 0; V < D.length; V++) {
                  const j = Array.isArray(I) ? I[V] : I.type, G = D[V];
                  A.concat(V + 1).checkSubtype(j, G.type);
                }
                if (A.errors.length === 0) return new fs(f, b, P, D);
              }
            }
            if (T.length === 1) l.errors.push(...A.errors);
            else {
              const I = (T.length ? T : v).map((([D]) => {
                return U = D, Array.isArray(U) ? `(${U.map(zt).join(", ")})` : `(${zt(U.type)}...)`;
                var U;
              })).join(" | "), P = [];
              for (let D = 1; D < n.length; D++) {
                const U = l.parse(n[D], 1 + P.length);
                if (!U) return null;
                P.push(zt(U.type));
              }
              l.error(`Expected arguments of type ${I}, but found (${P.join(", ")}) instead.`);
            }
            return null;
          }
          static register(n, l) {
            fs.definitions = l;
            for (const f in l) n[f] = fs;
          }
        }
        function Id(c, [n, l, f, _]) {
          n = n.evaluate(c), l = l.evaluate(c), f = f.evaluate(c);
          const b = _ ? _.evaluate(c) : 1, v = ui(n, l, f, b);
          if (v) throw new oi(v);
          return new mt(n / 255, l / 255, f / 255, b, !1);
        }
        function Md(c, n) {
          return c in n;
        }
        function Fh(c, n) {
          const l = n[c];
          return l === void 0 ? null : l;
        }
        function bo(c) {
          return { type: c };
        }
        function Kl(c) {
          if (c instanceof Nl) return Kl(c.boundExpression);
          if (c instanceof fs && c.name === "error" || c instanceof Vl || c instanceof go || c instanceof yo || c instanceof qa) return !1;
          const n = c instanceof sn || c instanceof ss;
          let l = !0;
          return c.eachChild(((f) => {
            l = n ? l && Kl(f) : l && f instanceof mn;
          })), !!l && Yl(c) && Jl(c, ["zoom", "heatmap-density", "elevation", "line-progress", "accumulated", "is-supported-script"]);
        }
        function Yl(c) {
          if (c instanceof fs && (c.name === "get" && c.args.length === 1 || c.name === "feature-state" || c.name === "has" && c.args.length === 1 || c.name === "properties" || c.name === "geometry-type" || c.name === "id" || /^filter-/.test(c.name)) || c instanceof go || c instanceof yo) return !1;
          let n = !0;
          return c.eachChild(((l) => {
            n && !Yl(l) && (n = !1);
          })), n;
        }
        function Za(c) {
          if (c instanceof fs && c.name === "feature-state") return !1;
          let n = !0;
          return c.eachChild(((l) => {
            n && !Za(l) && (n = !1);
          })), n;
        }
        function Jl(c, n) {
          if (c instanceof fs && n.indexOf(c.name) >= 0) return !1;
          let l = !0;
          return c.eachChild(((f) => {
            l && !Jl(f, n) && (l = !1);
          })), l;
        }
        function Rd(c) {
          return { result: "success", value: c };
        }
        function Xo(c) {
          return { result: "error", value: c };
        }
        function Hn(c) {
          return c["property-type"] === "data-driven" || c["property-type"] === "cross-faded-data-driven";
        }
        function Pd(c) {
          return !!c.expression && c.expression.parameters.indexOf("zoom") > -1;
        }
        function kh(c) {
          return !!c.expression && c.expression.interpolated;
        }
        function kt(c) {
          return c instanceof Number ? "number" : c instanceof String ? "string" : c instanceof Boolean ? "boolean" : Array.isArray(c) ? "array" : c === null ? "null" : typeof c;
        }
        function Ka(c) {
          return typeof c == "object" && c !== null && !Array.isArray(c) && vt(c) === Sr;
        }
        function n_(c) {
          return c;
        }
        function Bd(c, n) {
          const l = c.stops && typeof c.stops[0][0] == "object", f = l || !(l || c.property !== void 0), _ = c.type || (kh(n) ? "exponential" : "interval"), b = (function(P) {
            switch (P.type) {
              case "color":
                return mt.parse;
              case "padding":
                return or.parse;
              case "numberArray":
                return Lr.parse;
              case "colorArray":
                return Gi.parse;
              default:
                return null;
            }
          })(n);
          if (b && ((c = Hi({}, c)).stops && (c.stops = c.stops.map(((P) => [P[0], b(P[1])]))), c.default = b(c.default ? c.default : n.default)), c.colorSpace && (v = c.colorSpace) !== "rgb" && v !== "hcl" && v !== "lab") throw new Error(`Unknown color space: "${c.colorSpace}"`);
          var v;
          const T = (function(P) {
            switch (P) {
              case "exponential":
                return Od;
              case "interval":
                return o_;
              case "categorical":
                return Dd;
              case "identity":
                return a_;
              default:
                throw new Error(`Unknown function type "${P}"`);
            }
          })(_);
          let A, I;
          if (_ === "categorical") {
            A = /* @__PURE__ */ Object.create(null);
            for (const P of c.stops) A[P[0]] = P[1];
            I = typeof c.stops[0][0];
          }
          if (l) {
            const P = {}, D = [];
            for (let j = 0; j < c.stops.length; j++) {
              const G = c.stops[j], Z = G[0].zoom;
              P[Z] === void 0 && (P[Z] = { zoom: Z, type: c.type, property: c.property, default: c.default, stops: [] }, D.push(Z)), P[Z].stops.push([G[0].value, G[1]]);
            }
            const U = [];
            for (const j of D) U.push([P[j].zoom, Bd(P[j], n)]);
            const V = { name: "linear" };
            return { kind: "composite", interpolationType: V, interpolationFactor: br.interpolationFactor.bind(void 0, V), zoomStops: U.map(((j) => j[0])), evaluate: ({ zoom: j }, G) => Od({ stops: U, base: c.base }, n, j).evaluate(j, G) };
          }
          if (f) {
            const P = _ === "exponential" ? { name: "exponential", base: c.base !== void 0 ? c.base : 1 } : null;
            return { kind: "camera", interpolationType: P, interpolationFactor: br.interpolationFactor.bind(void 0, P), zoomStops: c.stops.map(((D) => D[0])), evaluate: ({ zoom: D }) => T(c, n, D, A, I) };
          }
          return { kind: "source", evaluate(P, D) {
            const U = D && D.properties ? D.properties[c.property] : void 0;
            return U === void 0 ? $n(c.default, n.default) : T(c, n, U, A, I);
          } };
        }
        function $n(c, n, l) {
          return c !== void 0 ? c : n !== void 0 ? n : l !== void 0 ? l : void 0;
        }
        function Dd(c, n, l, f, _) {
          return $n(typeof l === _ ? f[l] : void 0, c.default, n.default);
        }
        function o_(c, n, l) {
          if (kt(l) !== "number") return $n(c.default, n.default);
          const f = c.stops.length;
          if (f === 1 || l <= c.stops[0][0]) return c.stops[0][1];
          if (l >= c.stops[f - 1][0]) return c.stops[f - 1][1];
          const _ = fo(c.stops.map(((b) => b[0])), l);
          return c.stops[_][1];
        }
        function Od(c, n, l) {
          const f = c.base !== void 0 ? c.base : 1;
          if (kt(l) !== "number") return $n(c.default, n.default);
          const _ = c.stops.length;
          if (_ === 1 || l <= c.stops[0][0]) return c.stops[0][1];
          if (l >= c.stops[_ - 1][0]) return c.stops[_ - 1][1];
          const b = fo(c.stops.map(((P) => P[0])), l), v = (function(P, D, U, V) {
            const j = V - U, G = P - U;
            return j === 0 ? 0 : D === 1 ? G / j : (Math.pow(D, G) - 1) / (Math.pow(D, j) - 1);
          })(l, f, c.stops[b][0], c.stops[b + 1][0]), T = c.stops[b][1], A = c.stops[b + 1][1], I = nn[n.type] || n_;
          return typeof T.evaluate == "function" ? { evaluate(...P) {
            const D = T.evaluate.apply(void 0, P), U = A.evaluate.apply(void 0, P);
            if (D !== void 0 && U !== void 0) return I(D, U, v, c.colorSpace);
          } } : I(T, A, v, c.colorSpace);
        }
        function a_(c, n, l) {
          switch (n.type) {
            case "color":
              l = mt.parse(l);
              break;
            case "formatted":
              l = Nr.fromString(l.toString());
              break;
            case "resolvedImage":
              l = rs.fromString(l.toString());
              break;
            case "padding":
              l = or.parse(l);
              break;
            case "colorArray":
              l = Gi.parse(l);
              break;
            case "numberArray":
              l = Lr.parse(l);
              break;
            default:
              kt(l) === n.type || n.type === "enum" && n.values[l] || (l = void 0);
          }
          return $n(l, c.default, n.default);
        }
        fs.register(Wo, { error: [{ kind: "error" }, [Dt], (c, [n]) => {
          throw new oi(n.evaluate(c));
        }], typeof: [Dt, [Tt], (c, [n]) => zt(vt(n.evaluate(c)))], "to-rgba": [zi(tt, 4), [$i], (c, [n]) => {
          const [l, f, _, b] = n.evaluate(c).rgb;
          return [255 * l, 255 * f, 255 * _, b];
        }], rgb: [$i, [tt, tt, tt], Id], rgba: [$i, [tt, tt, tt, tt], Id], has: { type: Ct, overloads: [[[Dt], (c, [n]) => Md(n.evaluate(c), c.properties())], [[Dt, Sr], (c, [n, l]) => Md(n.evaluate(c), l.evaluate(c))]] }, get: { type: Tt, overloads: [[[Dt], (c, [n]) => Fh(n.evaluate(c), c.properties())], [[Dt, Sr], (c, [n, l]) => Fh(n.evaluate(c), l.evaluate(c))]] }, "feature-state": [Tt, [Dt], (c, [n]) => Fh(n.evaluate(c), c.featureState || {})], properties: [Sr, [], (c) => c.properties()], "geometry-type": [Dt, [], (c) => c.geometryType()], id: [Tt, [], (c) => c.id()], zoom: [tt, [], (c) => c.globals.zoom], "heatmap-density": [tt, [], (c) => c.globals.heatmapDensity || 0], elevation: [tt, [], (c) => c.globals.elevation || 0], "line-progress": [tt, [], (c) => c.globals.lineProgress || 0], accumulated: [Tt, [], (c) => c.globals.accumulated === void 0 ? null : c.globals.accumulated], "+": [tt, bo(tt), (c, n) => {
          let l = 0;
          for (const f of n) l += f.evaluate(c);
          return l;
        }], "*": [tt, bo(tt), (c, n) => {
          let l = 1;
          for (const f of n) l *= f.evaluate(c);
          return l;
        }], "-": { type: tt, overloads: [[[tt, tt], (c, [n, l]) => n.evaluate(c) - l.evaluate(c)], [[tt], (c, [n]) => -n.evaluate(c)]] }, "/": [tt, [tt, tt], (c, [n, l]) => n.evaluate(c) / l.evaluate(c)], "%": [tt, [tt, tt], (c, [n, l]) => n.evaluate(c) % l.evaluate(c)], ln2: [tt, [], () => Math.LN2], pi: [tt, [], () => Math.PI], e: [tt, [], () => Math.E], "^": [tt, [tt, tt], (c, [n, l]) => Math.pow(n.evaluate(c), l.evaluate(c))], sqrt: [tt, [tt], (c, [n]) => Math.sqrt(n.evaluate(c))], log10: [tt, [tt], (c, [n]) => Math.log(n.evaluate(c)) / Math.LN10], ln: [tt, [tt], (c, [n]) => Math.log(n.evaluate(c))], log2: [tt, [tt], (c, [n]) => Math.log(n.evaluate(c)) / Math.LN2], sin: [tt, [tt], (c, [n]) => Math.sin(n.evaluate(c))], cos: [tt, [tt], (c, [n]) => Math.cos(n.evaluate(c))], tan: [tt, [tt], (c, [n]) => Math.tan(n.evaluate(c))], asin: [tt, [tt], (c, [n]) => Math.asin(n.evaluate(c))], acos: [tt, [tt], (c, [n]) => Math.acos(n.evaluate(c))], atan: [tt, [tt], (c, [n]) => Math.atan(n.evaluate(c))], min: [tt, bo(tt), (c, n) => Math.min(...n.map(((l) => l.evaluate(c))))], max: [tt, bo(tt), (c, n) => Math.max(...n.map(((l) => l.evaluate(c))))], abs: [tt, [tt], (c, [n]) => Math.abs(n.evaluate(c))], round: [tt, [tt], (c, [n]) => {
          const l = n.evaluate(c);
          return l < 0 ? -Math.round(-l) : Math.round(l);
        }], floor: [tt, [tt], (c, [n]) => Math.floor(n.evaluate(c))], ceil: [tt, [tt], (c, [n]) => Math.ceil(n.evaluate(c))], "filter-==": [Ct, [Dt, Tt], (c, [n, l]) => c.properties()[n.value] === l.value], "filter-id-==": [Ct, [Tt], (c, [n]) => c.id() === n.value], "filter-type-==": [Ct, [Dt], (c, [n]) => c.geometryType() === n.value], "filter-<": [Ct, [Dt, Tt], (c, [n, l]) => {
          const f = c.properties()[n.value], _ = l.value;
          return typeof f == typeof _ && f < _;
        }], "filter-id-<": [Ct, [Tt], (c, [n]) => {
          const l = c.id(), f = n.value;
          return typeof l == typeof f && l < f;
        }], "filter->": [Ct, [Dt, Tt], (c, [n, l]) => {
          const f = c.properties()[n.value], _ = l.value;
          return typeof f == typeof _ && f > _;
        }], "filter-id->": [Ct, [Tt], (c, [n]) => {
          const l = c.id(), f = n.value;
          return typeof l == typeof f && l > f;
        }], "filter-<=": [Ct, [Dt, Tt], (c, [n, l]) => {
          const f = c.properties()[n.value], _ = l.value;
          return typeof f == typeof _ && f <= _;
        }], "filter-id-<=": [Ct, [Tt], (c, [n]) => {
          const l = c.id(), f = n.value;
          return typeof l == typeof f && l <= f;
        }], "filter->=": [Ct, [Dt, Tt], (c, [n, l]) => {
          const f = c.properties()[n.value], _ = l.value;
          return typeof f == typeof _ && f >= _;
        }], "filter-id->=": [Ct, [Tt], (c, [n]) => {
          const l = c.id(), f = n.value;
          return typeof l == typeof f && l >= f;
        }], "filter-has": [Ct, [Tt], (c, [n]) => n.value in c.properties()], "filter-has-id": [Ct, [], (c) => c.id() !== null && c.id() !== void 0], "filter-type-in": [Ct, [zi(Dt)], (c, [n]) => n.value.indexOf(c.geometryType()) >= 0], "filter-id-in": [Ct, [zi(Tt)], (c, [n]) => n.value.indexOf(c.id()) >= 0], "filter-in-small": [Ct, [Dt, zi(Tt)], (c, [n, l]) => l.value.indexOf(c.properties()[n.value]) >= 0], "filter-in-large": [Ct, [Dt, zi(Tt)], (c, [n, l]) => (function(f, _, b, v) {
          for (; b <= v; ) {
            const T = b + v >> 1;
            if (_[T] === f) return !0;
            _[T] > f ? v = T - 1 : b = T + 1;
          }
          return !1;
        })(c.properties()[n.value], l.value, 0, l.value.length - 1)], all: { type: Ct, overloads: [[[Ct, Ct], (c, [n, l]) => n.evaluate(c) && l.evaluate(c)], [bo(Ct), (c, n) => {
          for (const l of n) if (!l.evaluate(c)) return !1;
          return !0;
        }]] }, any: { type: Ct, overloads: [[[Ct, Ct], (c, [n, l]) => n.evaluate(c) || l.evaluate(c)], [bo(Ct), (c, n) => {
          for (const l of n) if (l.evaluate(c)) return !0;
          return !1;
        }]] }, "!": [Ct, [Ct], (c, [n]) => !n.evaluate(c)], "is-supported-script": [Ct, [Dt], (c, [n]) => {
          const l = c.globals && c.globals.isSupportedScript;
          return !l || l(n.evaluate(c));
        }], upcase: [Dt, [Dt], (c, [n]) => n.evaluate(c).toUpperCase()], downcase: [Dt, [Dt], (c, [n]) => n.evaluate(c).toLowerCase()], concat: [Dt, bo(Tt), (c, n) => n.map(((l) => Mt(l.evaluate(c)))).join("")], "resolved-locale": [Dt, [en], (c, [n]) => n.evaluate(c).resolvedLocale()] });
        class Nh {
          constructor(n, l) {
            this.expression = n, this._warningHistory = {}, this._evaluator = new bh(), this._defaultValue = l ? (function(f) {
              if (f.type === "color" && Ka(f.default)) return new mt(0, 0, 0, 0);
              switch (f.type) {
                case "color":
                  return mt.parse(f.default) || null;
                case "padding":
                  return or.parse(f.default) || null;
                case "numberArray":
                  return Lr.parse(f.default) || null;
                case "colorArray":
                  return Gi.parse(f.default) || null;
                case "variableAnchorOffsetCollection":
                  return Ur.parse(f.default) || null;
                case "projectionDefinition":
                  return Cr.parse(f.default) || null;
                default:
                  return f.default === void 0 ? null : f.default;
              }
            })(l) : null, this._enumValues = l && l.type === "enum" ? l.values : null;
          }
          evaluateWithoutErrorHandling(n, l, f, _, b, v) {
            return this._evaluator.globals = n, this._evaluator.feature = l, this._evaluator.featureState = f, this._evaluator.canonical = _, this._evaluator.availableImages = b || null, this._evaluator.formattedSection = v, this.expression.evaluate(this._evaluator);
          }
          evaluate(n, l, f, _, b, v) {
            this._evaluator.globals = n, this._evaluator.feature = l || null, this._evaluator.featureState = f || null, this._evaluator.canonical = _, this._evaluator.availableImages = b || null, this._evaluator.formattedSection = v || null;
            try {
              const T = this.expression.evaluate(this._evaluator);
              if (T == null || typeof T == "number" && T != T) return this._defaultValue;
              if (this._enumValues && !(T in this._enumValues)) throw new oi(`Expected value to be one of ${Object.keys(this._enumValues).map(((A) => JSON.stringify(A))).join(", ")}, but found ${JSON.stringify(T)} instead.`);
              return T;
            } catch (T) {
              return this._warningHistory[T.message] || (this._warningHistory[T.message] = !0, typeof console < "u" && console.warn(T.message)), this._defaultValue;
            }
          }
        }
        function Ql(c) {
          return Array.isArray(c) && c.length > 0 && typeof c[0] == "string" && c[0] in Wo;
        }
        function Ya(c, n) {
          const l = new Ho(Wo, Kl, [], n ? (function(_) {
            const b = { color: $i, string: Dt, number: tt, enum: Dt, boolean: Ct, formatted: is, padding: zn, numberArray: Vn, colorArray: us, projectionDefinition: Ss, resolvedImage: li, variableAnchorOffsetCollection: yr };
            return _.type === "array" ? zi(b[_.value] || Tt, _.length) : b[_.type];
          })(n) : void 0), f = l.parse(c, void 0, void 0, void 0, n && n.type === "string" ? { typeAnnotation: "coerce" } : void 0);
          return f ? Rd(new Nh(f, n)) : Xo(l.errors);
        }
        class Ja {
          constructor(n, l) {
            this.kind = n, this._styleExpression = l, this.isStateDependent = n !== "constant" && !Za(l.expression), this.globalStateRefs = tl(l.expression);
          }
          evaluateWithoutErrorHandling(n, l, f, _, b, v) {
            return this._styleExpression.evaluateWithoutErrorHandling(n, l, f, _, b, v);
          }
          evaluate(n, l, f, _, b, v) {
            return this._styleExpression.evaluate(n, l, f, _, b, v);
          }
        }
        class Lh {
          constructor(n, l, f, _) {
            this.kind = n, this.zoomStops = f, this._styleExpression = l, this.isStateDependent = n !== "camera" && !Za(l.expression), this.globalStateRefs = tl(l.expression), this.interpolationType = _;
          }
          evaluateWithoutErrorHandling(n, l, f, _, b, v) {
            return this._styleExpression.evaluateWithoutErrorHandling(n, l, f, _, b, v);
          }
          evaluate(n, l, f, _, b, v) {
            return this._styleExpression.evaluate(n, l, f, _, b, v);
          }
          interpolationFactor(n, l, f) {
            return this.interpolationType ? br.interpolationFactor(this.interpolationType, n, l, f) : 0;
          }
        }
        function Fd(c, n) {
          const l = Ya(c, n);
          if (l.result === "error") return l;
          const f = l.value.expression, _ = Yl(f);
          if (!_ && !Hn(n)) return Xo([new _i("", "data expressions not supported")]);
          const b = Jl(f, ["zoom"]);
          if (!b && !Pd(n)) return Xo([new _i("", "zoom expressions not supported")]);
          const v = el(f);
          return v || b ? v instanceof _i ? Xo([v]) : v instanceof br && !kh(n) ? Xo([new _i("", '"interpolate" expressions cannot be used with this property')]) : Rd(v ? new Lh(_ ? "camera" : "composite", l.value, v.labels, v instanceof br ? v.interpolation : void 0) : new Ja(_ ? "constant" : "source", l.value)) : Xo([new _i("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
        }
        class Qa {
          constructor(n, l) {
            this._parameters = n, this._specification = l, Hi(this, Bd(this._parameters, this._specification));
          }
          static deserialize(n) {
            return new Qa(n._parameters, n._specification);
          }
          static serialize(n) {
            return { _parameters: n._parameters, _specification: n._specification };
          }
        }
        function el(c) {
          let n = null;
          if (c instanceof Na) n = el(c.result);
          else if (c instanceof Va) {
            for (const l of c.args) if (n = el(l), n) break;
          } else (c instanceof Bi || c instanceof br) && c.input instanceof fs && c.input.name === "zoom" && (n = c);
          return n instanceof _i || c.eachChild(((l) => {
            const f = el(l);
            f instanceof _i ? n = f : !n && f ? n = new _i("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : n && f && n !== f && (n = new _i("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
          })), n;
        }
        function tl(c, n = /* @__PURE__ */ new Set()) {
          return c instanceof qa && n.add(c.key), c.eachChild(((l) => {
            tl(l, n);
          })), n;
        }
        function ec(c) {
          if (c === !0 || c === !1) return !0;
          if (!Array.isArray(c) || c.length === 0) return !1;
          switch (c[0]) {
            case "has":
              return c.length >= 2 && c[1] !== "$id" && c[1] !== "$type";
            case "in":
              return c.length >= 3 && (typeof c[1] != "string" || Array.isArray(c[2]));
            case "!in":
            case "!has":
            case "none":
              return !1;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return c.length !== 3 || Array.isArray(c[1]) || Array.isArray(c[2]);
            case "any":
            case "all":
              for (const n of c.slice(1)) if (!ec(n) && typeof n != "boolean") return !1;
              return !0;
            default:
              return !0;
          }
        }
        const Uh = { type: "boolean", default: !1, transition: !1, "property-type": "data-driven", expression: { interpolated: !1, parameters: ["zoom", "feature"] } };
        function vo(c) {
          if (c == null) return { filter: () => !0, needGeometry: !1, getGlobalStateRefs: () => /* @__PURE__ */ new Set() };
          ec(c) || (c = xo(c));
          const n = Ya(c, Uh);
          if (n.result === "error") throw new Error(n.value.map(((l) => `${l.key}: ${l.message}`)).join(", "));
          return { filter: (l, f, _) => n.value.evaluate(l, f, {}, _), needGeometry: tc(c), getGlobalStateRefs: () => tl(n.value.expression) };
        }
        function zh(c, n) {
          return c < n ? -1 : c > n ? 1 : 0;
        }
        function tc(c) {
          if (!Array.isArray(c)) return !1;
          if (c[0] === "within" || c[0] === "distance") return !0;
          for (let n = 1; n < c.length; n++) if (tc(c[n])) return !0;
          return !1;
        }
        function xo(c) {
          if (!c) return !0;
          const n = c[0];
          return c.length <= 1 ? n !== "any" : n === "==" ? Vh(c[1], c[2], "==") : n === "!=" ? ic(Vh(c[1], c[2], "==")) : n === "<" || n === ">" || n === "<=" || n === ">=" ? Vh(c[1], c[2], n) : n === "any" ? (l = c.slice(1), ["any"].concat(l.map(xo))) : n === "all" ? ["all"].concat(c.slice(1).map(xo)) : n === "none" ? ["all"].concat(c.slice(1).map(xo).map(ic)) : n === "in" ? kd(c[1], c.slice(2)) : n === "!in" ? ic(kd(c[1], c.slice(2))) : n === "has" ? Nd(c[1]) : n !== "!has" || ic(Nd(c[1]));
          var l;
        }
        function Vh(c, n, l) {
          switch (c) {
            case "$type":
              return [`filter-type-${l}`, n];
            case "$id":
              return [`filter-id-${l}`, n];
            default:
              return [`filter-${l}`, c, n];
          }
        }
        function kd(c, n) {
          if (n.length === 0) return !1;
          switch (c) {
            case "$type":
              return ["filter-type-in", ["literal", n]];
            case "$id":
              return ["filter-id-in", ["literal", n]];
            default:
              return n.length > 200 && !n.some(((l) => typeof l != typeof n[0])) ? ["filter-in-large", c, ["literal", n.sort(zh)]] : ["filter-in-small", c, ["literal", n]];
          }
        }
        function Nd(c) {
          switch (c) {
            case "$type":
              return !0;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", c];
          }
        }
        function ic(c) {
          return ["!", c];
        }
        function jh(c) {
          const n = typeof c;
          if (n === "number" || n === "boolean" || n === "string" || c == null) return JSON.stringify(c);
          if (Array.isArray(c)) {
            let _ = "[";
            for (const b of c) _ += `${jh(b)},`;
            return `${_}]`;
          }
          const l = Object.keys(c).sort();
          let f = "{";
          for (let _ = 0; _ < l.length; _++) f += `${JSON.stringify(l[_])}:${jh(c[l[_]])},`;
          return `${f}}`;
        }
        function l_(c) {
          let n = "";
          for (const l of wt) n += `/${jh(c[l])}`;
          return n;
        }
        function Hh(c) {
          const n = c.value;
          return n ? [new Ge(c.key, n, "constants have been deprecated as of v8")] : [];
        }
        function Ei(c) {
          return c instanceof Number || c instanceof String || c instanceof Boolean ? c.valueOf() : c;
        }
        function on(c) {
          if (Array.isArray(c)) return c.map(on);
          if (c instanceof Object && !(c instanceof Number || c instanceof String || c instanceof Boolean)) {
            const n = {};
            for (const l in c) n[l] = on(c[l]);
            return n;
          }
          return Ei(c);
        }
        function ps(c) {
          const n = c.key, l = c.value, f = c.valueSpec || {}, _ = c.objectElementValidators || {}, b = c.style, v = c.styleSpec, T = c.validateSpec;
          let A = [];
          const I = kt(l);
          if (I !== "object") return [new Ge(n, l, `object expected, ${I} found`)];
          for (const P in l) {
            const D = P.split(".")[0], U = X(f, D) || f["*"];
            let V;
            if (X(_, D)) V = _[D];
            else if (X(f, D)) V = T;
            else if (_["*"]) V = _["*"];
            else {
              if (!f["*"]) {
                A.push(new Ge(n, l[P], `unknown property "${P}"`));
                continue;
              }
              V = T;
            }
            A = A.concat(V({ key: (n && `${n}.`) + P, value: l[P], valueSpec: U, style: b, styleSpec: v, object: l, objectKey: P, validateSpec: T }, l));
          }
          for (const P in f) _[P] || f[P].required && f[P].default === void 0 && l[P] === void 0 && A.push(new Ge(n, l, `missing required property "${P}"`));
          return A;
        }
        function rc(c) {
          const n = c.value, l = c.valueSpec, f = c.style, _ = c.styleSpec, b = c.key, v = c.arrayElementValidator || c.validateSpec;
          if (kt(n) !== "array") return [new Ge(b, n, `array expected, ${kt(n)} found`)];
          if (l.length && n.length !== l.length) return [new Ge(b, n, `array length ${l.length} expected, length ${n.length} found`)];
          if (l["min-length"] && n.length < l["min-length"]) return [new Ge(b, n, `array length at least ${l["min-length"]} expected, length ${n.length} found`)];
          let T = { type: l.value, values: l.values };
          _.$version < 7 && (T.function = l.function), kt(l.value) === "object" && (T = l.value);
          let A = [];
          for (let I = 0; I < n.length; I++) A = A.concat(v({ array: n, arrayIndex: I, value: n[I], valueSpec: T, validateSpec: c.validateSpec, style: f, styleSpec: _, key: `${b}[${I}]` }));
          return A;
        }
        function il(c) {
          const n = c.key, l = c.value, f = c.valueSpec;
          let _ = kt(l);
          return _ === "number" && l != l && (_ = "NaN"), _ !== "number" ? [new Ge(n, l, `number expected, ${_} found`)] : "minimum" in f && l < f.minimum ? [new Ge(n, l, `${l} is less than the minimum value ${f.minimum}`)] : "maximum" in f && l > f.maximum ? [new Ge(n, l, `${l} is greater than the maximum value ${f.maximum}`)] : [];
        }
        function Ld(c) {
          const n = c.valueSpec, l = Ei(c.value.type);
          let f, _, b, v = {};
          const T = l !== "categorical" && c.value.property === void 0, A = !T, I = kt(c.value.stops) === "array" && kt(c.value.stops[0]) === "array" && kt(c.value.stops[0][0]) === "object", P = ps({ key: c.key, value: c.value, valueSpec: c.styleSpec.function, validateSpec: c.validateSpec, style: c.style, styleSpec: c.styleSpec, objectElementValidators: { stops: function(V) {
            if (l === "identity") return [new Ge(V.key, V.value, 'identity function may not have a "stops" property')];
            let j = [];
            const G = V.value;
            return j = j.concat(rc({ key: V.key, value: G, valueSpec: V.valueSpec, validateSpec: V.validateSpec, style: V.style, styleSpec: V.styleSpec, arrayElementValidator: D })), kt(G) === "array" && G.length === 0 && j.push(new Ge(V.key, G, "array must have at least one stop")), j;
          }, default: function(V) {
            return V.validateSpec({ key: V.key, value: V.value, valueSpec: n, validateSpec: V.validateSpec, style: V.style, styleSpec: V.styleSpec });
          } } });
          return l === "identity" && T && P.push(new Ge(c.key, c.value, 'missing required property "property"')), l === "identity" || c.value.stops || P.push(new Ge(c.key, c.value, 'missing required property "stops"')), l === "exponential" && c.valueSpec.expression && !kh(c.valueSpec) && P.push(new Ge(c.key, c.value, "exponential functions not supported")), c.styleSpec.$version >= 8 && (A && !Hn(c.valueSpec) ? P.push(new Ge(c.key, c.value, "property functions not supported")) : T && !Pd(c.valueSpec) && P.push(new Ge(c.key, c.value, "zoom functions not supported"))), l !== "categorical" && !I || c.value.property !== void 0 || P.push(new Ge(c.key, c.value, '"property" property is required')), P;
          function D(V) {
            let j = [];
            const G = V.value, Z = V.key;
            if (kt(G) !== "array") return [new Ge(Z, G, `array expected, ${kt(G)} found`)];
            if (G.length !== 2) return [new Ge(Z, G, `array length 2 expected, length ${G.length} found`)];
            if (I) {
              if (kt(G[0]) !== "object") return [new Ge(Z, G, `object expected, ${kt(G[0])} found`)];
              if (G[0].zoom === void 0) return [new Ge(Z, G, "object stop key must have zoom")];
              if (G[0].value === void 0) return [new Ge(Z, G, "object stop key must have value")];
              if (b && b > Ei(G[0].zoom)) return [new Ge(Z, G[0].zoom, "stop zoom values must appear in ascending order")];
              Ei(G[0].zoom) !== b && (b = Ei(G[0].zoom), _ = void 0, v = {}), j = j.concat(ps({ key: `${Z}[0]`, value: G[0], valueSpec: { zoom: {} }, validateSpec: V.validateSpec, style: V.style, styleSpec: V.styleSpec, objectElementValidators: { zoom: il, value: U } }));
            } else j = j.concat(U({ key: `${Z}[0]`, value: G[0], validateSpec: V.validateSpec, style: V.style, styleSpec: V.styleSpec }, G));
            return Ql(on(G[1])) ? j.concat([new Ge(`${Z}[1]`, G[1], "expressions are not allowed in function stops.")]) : j.concat(V.validateSpec({ key: `${Z}[1]`, value: G[1], valueSpec: n, validateSpec: V.validateSpec, style: V.style, styleSpec: V.styleSpec }));
          }
          function U(V, j) {
            const G = kt(V.value), Z = Ei(V.value), te = V.value !== null ? V.value : j;
            if (f) {
              if (G !== f) return [new Ge(V.key, te, `${G} stop domain type must match previous stop domain type ${f}`)];
            } else f = G;
            if (G !== "number" && G !== "string" && G !== "boolean") return [new Ge(V.key, te, "stop domain value must be a number, string, or boolean")];
            if (G !== "number" && l !== "categorical") {
              let me = `number expected, ${G} found`;
              return Hn(n) && l === void 0 && (me += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new Ge(V.key, te, me)];
            }
            return l !== "categorical" || G !== "number" || isFinite(Z) && Math.floor(Z) === Z ? l !== "categorical" && G === "number" && _ !== void 0 && Z < _ ? [new Ge(V.key, te, "stop domain values must appear in ascending order")] : (_ = Z, l === "categorical" && Z in v ? [new Ge(V.key, te, "stop domain values must be unique")] : (v[Z] = !0, [])) : [new Ge(V.key, te, `integer expected, found ${Z}`)];
          }
        }
        function wo(c) {
          const n = (c.expressionContext === "property" ? Fd : Ya)(on(c.value), c.valueSpec);
          if (n.result === "error") return n.value.map(((f) => new Ge(`${c.key}${f.key}`, c.value, f.message)));
          const l = n.value.expression || n.value._styleExpression.expression;
          if (c.expressionContext === "property" && c.propertyKey === "text-font" && !l.outputDefined()) return [new Ge(c.key, c.value, `Invalid data expression for "${c.propertyKey}". Output values must be contained as literals within the expression.`)];
          if (c.expressionContext === "property" && c.propertyType === "layout" && !Za(l)) return [new Ge(c.key, c.value, '"feature-state" data expressions are not supported with layout properties.')];
          if (c.expressionContext === "filter" && !Za(l)) return [new Ge(c.key, c.value, '"feature-state" data expressions are not supported with filters.')];
          if (c.expressionContext && c.expressionContext.indexOf("cluster") === 0) {
            if (!Jl(l, ["zoom", "feature-state"])) return [new Ge(c.key, c.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if (c.expressionContext === "cluster-initial" && !Yl(l)) return [new Ge(c.key, c.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
          }
          return [];
        }
        function sc(c) {
          const n = c.key, l = c.value, f = kt(l);
          return f !== "string" ? [new Ge(n, l, `color expected, ${f} found`)] : mt.parse(String(l)) ? [] : [new Ge(n, l, `color expected, "${l}" found`)];
        }
        function bn(c) {
          const n = c.key, l = c.value, f = c.valueSpec, _ = [];
          return Array.isArray(f.values) ? f.values.indexOf(Ei(l)) === -1 && _.push(new Ge(n, l, `expected one of [${f.values.join(", ")}], ${JSON.stringify(l)} found`)) : Object.keys(f.values).indexOf(Ei(l)) === -1 && _.push(new Ge(n, l, `expected one of [${Object.keys(f.values).join(", ")}], ${JSON.stringify(l)} found`)), _;
        }
        function $h(c) {
          return ec(on(c.value)) ? wo(Hi({}, c, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : Ud(c);
        }
        function Ud(c) {
          const n = c.value, l = c.key;
          if (kt(n) !== "array") return [new Ge(l, n, `array expected, ${kt(n)} found`)];
          const f = c.styleSpec;
          let _, b = [];
          if (n.length < 1) return [new Ge(l, n, "filter array must have at least 1 element")];
          switch (b = b.concat(bn({ key: `${l}[0]`, value: n[0], valueSpec: f.filter_operator, style: c.style, styleSpec: c.styleSpec })), Ei(n[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              n.length >= 2 && Ei(n[1]) === "$type" && b.push(new Ge(l, n, `"$type" cannot be use with operator "${n[0]}"`));
            case "==":
            case "!=":
              n.length !== 3 && b.push(new Ge(l, n, `filter array for operator "${n[0]}" must have 3 elements`));
            case "in":
            case "!in":
              n.length >= 2 && (_ = kt(n[1]), _ !== "string" && b.push(new Ge(`${l}[1]`, n[1], `string expected, ${_} found`)));
              for (let v = 2; v < n.length; v++) _ = kt(n[v]), Ei(n[1]) === "$type" ? b = b.concat(bn({ key: `${l}[${v}]`, value: n[v], valueSpec: f.geometry_type, style: c.style, styleSpec: c.styleSpec })) : _ !== "string" && _ !== "number" && _ !== "boolean" && b.push(new Ge(`${l}[${v}]`, n[v], `string, number, or boolean expected, ${_} found`));
              break;
            case "any":
            case "all":
            case "none":
              for (let v = 1; v < n.length; v++) b = b.concat(Ud({ key: `${l}[${v}]`, value: n[v], style: c.style, styleSpec: c.styleSpec }));
              break;
            case "has":
            case "!has":
              _ = kt(n[1]), n.length !== 2 ? b.push(new Ge(l, n, `filter array for "${n[0]}" operator must have 2 elements`)) : _ !== "string" && b.push(new Ge(`${l}[1]`, n[1], `string expected, ${_} found`));
          }
          return b;
        }
        function zd(c, n) {
          const l = c.key, f = c.validateSpec, _ = c.style, b = c.styleSpec, v = c.value, T = c.objectKey, A = b[`${n}_${c.layerType}`];
          if (!A) return [];
          const I = T.match(/^(.*)-transition$/);
          if (n === "paint" && I && A[I[1]] && A[I[1]].transition) return f({ key: l, value: v, valueSpec: b.transition, style: _, styleSpec: b });
          const P = c.valueSpec || A[T];
          if (!P) return [new Ge(l, v, `unknown property "${T}"`)];
          let D;
          if (kt(v) === "string" && Hn(P) && !P.tokens && (D = /^{([^}]+)}$/.exec(v))) return [new Ge(l, v, `"${T}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(D[1])} }\`.`)];
          const U = [];
          return c.layerType === "symbol" && (T === "text-field" && _ && !_.glyphs && U.push(new Ge(l, v, 'use of "text-field" requires a style "glyphs" property')), T === "text-font" && Ka(on(v)) && Ei(v.type) === "identity" && U.push(new Ge(l, v, '"text-font" does not support identity functions'))), U.concat(f({ key: c.key, value: v, valueSpec: P, style: _, styleSpec: b, expressionContext: "property", propertyType: n, propertyKey: T }));
        }
        function Vd(c) {
          return zd(c, "paint");
        }
        function jd(c) {
          return zd(c, "layout");
        }
        function Hd(c) {
          let n = [];
          const l = c.value, f = c.key, _ = c.style, b = c.styleSpec;
          if (kt(l) !== "object") return [new Ge(f, l, `object expected, ${kt(l)} found`)];
          l.type || l.ref || n.push(new Ge(f, l, 'either "type" or "ref" is required'));
          let v = Ei(l.type);
          const T = Ei(l.ref);
          if (l.id) {
            const A = Ei(l.id);
            for (let I = 0; I < c.arrayIndex; I++) {
              const P = _.layers[I];
              Ei(P.id) === A && n.push(new Ge(f, l.id, `duplicate layer id "${l.id}", previously used at line ${P.id.__line__}`));
            }
          }
          if ("ref" in l) {
            let A;
            ["type", "source", "source-layer", "filter", "layout"].forEach(((I) => {
              I in l && n.push(new Ge(f, l[I], `"${I}" is prohibited for ref layers`));
            })), _.layers.forEach(((I) => {
              Ei(I.id) === T && (A = I);
            })), A ? A.ref ? n.push(new Ge(f, l.ref, "ref cannot reference another ref layer")) : v = Ei(A.type) : n.push(new Ge(f, l.ref, `ref layer "${T}" not found`));
          } else if (v !== "background") if (l.source) {
            const A = _.sources && _.sources[l.source], I = A && Ei(A.type);
            A ? I === "vector" && v === "raster" ? n.push(new Ge(f, l.source, `layer "${l.id}" requires a raster source`)) : I !== "raster-dem" && v === "hillshade" || I !== "raster-dem" && v === "color-relief" ? n.push(new Ge(f, l.source, `layer "${l.id}" requires a raster-dem source`)) : I === "raster" && v !== "raster" ? n.push(new Ge(f, l.source, `layer "${l.id}" requires a vector source`)) : I !== "vector" || l["source-layer"] ? I === "raster-dem" && v !== "hillshade" && v !== "color-relief" ? n.push(new Ge(f, l.source, "raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.")) : v !== "line" || !l.paint || !l.paint["line-gradient"] || I === "geojson" && A.lineMetrics || n.push(new Ge(f, l, `layer "${l.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : n.push(new Ge(f, l, `layer "${l.id}" must specify a "source-layer"`)) : n.push(new Ge(f, l.source, `source "${l.source}" not found`));
          } else n.push(new Ge(f, l, 'missing required property "source"'));
          return n = n.concat(ps({ key: f, value: l, valueSpec: b.layer, style: c.style, styleSpec: c.styleSpec, validateSpec: c.validateSpec, objectElementValidators: { "*": () => [], type: () => c.validateSpec({ key: `${f}.type`, value: l.type, valueSpec: b.layer.type, style: c.style, styleSpec: c.styleSpec, validateSpec: c.validateSpec, object: l, objectKey: "type" }), filter: $h, layout: (A) => ps({ layer: l, key: A.key, value: A.value, style: A.style, styleSpec: A.styleSpec, validateSpec: A.validateSpec, objectElementValidators: { "*": (I) => jd(Hi({ layerType: v }, I)) } }), paint: (A) => ps({ layer: l, key: A.key, value: A.value, style: A.style, styleSpec: A.styleSpec, validateSpec: A.validateSpec, objectElementValidators: { "*": (I) => Vd(Hi({ layerType: v }, I)) } }) } })), n;
        }
        function Bs(c) {
          const n = c.value, l = c.key, f = kt(n);
          return f !== "string" ? [new Ge(l, n, `string expected, ${f} found`)] : [];
        }
        const qo = { promoteId: function({ key: c, value: n }) {
          if (kt(n) === "string") return Bs({ key: c, value: n });
          {
            const l = [];
            for (const f in n) l.push(...Bs({ key: `${c}.${f}`, value: n[f] }));
            return l;
          }
        } };
        function Wr(c) {
          const n = c.value, l = c.key, f = c.styleSpec, _ = c.style, b = c.validateSpec;
          if (!n.type) return [new Ge(l, n, '"type" is required')];
          const v = Ei(n.type);
          let T;
          switch (v) {
            case "vector":
            case "raster":
              return T = ps({ key: l, value: n, valueSpec: f[`source_${v.replace("-", "_")}`], style: c.style, styleSpec: f, objectElementValidators: qo, validateSpec: b }), T;
            case "raster-dem":
              return T = (function(A) {
                var I;
                const P = (I = A.sourceName) !== null && I !== void 0 ? I : "", D = A.value, U = A.styleSpec, V = U.source_raster_dem, j = A.style;
                let G = [];
                const Z = kt(D);
                if (D === void 0) return G;
                if (Z !== "object") return G.push(new Ge("source_raster_dem", D, `object expected, ${Z} found`)), G;
                const te = Ei(D.encoding) === "custom", me = ["redFactor", "greenFactor", "blueFactor", "baseShift"], ce = A.value.encoding ? `"${A.value.encoding}"` : "Default";
                for (const de in D) !te && me.includes(de) ? G.push(new Ge(de, D[de], `In "${P}": "${de}" is only valid when "encoding" is set to "custom". ${ce} encoding found`)) : V[de] ? G = G.concat(A.validateSpec({ key: de, value: D[de], valueSpec: V[de], validateSpec: A.validateSpec, style: j, styleSpec: U })) : G.push(new Ge(de, D[de], `unknown property "${de}"`));
                return G;
              })({ sourceName: l, value: n, style: c.style, styleSpec: f, validateSpec: b }), T;
            case "geojson":
              if (T = ps({ key: l, value: n, valueSpec: f.source_geojson, style: _, styleSpec: f, validateSpec: b, objectElementValidators: qo }), n.cluster) for (const A in n.clusterProperties) {
                const [I, P] = n.clusterProperties[A], D = typeof I == "string" ? [I, ["accumulated"], ["get", A]] : I;
                T.push(...wo({ key: `${l}.${A}.map`, value: P, expressionContext: "cluster-map" })), T.push(...wo({ key: `${l}.${A}.reduce`, value: D, expressionContext: "cluster-reduce" }));
              }
              return T;
            case "video":
              return ps({ key: l, value: n, valueSpec: f.source_video, style: _, validateSpec: b, styleSpec: f });
            case "image":
              return ps({ key: l, value: n, valueSpec: f.source_image, style: _, validateSpec: b, styleSpec: f });
            case "canvas":
              return [new Ge(l, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return bn({ key: `${l}.type`, value: n.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] } });
          }
        }
        function Zo(c) {
          const n = c.value, l = c.styleSpec, f = l.light, _ = c.style;
          let b = [];
          const v = kt(n);
          if (n === void 0) return b;
          if (v !== "object") return b = b.concat([new Ge("light", n, `object expected, ${v} found`)]), b;
          for (const T in n) {
            const A = T.match(/^(.*)-transition$/);
            b = b.concat(A && f[A[1]] && f[A[1]].transition ? c.validateSpec({ key: T, value: n[T], valueSpec: l.transition, validateSpec: c.validateSpec, style: _, styleSpec: l }) : f[T] ? c.validateSpec({ key: T, value: n[T], valueSpec: f[T], validateSpec: c.validateSpec, style: _, styleSpec: l }) : [new Ge(T, n[T], `unknown property "${T}"`)]);
          }
          return b;
        }
        function Gh(c) {
          const n = c.value, l = c.styleSpec, f = l.sky, _ = c.style, b = kt(n);
          if (n === void 0) return [];
          if (b !== "object") return [new Ge("sky", n, `object expected, ${b} found`)];
          let v = [];
          for (const T in n) v = v.concat(f[T] ? c.validateSpec({ key: T, value: n[T], valueSpec: f[T], style: _, styleSpec: l }) : [new Ge(T, n[T], `unknown property "${T}"`)]);
          return v;
        }
        function $d(c) {
          const n = c.value, l = c.styleSpec, f = l.terrain, _ = c.style;
          let b = [];
          const v = kt(n);
          if (n === void 0) return b;
          if (v !== "object") return b = b.concat([new Ge("terrain", n, `object expected, ${v} found`)]), b;
          for (const T in n) b = b.concat(f[T] ? c.validateSpec({ key: T, value: n[T], valueSpec: f[T], validateSpec: c.validateSpec, style: _, styleSpec: l }) : [new Ge(T, n[T], `unknown property "${T}"`)]);
          return b;
        }
        function Gd(c) {
          let n = [];
          const l = c.value, f = c.key;
          if (Array.isArray(l)) {
            const _ = [], b = [];
            for (const v in l) l[v].id && _.includes(l[v].id) && n.push(new Ge(f, l, `all the sprites' ids must be unique, but ${l[v].id} is duplicated`)), _.push(l[v].id), l[v].url && b.includes(l[v].url) && n.push(new Ge(f, l, `all the sprites' URLs must be unique, but ${l[v].url} is duplicated`)), b.push(l[v].url), n = n.concat(ps({ key: `${f}[${v}]`, value: l[v], valueSpec: { id: { type: "string", required: !0 }, url: { type: "string", required: !0 } }, validateSpec: c.validateSpec }));
            return n;
          }
          return Bs({ key: f, value: l });
        }
        function Ko(c) {
          return n = c.value, n && n.constructor === Object ? [] : [new Ge(c.key, c.value, `object expected, ${kt(c.value)} found`)];
          var n;
        }
        const Wh = { "*": () => [], array: rc, boolean: function(c) {
          const n = c.value, l = c.key, f = kt(n);
          return f !== "boolean" ? [new Ge(l, n, `boolean expected, ${f} found`)] : [];
        }, number: il, color: sc, constants: Hh, enum: bn, filter: $h, function: Ld, layer: Hd, object: ps, source: Wr, light: Zo, sky: Gh, terrain: $d, projection: function(c) {
          const n = c.value, l = c.styleSpec, f = l.projection, _ = c.style, b = kt(n);
          if (n === void 0) return [];
          if (b !== "object") return [new Ge("projection", n, `object expected, ${b} found`)];
          let v = [];
          for (const T in n) v = v.concat(f[T] ? c.validateSpec({ key: T, value: n[T], valueSpec: f[T], style: _, styleSpec: l }) : [new Ge(T, n[T], `unknown property "${T}"`)]);
          return v;
        }, projectionDefinition: function(c) {
          const n = c.key;
          let l = c.value;
          l = l instanceof String ? l.valueOf() : l;
          const f = kt(l);
          return f !== "array" || (function(_) {
            return Array.isArray(_) && _.length === 3 && typeof _[0] == "string" && typeof _[1] == "string" && typeof _[2] == "number";
          })(l) || (function(_) {
            return !!["interpolate", "step", "literal"].includes(_[0]);
          })(l) ? ["array", "string"].includes(f) ? [] : [new Ge(n, l, `projection expected, invalid type "${f}" found`)] : [new Ge(n, l, `projection expected, invalid array ${JSON.stringify(l)} found`)];
        }, string: Bs, formatted: function(c) {
          return Bs(c).length === 0 ? [] : wo(c);
        }, resolvedImage: function(c) {
          return Bs(c).length === 0 ? [] : wo(c);
        }, padding: function(c) {
          const n = c.key, l = c.value;
          if (kt(l) === "array") {
            if (l.length < 1 || l.length > 4) return [new Ge(n, l, `padding requires 1 to 4 values; ${l.length} values found`)];
            const f = { type: "number" };
            let _ = [];
            for (let b = 0; b < l.length; b++) _ = _.concat(c.validateSpec({ key: `${n}[${b}]`, value: l[b], validateSpec: c.validateSpec, valueSpec: f }));
            return _;
          }
          return il({ key: n, value: l, valueSpec: {} });
        }, numberArray: function(c) {
          const n = c.key, l = c.value;
          if (kt(l) === "array") {
            const f = { type: "number" };
            if (l.length < 1) return [new Ge(n, l, "array length at least 1 expected, length 0 found")];
            let _ = [];
            for (let b = 0; b < l.length; b++) _ = _.concat(c.validateSpec({ key: `${n}[${b}]`, value: l[b], validateSpec: c.validateSpec, valueSpec: f }));
            return _;
          }
          return il({ key: n, value: l, valueSpec: {} });
        }, colorArray: function(c) {
          const n = c.key, l = c.value;
          if (kt(l) === "array") {
            if (l.length < 1) return [new Ge(n, l, "array length at least 1 expected, length 0 found")];
            let f = [];
            for (let _ = 0; _ < l.length; _++) f = f.concat(sc({ key: `${n}[${_}]`, value: l[_] }));
            return f;
          }
          return sc({ key: n, value: l });
        }, variableAnchorOffsetCollection: function(c) {
          const n = c.key, l = c.value, f = kt(l), _ = c.styleSpec;
          if (f !== "array" || l.length < 1 || l.length % 2 != 0) return [new Ge(n, l, "variableAnchorOffsetCollection requires a non-empty array of even length")];
          let b = [];
          for (let v = 0; v < l.length; v += 2) b = b.concat(bn({ key: `${n}[${v}]`, value: l[v], valueSpec: _.layout_symbol["text-anchor"] })), b = b.concat(rc({ key: `${n}[${v + 1}]`, value: l[v + 1], valueSpec: { length: 2, value: "number" }, validateSpec: c.validateSpec, style: c.style, styleSpec: _ }));
          return b;
        }, sprite: Gd, state: Ko };
        function Yo(c) {
          const n = c.value, l = c.valueSpec, f = c.styleSpec;
          return c.validateSpec = Yo, l.expression && Ka(Ei(n)) ? Ld(c) : l.expression && Ql(on(n)) ? wo(c) : l.type && Wh[l.type] ? Wh[l.type](c) : ps(Hi({}, c, { valueSpec: l.type ? f[l.type] : l }));
        }
        function Wd(c) {
          const n = c.value, l = c.key, f = Bs(c);
          return f.length || (n.indexOf("{fontstack}") === -1 && f.push(new Ge(l, n, '"glyphs" url must include a "{fontstack}" token')), n.indexOf("{range}") === -1 && f.push(new Ge(l, n, '"glyphs" url must include a "{range}" token'))), f;
        }
        function Xr(c, n = ve) {
          let l = [];
          return l = l.concat(Yo({ key: "", value: c, valueSpec: n.$root, styleSpec: n, style: c, validateSpec: Yo, objectElementValidators: { glyphs: Wd, "*": () => [] } })), c.constants && (l = l.concat(Hh({ key: "constants", value: c.constants }))), Jo(l);
        }
        function Ds(c) {
          return function(n) {
            return c({ ...n, validateSpec: Yo });
          };
        }
        function Jo(c) {
          return [].concat(c).sort(((n, l) => n.line - l.line));
        }
        function Os(c) {
          return function(...n) {
            return Jo(c.apply(this, n));
          };
        }
        Xr.source = Os(Ds(Wr)), Xr.sprite = Os(Ds(Gd)), Xr.glyphs = Os(Ds(Wd)), Xr.light = Os(Ds(Zo)), Xr.sky = Os(Ds(Gh)), Xr.terrain = Os(Ds($d)), Xr.state = Os(Ds(Ko)), Xr.layer = Os(Ds(Hd)), Xr.filter = Os(Ds($h)), Xr.paintProperty = Os(Ds(Vd)), Xr.layoutProperty = Os(Ds(jd));
        const Qo = Xr, c_ = Qo.light, rl = Qo.sky, h_ = Qo.paintProperty, u_ = Qo.layoutProperty;
        function sl(c, n) {
          let l = !1;
          if (n && n.length) for (const f of n) c.fire(new ze(new Error(f.message))), l = !0;
          return l;
        }
        class nl {
          constructor(n, l, f) {
            const _ = this.cells = [];
            if (n instanceof ArrayBuffer) {
              this.arrayBuffer = n;
              const v = new Int32Array(this.arrayBuffer);
              n = v[0], this.d = (l = v[1]) + 2 * (f = v[2]);
              for (let A = 0; A < this.d * this.d; A++) {
                const I = v[3 + A], P = v[3 + A + 1];
                _.push(I === P ? null : v.subarray(I, P));
              }
              const T = v[3 + _.length + 1];
              this.keys = v.subarray(v[3 + _.length], T), this.bboxes = v.subarray(T), this.insert = this._insertReadonly;
            } else {
              this.d = l + 2 * f;
              for (let v = 0; v < this.d * this.d; v++) _.push([]);
              this.keys = [], this.bboxes = [];
            }
            this.n = l, this.extent = n, this.padding = f, this.scale = l / n, this.uid = 0;
            const b = f / l * n;
            this.min = -b, this.max = n + b;
          }
          insert(n, l, f, _, b) {
            this._forEachCell(l, f, _, b, this._insertCell, this.uid++, void 0, void 0), this.keys.push(n), this.bboxes.push(l), this.bboxes.push(f), this.bboxes.push(_), this.bboxes.push(b);
          }
          _insertReadonly() {
            throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
          }
          _insertCell(n, l, f, _, b, v) {
            this.cells[b].push(v);
          }
          query(n, l, f, _, b) {
            const v = this.min, T = this.max;
            if (n <= v && l <= v && T <= f && T <= _ && !b) return Array.prototype.slice.call(this.keys);
            {
              const A = [];
              return this._forEachCell(n, l, f, _, this._queryCell, A, {}, b), A;
            }
          }
          _queryCell(n, l, f, _, b, v, T, A) {
            const I = this.cells[b];
            if (I !== null) {
              const P = this.keys, D = this.bboxes;
              for (let U = 0; U < I.length; U++) {
                const V = I[U];
                if (T[V] === void 0) {
                  const j = 4 * V;
                  (A ? A(D[j + 0], D[j + 1], D[j + 2], D[j + 3]) : n <= D[j + 2] && l <= D[j + 3] && f >= D[j + 0] && _ >= D[j + 1]) ? (T[V] = !0, v.push(P[V])) : T[V] = !1;
                }
              }
            }
          }
          _forEachCell(n, l, f, _, b, v, T, A) {
            const I = this._convertToCellCoord(n), P = this._convertToCellCoord(l), D = this._convertToCellCoord(f), U = this._convertToCellCoord(_);
            for (let V = I; V <= D; V++) for (let j = P; j <= U; j++) {
              const G = this.d * j + V;
              if ((!A || A(this._convertFromCellCoord(V), this._convertFromCellCoord(j), this._convertFromCellCoord(V + 1), this._convertFromCellCoord(j + 1))) && b.call(this, n, l, f, _, G, v, T, A)) return;
            }
          }
          _convertFromCellCoord(n) {
            return (n - this.padding) / this.scale;
          }
          _convertToCellCoord(n) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(n * this.scale) + this.padding));
          }
          toArrayBuffer() {
            if (this.arrayBuffer) return this.arrayBuffer;
            const n = this.cells, l = 3 + this.cells.length + 1 + 1;
            let f = 0;
            for (let v = 0; v < this.cells.length; v++) f += this.cells[v].length;
            const _ = new Int32Array(l + f + this.keys.length + this.bboxes.length);
            _[0] = this.extent, _[1] = this.n, _[2] = this.padding;
            let b = l;
            for (let v = 0; v < n.length; v++) {
              const T = n[v];
              _[3 + v] = b, _.set(T, b), b += T.length;
            }
            return _[3 + n.length] = b, _.set(this.keys, b), b += this.keys.length, _[3 + n.length + 1] = b, _.set(this.bboxes, b), b += this.bboxes.length, _.buffer;
          }
          static serialize(n, l) {
            const f = n.toArrayBuffer();
            return l && l.push(f), { buffer: f };
          }
          static deserialize(n) {
            return new nl(n.buffer);
          }
        }
        const Fs = {};
        function nt(c, n, l = {}) {
          if (Fs[c]) throw new Error(`${c} is already registered.`);
          Object.defineProperty(n, "_classRegistryKey", { value: c, writeable: !1 }), Fs[c] = { klass: n, omit: l.omit || [], shallow: l.shallow || [] };
        }
        nt("Object", Object), nt("Set", Set), nt("TransferableGridIndex", nl), nt("Color", mt), nt("Error", Error), nt("AJAXError", ae), nt("ResolvedImage", rs), nt("StylePropertyFunction", Qa), nt("StyleExpression", Nh, { omit: ["_evaluator"] }), nt("ZoomDependentExpression", Lh), nt("ZoomConstantExpression", Ja), nt("CompoundExpression", fs, { omit: ["_evaluate"] });
        for (const c in Wo) Wo[c]._classRegistryKey || nt(`Expression_${c}`, Wo[c]);
        function Xh(c) {
          return c && typeof ArrayBuffer < "u" && (c instanceof ArrayBuffer || c.constructor && c.constructor.name === "ArrayBuffer");
        }
        function nc(c) {
          return c.$name || c.constructor._classRegistryKey;
        }
        function qh(c) {
          return !(function(n) {
            if (n === null || typeof n != "object") return !1;
            const l = nc(n);
            return !(!l || l === "Object");
          })(c) && (c == null || typeof c == "boolean" || typeof c == "number" || typeof c == "string" || c instanceof Boolean || c instanceof Number || c instanceof String || c instanceof Date || c instanceof RegExp || c instanceof Blob || c instanceof Error || Xh(c) || es(c) || ArrayBuffer.isView(c) || c instanceof ImageData);
        }
        function ea(c, n) {
          if (qh(c)) return (Xh(c) || es(c)) && n && n.push(c), ArrayBuffer.isView(c) && n && n.push(c.buffer), c instanceof ImageData && n && n.push(c.data.buffer), c;
          if (Array.isArray(c)) {
            const b = [];
            for (const v of c) b.push(ea(v, n));
            return b;
          }
          if (typeof c != "object") throw new Error("can't serialize object of type " + typeof c);
          const l = nc(c);
          if (!l) throw new Error(`can't serialize object of unregistered class ${c.constructor.name}`);
          if (!Fs[l]) throw new Error(`${l} is not registered.`);
          const { klass: f } = Fs[l], _ = f.serialize ? f.serialize(c, n) : {};
          if (f.serialize) {
            if (n && _ === n[n.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property");
          } else {
            for (const b in c) {
              if (!c.hasOwnProperty(b) || Fs[l].omit.indexOf(b) >= 0) continue;
              const v = c[b];
              _[b] = Fs[l].shallow.indexOf(b) >= 0 ? v : ea(v, n);
            }
            c instanceof Error && (_.message = c.message);
          }
          if (_.$name) throw new Error("$name property is reserved for worker serialization logic.");
          return l !== "Object" && (_.$name = l), _;
        }
        function To(c) {
          if (qh(c)) return c;
          if (Array.isArray(c)) return c.map(To);
          if (typeof c != "object") throw new Error("can't deserialize object of type " + typeof c);
          const n = nc(c) || "Object";
          if (!Fs[n]) throw new Error(`can't deserialize unregistered class ${n}`);
          const { klass: l } = Fs[n];
          if (!l) throw new Error(`can't deserialize unregistered class ${n}`);
          if (l.deserialize) return l.deserialize(c);
          const f = Object.create(l.prototype);
          for (const _ of Object.keys(c)) {
            if (_ === "$name") continue;
            const b = c[_];
            f[_] = Fs[n].shallow.indexOf(_) >= 0 ? b : To(b);
          }
          return f;
        }
        class oc {
          constructor() {
            this.first = !0;
          }
          update(n, l) {
            const f = Math.floor(n);
            return this.first ? (this.first = !1, this.lastIntegerZoom = f, this.lastIntegerZoomTime = 0, this.lastZoom = n, this.lastFloorZoom = f, !0) : (this.lastFloorZoom > f ? (this.lastIntegerZoom = f + 1, this.lastIntegerZoomTime = l) : this.lastFloorZoom < f && (this.lastIntegerZoom = f, this.lastIntegerZoomTime = l), n !== this.lastZoom && (this.lastZoom = n, this.lastFloorZoom = f, !0));
          }
        }
        const Lt = { "Latin-1 Supplement": (c) => c >= 128 && c <= 255, "Hangul Jamo": (c) => c >= 4352 && c <= 4607, Khmer: (c) => c >= 6016 && c <= 6143, "General Punctuation": (c) => c >= 8192 && c <= 8303, "Letterlike Symbols": (c) => c >= 8448 && c <= 8527, "Number Forms": (c) => c >= 8528 && c <= 8591, "Miscellaneous Technical": (c) => c >= 8960 && c <= 9215, "Control Pictures": (c) => c >= 9216 && c <= 9279, "Optical Character Recognition": (c) => c >= 9280 && c <= 9311, "Enclosed Alphanumerics": (c) => c >= 9312 && c <= 9471, "Geometric Shapes": (c) => c >= 9632 && c <= 9727, "Miscellaneous Symbols": (c) => c >= 9728 && c <= 9983, "Miscellaneous Symbols and Arrows": (c) => c >= 11008 && c <= 11263, "Ideographic Description Characters": (c) => c >= 12272 && c <= 12287, "CJK Symbols and Punctuation": (c) => c >= 12288 && c <= 12351, Hiragana: (c) => c >= 12352 && c <= 12447, Katakana: (c) => c >= 12448 && c <= 12543, Kanbun: (c) => c >= 12688 && c <= 12703, "CJK Strokes": (c) => c >= 12736 && c <= 12783, "Enclosed CJK Letters and Months": (c) => c >= 12800 && c <= 13055, "CJK Compatibility": (c) => c >= 13056 && c <= 13311, "Yijing Hexagram Symbols": (c) => c >= 19904 && c <= 19967, "CJK Unified Ideographs": (c) => c >= 19968 && c <= 40959, "Hangul Syllables": (c) => c >= 44032 && c <= 55215, "Private Use Area": (c) => c >= 57344 && c <= 63743, "Vertical Forms": (c) => c >= 65040 && c <= 65055, "CJK Compatibility Forms": (c) => c >= 65072 && c <= 65103, "Small Form Variants": (c) => c >= 65104 && c <= 65135, "Halfwidth and Fullwidth Forms": (c) => c >= 65280 && c <= 65519 };
        function ac(c) {
          for (const n of c) if (Kh(n.charCodeAt(0))) return !0;
          return !1;
        }
        function d_(c) {
          for (const n of c) if (!Xd(n.charCodeAt(0))) return !1;
          return !0;
        }
        function lc(c) {
          const n = c.map(((l) => {
            try {
              return new RegExp(`\\p{sc=${l}}`, "u").source;
            } catch {
              return null;
            }
          })).filter(((l) => l));
          return new RegExp(n.join("|"), "u");
        }
        const f_ = lc(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);
        function Xd(c) {
          return !f_.test(String.fromCodePoint(c));
        }
        const Zh = lc(["Bopo", "Hani", "Hira", "Kana", "Kits", "Nshu", "Tang", "Yiii"]);
        function Kh(c) {
          return !(c !== 746 && c !== 747 && (c < 4352 || !(Lt["CJK Compatibility Forms"](c) && !(c >= 65097 && c <= 65103) || Lt["CJK Compatibility"](c) || Lt["CJK Strokes"](c) || !(!Lt["CJK Symbols and Punctuation"](c) || c >= 12296 && c <= 12305 || c >= 12308 && c <= 12319 || c === 12336) || Lt["Enclosed CJK Letters and Months"](c) || Lt["Ideographic Description Characters"](c) || Lt.Kanbun(c) || Lt.Katakana(c) && c !== 12540 || !(!Lt["Halfwidth and Fullwidth Forms"](c) || c === 65288 || c === 65289 || c === 65293 || c >= 65306 && c <= 65310 || c === 65339 || c === 65341 || c === 65343 || c >= 65371 && c <= 65503 || c === 65507 || c >= 65512 && c <= 65519) || !(!Lt["Small Form Variants"](c) || c >= 65112 && c <= 65118 || c >= 65123 && c <= 65126) || Lt["Vertical Forms"](c) || Lt["Yijing Hexagram Symbols"](c) || new RegExp("\\p{sc=Cans}", "u").test(String.fromCodePoint(c)) || new RegExp("\\p{sc=Hang}", "u").test(String.fromCodePoint(c)) || Zh.test(String.fromCodePoint(c)))));
        }
        function qd(c) {
          return !(Kh(c) || (function(n) {
            return !!(Lt["Latin-1 Supplement"](n) && (n === 167 || n === 169 || n === 174 || n === 177 || n === 188 || n === 189 || n === 190 || n === 215 || n === 247) || Lt["General Punctuation"](n) && (n === 8214 || n === 8224 || n === 8225 || n === 8240 || n === 8241 || n === 8251 || n === 8252 || n === 8258 || n === 8263 || n === 8264 || n === 8265 || n === 8273) || Lt["Letterlike Symbols"](n) || Lt["Number Forms"](n) || Lt["Miscellaneous Technical"](n) && (n >= 8960 && n <= 8967 || n >= 8972 && n <= 8991 || n >= 8996 && n <= 9e3 || n === 9003 || n >= 9085 && n <= 9114 || n >= 9150 && n <= 9165 || n === 9167 || n >= 9169 && n <= 9179 || n >= 9186 && n <= 9215) || Lt["Control Pictures"](n) && n !== 9251 || Lt["Optical Character Recognition"](n) || Lt["Enclosed Alphanumerics"](n) || Lt["Geometric Shapes"](n) || Lt["Miscellaneous Symbols"](n) && !(n >= 9754 && n <= 9759) || Lt["Miscellaneous Symbols and Arrows"](n) && (n >= 11026 && n <= 11055 || n >= 11088 && n <= 11097 || n >= 11192 && n <= 11243) || Lt["CJK Symbols and Punctuation"](n) || Lt.Katakana(n) || Lt["Private Use Area"](n) || Lt["CJK Compatibility Forms"](n) || Lt["Small Form Variants"](n) || Lt["Halfwidth and Fullwidth Forms"](n) || n === 8734 || n === 8756 || n === 8757 || n >= 9984 && n <= 10087 || n >= 10102 && n <= 10131 || n === 65532 || n === 65533);
          })(c));
        }
        const Zd = lc(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);
        function Yh(c) {
          return Zd.test(String.fromCodePoint(c));
        }
        function Kd(c, n) {
          return !(!n && Yh(c) || c >= 2304 && c <= 3583 || c >= 3840 && c <= 4255 || Lt.Khmer(c));
        }
        function Yd(c) {
          for (const n of c) if (Yh(n.charCodeAt(0))) return !0;
          return !1;
        }
        const ks = new class {
          constructor() {
            this.TIMEOUT = 5e3, this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null, this.loadScriptResolve = () => {
            };
          }
          setState(c) {
            this.pluginStatus = c.pluginStatus, this.pluginURL = c.pluginURL;
          }
          getState() {
            return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL };
          }
          setMethods(c) {
            if (ks.isParsed()) throw new Error("RTL text plugin already registered.");
            this.applyArabicShaping = c.applyArabicShaping, this.processBidirectionalText = c.processBidirectionalText, this.processStyledBidirectionalText = c.processStyledBidirectionalText, this.loadScriptResolve();
          }
          isParsed() {
            return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null;
          }
          getRTLTextPluginStatus() {
            return this.pluginStatus;
          }
          syncState(c, n) {
            return a(this, void 0, void 0, (function* () {
              if (this.isParsed()) return this.getState();
              if (c.pluginStatus !== "loading") return this.setState(c), c;
              const l = c.pluginURL, f = new Promise(((b) => {
                this.loadScriptResolve = b;
              }));
              n(l);
              const _ = new Promise(((b) => setTimeout((() => b()), this.TIMEOUT)));
              if (yield Promise.race([f, _]), this.isParsed()) {
                const b = { pluginStatus: "loaded", pluginURL: l };
                return this.setState(b), b;
              }
              throw this.setState({ pluginStatus: "error", pluginURL: "" }), new Error(`RTL Text Plugin failed to import scripts from ${l}`);
            }));
          }
        }();
        class gi {
          constructor(n, l) {
            this.zoom = n, l ? (this.now = l.now || 0, this.fadeDuration = l.fadeDuration || 0, this.zoomHistory = l.zoomHistory || new oc(), this.transition = l.transition || {}, this.globalState = l.globalState || {}) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new oc(), this.transition = {}, this.globalState = {});
          }
          isSupportedScript(n) {
            return (function(l, f) {
              for (const _ of l) if (!Kd(_.charCodeAt(0), f)) return !1;
              return !0;
            })(n, ks.getRTLTextPluginStatus() === "loaded");
          }
          crossFadingFactor() {
            return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
          }
          getCrossfadeParameters() {
            const n = this.zoom, l = n - Math.floor(n), f = this.crossFadingFactor();
            return n > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: l + (1 - l) * f } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - f) * l };
          }
        }
        class ta {
          constructor(n, l) {
            this.property = n, this.value = l, this.expression = (function(f, _) {
              if (Ka(f)) return new Qa(f, _);
              if (Ql(f)) {
                const b = Fd(f, _);
                if (b.result === "error") throw new Error(b.value.map(((v) => `${v.key}: ${v.message}`)).join(", "));
                return b.value;
              }
              {
                let b = f;
                return _.type === "color" && typeof f == "string" ? b = mt.parse(f) : _.type !== "padding" || typeof f != "number" && !Array.isArray(f) ? _.type !== "numberArray" || typeof f != "number" && !Array.isArray(f) ? _.type !== "colorArray" || typeof f != "string" && !Array.isArray(f) ? _.type === "variableAnchorOffsetCollection" && Array.isArray(f) ? b = Ur.parse(f) : _.type === "projectionDefinition" && typeof f == "string" && (b = Cr.parse(f)) : b = Gi.parse(f) : b = Lr.parse(f) : b = or.parse(f), { globalStateRefs: /* @__PURE__ */ new Set(), kind: "constant", evaluate: () => b };
              }
            })(l === void 0 ? n.specification.default : l, n.specification);
          }
          isDataDriven() {
            return this.expression.kind === "source" || this.expression.kind === "composite";
          }
          getGlobalStateRefs() {
            return this.expression.globalStateRefs || /* @__PURE__ */ new Set();
          }
          possiblyEvaluate(n, l, f) {
            return this.property.possiblyEvaluate(this, n, l, f);
          }
        }
        class Jh {
          constructor(n) {
            this.property = n, this.value = new ta(n, void 0);
          }
          transitioned(n, l) {
            return new Qh(this.property, this.value, l, ji({}, n.transition, this.transition), n.now);
          }
          untransitioned() {
            return new Qh(this.property, this.value, null, {}, 0);
          }
        }
        class Jd {
          constructor(n) {
            this._properties = n, this._values = Object.create(n.defaultTransitionablePropertyValues);
          }
          getValue(n) {
            return Ji(this._values[n].value.value);
          }
          setValue(n, l) {
            Object.prototype.hasOwnProperty.call(this._values, n) || (this._values[n] = new Jh(this._values[n].property)), this._values[n].value = new ta(this._values[n].property, l === null ? void 0 : Ji(l));
          }
          getTransition(n) {
            return Ji(this._values[n].transition);
          }
          setTransition(n, l) {
            Object.prototype.hasOwnProperty.call(this._values, n) || (this._values[n] = new Jh(this._values[n].property)), this._values[n].transition = Ji(l) || void 0;
          }
          serialize() {
            const n = {};
            for (const l of Object.keys(this._values)) {
              const f = this.getValue(l);
              f !== void 0 && (n[l] = f);
              const _ = this.getTransition(l);
              _ !== void 0 && (n[`${l}-transition`] = _);
            }
            return n;
          }
          transitioned(n, l) {
            const f = new eu(this._properties);
            for (const _ of Object.keys(this._values)) f._values[_] = this._values[_].transitioned(n, l._values[_]);
            return f;
          }
          untransitioned() {
            const n = new eu(this._properties);
            for (const l of Object.keys(this._values)) n._values[l] = this._values[l].untransitioned();
            return n;
          }
        }
        class Qh {
          constructor(n, l, f, _, b) {
            this.property = n, this.value = l, this.begin = b + _.delay || 0, this.end = this.begin + _.duration || 0, n.specification.transition && (_.delay || _.duration) && (this.prior = f);
          }
          possiblyEvaluate(n, l, f) {
            const _ = n.now || 0, b = this.value.possiblyEvaluate(n, l, f), v = this.prior;
            if (v) {
              if (_ > this.end) return this.prior = null, b;
              if (this.value.isDataDriven()) return this.prior = null, b;
              if (_ < this.begin) return v.possiblyEvaluate(n, l, f);
              {
                const T = (_ - this.begin) / (this.end - this.begin);
                return this.property.interpolate(v.possiblyEvaluate(n, l, f), b, cs(T));
              }
            }
            return b;
          }
        }
        class eu {
          constructor(n) {
            this._properties = n, this._values = Object.create(n.defaultTransitioningPropertyValues);
          }
          possiblyEvaluate(n, l, f) {
            const _ = new cc(this._properties);
            for (const b of Object.keys(this._values)) _._values[b] = this._values[b].possiblyEvaluate(n, l, f);
            return _;
          }
          hasTransition() {
            for (const n of Object.keys(this._values)) if (this._values[n].prior) return !0;
            return !1;
          }
        }
        class Qd {
          constructor(n) {
            this._properties = n, this._values = Object.create(n.defaultPropertyValues);
          }
          hasValue(n) {
            return this._values[n].value !== void 0;
          }
          getValue(n) {
            return Ji(this._values[n].value);
          }
          setValue(n, l) {
            this._values[n] = new ta(this._values[n].property, l === null ? void 0 : Ji(l));
          }
          serialize() {
            const n = {};
            for (const l of Object.keys(this._values)) {
              const f = this.getValue(l);
              f !== void 0 && (n[l] = f);
            }
            return n;
          }
          possiblyEvaluate(n, l, f) {
            const _ = new cc(this._properties);
            for (const b of Object.keys(this._values)) _._values[b] = this._values[b].possiblyEvaluate(n, l, f);
            return _;
          }
        }
        class an {
          constructor(n, l, f) {
            this.property = n, this.value = l, this.parameters = f;
          }
          isConstant() {
            return this.value.kind === "constant";
          }
          constantOr(n) {
            return this.value.kind === "constant" ? this.value.value : n;
          }
          evaluate(n, l, f, _) {
            return this.property.evaluate(this.value, this.parameters, n, l, f, _);
          }
        }
        class cc {
          constructor(n) {
            this._properties = n, this._values = Object.create(n.defaultPossiblyEvaluatedValues);
          }
          get(n) {
            return this._values[n];
          }
        }
        class dt {
          constructor(n) {
            this.specification = n;
          }
          possiblyEvaluate(n, l) {
            if (n.isDataDriven()) throw new Error("Value should not be data driven");
            return n.expression.evaluate(l);
          }
          interpolate(n, l, f) {
            const _ = nn[this.specification.type];
            return _ ? _(n, l, f) : n;
          }
        }
        class yt {
          constructor(n, l) {
            this.specification = n, this.overrides = l;
          }
          possiblyEvaluate(n, l, f, _) {
            return new an(this, n.expression.kind === "constant" || n.expression.kind === "camera" ? { kind: "constant", value: n.expression.evaluate(l, null, {}, f, _) } : n.expression, l);
          }
          interpolate(n, l, f) {
            if (n.value.kind !== "constant" || l.value.kind !== "constant") return n;
            if (n.value.value === void 0 || l.value.value === void 0) return new an(this, { kind: "constant", value: void 0 }, n.parameters);
            const _ = nn[this.specification.type];
            if (_) {
              const b = _(n.value.value, l.value.value, f);
              return new an(this, { kind: "constant", value: b }, n.parameters);
            }
            return n;
          }
          evaluate(n, l, f, _, b, v) {
            return n.kind === "constant" ? n.value : n.evaluate(l, f, _, b, v);
          }
        }
        class hc extends yt {
          possiblyEvaluate(n, l, f, _) {
            if (n.value === void 0) return new an(this, { kind: "constant", value: void 0 }, l);
            if (n.expression.kind === "constant") {
              const b = n.expression.evaluate(l, null, {}, f, _), v = n.property.specification.type === "resolvedImage" && typeof b != "string" ? b.name : b, T = this._calculate(v, v, v, l);
              return new an(this, { kind: "constant", value: T }, l);
            }
            if (n.expression.kind === "camera") {
              const b = this._calculate(n.expression.evaluate({ zoom: l.zoom - 1 }), n.expression.evaluate({ zoom: l.zoom }), n.expression.evaluate({ zoom: l.zoom + 1 }), l);
              return new an(this, { kind: "constant", value: b }, l);
            }
            return new an(this, n.expression, l);
          }
          evaluate(n, l, f, _, b, v) {
            if (n.kind === "source") {
              const T = n.evaluate(l, f, _, b, v);
              return this._calculate(T, T, T, l);
            }
            return n.kind === "composite" ? this._calculate(n.evaluate({ zoom: Math.floor(l.zoom) - 1 }, f, _), n.evaluate({ zoom: Math.floor(l.zoom) }, f, _), n.evaluate({ zoom: Math.floor(l.zoom) + 1 }, f, _), l) : n.value;
          }
          _calculate(n, l, f, _) {
            return _.zoom > _.zoomHistory.lastIntegerZoom ? { from: n, to: l } : { from: f, to: l };
          }
          interpolate(n) {
            return n;
          }
        }
        class Gn {
          constructor(n) {
            this.specification = n;
          }
          possiblyEvaluate(n, l, f, _) {
            if (n.value !== void 0) {
              if (n.expression.kind === "constant") {
                const b = n.expression.evaluate(l, null, {}, f, _);
                return this._calculate(b, b, b, l);
              }
              return this._calculate(n.expression.evaluate(new gi(Math.floor(l.zoom - 1), l)), n.expression.evaluate(new gi(Math.floor(l.zoom), l)), n.expression.evaluate(new gi(Math.floor(l.zoom + 1), l)), l);
            }
          }
          _calculate(n, l, f, _) {
            return _.zoom > _.zoomHistory.lastIntegerZoom ? { from: n, to: l } : { from: f, to: l };
          }
          interpolate(n) {
            return n;
          }
        }
        class uc {
          constructor(n) {
            this.specification = n;
          }
          possiblyEvaluate(n, l, f, _) {
            return !!n.expression.evaluate(l, null, {}, f, _);
          }
          interpolate() {
            return !1;
          }
        }
        class zr {
          constructor(n) {
            this.properties = n, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            for (const l in n) {
              const f = n[l];
              f.specification.overridable && this.overridableProperties.push(l);
              const _ = this.defaultPropertyValues[l] = new ta(f, void 0), b = this.defaultTransitionablePropertyValues[l] = new Jh(f);
              this.defaultTransitioningPropertyValues[l] = b.untransitioned(), this.defaultPossiblyEvaluatedValues[l] = _.possiblyEvaluate({});
            }
          }
        }
        nt("DataDrivenProperty", yt), nt("DataConstantProperty", dt), nt("CrossFadedDataDrivenProperty", hc), nt("CrossFadedProperty", Gn), nt("ColorRampProperty", uc);
        const ef = "-transition";
        class _s extends lt {
          constructor(n, l) {
            if (super(), this.id = n.id, this.type = n.type, this._featureFilter = { filter: () => !0, needGeometry: !1, getGlobalStateRefs: () => /* @__PURE__ */ new Set() }, n.type !== "custom" && (this.metadata = n.metadata, this.minzoom = n.minzoom, this.maxzoom = n.maxzoom, n.type !== "background" && (this.source = n.source, this.sourceLayer = n["source-layer"], this.filter = n.filter, this._featureFilter = vo(n.filter)), l.layout && (this._unevaluatedLayout = new Qd(l.layout)), l.paint)) {
              this._transitionablePaint = new Jd(l.paint);
              for (const f in n.paint) this.setPaintProperty(f, n.paint[f], { validate: !1 });
              for (const f in n.layout) this.setLayoutProperty(f, n.layout[f], { validate: !1 });
              this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new cc(l.paint);
            }
          }
          setFilter(n) {
            this.filter = n, this._featureFilter = vo(n);
          }
          getCrossfadeParameters() {
            return this._crossfadeParameters;
          }
          getLayoutProperty(n) {
            return n === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(n);
          }
          getLayoutAffectingGlobalStateRefs() {
            const n = /* @__PURE__ */ new Set();
            if (this._unevaluatedLayout) for (const l in this._unevaluatedLayout._values) {
              const f = this._unevaluatedLayout._values[l];
              for (const _ of f.getGlobalStateRefs()) n.add(_);
            }
            for (const l of this._featureFilter.getGlobalStateRefs()) n.add(l);
            return n;
          }
          setLayoutProperty(n, l, f = {}) {
            l != null && this._validate(u_, `layers.${this.id}.layout.${n}`, n, l, f) || (n !== "visibility" ? this._unevaluatedLayout.setValue(n, l) : this.visibility = l);
          }
          getPaintProperty(n) {
            return n.endsWith(ef) ? this._transitionablePaint.getTransition(n.slice(0, -11)) : this._transitionablePaint.getValue(n);
          }
          setPaintProperty(n, l, f = {}) {
            if (l != null && this._validate(h_, `layers.${this.id}.paint.${n}`, n, l, f)) return !1;
            if (n.endsWith(ef)) return this._transitionablePaint.setTransition(n.slice(0, -11), l || void 0), !1;
            {
              const _ = this._transitionablePaint._values[n], b = _.property.specification["property-type"] === "cross-faded-data-driven", v = _.value.isDataDriven(), T = _.value;
              this._transitionablePaint.setValue(n, l), this._handleSpecialPaintPropertyUpdate(n);
              const A = this._transitionablePaint._values[n].value;
              return A.isDataDriven() || v || b || this._handleOverridablePaintPropertyUpdate(n, T, A);
            }
          }
          _handleSpecialPaintPropertyUpdate(n) {
          }
          _handleOverridablePaintPropertyUpdate(n, l, f) {
            return !1;
          }
          isHidden(n) {
            return !!(this.minzoom && n < this.minzoom) || !!(this.maxzoom && n >= this.maxzoom) || this.visibility === "none";
          }
          updateTransitions(n) {
            this._transitioningPaint = this._transitionablePaint.transitioned(n, this._transitioningPaint);
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition();
          }
          recalculate(n, l) {
            n.getCrossfadeParameters && (this._crossfadeParameters = n.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(n, void 0, l)), this.paint = this._transitioningPaint.possiblyEvaluate(n, void 0, l);
          }
          serialize() {
            const n = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
            return this.visibility && (n.layout = n.layout || {}, n.layout.visibility = this.visibility), ws(n, ((l, f) => !(l === void 0 || f === "layout" && !Object.keys(l).length || f === "paint" && !Object.keys(l).length)));
          }
          _validate(n, l, f, _, b = {}) {
            return (!b || b.validate !== !1) && sl(this, n.call(Qo, { key: l, layerType: this.type, objectKey: f, value: _, styleSpec: ve, style: { glyphs: !0, sprite: !0 } }));
          }
          is3D() {
            return !1;
          }
          isTileClipped() {
            return !1;
          }
          hasOffscreenPass() {
            return !1;
          }
          resize() {
          }
          isStateDependent() {
            for (const n in this.paint._values) {
              const l = this.paint.get(n);
              if (l instanceof an && Hn(l.property.specification) && (l.value.kind === "source" || l.value.kind === "composite") && l.value.isStateDependent) return !0;
            }
            return !1;
          }
        }
        const p_ = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
        class ol {
          constructor(n, l) {
            this._structArray = n, this._pos1 = l * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
          }
        }
        class ei {
          constructor() {
            this.isTransferred = !1, this.capacity = -1, this.resize(0);
          }
          static serialize(n, l) {
            return n._trim(), l && (n.isTransferred = !0, l.push(n.arrayBuffer)), { length: n.length, arrayBuffer: n.arrayBuffer };
          }
          static deserialize(n) {
            const l = Object.create(this.prototype);
            return l.arrayBuffer = n.arrayBuffer, l.length = n.length, l.capacity = n.arrayBuffer.byteLength / l.bytesPerElement, l._refreshViews(), l;
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
          }
          clear() {
            this.length = 0;
          }
          resize(n) {
            this.reserve(n), this.length = n;
          }
          reserve(n) {
            if (n > this.capacity) {
              this.capacity = Math.max(n, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              const l = this.uint8;
              this._refreshViews(), l && this.uint8.set(l);
            }
          }
          _refreshViews() {
            throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
          }
        }
        function Di(c, n = 1) {
          let l = 0, f = 0;
          return { members: c.map(((_) => {
            const b = p_[_.type].BYTES_PER_ELEMENT, v = l = dc(l, Math.max(n, b)), T = _.components || 1;
            return f = Math.max(f, b), l += b * T, { name: _.name, type: _.type, components: T, offset: v };
          })), size: dc(l, Math.max(f, n)), alignment: n };
        }
        function dc(c, n) {
          return Math.ceil(c / n) * n;
        }
        class ia extends ei {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(n, l) {
            const f = this.length;
            return this.resize(f + 1), this.emplace(f, n, l);
          }
          emplace(n, l, f) {
            const _ = 2 * n;
            return this.int16[_ + 0] = l, this.int16[_ + 1] = f, n;
          }
        }
        ia.prototype.bytesPerElement = 4, nt("StructArrayLayout2i4", ia);
        class ra extends ei {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(n, l, f) {
            const _ = this.length;
            return this.resize(_ + 1), this.emplace(_, n, l, f);
          }
          emplace(n, l, f, _) {
            const b = 3 * n;
            return this.int16[b + 0] = l, this.int16[b + 1] = f, this.int16[b + 2] = _, n;
          }
        }
        ra.prototype.bytesPerElement = 6, nt("StructArrayLayout3i6", ra);
        class tu extends ei {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(n, l, f, _) {
            const b = this.length;
            return this.resize(b + 1), this.emplace(b, n, l, f, _);
          }
          emplace(n, l, f, _, b) {
            const v = 4 * n;
            return this.int16[v + 0] = l, this.int16[v + 1] = f, this.int16[v + 2] = _, this.int16[v + 3] = b, n;
          }
        }
        tu.prototype.bytesPerElement = 8, nt("StructArrayLayout4i8", tu);
        class sa extends ei {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(n, l, f, _, b, v) {
            const T = this.length;
            return this.resize(T + 1), this.emplace(T, n, l, f, _, b, v);
          }
          emplace(n, l, f, _, b, v, T) {
            const A = 6 * n;
            return this.int16[A + 0] = l, this.int16[A + 1] = f, this.int16[A + 2] = _, this.int16[A + 3] = b, this.int16[A + 4] = v, this.int16[A + 5] = T, n;
          }
        }
        sa.prototype.bytesPerElement = 12, nt("StructArrayLayout2i4i12", sa);
        class Ao extends ei {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(n, l, f, _, b, v) {
            const T = this.length;
            return this.resize(T + 1), this.emplace(T, n, l, f, _, b, v);
          }
          emplace(n, l, f, _, b, v, T) {
            const A = 4 * n, I = 8 * n;
            return this.int16[A + 0] = l, this.int16[A + 1] = f, this.uint8[I + 4] = _, this.uint8[I + 5] = b, this.uint8[I + 6] = v, this.uint8[I + 7] = T, n;
          }
        }
        Ao.prototype.bytesPerElement = 8, nt("StructArrayLayout2i4ub8", Ao);
        class al extends ei {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(n, l) {
            const f = this.length;
            return this.resize(f + 1), this.emplace(f, n, l);
          }
          emplace(n, l, f) {
            const _ = 2 * n;
            return this.float32[_ + 0] = l, this.float32[_ + 1] = f, n;
          }
        }
        al.prototype.bytesPerElement = 8, nt("StructArrayLayout2f8", al);
        class fc extends ei {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(n, l, f, _, b, v, T, A, I, P) {
            const D = this.length;
            return this.resize(D + 1), this.emplace(D, n, l, f, _, b, v, T, A, I, P);
          }
          emplace(n, l, f, _, b, v, T, A, I, P, D) {
            const U = 10 * n;
            return this.uint16[U + 0] = l, this.uint16[U + 1] = f, this.uint16[U + 2] = _, this.uint16[U + 3] = b, this.uint16[U + 4] = v, this.uint16[U + 5] = T, this.uint16[U + 6] = A, this.uint16[U + 7] = I, this.uint16[U + 8] = P, this.uint16[U + 9] = D, n;
          }
        }
        fc.prototype.bytesPerElement = 20, nt("StructArrayLayout10ui20", fc);
        class Eo extends ei {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(n, l, f, _, b, v, T, A, I, P, D, U) {
            const V = this.length;
            return this.resize(V + 1), this.emplace(V, n, l, f, _, b, v, T, A, I, P, D, U);
          }
          emplace(n, l, f, _, b, v, T, A, I, P, D, U, V) {
            const j = 12 * n;
            return this.int16[j + 0] = l, this.int16[j + 1] = f, this.int16[j + 2] = _, this.int16[j + 3] = b, this.uint16[j + 4] = v, this.uint16[j + 5] = T, this.uint16[j + 6] = A, this.uint16[j + 7] = I, this.int16[j + 8] = P, this.int16[j + 9] = D, this.int16[j + 10] = U, this.int16[j + 11] = V, n;
          }
        }
        Eo.prototype.bytesPerElement = 24, nt("StructArrayLayout4i4ui4i24", Eo);
        class iu extends ei {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(n, l, f) {
            const _ = this.length;
            return this.resize(_ + 1), this.emplace(_, n, l, f);
          }
          emplace(n, l, f, _) {
            const b = 3 * n;
            return this.float32[b + 0] = l, this.float32[b + 1] = f, this.float32[b + 2] = _, n;
          }
        }
        iu.prototype.bytesPerElement = 12, nt("StructArrayLayout3f12", iu);
        class ru extends ei {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(n) {
            const l = this.length;
            return this.resize(l + 1), this.emplace(l, n);
          }
          emplace(n, l) {
            return this.uint32[1 * n + 0] = l, n;
          }
        }
        ru.prototype.bytesPerElement = 4, nt("StructArrayLayout1ul4", ru);
        class pc extends ei {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(n, l, f, _, b, v, T, A, I) {
            const P = this.length;
            return this.resize(P + 1), this.emplace(P, n, l, f, _, b, v, T, A, I);
          }
          emplace(n, l, f, _, b, v, T, A, I, P) {
            const D = 10 * n, U = 5 * n;
            return this.int16[D + 0] = l, this.int16[D + 1] = f, this.int16[D + 2] = _, this.int16[D + 3] = b, this.int16[D + 4] = v, this.int16[D + 5] = T, this.uint32[U + 3] = A, this.uint16[D + 8] = I, this.uint16[D + 9] = P, n;
          }
        }
        pc.prototype.bytesPerElement = 20, nt("StructArrayLayout6i1ul2ui20", pc);
        class su extends ei {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(n, l, f, _, b, v) {
            const T = this.length;
            return this.resize(T + 1), this.emplace(T, n, l, f, _, b, v);
          }
          emplace(n, l, f, _, b, v, T) {
            const A = 6 * n;
            return this.int16[A + 0] = l, this.int16[A + 1] = f, this.int16[A + 2] = _, this.int16[A + 3] = b, this.int16[A + 4] = v, this.int16[A + 5] = T, n;
          }
        }
        su.prototype.bytesPerElement = 12, nt("StructArrayLayout2i2i2i12", su);
        class m extends ei {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(n, l, f, _, b) {
            const v = this.length;
            return this.resize(v + 1), this.emplace(v, n, l, f, _, b);
          }
          emplace(n, l, f, _, b, v) {
            const T = 4 * n, A = 8 * n;
            return this.float32[T + 0] = l, this.float32[T + 1] = f, this.float32[T + 2] = _, this.int16[A + 6] = b, this.int16[A + 7] = v, n;
          }
        }
        m.prototype.bytesPerElement = 16, nt("StructArrayLayout2f1f2i16", m);
        class r extends ei {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(n, l, f, _, b, v) {
            const T = this.length;
            return this.resize(T + 1), this.emplace(T, n, l, f, _, b, v);
          }
          emplace(n, l, f, _, b, v, T) {
            const A = 16 * n, I = 4 * n, P = 8 * n;
            return this.uint8[A + 0] = l, this.uint8[A + 1] = f, this.float32[I + 1] = _, this.float32[I + 2] = b, this.int16[P + 6] = v, this.int16[P + 7] = T, n;
          }
        }
        r.prototype.bytesPerElement = 16, nt("StructArrayLayout2ub2f2i16", r);
        class h extends ei {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(n, l, f) {
            const _ = this.length;
            return this.resize(_ + 1), this.emplace(_, n, l, f);
          }
          emplace(n, l, f, _) {
            const b = 3 * n;
            return this.uint16[b + 0] = l, this.uint16[b + 1] = f, this.uint16[b + 2] = _, n;
          }
        }
        h.prototype.bytesPerElement = 6, nt("StructArrayLayout3ui6", h);
        class p extends ei {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(n, l, f, _, b, v, T, A, I, P, D, U, V, j, G, Z, te) {
            const me = this.length;
            return this.resize(me + 1), this.emplace(me, n, l, f, _, b, v, T, A, I, P, D, U, V, j, G, Z, te);
          }
          emplace(n, l, f, _, b, v, T, A, I, P, D, U, V, j, G, Z, te, me) {
            const ce = 24 * n, de = 12 * n, Re = 48 * n;
            return this.int16[ce + 0] = l, this.int16[ce + 1] = f, this.uint16[ce + 2] = _, this.uint16[ce + 3] = b, this.uint32[de + 2] = v, this.uint32[de + 3] = T, this.uint32[de + 4] = A, this.uint16[ce + 10] = I, this.uint16[ce + 11] = P, this.uint16[ce + 12] = D, this.float32[de + 7] = U, this.float32[de + 8] = V, this.uint8[Re + 36] = j, this.uint8[Re + 37] = G, this.uint8[Re + 38] = Z, this.uint32[de + 10] = te, this.int16[ce + 22] = me, n;
          }
        }
        p.prototype.bytesPerElement = 48, nt("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", p);
        class g extends ei {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(n, l, f, _, b, v, T, A, I, P, D, U, V, j, G, Z, te, me, ce, de, Re, ke, je, it, Xe, Qe, pt, Ye) {
            const et = this.length;
            return this.resize(et + 1), this.emplace(et, n, l, f, _, b, v, T, A, I, P, D, U, V, j, G, Z, te, me, ce, de, Re, ke, je, it, Xe, Qe, pt, Ye);
          }
          emplace(n, l, f, _, b, v, T, A, I, P, D, U, V, j, G, Z, te, me, ce, de, Re, ke, je, it, Xe, Qe, pt, Ye, et) {
            const Ue = 32 * n, xt = 16 * n;
            return this.int16[Ue + 0] = l, this.int16[Ue + 1] = f, this.int16[Ue + 2] = _, this.int16[Ue + 3] = b, this.int16[Ue + 4] = v, this.int16[Ue + 5] = T, this.int16[Ue + 6] = A, this.int16[Ue + 7] = I, this.uint16[Ue + 8] = P, this.uint16[Ue + 9] = D, this.uint16[Ue + 10] = U, this.uint16[Ue + 11] = V, this.uint16[Ue + 12] = j, this.uint16[Ue + 13] = G, this.uint16[Ue + 14] = Z, this.uint16[Ue + 15] = te, this.uint16[Ue + 16] = me, this.uint16[Ue + 17] = ce, this.uint16[Ue + 18] = de, this.uint16[Ue + 19] = Re, this.uint16[Ue + 20] = ke, this.uint16[Ue + 21] = je, this.uint16[Ue + 22] = it, this.uint32[xt + 12] = Xe, this.float32[xt + 13] = Qe, this.float32[xt + 14] = pt, this.uint16[Ue + 30] = Ye, this.uint16[Ue + 31] = et, n;
          }
        }
        g.prototype.bytesPerElement = 64, nt("StructArrayLayout8i15ui1ul2f2ui64", g);
        class y extends ei {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(n) {
            const l = this.length;
            return this.resize(l + 1), this.emplace(l, n);
          }
          emplace(n, l) {
            return this.float32[1 * n + 0] = l, n;
          }
        }
        y.prototype.bytesPerElement = 4, nt("StructArrayLayout1f4", y);
        class x extends ei {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(n, l, f) {
            const _ = this.length;
            return this.resize(_ + 1), this.emplace(_, n, l, f);
          }
          emplace(n, l, f, _) {
            const b = 3 * n;
            return this.uint16[6 * n + 0] = l, this.float32[b + 1] = f, this.float32[b + 2] = _, n;
          }
        }
        x.prototype.bytesPerElement = 12, nt("StructArrayLayout1ui2f12", x);
        class E extends ei {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(n, l, f) {
            const _ = this.length;
            return this.resize(_ + 1), this.emplace(_, n, l, f);
          }
          emplace(n, l, f, _) {
            const b = 4 * n;
            return this.uint32[2 * n + 0] = l, this.uint16[b + 2] = f, this.uint16[b + 3] = _, n;
          }
        }
        E.prototype.bytesPerElement = 8, nt("StructArrayLayout1ul2ui8", E);
        class C extends ei {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(n, l) {
            const f = this.length;
            return this.resize(f + 1), this.emplace(f, n, l);
          }
          emplace(n, l, f) {
            const _ = 2 * n;
            return this.uint16[_ + 0] = l, this.uint16[_ + 1] = f, n;
          }
        }
        C.prototype.bytesPerElement = 4, nt("StructArrayLayout2ui4", C);
        class R extends ei {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(n) {
            const l = this.length;
            return this.resize(l + 1), this.emplace(l, n);
          }
          emplace(n, l) {
            return this.uint16[1 * n + 0] = l, n;
          }
        }
        R.prototype.bytesPerElement = 2, nt("StructArrayLayout1ui2", R);
        class B extends ei {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(n, l, f, _) {
            const b = this.length;
            return this.resize(b + 1), this.emplace(b, n, l, f, _);
          }
          emplace(n, l, f, _, b) {
            const v = 4 * n;
            return this.float32[v + 0] = l, this.float32[v + 1] = f, this.float32[v + 2] = _, this.float32[v + 3] = b, n;
          }
        }
        B.prototype.bytesPerElement = 16, nt("StructArrayLayout4f16", B);
        class k extends ol {
          get anchorPointX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorPointY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get x1() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get y1() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get x2() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get y2() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get anchorPoint() {
            return new w(this.anchorPointX, this.anchorPointY);
          }
        }
        k.prototype.size = 20;
        class O extends pc {
          get(n) {
            return new k(this, n);
          }
        }
        nt("CollisionBoxArray", O);
        class z extends ol {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 3];
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 2];
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 4];
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 7];
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 8];
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 36];
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 37];
          }
          set placedOrientation(n) {
            this._structArray.uint8[this._pos1 + 37] = n;
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 38];
          }
          set hidden(n) {
            this._structArray.uint8[this._pos1 + 38] = n;
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 10];
          }
          set crossTileID(n) {
            this._structArray.uint32[this._pos4 + 10] = n;
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 22];
          }
        }
        z.prototype.size = 48;
        class H extends p {
          get(n) {
            return new z(this, n);
          }
        }
        nt("PlacedSymbolArray", H);
        class Y extends ol {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 6];
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 7];
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 13];
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 14];
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 15];
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 16];
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 17];
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 19];
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 20];
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 21];
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 22];
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 12];
          }
          set crossTileID(n) {
            this._structArray.uint32[this._pos4 + 12] = n;
          }
          get textBoxScale() {
            return this._structArray.float32[this._pos4 + 13];
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 14];
          }
          get textAnchorOffsetStartIndex() {
            return this._structArray.uint16[this._pos2 + 30];
          }
          get textAnchorOffsetEndIndex() {
            return this._structArray.uint16[this._pos2 + 31];
          }
        }
        Y.prototype.size = 64;
        class K extends g {
          get(n) {
            return new Y(this, n);
          }
        }
        nt("SymbolInstanceArray", K);
        class J extends y {
          getoffsetX(n) {
            return this.float32[1 * n + 0];
          }
        }
        nt("GlyphOffsetArray", J);
        class ie extends ra {
          getx(n) {
            return this.int16[3 * n + 0];
          }
          gety(n) {
            return this.int16[3 * n + 1];
          }
          gettileUnitDistanceFromAnchor(n) {
            return this.int16[3 * n + 2];
          }
        }
        nt("SymbolLineVertexArray", ie);
        class le extends ol {
          get textAnchor() {
            return this._structArray.uint16[this._pos2 + 0];
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 1];
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 2];
          }
        }
        le.prototype.size = 12;
        class se extends x {
          get(n) {
            return new le(this, n);
          }
        }
        nt("TextAnchorOffsetArray", se);
        class he extends ol {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3];
          }
        }
        he.prototype.size = 8;
        class fe extends E {
          get(n) {
            return new he(this, n);
          }
        }
        nt("FeatureIndexArray", fe);
        class oe extends ia {
        }
        class be extends ia {
        }
        class Fe extends ia {
        }
        class Ie extends sa {
        }
        class Me extends Ao {
        }
        class Oe extends al {
        }
        class We extends fc {
        }
        class qe extends Eo {
        }
        class Ve extends iu {
        }
        class ht extends ru {
        }
        class Bt extends su {
        }
        class Wt extends r {
        }
        class ti extends h {
        }
        class Yt extends C {
        }
        const vi = Di([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Si } = vi;
        class Rt {
          constructor(n = []) {
            this._forceNewSegmentOnNextPrepare = !1, this.segments = n;
          }
          prepareSegment(n, l, f, _) {
            const b = this.segments[this.segments.length - 1];
            return n > Rt.MAX_VERTEX_ARRAY_LENGTH && ai(`Max vertices per segment is ${Rt.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${n}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${Rt.MAX_VERTEX_ARRAY_LENGTH} vertices.`), this._forceNewSegmentOnNextPrepare || !b || b.vertexLength + n > Rt.MAX_VERTEX_ARRAY_LENGTH || b.sortKey !== _ ? this.createNewSegment(l, f, _) : b;
          }
          createNewSegment(n, l, f) {
            const _ = { vertexOffset: n.length, primitiveOffset: l.length, vertexLength: 0, primitiveLength: 0, vaos: {} };
            return f !== void 0 && (_.sortKey = f), this._forceNewSegmentOnNextPrepare = !1, this.segments.push(_), _;
          }
          getOrCreateLatestSegment(n, l, f) {
            return this.prepareSegment(0, n, l, f);
          }
          forceNewSegmentOnNextPrepare() {
            this._forceNewSegmentOnNextPrepare = !0;
          }
          get() {
            return this.segments;
          }
          destroy() {
            for (const n of this.segments) for (const l in n.vaos) n.vaos[l].destroy();
          }
          static simpleSegment(n, l, f, _) {
            return new Rt([{ vertexOffset: n, primitiveOffset: l, vertexLength: f, primitiveLength: _, vaos: {}, sortKey: 0 }]);
          }
        }
        function ii(c, n) {
          return 256 * (c = Er(Math.floor(c), 0, 255)) + Er(Math.floor(n), 0, 255);
        }
        Rt.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, nt("SegmentVector", Rt);
        const Wi = Di([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]);
        var Qi, lr, Vr, Ns = { exports: {} }, Wn = { exports: {} }, Xn = { exports: {} }, na = (function() {
          if (Vr) return Ns.exports;
          Vr = 1;
          var c = (Qi || (Qi = 1, Wn.exports = function(l, f) {
            var _, b, v, T, A, I, P, D;
            for (b = l.length - (_ = 3 & l.length), v = f, A = 3432918353, I = 461845907, D = 0; D < b; ) P = 255 & l.charCodeAt(D) | (255 & l.charCodeAt(++D)) << 8 | (255 & l.charCodeAt(++D)) << 16 | (255 & l.charCodeAt(++D)) << 24, ++D, v = 27492 + (65535 & (T = 5 * (65535 & (v = (v ^= P = (65535 & (P = (P = (65535 & P) * A + (((P >>> 16) * A & 65535) << 16) & 4294967295) << 15 | P >>> 17)) * I + (((P >>> 16) * I & 65535) << 16) & 4294967295) << 13 | v >>> 19)) + ((5 * (v >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (T >>> 16) & 65535) << 16);
            switch (P = 0, _) {
              case 3:
                P ^= (255 & l.charCodeAt(D + 2)) << 16;
              case 2:
                P ^= (255 & l.charCodeAt(D + 1)) << 8;
              case 1:
                v ^= P = (65535 & (P = (P = (65535 & (P ^= 255 & l.charCodeAt(D))) * A + (((P >>> 16) * A & 65535) << 16) & 4294967295) << 15 | P >>> 17)) * I + (((P >>> 16) * I & 65535) << 16) & 4294967295;
            }
            return v ^= l.length, v = 2246822507 * (65535 & (v ^= v >>> 16)) + ((2246822507 * (v >>> 16) & 65535) << 16) & 4294967295, v = 3266489909 * (65535 & (v ^= v >>> 13)) + ((3266489909 * (v >>> 16) & 65535) << 16) & 4294967295, (v ^= v >>> 16) >>> 0;
          }), Wn.exports), n = (lr || (lr = 1, Xn.exports = function(l, f) {
            for (var _, b = l.length, v = f ^ b, T = 0; b >= 4; ) _ = 1540483477 * (65535 & (_ = 255 & l.charCodeAt(T) | (255 & l.charCodeAt(++T)) << 8 | (255 & l.charCodeAt(++T)) << 16 | (255 & l.charCodeAt(++T)) << 24)) + ((1540483477 * (_ >>> 16) & 65535) << 16), v = 1540483477 * (65535 & v) + ((1540483477 * (v >>> 16) & 65535) << 16) ^ (_ = 1540483477 * (65535 & (_ ^= _ >>> 24)) + ((1540483477 * (_ >>> 16) & 65535) << 16)), b -= 4, ++T;
            switch (b) {
              case 3:
                v ^= (255 & l.charCodeAt(T + 2)) << 16;
              case 2:
                v ^= (255 & l.charCodeAt(T + 1)) << 8;
              case 1:
                v = 1540483477 * (65535 & (v ^= 255 & l.charCodeAt(T))) + ((1540483477 * (v >>> 16) & 65535) << 16);
            }
            return v = 1540483477 * (65535 & (v ^= v >>> 13)) + ((1540483477 * (v >>> 16) & 65535) << 16), (v ^= v >>> 15) >>> 0;
          }), Xn.exports);
          return Ns.exports = c, Ns.exports.murmur3 = c, Ns.exports.murmur2 = n, Ns.exports;
        })(), oa = S(na);
        class So {
          constructor() {
            this.ids = [], this.positions = [], this.indexed = !1;
          }
          add(n, l, f, _) {
            this.ids.push(Co(n)), this.positions.push(l, f, _);
          }
          getPositions(n) {
            if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
            const l = Co(n);
            let f = 0, _ = this.ids.length - 1;
            for (; f < _; ) {
              const v = f + _ >> 1;
              this.ids[v] >= l ? _ = v : f = v + 1;
            }
            const b = [];
            for (; this.ids[f] === l; ) b.push({ index: this.positions[3 * f], start: this.positions[3 * f + 1], end: this.positions[3 * f + 2] }), f++;
            return b;
          }
          static serialize(n, l) {
            const f = new Float64Array(n.ids), _ = new Uint32Array(n.positions);
            return qr(f, _, 0, f.length - 1), l && l.push(f.buffer, _.buffer), { ids: f, positions: _ };
          }
          static deserialize(n) {
            const l = new So();
            return l.ids = n.ids, l.positions = n.positions, l.indexed = !0, l;
          }
        }
        function Co(c) {
          const n = +c;
          return !isNaN(n) && n <= Number.MAX_SAFE_INTEGER ? n : oa(String(c));
        }
        function qr(c, n, l, f) {
          for (; l < f; ) {
            const _ = c[l + f >> 1];
            let b = l - 1, v = f + 1;
            for (; ; ) {
              do
                b++;
              while (c[b] < _);
              do
                v--;
              while (c[v] > _);
              if (b >= v) break;
              Ls(c, b, v), Ls(n, 3 * b, 3 * v), Ls(n, 3 * b + 1, 3 * v + 1), Ls(n, 3 * b + 2, 3 * v + 2);
            }
            v - l < f - v ? (qr(c, n, l, v), l = v + 1) : (qr(c, n, v + 1, f), f = v);
          }
        }
        function Ls(c, n, l) {
          const f = c[n];
          c[n] = c[l], c[l] = f;
        }
        nt("FeaturePositionMap", So);
        class jr {
          constructor(n, l) {
            this.gl = n.gl, this.location = l;
          }
        }
        class qn extends jr {
          constructor(n, l) {
            super(n, l), this.current = 0;
          }
          set(n) {
            this.current !== n && (this.current = n, this.gl.uniform1f(this.location, n));
          }
        }
        class Xi extends jr {
          constructor(n, l) {
            super(n, l), this.current = [0, 0, 0, 0];
          }
          set(n) {
            n[0] === this.current[0] && n[1] === this.current[1] && n[2] === this.current[2] && n[3] === this.current[3] || (this.current = n, this.gl.uniform4f(this.location, n[0], n[1], n[2], n[3]));
          }
        }
        class er extends jr {
          constructor(n, l) {
            super(n, l), this.current = mt.transparent;
          }
          set(n) {
            n.r === this.current.r && n.g === this.current.g && n.b === this.current.b && n.a === this.current.a || (this.current = n, this.gl.uniform4f(this.location, n.r, n.g, n.b, n.a));
          }
        }
        const gs = new Float32Array(16);
        function qi(c) {
          return [ii(255 * c.r, 255 * c.g), ii(255 * c.b, 255 * c.a)];
        }
        class ll {
          constructor(n, l, f) {
            this.value = n, this.uniformNames = l.map(((_) => `u_${_}`)), this.type = f;
          }
          setUniform(n, l, f) {
            n.set(f.constantOr(this.value));
          }
          getBinding(n, l, f) {
            return this.type === "color" ? new er(n, l) : new qn(n, l);
          }
        }
        class aa {
          constructor(n, l) {
            this.uniformNames = l.map(((f) => `u_${f}`)), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
          }
          setConstantPatternPositions(n, l) {
            this.pixelRatioFrom = l.pixelRatio, this.pixelRatioTo = n.pixelRatio, this.patternFrom = l.tlbr, this.patternTo = n.tlbr;
          }
          setUniform(n, l, f, _) {
            const b = _ === "u_pattern_to" ? this.patternTo : _ === "u_pattern_from" ? this.patternFrom : _ === "u_pixel_ratio_to" ? this.pixelRatioTo : _ === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
            b && n.set(b);
          }
          getBinding(n, l, f) {
            return f.substr(0, 9) === "u_pattern" ? new Xi(n, l) : new qn(n, l);
          }
        }
        class vn {
          constructor(n, l, f, _) {
            this.expression = n, this.type = f, this.maxValue = 0, this.paintVertexAttributes = l.map(((b) => ({ name: `a_${b}`, type: "Float32", components: f === "color" ? 2 : 1, offset: 0 }))), this.paintVertexArray = new _();
          }
          populatePaintArray(n, l, f, _, b) {
            const v = this.paintVertexArray.length, T = this.expression.evaluate(new gi(0), l, {}, _, [], b);
            this.paintVertexArray.resize(n), this._setPaintValue(v, n, T);
          }
          updatePaintArray(n, l, f, _) {
            const b = this.expression.evaluate({ zoom: 0 }, f, _);
            this._setPaintValue(n, l, b);
          }
          _setPaintValue(n, l, f) {
            if (this.type === "color") {
              const _ = qi(f);
              for (let b = n; b < l; b++) this.paintVertexArray.emplace(b, _[0], _[1]);
            } else {
              for (let _ = n; _ < l; _++) this.paintVertexArray.emplace(_, f);
              this.maxValue = Math.max(this.maxValue, Math.abs(f));
            }
          }
          upload(n) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = n.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
        }
        class Us {
          constructor(n, l, f, _, b, v) {
            this.expression = n, this.uniformNames = l.map(((T) => `u_${T}_t`)), this.type = f, this.useIntegerZoom = _, this.zoom = b, this.maxValue = 0, this.paintVertexAttributes = l.map(((T) => ({ name: `a_${T}`, type: "Float32", components: f === "color" ? 4 : 2, offset: 0 }))), this.paintVertexArray = new v();
          }
          populatePaintArray(n, l, f, _, b) {
            const v = this.expression.evaluate(new gi(this.zoom), l, {}, _, [], b), T = this.expression.evaluate(new gi(this.zoom + 1), l, {}, _, [], b), A = this.paintVertexArray.length;
            this.paintVertexArray.resize(n), this._setPaintValue(A, n, v, T);
          }
          updatePaintArray(n, l, f, _) {
            const b = this.expression.evaluate({ zoom: this.zoom }, f, _), v = this.expression.evaluate({ zoom: this.zoom + 1 }, f, _);
            this._setPaintValue(n, l, b, v);
          }
          _setPaintValue(n, l, f, _) {
            if (this.type === "color") {
              const b = qi(f), v = qi(_);
              for (let T = n; T < l; T++) this.paintVertexArray.emplace(T, b[0], b[1], v[0], v[1]);
            } else {
              for (let b = n; b < l; b++) this.paintVertexArray.emplace(b, f, _);
              this.maxValue = Math.max(this.maxValue, Math.abs(f), Math.abs(_));
            }
          }
          upload(n) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = n.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
          setUniform(n, l) {
            const f = this.useIntegerZoom ? Math.floor(l.zoom) : l.zoom, _ = Er(this.expression.interpolationFactor(f, this.zoom, this.zoom + 1), 0, 1);
            n.set(_);
          }
          getBinding(n, l, f) {
            return new qn(n, l);
          }
        }
        class Zn {
          constructor(n, l, f, _, b, v) {
            this.expression = n, this.type = l, this.useIntegerZoom = f, this.zoom = _, this.layerId = v, this.zoomInPaintVertexArray = new b(), this.zoomOutPaintVertexArray = new b();
          }
          populatePaintArray(n, l, f) {
            const _ = this.zoomInPaintVertexArray.length;
            this.zoomInPaintVertexArray.resize(n), this.zoomOutPaintVertexArray.resize(n), this._setPaintValues(_, n, l.patterns && l.patterns[this.layerId], f);
          }
          updatePaintArray(n, l, f, _, b) {
            this._setPaintValues(n, l, f.patterns && f.patterns[this.layerId], b);
          }
          _setPaintValues(n, l, f, _) {
            if (!_ || !f) return;
            const { min: b, mid: v, max: T } = f, A = _[b], I = _[v], P = _[T];
            if (A && I && P) for (let D = n; D < l; D++) this.zoomInPaintVertexArray.emplace(D, I.tl[0], I.tl[1], I.br[0], I.br[1], A.tl[0], A.tl[1], A.br[0], A.br[1], I.pixelRatio, A.pixelRatio), this.zoomOutPaintVertexArray.emplace(D, I.tl[0], I.tl[1], I.br[0], I.br[1], P.tl[0], P.tl[1], P.br[0], P.br[1], I.pixelRatio, P.pixelRatio);
          }
          upload(n) {
            this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = n.createVertexBuffer(this.zoomInPaintVertexArray, Wi.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = n.createVertexBuffer(this.zoomOutPaintVertexArray, Wi.members, this.expression.isStateDependent));
          }
          destroy() {
            this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
          }
        }
        class tf {
          constructor(n, l, f) {
            this.binders = {}, this._buffers = [];
            const _ = [];
            for (const b in n.paint._values) {
              if (!f(b)) continue;
              const v = n.paint.get(b);
              if (!(v instanceof an && Hn(v.property.specification))) continue;
              const T = rf(b, n.type), A = v.value, I = v.property.specification.type, P = v.property.useIntegerZoom, D = v.property.specification["property-type"], U = D === "cross-faded" || D === "cross-faded-data-driven";
              if (A.kind === "constant") this.binders[b] = U ? new aa(A.value, T) : new ll(A.value, T, I), _.push(`/u_${b}`);
              else if (A.kind === "source" || U) {
                const V = nu(b, I, "source");
                this.binders[b] = U ? new Zn(A, I, P, l, V, n.id) : new vn(A, T, I, V), _.push(`/a_${b}`);
              } else {
                const V = nu(b, I, "composite");
                this.binders[b] = new Us(A, T, I, P, l, V), _.push(`/z_${b}`);
              }
            }
            this.cacheKey = _.sort().join("");
          }
          getMaxValue(n) {
            const l = this.binders[n];
            return l instanceof vn || l instanceof Us ? l.maxValue : 0;
          }
          populatePaintArrays(n, l, f, _, b) {
            for (const v in this.binders) {
              const T = this.binders[v];
              (T instanceof vn || T instanceof Us || T instanceof Zn) && T.populatePaintArray(n, l, f, _, b);
            }
          }
          setConstantPatternPositions(n, l) {
            for (const f in this.binders) {
              const _ = this.binders[f];
              _ instanceof aa && _.setConstantPatternPositions(n, l);
            }
          }
          updatePaintArrays(n, l, f, _, b) {
            let v = !1;
            for (const T in n) {
              const A = l.getPositions(T);
              for (const I of A) {
                const P = f.feature(I.index);
                for (const D in this.binders) {
                  const U = this.binders[D];
                  if ((U instanceof vn || U instanceof Us || U instanceof Zn) && U.expression.isStateDependent === !0) {
                    const V = _.paint.get(D);
                    U.expression = V.value, U.updatePaintArray(I.start, I.end, P, n[T], b), v = !0;
                  }
                }
              }
            }
            return v;
          }
          defines() {
            const n = [];
            for (const l in this.binders) {
              const f = this.binders[l];
              (f instanceof ll || f instanceof aa) && n.push(...f.uniformNames.map(((_) => `#define HAS_UNIFORM_${_}`)));
            }
            return n;
          }
          getBinderAttributes() {
            const n = [];
            for (const l in this.binders) {
              const f = this.binders[l];
              if (f instanceof vn || f instanceof Us) for (let _ = 0; _ < f.paintVertexAttributes.length; _++) n.push(f.paintVertexAttributes[_].name);
              else if (f instanceof Zn) for (let _ = 0; _ < Wi.members.length; _++) n.push(Wi.members[_].name);
            }
            return n;
          }
          getBinderUniforms() {
            const n = [];
            for (const l in this.binders) {
              const f = this.binders[l];
              if (f instanceof ll || f instanceof aa || f instanceof Us) for (const _ of f.uniformNames) n.push(_);
            }
            return n;
          }
          getPaintVertexBuffers() {
            return this._buffers;
          }
          getUniforms(n, l) {
            const f = [];
            for (const _ in this.binders) {
              const b = this.binders[_];
              if (b instanceof ll || b instanceof aa || b instanceof Us) {
                for (const v of b.uniformNames) if (l[v]) {
                  const T = b.getBinding(n, l[v], v);
                  f.push({ name: v, property: _, binding: T });
                }
              }
            }
            return f;
          }
          setUniforms(n, l, f, _) {
            for (const { name: b, property: v, binding: T } of l) this.binders[v].setUniform(T, _, f.get(v), b);
          }
          updatePaintBuffers(n) {
            this._buffers = [];
            for (const l in this.binders) {
              const f = this.binders[l];
              if (n && f instanceof Zn) {
                const _ = n.fromScale === 2 ? f.zoomInPaintVertexBuffer : f.zoomOutPaintVertexBuffer;
                _ && this._buffers.push(_);
              } else (f instanceof vn || f instanceof Us) && f.paintVertexBuffer && this._buffers.push(f.paintVertexBuffer);
            }
          }
          upload(n) {
            for (const l in this.binders) {
              const f = this.binders[l];
              (f instanceof vn || f instanceof Us || f instanceof Zn) && f.upload(n);
            }
            this.updatePaintBuffers();
          }
          destroy() {
            for (const n in this.binders) {
              const l = this.binders[n];
              (l instanceof vn || l instanceof Us || l instanceof Zn) && l.destroy();
            }
          }
        }
        class ns {
          constructor(n, l, f = () => !0) {
            this.programConfigurations = {};
            for (const _ of n) this.programConfigurations[_.id] = new tf(_, l, f);
            this.needsUpload = !1, this._featureMap = new So(), this._bufferOffset = 0;
          }
          populatePaintArrays(n, l, f, _, b, v) {
            for (const T in this.programConfigurations) this.programConfigurations[T].populatePaintArrays(n, l, _, b, v);
            l.id !== void 0 && this._featureMap.add(l.id, f, this._bufferOffset, n), this._bufferOffset = n, this.needsUpload = !0;
          }
          updatePaintArrays(n, l, f, _) {
            for (const b of f) this.needsUpload = this.programConfigurations[b.id].updatePaintArrays(n, this._featureMap, l, b, _) || this.needsUpload;
          }
          get(n) {
            return this.programConfigurations[n];
          }
          upload(n) {
            if (this.needsUpload) {
              for (const l in this.programConfigurations) this.programConfigurations[l].upload(n);
              this.needsUpload = !1;
            }
          }
          destroy() {
            for (const n in this.programConfigurations) this.programConfigurations[n].destroy();
          }
        }
        function rf(c, n) {
          return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[c] || [c.replace(`${n}-`, "").replace(/-/g, "_")];
        }
        function nu(c, n, l) {
          const f = { color: { source: al, composite: B }, number: { source: y, composite: al } }, _ = (function(b) {
            return { "line-pattern": { source: We, composite: We }, "fill-pattern": { source: We, composite: We }, "fill-extrusion-pattern": { source: We, composite: We } }[b];
          })(c);
          return _ && _[l] || f[n][l];
        }
        nt("ConstantBinder", ll), nt("CrossFadedConstantBinder", aa), nt("SourceExpressionBinder", vn), nt("CrossFadedCompositeBinder", Zn), nt("CompositeExpressionBinder", Us), nt("ProgramConfiguration", tf, { omit: ["_buffers"] }), nt("ProgramConfigurationSet", ns);
        const _c = Math.pow(2, 14) - 1, gc = -_c - 1;
        function Kn(c) {
          const n = Ht / c.extent, l = c.loadGeometry();
          for (let f = 0; f < l.length; f++) {
            const _ = l[f];
            for (let b = 0; b < _.length; b++) {
              const v = _[b], T = Math.round(v.x * n), A = Math.round(v.y * n);
              v.x = Er(T, gc, _c), v.y = Er(A, gc, _c), (T < v.x || T > v.x + 1 || A < v.y || A > v.y + 1) && ai("Geometry exceeds allowed extent, reduce your vector tile buffer size");
            }
          }
          return l;
        }
        function xn(c, n) {
          return { type: c.type, id: c.id, properties: c.properties, geometry: n ? Kn(c) : [] };
        }
        const rb = -32768;
        function _E(c, n, l, f, _) {
          c.emplaceBack(rb + 8 * n + f, rb + 8 * l + _);
        }
        class __ {
          constructor(n) {
            this.zoom = n.zoom, this.globalState = n.globalState, this.overscaling = n.overscaling, this.layers = n.layers, this.layerIds = this.layers.map(((l) => l.id)), this.index = n.index, this.hasPattern = !1, this.layoutVertexArray = new be(), this.indexArray = new ti(), this.segments = new Rt(), this.programConfigurations = new ns(n.layers, n.zoom), this.stateDependentLayerIds = this.layers.filter(((l) => l.isStateDependent())).map(((l) => l.id));
          }
          populate(n, l, f) {
            const _ = this.layers[0], b = [];
            let v = null, T = !1, A = _.type === "heatmap";
            if (_.type === "circle") {
              const P = _;
              v = P.layout.get("circle-sort-key"), T = !v.isConstant(), A = A || P.paint.get("circle-pitch-alignment") === "map";
            }
            const I = A ? l.subdivisionGranularity.circle : 1;
            for (const { feature: P, id: D, index: U, sourceLayerIndex: V } of n) {
              const j = this.layers[0]._featureFilter.needGeometry, G = xn(P, j);
              if (!this.layers[0]._featureFilter.filter(new gi(this.zoom, { globalState: this.globalState }), G, f)) continue;
              const Z = T ? v.evaluate(G, {}, f) : void 0, te = { id: D, properties: P.properties, type: P.type, sourceLayerIndex: V, index: U, geometry: j ? G.geometry : Kn(P), patterns: {}, sortKey: Z };
              b.push(te);
            }
            T && b.sort(((P, D) => P.sortKey - D.sortKey));
            for (const P of b) {
              const { geometry: D, index: U, sourceLayerIndex: V } = P, j = n[U].feature;
              this.addFeature(P, D, U, f, I), l.featureIndex.insert(j, D, U, V, this.index);
            }
          }
          update(n, l, f) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(n, l, this.stateDependentLayers, f);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(n) {
            this.uploaded || (this.layoutVertexBuffer = n.createVertexBuffer(this.layoutVertexArray, Si), this.indexBuffer = n.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(n), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          addFeature(n, l, f, _, b = 1) {
            let v;
            switch (b) {
              case 1:
                v = [0, 7];
                break;
              case 3:
                v = [0, 2, 5, 7];
                break;
              case 5:
                v = [0, 1, 3, 4, 6, 7];
                break;
              case 7:
                v = [0, 1, 2, 3, 4, 5, 6, 7];
                break;
              default:
                throw new Error(`Invalid circle bucket granularity: ${b}; valid values are 1, 3, 5, 7.`);
            }
            const T = v.length;
            for (const A of l) for (const I of A) {
              const P = I.x, D = I.y;
              if (P < 0 || P >= Ht || D < 0 || D >= Ht) continue;
              const U = this.segments.prepareSegment(T * T, this.layoutVertexArray, this.indexArray, n.sortKey), V = U.vertexLength;
              for (let j = 0; j < T; j++) for (let G = 0; G < T; G++) _E(this.layoutVertexArray, P, D, v[G], v[j]);
              for (let j = 0; j < T - 1; j++) for (let G = 0; G < T - 1; G++) {
                const Z = V + j * T + G, te = V + (j + 1) * T + G;
                this.indexArray.emplaceBack(Z, te + 1, Z + 1), this.indexArray.emplaceBack(Z, te, te + 1);
              }
              U.vertexLength += T * T, U.primitiveLength += (T - 1) * (T - 1) * 2;
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, n, f, {}, _);
          }
        }
        function sb(c, n) {
          for (let l = 0; l < c.length; l++) if (mc(n, c[l])) return !0;
          for (let l = 0; l < n.length; l++) if (mc(c, n[l])) return !0;
          return !!g_(c, n);
        }
        function gE(c, n, l) {
          return !!mc(c, n) || !!m_(n, c, l);
        }
        function nb(c, n) {
          if (c.length === 1) return ab(n, c[0]);
          for (let l = 0; l < n.length; l++) {
            const f = n[l];
            for (let _ = 0; _ < f.length; _++) if (mc(c, f[_])) return !0;
          }
          for (let l = 0; l < c.length; l++) if (ab(n, c[l])) return !0;
          for (let l = 0; l < n.length; l++) if (g_(c, n[l])) return !0;
          return !1;
        }
        function mE(c, n, l) {
          if (c.length > 1) {
            if (g_(c, n)) return !0;
            for (let f = 0; f < n.length; f++) if (m_(n[f], c, l)) return !0;
          }
          for (let f = 0; f < c.length; f++) if (m_(c[f], n, l)) return !0;
          return !1;
        }
        function g_(c, n) {
          if (c.length === 0 || n.length === 0) return !1;
          for (let l = 0; l < c.length - 1; l++) {
            const f = c[l], _ = c[l + 1];
            for (let b = 0; b < n.length - 1; b++) if (yE(f, _, n[b], n[b + 1])) return !0;
          }
          return !1;
        }
        function yE(c, n, l, f) {
          return mr(c, l, f) !== mr(n, l, f) && mr(c, n, l) !== mr(c, n, f);
        }
        function m_(c, n, l) {
          const f = l * l;
          if (n.length === 1) return c.distSqr(n[0]) < f;
          for (let _ = 1; _ < n.length; _++) if (ob(c, n[_ - 1], n[_]) < f) return !0;
          return !1;
        }
        function ob(c, n, l) {
          const f = n.distSqr(l);
          if (f === 0) return c.distSqr(n);
          const _ = ((c.x - n.x) * (l.x - n.x) + (c.y - n.y) * (l.y - n.y)) / f;
          return c.distSqr(_ < 0 ? n : _ > 1 ? l : l.sub(n)._mult(_)._add(n));
        }
        function ab(c, n) {
          let l, f, _, b = !1;
          for (let v = 0; v < c.length; v++) {
            l = c[v];
            for (let T = 0, A = l.length - 1; T < l.length; A = T++) f = l[T], _ = l[A], f.y > n.y != _.y > n.y && n.x < (_.x - f.x) * (n.y - f.y) / (_.y - f.y) + f.x && (b = !b);
          }
          return b;
        }
        function mc(c, n) {
          let l = !1;
          for (let f = 0, _ = c.length - 1; f < c.length; _ = f++) {
            const b = c[f], v = c[_];
            b.y > n.y != v.y > n.y && n.x < (v.x - b.x) * (n.y - b.y) / (v.y - b.y) + b.x && (l = !l);
          }
          return l;
        }
        function bE(c, n, l) {
          const f = l[0], _ = l[2];
          if (c.x < f.x && n.x < f.x || c.x > _.x && n.x > _.x || c.y < f.y && n.y < f.y || c.y > _.y && n.y > _.y) return !1;
          const b = mr(c, n, l[0]);
          return b !== mr(c, n, l[1]) || b !== mr(c, n, l[2]) || b !== mr(c, n, l[3]);
        }
        function ou(c, n, l) {
          const f = n.paint.get(c).value;
          return f.kind === "constant" ? f.value : l.programConfigurations.get(n.id).getMaxValue(c);
        }
        function sf(c) {
          return Math.sqrt(c[0] * c[0] + c[1] * c[1]);
        }
        function nf(c, n, l, f, _) {
          if (!n[0] && !n[1]) return c;
          const b = w.convert(n)._mult(_);
          l === "viewport" && b._rotate(-f);
          const v = [];
          for (let T = 0; T < c.length; T++) v.push(c[T].sub(b));
          return v;
        }
        let lb, cb;
        nt("CircleBucket", __, { omit: ["layers"] });
        var vE = { get paint() {
          return cb = cb || new zr({ "circle-radius": new yt(ve.paint_circle["circle-radius"]), "circle-color": new yt(ve.paint_circle["circle-color"]), "circle-blur": new yt(ve.paint_circle["circle-blur"]), "circle-opacity": new yt(ve.paint_circle["circle-opacity"]), "circle-translate": new dt(ve.paint_circle["circle-translate"]), "circle-translate-anchor": new dt(ve.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new dt(ve.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new dt(ve.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new yt(ve.paint_circle["circle-stroke-width"]), "circle-stroke-color": new yt(ve.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new yt(ve.paint_circle["circle-stroke-opacity"]) });
        }, get layout() {
          return lb = lb || new zr({ "circle-sort-key": new yt(ve.layout_circle["circle-sort-key"]) });
        } };
        class xE extends _s {
          constructor(n) {
            super(n, vE);
          }
          createBucket(n) {
            return new __(n);
          }
          queryRadius(n) {
            const l = n;
            return ou("circle-radius", this, l) + ou("circle-stroke-width", this, l) + sf(this.paint.get("circle-translate"));
          }
          queryIntersectsFeature({ queryGeometry: n, feature: l, featureState: f, geometry: _, transform: b, pixelsToTileUnits: v, unwrappedTileID: T, getElevation: A }) {
            const I = nf(n, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -b.bearingInRadians, v), P = this.paint.get("circle-radius").evaluate(l, f) + this.paint.get("circle-stroke-width").evaluate(l, f), D = this.paint.get("circle-pitch-alignment") === "map", U = D ? I : (function(j, G, Z, te) {
              return j.map(((me) => hb(me, G, Z, te)));
            })(I, b, T, A), V = D ? P * v : P;
            for (const j of _) for (const G of j) {
              const Z = D ? G : hb(G, b, T, A);
              let te = V;
              const me = b.projectTileCoordinates(G.x, G.y, T, A).signedDistanceFromCamera;
              if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map" ? te *= me / b.cameraToCenterDistance : this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport" && (te *= b.cameraToCenterDistance / me), gE(U, Z, te)) return !0;
            }
            return !1;
          }
        }
        function hb(c, n, l, f) {
          const _ = n.projectTileCoordinates(c.x, c.y, l, f).point;
          return new w((0.5 * _.x + 0.5) * n.width, (0.5 * -_.y + 0.5) * n.height);
        }
        class ub extends __ {
        }
        let db;
        nt("HeatmapBucket", ub, { omit: ["layers"] });
        var wE = { get paint() {
          return db = db || new zr({ "heatmap-radius": new yt(ve.paint_heatmap["heatmap-radius"]), "heatmap-weight": new yt(ve.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new dt(ve.paint_heatmap["heatmap-intensity"]), "heatmap-color": new uc(ve.paint_heatmap["heatmap-color"]), "heatmap-opacity": new dt(ve.paint_heatmap["heatmap-opacity"]) });
        } };
        function y_(c, { width: n, height: l }, f, _) {
          if (_) {
            if (_ instanceof Uint8ClampedArray) _ = new Uint8Array(_.buffer);
            else if (_.length !== n * l * f) throw new RangeError(`mismatched image size. expected: ${_.length} but got: ${n * l * f}`);
          } else _ = new Uint8Array(n * l * f);
          return c.width = n, c.height = l, c.data = _, c;
        }
        function fb(c, { width: n, height: l }, f) {
          if (n === c.width && l === c.height) return;
          const _ = y_({}, { width: n, height: l }, f);
          b_(c, _, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(c.width, n), height: Math.min(c.height, l) }, f), c.width = n, c.height = l, c.data = _.data;
        }
        function b_(c, n, l, f, _, b) {
          if (_.width === 0 || _.height === 0) return n;
          if (_.width > c.width || _.height > c.height || l.x > c.width - _.width || l.y > c.height - _.height) throw new RangeError("out of range source coordinates for image copy");
          if (_.width > n.width || _.height > n.height || f.x > n.width - _.width || f.y > n.height - _.height) throw new RangeError("out of range destination coordinates for image copy");
          const v = c.data, T = n.data;
          if (v === T) throw new Error("srcData equals dstData, so image is already copied");
          for (let A = 0; A < _.height; A++) {
            const I = ((l.y + A) * c.width + l.x) * b, P = ((f.y + A) * n.width + f.x) * b;
            for (let D = 0; D < _.width * b; D++) T[P + D] = v[I + D];
          }
          return n;
        }
        class au {
          constructor(n, l) {
            y_(this, n, 1, l);
          }
          resize(n) {
            fb(this, n, 1);
          }
          clone() {
            return new au({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(n, l, f, _, b) {
            b_(n, l, f, _, b, 1);
          }
        }
        class os {
          constructor(n, l) {
            y_(this, n, 4, l);
          }
          resize(n) {
            fb(this, n, 4);
          }
          replace(n, l) {
            l ? this.data.set(n) : this.data = n instanceof Uint8ClampedArray ? new Uint8Array(n.buffer) : n;
          }
          clone() {
            return new os({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(n, l, f, _, b) {
            b_(n, l, f, _, b, 4);
          }
          setPixel(n, l, f) {
            const _ = 4 * (n * this.width + l);
            this.data[_ + 0] = Math.round(255 * f.r / f.a), this.data[_ + 1] = Math.round(255 * f.g / f.a), this.data[_ + 2] = Math.round(255 * f.b / f.a), this.data[_ + 3] = Math.round(255 * f.a);
          }
        }
        function pb(c) {
          const n = {}, l = c.resolution || 256, f = c.clips ? c.clips.length : 1, _ = c.image || new os({ width: l, height: f });
          if (Math.log(l) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${l}`);
          const b = (v, T, A) => {
            n[c.evaluationKey] = A;
            const I = c.expression.evaluate(n);
            _.setPixel(v / 4 / l, T / 4, I);
          };
          if (c.clips) for (let v = 0, T = 0; v < f; ++v, T += 4 * l) for (let A = 0, I = 0; A < l; A++, I += 4) {
            const P = A / (l - 1), { start: D, end: U } = c.clips[v];
            b(T, I, D * (1 - P) + U * P);
          }
          else for (let v = 0, T = 0; v < l; v++, T += 4) b(0, T, v / (l - 1));
          return _;
        }
        nt("AlphaImage", au), nt("RGBAImage", os);
        const v_ = "big-fb";
        class TE extends _s {
          createBucket(n) {
            return new ub(n);
          }
          constructor(n) {
            super(n, wE), this.heatmapFbos = /* @__PURE__ */ new Map(), this._updateColorRamp();
          }
          _handleSpecialPaintPropertyUpdate(n) {
            n === "heatmap-color" && this._updateColorRamp();
          }
          _updateColorRamp() {
            this.colorRamp = pb({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
          }
          resize() {
            this.heatmapFbos.has(v_) && this.heatmapFbos.delete(v_);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            return !1;
          }
          hasOffscreenPass() {
            return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
          }
        }
        let _b;
        var AE = { get paint() {
          return _b = _b || new zr({ "hillshade-illumination-direction": new dt(ve.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-altitude": new dt(ve.paint_hillshade["hillshade-illumination-altitude"]), "hillshade-illumination-anchor": new dt(ve.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new dt(ve.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new dt(ve.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new dt(ve.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new dt(ve.paint_hillshade["hillshade-accent-color"]), "hillshade-method": new dt(ve.paint_hillshade["hillshade-method"]) });
        } };
        class EE extends _s {
          constructor(n) {
            super(n, AE), this.recalculate({ zoom: 0, zoomHistory: {} }, void 0);
          }
          getIlluminationProperties() {
            let n = this.paint.get("hillshade-illumination-direction").values, l = this.paint.get("hillshade-illumination-altitude").values, f = this.paint.get("hillshade-highlight-color").values, _ = this.paint.get("hillshade-shadow-color").values;
            const b = Math.max(n.length, l.length, f.length, _.length);
            n = n.concat(Array(b - n.length).fill(n.at(-1))), l = l.concat(Array(b - l.length).fill(l.at(-1))), f = f.concat(Array(b - f.length).fill(f.at(-1))), _ = _.concat(Array(b - _.length).fill(_.at(-1)));
            const v = l.map(_n);
            return { directionRadians: n.map(_n), altitudeRadians: v, shadowColor: _, highlightColor: f };
          }
          hasOffscreenPass() {
            return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
          }
        }
        let gb;
        var SE = { get paint() {
          return gb = gb || new zr({ "color-relief-opacity": new dt(ve["paint_color-relief"]["color-relief-opacity"]), "color-relief-color": new uc(ve["paint_color-relief"]["color-relief-color"]) });
        } };
        class x_ {
          constructor(n, l, f, _) {
            this.context = n, this.format = f, this.texture = n.gl.createTexture(), this.update(l, _);
          }
          update(n, l, f) {
            const { width: _, height: b } = n, v = !(this.size && this.size[0] === _ && this.size[1] === b || f), { context: T } = this, { gl: A } = T;
            if (this.useMipmap = !!(l && l.useMipmap), A.bindTexture(A.TEXTURE_2D, this.texture), T.pixelStoreUnpackFlipY.set(!1), T.pixelStoreUnpack.set(1), T.pixelStoreUnpackPremultiplyAlpha.set(this.format === A.RGBA && (!l || l.premultiply !== !1)), v) this.size = [_, b], n instanceof HTMLImageElement || n instanceof HTMLCanvasElement || n instanceof HTMLVideoElement || n instanceof ImageData || es(n) ? A.texImage2D(A.TEXTURE_2D, 0, this.format, this.format, A.UNSIGNED_BYTE, n) : A.texImage2D(A.TEXTURE_2D, 0, this.format, _, b, 0, this.format, A.UNSIGNED_BYTE, n.data);
            else {
              const { x: I, y: P } = f || { x: 0, y: 0 };
              n instanceof HTMLImageElement || n instanceof HTMLCanvasElement || n instanceof HTMLVideoElement || n instanceof ImageData || es(n) ? A.texSubImage2D(A.TEXTURE_2D, 0, I, P, A.RGBA, A.UNSIGNED_BYTE, n) : A.texSubImage2D(A.TEXTURE_2D, 0, I, P, _, b, A.RGBA, A.UNSIGNED_BYTE, n.data);
            }
            this.useMipmap && this.isSizePowerOfTwo() && A.generateMipmap(A.TEXTURE_2D), T.pixelStoreUnpackFlipY.setDefault(), T.pixelStoreUnpack.setDefault(), T.pixelStoreUnpackPremultiplyAlpha.setDefault();
          }
          bind(n, l, f) {
            const { context: _ } = this, { gl: b } = _;
            b.bindTexture(b.TEXTURE_2D, this.texture), f !== b.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (f = b.LINEAR), n !== this.filter && (b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, n), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, f || n), this.filter = n), l !== this.wrap && (b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, l), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, l), this.wrap = l);
          }
          isSizePowerOfTwo() {
            return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
          }
          destroy() {
            const { gl: n } = this.context;
            n.deleteTexture(this.texture), this.texture = null;
          }
        }
        class mb {
          constructor(n, l, f, _ = 1, b = 1, v = 1, T = 0) {
            if (this.uid = n, l.height !== l.width) throw new RangeError("DEM tiles must be square");
            if (f && !["mapbox", "terrarium", "custom"].includes(f)) return void ai(`"${f}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
            this.stride = l.height;
            const A = this.dim = l.height - 2;
            switch (this.data = new Uint32Array(l.data.buffer), f) {
              case "terrarium":
                this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
                break;
              case "custom":
                this.redFactor = _, this.greenFactor = b, this.blueFactor = v, this.baseShift = T;
                break;
              default:
                this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
            }
            for (let I = 0; I < A; I++) this.data[this._idx(-1, I)] = this.data[this._idx(0, I)], this.data[this._idx(A, I)] = this.data[this._idx(A - 1, I)], this.data[this._idx(I, -1)] = this.data[this._idx(I, 0)], this.data[this._idx(I, A)] = this.data[this._idx(I, A - 1)];
            this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(A, -1)] = this.data[this._idx(A - 1, 0)], this.data[this._idx(-1, A)] = this.data[this._idx(0, A - 1)], this.data[this._idx(A, A)] = this.data[this._idx(A - 1, A - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
            for (let I = 0; I < A; I++) for (let P = 0; P < A; P++) {
              const D = this.get(I, P);
              D > this.max && (this.max = D), D < this.min && (this.min = D);
            }
          }
          get(n, l) {
            const f = new Uint8Array(this.data.buffer), _ = 4 * this._idx(n, l);
            return this.unpack(f[_], f[_ + 1], f[_ + 2]);
          }
          getUnpackVector() {
            return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
          }
          _idx(n, l) {
            if (n < -1 || n >= this.dim + 1 || l < -1 || l >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
            return (l + 1) * this.stride + (n + 1);
          }
          unpack(n, l, f) {
            return n * this.redFactor + l * this.greenFactor + f * this.blueFactor - this.baseShift;
          }
          pack(n) {
            return yb(n, this.getUnpackVector());
          }
          getPixels() {
            return new os({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
          }
          backfillBorder(n, l, f) {
            if (this.dim !== n.dim) throw new Error("dem dimension mismatch");
            let _ = l * this.dim, b = l * this.dim + this.dim, v = f * this.dim, T = f * this.dim + this.dim;
            switch (l) {
              case -1:
                _ = b - 1;
                break;
              case 1:
                b = _ + 1;
            }
            switch (f) {
              case -1:
                v = T - 1;
                break;
              case 1:
                T = v + 1;
            }
            const A = -l * this.dim, I = -f * this.dim;
            for (let P = v; P < T; P++) for (let D = _; D < b; D++) this.data[this._idx(D, P)] = n.data[this._idx(D + A, P + I)];
          }
        }
        function yb(c, n) {
          const l = n[0], f = n[1], _ = n[2], b = n[3], v = Math.min(l, f, _), T = Math.round((c + b) / v);
          return { r: Math.floor(T * v / l) % 256, g: Math.floor(T * v / f) % 256, b: Math.floor(T * v / _) % 256 };
        }
        nt("DEMData", mb);
        class CE extends _s {
          constructor(n) {
            super(n, SE);
          }
          _createColorRamp(n) {
            const l = { elevationStops: [], colorStops: [] }, f = this._transitionablePaint._values["color-relief-color"].value.expression;
            if (f instanceof Ja && f._styleExpression.expression instanceof br) {
              this.colorRampExpression = f;
              const v = f._styleExpression.expression;
              l.elevationStops = v.labels, l.colorStops = [];
              for (const T of l.elevationStops) l.colorStops.push(v.evaluate({ globals: { elevation: T } }));
            }
            if (l.elevationStops.length < 1 && (l.elevationStops = [0], l.colorStops = [mt.transparent]), l.elevationStops.length < 2 && (l.elevationStops.push(l.elevationStops[0] + 1), l.colorStops.push(l.colorStops[0])), l.elevationStops.length <= n) return l;
            const _ = { elevationStops: [], colorStops: [] }, b = (l.elevationStops.length - 1) / (n - 1);
            for (let v = 0; v < l.elevationStops.length - 0.5; v += b) _.elevationStops.push(l.elevationStops[Math.round(v)]), _.colorStops.push(l.colorStops[Math.round(v)]);
            return ai(`Too many colors in specification of ${this.id} color-relief layer, may not render properly.`), _;
          }
          _colorRampChanged() {
            return this.colorRampExpression != this._transitionablePaint._values["color-relief-color"].value.expression;
          }
          getColorRampTextures(n, l, f) {
            if (this.colorRampTextures && !this._colorRampChanged()) return this.colorRampTextures;
            const _ = this._createColorRamp(l), b = new os({ width: _.colorStops.length, height: 1 }), v = new os({ width: _.colorStops.length, height: 1 });
            for (let T = 0; T < _.elevationStops.length; T++) {
              const A = yb(_.elevationStops[T], f);
              v.setPixel(0, T, new mt(A.r / 255, A.g / 255, A.b / 255, 1)), b.setPixel(0, T, _.colorStops[T]);
            }
            return this.colorRampTextures = { elevationTexture: new x_(n, v, n.gl.RGBA), colorTexture: new x_(n, b, n.gl.RGBA) }, this.colorRampTextures;
          }
          hasOffscreenPass() {
            return this.visibility !== "none" && !!this.colorRampTextures;
          }
        }
        const IE = Di([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: ME } = IE;
        function w_(c, n, l) {
          const f = l.patternDependencies;
          let _ = !1;
          for (const b of n) {
            const v = b.paint.get(`${c}-pattern`);
            v.isConstant() || (_ = !0);
            const T = v.constantOr(null);
            T && (_ = !0, f[T.to] = !0, f[T.from] = !0);
          }
          return _;
        }
        function T_(c, n, l, f, _) {
          const b = _.patternDependencies;
          for (const v of n) {
            const T = v.paint.get(`${c}-pattern`).value;
            if (T.kind !== "constant") {
              let A = T.evaluate({ zoom: f - 1 }, l, {}, _.availableImages), I = T.evaluate({ zoom: f }, l, {}, _.availableImages), P = T.evaluate({ zoom: f + 1 }, l, {}, _.availableImages);
              A = A && A.name ? A.name : A, I = I && I.name ? I.name : I, P = P && P.name ? P.name : P, b[A] = !0, b[I] = !0, b[P] = !0, l.patterns[v.id] = { min: A, mid: I, max: P };
            }
          }
          return l;
        }
        function bb(c, n, l, f, _) {
          let b;
          if (_ === (function(v, T, A, I) {
            let P = 0;
            for (let D = T, U = A - I; D < A; D += I) P += (v[U] - v[D]) * (v[D + 1] + v[U + 1]), U = D;
            return P;
          })(c, n, l, f) > 0) for (let v = n; v < l; v += f) b = Tb(v / f | 0, c[v], c[v + 1], b);
          else for (let v = l - f; v >= n; v -= f) b = Tb(v / f | 0, c[v], c[v + 1], b);
          return b && yc(b, b.next) && (uu(b), b = b.next), b;
        }
        function cl(c, n) {
          if (!c) return c;
          n || (n = c);
          let l, f = c;
          do
            if (l = !1, f.steiner || !yc(f, f.next) && Vi(f.prev, f, f.next) !== 0) f = f.next;
            else {
              if (uu(f), f = n = f.prev, f === f.next) break;
              l = !0;
            }
          while (l || f !== n);
          return n;
        }
        function lu(c, n, l, f, _, b, v) {
          if (!c) return;
          !v && b && (function(A, I, P, D) {
            let U = A;
            do
              U.z === 0 && (U.z = A_(U.x, U.y, I, P, D)), U.prevZ = U.prev, U.nextZ = U.next, U = U.next;
            while (U !== A);
            U.prevZ.nextZ = null, U.prevZ = null, (function(V) {
              let j, G = 1;
              do {
                let Z, te = V;
                V = null;
                let me = null;
                for (j = 0; te; ) {
                  j++;
                  let ce = te, de = 0;
                  for (let ke = 0; ke < G && (de++, ce = ce.nextZ, ce); ke++) ;
                  let Re = G;
                  for (; de > 0 || Re > 0 && ce; ) de !== 0 && (Re === 0 || !ce || te.z <= ce.z) ? (Z = te, te = te.nextZ, de--) : (Z = ce, ce = ce.nextZ, Re--), me ? me.nextZ = Z : V = Z, Z.prevZ = me, me = Z;
                  te = ce;
                }
                me.nextZ = null, G *= 2;
              } while (j > 1);
            })(U);
          })(c, f, _, b);
          let T = c;
          for (; c.prev !== c.next; ) {
            const A = c.prev, I = c.next;
            if (b ? PE(c, f, _, b) : RE(c)) n.push(A.i, c.i, I.i), uu(c), c = I.next, T = I.next;
            else if ((c = I) === T) {
              v ? v === 1 ? lu(c = BE(cl(c), n), n, l, f, _, b, 2) : v === 2 && DE(c, n, l, f, _, b) : lu(cl(c), n, l, f, _, b, 1);
              break;
            }
          }
        }
        function RE(c) {
          const n = c.prev, l = c, f = c.next;
          if (Vi(n, l, f) >= 0) return !1;
          const _ = n.x, b = l.x, v = f.x, T = n.y, A = l.y, I = f.y, P = Math.min(_, b, v), D = Math.min(T, A, I), U = Math.max(_, b, v), V = Math.max(T, A, I);
          let j = f.next;
          for (; j !== n; ) {
            if (j.x >= P && j.x <= U && j.y >= D && j.y <= V && cu(_, T, b, A, v, I, j.x, j.y) && Vi(j.prev, j, j.next) >= 0) return !1;
            j = j.next;
          }
          return !0;
        }
        function PE(c, n, l, f) {
          const _ = c.prev, b = c, v = c.next;
          if (Vi(_, b, v) >= 0) return !1;
          const T = _.x, A = b.x, I = v.x, P = _.y, D = b.y, U = v.y, V = Math.min(T, A, I), j = Math.min(P, D, U), G = Math.max(T, A, I), Z = Math.max(P, D, U), te = A_(V, j, n, l, f), me = A_(G, Z, n, l, f);
          let ce = c.prevZ, de = c.nextZ;
          for (; ce && ce.z >= te && de && de.z <= me; ) {
            if (ce.x >= V && ce.x <= G && ce.y >= j && ce.y <= Z && ce !== _ && ce !== v && cu(T, P, A, D, I, U, ce.x, ce.y) && Vi(ce.prev, ce, ce.next) >= 0 || (ce = ce.prevZ, de.x >= V && de.x <= G && de.y >= j && de.y <= Z && de !== _ && de !== v && cu(T, P, A, D, I, U, de.x, de.y) && Vi(de.prev, de, de.next) >= 0)) return !1;
            de = de.nextZ;
          }
          for (; ce && ce.z >= te; ) {
            if (ce.x >= V && ce.x <= G && ce.y >= j && ce.y <= Z && ce !== _ && ce !== v && cu(T, P, A, D, I, U, ce.x, ce.y) && Vi(ce.prev, ce, ce.next) >= 0) return !1;
            ce = ce.prevZ;
          }
          for (; de && de.z <= me; ) {
            if (de.x >= V && de.x <= G && de.y >= j && de.y <= Z && de !== _ && de !== v && cu(T, P, A, D, I, U, de.x, de.y) && Vi(de.prev, de, de.next) >= 0) return !1;
            de = de.nextZ;
          }
          return !0;
        }
        function BE(c, n) {
          let l = c;
          do {
            const f = l.prev, _ = l.next.next;
            !yc(f, _) && xb(f, l, l.next, _) && hu(f, _) && hu(_, f) && (n.push(f.i, l.i, _.i), uu(l), uu(l.next), l = c = _), l = l.next;
          } while (l !== c);
          return cl(l);
        }
        function DE(c, n, l, f, _, b) {
          let v = c;
          do {
            let T = v.next.next;
            for (; T !== v.prev; ) {
              if (v.i !== T.i && LE(v, T)) {
                let A = wb(v, T);
                return v = cl(v, v.next), A = cl(A, A.next), lu(v, n, l, f, _, b, 0), void lu(A, n, l, f, _, b, 0);
              }
              T = T.next;
            }
            v = v.next;
          } while (v !== c);
        }
        function OE(c, n) {
          let l = c.x - n.x;
          return l === 0 && (l = c.y - n.y, l === 0) && (l = (c.next.y - c.y) / (c.next.x - c.x) - (n.next.y - n.y) / (n.next.x - n.x)), l;
        }
        function FE(c, n) {
          const l = (function(_, b) {
            let v = b;
            const T = _.x, A = _.y;
            let I, P = -1 / 0;
            if (yc(_, v)) return v;
            do {
              if (yc(_, v.next)) return v.next;
              if (A <= v.y && A >= v.next.y && v.next.y !== v.y) {
                const G = v.x + (A - v.y) * (v.next.x - v.x) / (v.next.y - v.y);
                if (G <= T && G > P && (P = G, I = v.x < v.next.x ? v : v.next, G === T)) return I;
              }
              v = v.next;
            } while (v !== b);
            if (!I) return null;
            const D = I, U = I.x, V = I.y;
            let j = 1 / 0;
            v = I;
            do {
              if (T >= v.x && v.x >= U && T !== v.x && vb(A < V ? T : P, A, U, V, A < V ? P : T, A, v.x, v.y)) {
                const G = Math.abs(A - v.y) / (T - v.x);
                hu(v, _) && (G < j || G === j && (v.x > I.x || v.x === I.x && kE(I, v))) && (I = v, j = G);
              }
              v = v.next;
            } while (v !== D);
            return I;
          })(c, n);
          if (!l) return n;
          const f = wb(l, c);
          return cl(f, f.next), cl(l, l.next);
        }
        function kE(c, n) {
          return Vi(c.prev, c, n.prev) < 0 && Vi(n.next, c, c.next) < 0;
        }
        function A_(c, n, l, f, _) {
          return (c = 1431655765 & ((c = 858993459 & ((c = 252645135 & ((c = 16711935 & ((c = (c - l) * _ | 0) | c << 8)) | c << 4)) | c << 2)) | c << 1)) | (n = 1431655765 & ((n = 858993459 & ((n = 252645135 & ((n = 16711935 & ((n = (n - f) * _ | 0) | n << 8)) | n << 4)) | n << 2)) | n << 1)) << 1;
        }
        function NE(c) {
          let n = c, l = c;
          do
            (n.x < l.x || n.x === l.x && n.y < l.y) && (l = n), n = n.next;
          while (n !== c);
          return l;
        }
        function vb(c, n, l, f, _, b, v, T) {
          return (_ - v) * (n - T) >= (c - v) * (b - T) && (c - v) * (f - T) >= (l - v) * (n - T) && (l - v) * (b - T) >= (_ - v) * (f - T);
        }
        function cu(c, n, l, f, _, b, v, T) {
          return !(c === v && n === T) && vb(c, n, l, f, _, b, v, T);
        }
        function LE(c, n) {
          return c.next.i !== n.i && c.prev.i !== n.i && !(function(l, f) {
            let _ = l;
            do {
              if (_.i !== l.i && _.next.i !== l.i && _.i !== f.i && _.next.i !== f.i && xb(_, _.next, l, f)) return !0;
              _ = _.next;
            } while (_ !== l);
            return !1;
          })(c, n) && (hu(c, n) && hu(n, c) && (function(l, f) {
            let _ = l, b = !1;
            const v = (l.x + f.x) / 2, T = (l.y + f.y) / 2;
            do
              _.y > T != _.next.y > T && _.next.y !== _.y && v < (_.next.x - _.x) * (T - _.y) / (_.next.y - _.y) + _.x && (b = !b), _ = _.next;
            while (_ !== l);
            return b;
          })(c, n) && (Vi(c.prev, c, n.prev) || Vi(c, n.prev, n)) || yc(c, n) && Vi(c.prev, c, c.next) > 0 && Vi(n.prev, n, n.next) > 0);
        }
        function Vi(c, n, l) {
          return (n.y - c.y) * (l.x - n.x) - (n.x - c.x) * (l.y - n.y);
        }
        function yc(c, n) {
          return c.x === n.x && c.y === n.y;
        }
        function xb(c, n, l, f) {
          const _ = af(Vi(c, n, l)), b = af(Vi(c, n, f)), v = af(Vi(l, f, c)), T = af(Vi(l, f, n));
          return _ !== b && v !== T || !(_ !== 0 || !of(c, l, n)) || !(b !== 0 || !of(c, f, n)) || !(v !== 0 || !of(l, c, f)) || !(T !== 0 || !of(l, n, f));
        }
        function of(c, n, l) {
          return n.x <= Math.max(c.x, l.x) && n.x >= Math.min(c.x, l.x) && n.y <= Math.max(c.y, l.y) && n.y >= Math.min(c.y, l.y);
        }
        function af(c) {
          return c > 0 ? 1 : c < 0 ? -1 : 0;
        }
        function hu(c, n) {
          return Vi(c.prev, c, c.next) < 0 ? Vi(c, n, c.next) >= 0 && Vi(c, c.prev, n) >= 0 : Vi(c, n, c.prev) < 0 || Vi(c, c.next, n) < 0;
        }
        function wb(c, n) {
          const l = E_(c.i, c.x, c.y), f = E_(n.i, n.x, n.y), _ = c.next, b = n.prev;
          return c.next = n, n.prev = c, l.next = _, _.prev = l, f.next = l, l.prev = f, b.next = f, f.prev = b, f;
        }
        function Tb(c, n, l, f) {
          const _ = E_(c, n, l);
          return f ? (_.next = f.next, _.prev = f, f.next.prev = _, f.next = _) : (_.prev = _, _.next = _), _;
        }
        function uu(c) {
          c.next.prev = c.prev, c.prev.next = c.next, c.prevZ && (c.prevZ.nextZ = c.nextZ), c.nextZ && (c.nextZ.prevZ = c.prevZ);
        }
        function E_(c, n, l) {
          return { i: c, x: n, y: l, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: !1 };
        }
        class bc {
          constructor(n, l) {
            if (l > n) throw new Error("Min granularity must not be greater than base granularity.");
            this._baseZoomGranularity = n, this._minGranularity = l;
          }
          getGranularityForZoomLevel(n) {
            return Math.max(Math.floor(this._baseZoomGranularity / (1 << n)), this._minGranularity, 1);
          }
        }
        class lf {
          constructor(n) {
            this.fill = n.fill, this.line = n.line, this.tile = n.tile, this.stencil = n.stencil, this.circle = n.circle;
          }
        }
        lf.noSubdivision = new lf({ fill: new bc(0, 0), line: new bc(0, 0), tile: new bc(0, 0), stencil: new bc(0, 0), circle: 1 }), nt("SubdivisionGranularityExpression", bc), nt("SubdivisionGranularitySetting", lf);
        const vc = -32768, du = 32767;
        class UE {
          constructor(n, l) {
            this._vertexBuffer = [], this._vertexDictionary = /* @__PURE__ */ new Map(), this._used = !1, this._granularity = n, this._granularityCellSize = Ht / n, this._canonical = l;
          }
          _getKey(n, l) {
            return (n += 32768) << 16 | l + 32768;
          }
          _vertexToIndex(n, l) {
            if (n < -32768 || l < -32768 || n > 32767 || l > 32767) throw new Error("Vertex coordinates are out of signed 16 bit integer range.");
            const f = 0 | Math.round(n), _ = 0 | Math.round(l), b = this._getKey(f, _);
            if (this._vertexDictionary.has(b)) return this._vertexDictionary.get(b);
            const v = this._vertexBuffer.length / 2;
            return this._vertexDictionary.set(b, v), this._vertexBuffer.push(f, _), v;
          }
          _subdivideTrianglesScanline(n) {
            if (this._granularity < 2) return (function(_, b) {
              const v = [];
              for (let T = 0; T < b.length; T += 3) {
                const A = b[T], I = b[T + 1], P = b[T + 2], D = _[2 * A], U = _[2 * A + 1];
                (_[2 * I] - D) * (_[2 * P + 1] - U) - (_[2 * I + 1] - U) * (_[2 * P] - D) > 0 ? (v.push(A), v.push(P), v.push(I)) : (v.push(A), v.push(I), v.push(P));
              }
              return v;
            })(this._vertexBuffer, n);
            const l = [], f = n.length;
            for (let _ = 0; _ < f; _ += 3) {
              const b = [n[_ + 0], n[_ + 1], n[_ + 2]], v = [this._vertexBuffer[2 * n[_ + 0] + 0], this._vertexBuffer[2 * n[_ + 0] + 1], this._vertexBuffer[2 * n[_ + 1] + 0], this._vertexBuffer[2 * n[_ + 1] + 1], this._vertexBuffer[2 * n[_ + 2] + 0], this._vertexBuffer[2 * n[_ + 2] + 1]];
              let T = 1 / 0, A = 1 / 0, I = -1 / 0, P = -1 / 0;
              for (let G = 0; G < 3; G++) {
                const Z = v[2 * G], te = v[2 * G + 1];
                T = Math.min(T, Z), I = Math.max(I, Z), A = Math.min(A, te), P = Math.max(P, te);
              }
              if (T === I || A === P) continue;
              const D = Math.floor(T / this._granularityCellSize), U = Math.ceil(I / this._granularityCellSize), V = Math.floor(A / this._granularityCellSize), j = Math.ceil(P / this._granularityCellSize);
              if (D !== U || V !== j) for (let G = V; G < j; G++) {
                const Z = this._scanlineGenerateVertexRingForCellRow(G, v, b);
                zE(this._vertexBuffer, Z, l);
              }
              else l.push(...b);
            }
            return l;
          }
          _scanlineGenerateVertexRingForCellRow(n, l, f) {
            const _ = n * this._granularityCellSize, b = _ + this._granularityCellSize, v = [];
            for (let T = 0; T < 3; T++) {
              const A = l[2 * T], I = l[2 * T + 1], P = l[2 * (T + 1) % 6], D = l[(2 * (T + 1) + 1) % 6], U = l[2 * (T + 2) % 6], V = l[(2 * (T + 2) + 1) % 6], j = P - A, G = D - I, Z = j === 0, te = G === 0, me = (_ - I) / G, ce = (b - I) / G, de = Math.min(me, ce), Re = Math.max(me, ce);
              if (!te && (de >= 1 || Re <= 0) || te && (I < _ || I > b)) {
                D >= _ && D <= b && v.push(f[(T + 1) % 3]);
                continue;
              }
              !te && de > 0 && v.push(this._vertexToIndex(A + j * de, I + G * de));
              const ke = A + j * Math.max(de, 0), je = A + j * Math.min(Re, 1);
              Z || this._generateIntraEdgeVertices(v, A, I, P, D, ke, je), !te && Re < 1 && v.push(this._vertexToIndex(A + j * Re, I + G * Re)), (te || D >= _ && D <= b) && v.push(f[(T + 1) % 3]), !te && (D <= _ || D >= b) && this._generateInterEdgeVertices(v, A, I, P, D, U, V, je, _, b);
            }
            return v;
          }
          _generateIntraEdgeVertices(n, l, f, _, b, v, T) {
            const A = _ - l, I = b - f, P = I === 0, D = P ? Math.min(l, _) : Math.min(v, T), U = P ? Math.max(l, _) : Math.max(v, T), V = Math.floor(D / this._granularityCellSize) + 1, j = Math.ceil(U / this._granularityCellSize) - 1;
            if (P ? l < _ : v < T) for (let G = V; G <= j; G++) {
              const Z = G * this._granularityCellSize;
              n.push(this._vertexToIndex(Z, f + I * (Z - l) / A));
            }
            else for (let G = j; G >= V; G--) {
              const Z = G * this._granularityCellSize;
              n.push(this._vertexToIndex(Z, f + I * (Z - l) / A));
            }
          }
          _generateInterEdgeVertices(n, l, f, _, b, v, T, A, I, P) {
            const D = b - f, U = v - _, V = T - b, j = (I - b) / V, G = (P - b) / V, Z = Math.min(j, G), te = Math.max(j, G), me = _ + U * Z;
            let ce = Math.floor(Math.min(me, A) / this._granularityCellSize) + 1, de = Math.ceil(Math.max(me, A) / this._granularityCellSize) - 1, Re = A < me;
            const ke = V === 0;
            if (ke && (T === I || T === P)) return;
            if (ke || Z >= 1 || te <= 0) {
              const it = f - T, Xe = v + (l - v) * Math.min((I - T) / it, (P - T) / it);
              ce = Math.floor(Math.min(Xe, A) / this._granularityCellSize) + 1, de = Math.ceil(Math.max(Xe, A) / this._granularityCellSize) - 1, Re = A < Xe;
            }
            const je = D > 0 ? P : I;
            if (Re) for (let it = ce; it <= de; it++) n.push(this._vertexToIndex(it * this._granularityCellSize, je));
            else for (let it = de; it >= ce; it--) n.push(this._vertexToIndex(it * this._granularityCellSize, je));
          }
          _generateOutline(n) {
            const l = [];
            for (const f of n) {
              const _ = hl(f, this._granularity, !0), b = this._pointArrayToIndices(_), v = [];
              for (let T = 1; T < b.length; T++) v.push(b[T - 1]), v.push(b[T]);
              l.push(v);
            }
            return l;
          }
          _handlePoles(n) {
            let l = !1, f = !1;
            this._canonical && (this._canonical.y === 0 && (l = !0), this._canonical.y === (1 << this._canonical.z) - 1 && (f = !0)), (l || f) && this._fillPoles(n, l, f);
          }
          _ensureNoPoleVertices() {
            const n = this._vertexBuffer;
            for (let l = 0; l < n.length; l += 2) {
              const f = n[l + 1];
              f === vc && (n[l + 1] = -32767), f === du && (n[l + 1] = 32766);
            }
          }
          _generatePoleQuad(n, l, f, _, b, v) {
            _ > b != (v === vc) ? (n.push(l), n.push(f), n.push(this._vertexToIndex(_, v)), n.push(f), n.push(this._vertexToIndex(b, v)), n.push(this._vertexToIndex(_, v))) : (n.push(f), n.push(l), n.push(this._vertexToIndex(_, v)), n.push(this._vertexToIndex(b, v)), n.push(f), n.push(this._vertexToIndex(_, v)));
          }
          _fillPoles(n, l, f) {
            const _ = this._vertexBuffer, b = Ht, v = n.length;
            for (let T = 2; T < v; T += 3) {
              const A = n[T - 2], I = n[T - 1], P = n[T], D = _[2 * A], U = _[2 * A + 1], V = _[2 * I], j = _[2 * I + 1], G = _[2 * P], Z = _[2 * P + 1];
              l && (U === 0 && j === 0 && this._generatePoleQuad(n, A, I, D, V, vc), j === 0 && Z === 0 && this._generatePoleQuad(n, I, P, V, G, vc), Z === 0 && U === 0 && this._generatePoleQuad(n, P, A, G, D, vc)), f && (U === b && j === b && this._generatePoleQuad(n, A, I, D, V, du), j === b && Z === b && this._generatePoleQuad(n, I, P, V, G, du), Z === b && U === b && this._generatePoleQuad(n, P, A, G, D, du));
            }
          }
          _initializeVertices(n) {
            for (let l = 0; l < n.length; l += 2) this._vertexToIndex(n[l], n[l + 1]);
          }
          subdividePolygonInternal(n, l) {
            if (this._used) throw new Error("Subdivision: multiple use not allowed.");
            this._used = !0;
            const { flattened: f, holeIndices: _ } = (function(T) {
              const A = [], I = [];
              for (const P of T) if (P.length !== 0) {
                P !== T[0] && A.push(I.length / 2);
                for (let D = 0; D < P.length; D++) I.push(P[D].x), I.push(P[D].y);
              }
              return { flattened: I, holeIndices: A };
            })(n);
            let b;
            this._initializeVertices(f);
            try {
              const T = (function(I, P, D = 2) {
                const U = P && P.length, V = U ? P[0] * D : I.length;
                let j = bb(I, 0, V, D, !0);
                const G = [];
                if (!j || j.next === j.prev) return G;
                let Z, te, me;
                if (U && (j = (function(ce, de, Re, ke) {
                  const je = [];
                  for (let it = 0, Xe = de.length; it < Xe; it++) {
                    const Qe = bb(ce, de[it] * ke, it < Xe - 1 ? de[it + 1] * ke : ce.length, ke, !1);
                    Qe === Qe.next && (Qe.steiner = !0), je.push(NE(Qe));
                  }
                  je.sort(OE);
                  for (let it = 0; it < je.length; it++) Re = FE(je[it], Re);
                  return Re;
                })(I, P, j, D)), I.length > 80 * D) {
                  Z = I[0], te = I[1];
                  let ce = Z, de = te;
                  for (let Re = D; Re < V; Re += D) {
                    const ke = I[Re], je = I[Re + 1];
                    ke < Z && (Z = ke), je < te && (te = je), ke > ce && (ce = ke), je > de && (de = je);
                  }
                  me = Math.max(ce - Z, de - te), me = me !== 0 ? 32767 / me : 0;
                }
                return lu(j, G, D, Z, te, me, 0), G;
              })(f, _), A = this._convertIndices(f, T);
              b = this._subdivideTrianglesScanline(A);
            } catch (T) {
              console.error(T);
            }
            let v = [];
            return l && (v = this._generateOutline(n)), this._ensureNoPoleVertices(), this._handlePoles(b), { verticesFlattened: this._vertexBuffer, indicesTriangles: b, indicesLineList: v };
          }
          _convertIndices(n, l) {
            const f = [];
            for (let _ = 0; _ < l.length; _++) f.push(this._vertexToIndex(n[2 * l[_]], n[2 * l[_] + 1]));
            return f;
          }
          _pointArrayToIndices(n) {
            const l = [];
            for (let f = 0; f < n.length; f++) {
              const _ = n[f];
              l.push(this._vertexToIndex(_.x, _.y));
            }
            return l;
          }
        }
        function Ab(c, n, l, f = !0) {
          return new UE(l, n).subdividePolygonInternal(c, f);
        }
        function hl(c, n, l = !1) {
          if (!c || c.length < 1) return [];
          if (c.length < 2) return [];
          const f = c[0], _ = c[c.length - 1], b = l && (f.x !== _.x || f.y !== _.y);
          if (n < 2) return b ? [...c, c[0]] : [...c];
          const v = Math.floor(Ht / n), T = [];
          T.push(new w(c[0].x, c[0].y));
          const A = c.length, I = b ? A : A - 1;
          for (let P = 0; P < I; P++) {
            const D = c[P], U = P < A - 1 ? c[P + 1] : c[0], V = D.x, j = D.y, G = U.x, Z = U.y, te = V !== G, me = j !== Z;
            if (!te && !me) continue;
            const ce = G - V, de = Z - j, Re = Math.abs(ce), ke = Math.abs(de);
            let je = V, it = j;
            for (; ; ) {
              const Qe = ce > 0 ? (Math.floor(je / v) + 1) * v : (Math.ceil(je / v) - 1) * v, pt = de > 0 ? (Math.floor(it / v) + 1) * v : (Math.ceil(it / v) - 1) * v, Ye = Math.abs(je - Qe), et = Math.abs(it - pt), Ue = Math.abs(je - G), xt = Math.abs(it - Z), At = te ? Ye / Re : Number.POSITIVE_INFINITY, gt = me ? et / ke : Number.POSITIVE_INFINITY;
              if ((Ue <= Ye || !te) && (xt <= et || !me)) break;
              if (At < gt && te || !me) {
                je = Qe, it += de * At;
                const ut = new w(je, Math.round(it));
                T[T.length - 1].x === ut.x && T[T.length - 1].y === ut.y || T.push(ut);
              } else {
                je += ce * gt, it = pt;
                const ut = new w(Math.round(je), it);
                T[T.length - 1].x === ut.x && T[T.length - 1].y === ut.y || T.push(ut);
              }
            }
            const Xe = new w(G, Z);
            T[T.length - 1].x === Xe.x && T[T.length - 1].y === Xe.y || T.push(Xe);
          }
          return T;
        }
        function zE(c, n, l) {
          if (n.length === 0) throw new Error("Subdivision vertex ring is empty.");
          let f = 0, _ = c[2 * n[0]];
          for (let A = 1; A < n.length; A++) {
            const I = c[2 * n[A]];
            I < _ && (_ = I, f = A);
          }
          const b = n.length;
          let v = f, T = (v + 1) % b;
          for (; ; ) {
            const A = v - 1 >= 0 ? v - 1 : b - 1, I = (T + 1) % b, P = c[2 * n[A]], D = c[2 * n[I]], U = c[2 * n[v]], V = c[2 * n[v] + 1], j = c[2 * n[T] + 1];
            let G = !1;
            if (P < D) G = !0;
            else if (P > D) G = !1;
            else {
              const Z = j - V, te = -(c[2 * n[T]] - U), me = V < j ? 1 : -1;
              ((P - U) * Z + (c[2 * n[A] + 1] - V) * te) * me > ((D - U) * Z + (c[2 * n[I] + 1] - V) * te) * me && (G = !0);
            }
            if (G) {
              const Z = n[A], te = n[v], me = n[T];
              Z !== te && Z !== me && te !== me && l.push(me, te, Z), v--, v < 0 && (v = b - 1);
            } else {
              const Z = n[I], te = n[v], me = n[T];
              Z !== te && Z !== me && te !== me && l.push(me, te, Z), T++, T >= b && (T = 0);
            }
            if (A === I) break;
          }
        }
        function Eb(c, n, l, f, _, b, v, T, A) {
          const I = _.length / 2, P = v && T && A;
          if (I < Rt.MAX_VERTEX_ARRAY_LENGTH) {
            const D = n.prepareSegment(I, l, f), U = D.vertexLength;
            for (let G = 0; G < b.length; G += 3) f.emplaceBack(U + b[G], U + b[G + 1], U + b[G + 2]);
            let V, j;
            D.vertexLength += I, D.primitiveLength += b.length / 3, P && (j = v.prepareSegment(I, l, T), V = j.vertexLength, j.vertexLength += I);
            for (let G = 0; G < _.length; G += 2) c(_[G], _[G + 1]);
            if (P) for (let G = 0; G < A.length; G++) {
              const Z = A[G];
              for (let te = 1; te < Z.length; te += 2) T.emplaceBack(V + Z[te - 1], V + Z[te]);
              j.primitiveLength += Z.length / 2;
            }
          } else (function(D, U, V, j, G, Z) {
            const te = [];
            for (let ke = 0; ke < j.length / 2; ke++) te.push(-1);
            const me = { count: 0 };
            let ce = 0, de = D.getOrCreateLatestSegment(U, V), Re = de.vertexLength;
            for (let ke = 2; ke < G.length; ke += 3) {
              const je = G[ke - 2], it = G[ke - 1], Xe = G[ke];
              let Qe = te[je] < ce, pt = te[it] < ce, Ye = te[Xe] < ce;
              de.vertexLength + ((Qe ? 1 : 0) + (pt ? 1 : 0) + (Ye ? 1 : 0)) > Rt.MAX_VERTEX_ARRAY_LENGTH && (de = D.createNewSegment(U, V), ce = me.count, Qe = !0, pt = !0, Ye = !0, Re = 0);
              const et = fu(te, j, Z, me, je, Qe, de), Ue = fu(te, j, Z, me, it, pt, de), xt = fu(te, j, Z, me, Xe, Ye, de);
              V.emplaceBack(Re + et - ce, Re + Ue - ce, Re + xt - ce), de.primitiveLength++;
            }
          })(n, l, f, _, b, c), P && (function(D, U, V, j, G, Z) {
            const te = [];
            for (let ke = 0; ke < j.length / 2; ke++) te.push(-1);
            const me = { count: 0 };
            let ce = 0, de = D.getOrCreateLatestSegment(U, V), Re = de.vertexLength;
            for (let ke = 0; ke < G.length; ke++) {
              const je = G[ke];
              for (let it = 1; it < G[ke].length; it += 2) {
                const Xe = je[it - 1], Qe = je[it];
                let pt = te[Xe] < ce, Ye = te[Qe] < ce;
                de.vertexLength + ((pt ? 1 : 0) + (Ye ? 1 : 0)) > Rt.MAX_VERTEX_ARRAY_LENGTH && (de = D.createNewSegment(U, V), ce = me.count, pt = !0, Ye = !0, Re = 0);
                const et = fu(te, j, Z, me, Xe, pt, de), Ue = fu(te, j, Z, me, Qe, Ye, de);
                V.emplaceBack(Re + et - ce, Re + Ue - ce), de.primitiveLength++;
              }
            }
          })(v, l, T, _, A, c), n.forceNewSegmentOnNextPrepare(), v?.forceNewSegmentOnNextPrepare();
        }
        function fu(c, n, l, f, _, b, v) {
          if (b) {
            const T = f.count;
            return l(n[2 * _], n[2 * _ + 1]), c[_] = f.count, f.count++, v.vertexLength++, T;
          }
          return c[_];
        }
        class S_ {
          constructor(n) {
            this.zoom = n.zoom, this.globalState = n.globalState, this.overscaling = n.overscaling, this.layers = n.layers, this.layerIds = this.layers.map(((l) => l.id)), this.index = n.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new Fe(), this.indexArray = new ti(), this.indexArray2 = new Yt(), this.programConfigurations = new ns(n.layers, n.zoom), this.segments = new Rt(), this.segments2 = new Rt(), this.stateDependentLayerIds = this.layers.filter(((l) => l.isStateDependent())).map(((l) => l.id));
          }
          populate(n, l, f) {
            this.hasPattern = w_("fill", this.layers, l);
            const _ = this.layers[0].layout.get("fill-sort-key"), b = !_.isConstant(), v = [];
            for (const { feature: T, id: A, index: I, sourceLayerIndex: P } of n) {
              const D = this.layers[0]._featureFilter.needGeometry, U = xn(T, D);
              if (!this.layers[0]._featureFilter.filter(new gi(this.zoom, { globalState: this.globalState }), U, f)) continue;
              const V = b ? _.evaluate(U, {}, f, l.availableImages) : void 0, j = { id: A, properties: T.properties, type: T.type, sourceLayerIndex: P, index: I, geometry: D ? U.geometry : Kn(T), patterns: {}, sortKey: V };
              v.push(j);
            }
            b && v.sort(((T, A) => T.sortKey - A.sortKey));
            for (const T of v) {
              const { geometry: A, index: I, sourceLayerIndex: P } = T;
              if (this.hasPattern) {
                const D = T_("fill", this.layers, T, this.zoom, l);
                this.patternFeatures.push(D);
              } else this.addFeature(T, A, I, f, {}, l.subdivisionGranularity);
              l.featureIndex.insert(n[I].feature, A, I, P, this.index);
            }
          }
          update(n, l, f) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(n, l, this.stateDependentLayers, f);
          }
          addFeatures(n, l, f) {
            for (const _ of this.patternFeatures) this.addFeature(_, _.geometry, _.index, l, f, n.subdivisionGranularity);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(n) {
            this.uploaded || (this.layoutVertexBuffer = n.createVertexBuffer(this.layoutVertexArray, ME), this.indexBuffer = n.createIndexBuffer(this.indexArray), this.indexBuffer2 = n.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(n), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
          }
          addFeature(n, l, f, _, b, v) {
            for (const T of Xa(l, 500)) {
              const A = Ab(T, _, v.fill.getGranularityForZoomLevel(_.z)), I = this.layoutVertexArray;
              Eb(((P, D) => {
                I.emplaceBack(P, D);
              }), this.segments, this.layoutVertexArray, this.indexArray, A.verticesFlattened, A.indicesTriangles, this.segments2, this.indexArray2, A.indicesLineList);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, n, f, b, _);
          }
        }
        let Sb, Cb;
        nt("FillBucket", S_, { omit: ["layers", "patternFeatures"] });
        var VE = { get paint() {
          return Cb = Cb || new zr({ "fill-antialias": new dt(ve.paint_fill["fill-antialias"]), "fill-opacity": new yt(ve.paint_fill["fill-opacity"]), "fill-color": new yt(ve.paint_fill["fill-color"]), "fill-outline-color": new yt(ve.paint_fill["fill-outline-color"]), "fill-translate": new dt(ve.paint_fill["fill-translate"]), "fill-translate-anchor": new dt(ve.paint_fill["fill-translate-anchor"]), "fill-pattern": new hc(ve.paint_fill["fill-pattern"]) });
        }, get layout() {
          return Sb = Sb || new zr({ "fill-sort-key": new yt(ve.layout_fill["fill-sort-key"]) });
        } };
        class jE extends _s {
          constructor(n) {
            super(n, VE);
          }
          recalculate(n, l) {
            super.recalculate(n, l);
            const f = this.paint._values["fill-outline-color"];
            f.value.kind === "constant" && f.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
          }
          createBucket(n) {
            return new S_(n);
          }
          queryRadius() {
            return sf(this.paint.get("fill-translate"));
          }
          queryIntersectsFeature({ queryGeometry: n, geometry: l, transform: f, pixelsToTileUnits: _ }) {
            return nb(nf(n, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -f.bearingInRadians, _), l);
          }
          isTileClipped() {
            return !0;
          }
        }
        const HE = Di([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), $E = Di([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: GE } = HE;
        class xc {
          constructor(n, l, f, _, b) {
            this.properties = {}, this.extent = f, this.type = 0, this.id = void 0, this._pbf = n, this._geometry = -1, this._keys = _, this._values = b, n.readFields(WE, this, l);
          }
          loadGeometry() {
            const n = this._pbf;
            n.pos = this._geometry;
            const l = n.readVarint() + n.pos, f = [];
            let _, b = 1, v = 0, T = 0, A = 0;
            for (; n.pos < l; ) {
              if (v <= 0) {
                const I = n.readVarint();
                b = 7 & I, v = I >> 3;
              }
              if (v--, b === 1 || b === 2) T += n.readSVarint(), A += n.readSVarint(), b === 1 && (_ && f.push(_), _ = []), _ && _.push(new w(T, A));
              else {
                if (b !== 7) throw new Error(`unknown command ${b}`);
                _ && _.push(_[0].clone());
              }
            }
            return _ && f.push(_), f;
          }
          bbox() {
            const n = this._pbf;
            n.pos = this._geometry;
            const l = n.readVarint() + n.pos;
            let f = 1, _ = 0, b = 0, v = 0, T = 1 / 0, A = -1 / 0, I = 1 / 0, P = -1 / 0;
            for (; n.pos < l; ) {
              if (_ <= 0) {
                const D = n.readVarint();
                f = 7 & D, _ = D >> 3;
              }
              if (_--, f === 1 || f === 2) b += n.readSVarint(), v += n.readSVarint(), b < T && (T = b), b > A && (A = b), v < I && (I = v), v > P && (P = v);
              else if (f !== 7) throw new Error(`unknown command ${f}`);
            }
            return [T, I, A, P];
          }
          toGeoJSON(n, l, f) {
            const _ = this.extent * Math.pow(2, f), b = this.extent * n, v = this.extent * l, T = this.loadGeometry();
            function A(U) {
              return [360 * (U.x + b) / _ - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (U.y + v) / _) * Math.PI)) - 90];
            }
            function I(U) {
              return U.map(A);
            }
            let P;
            if (this.type === 1) {
              const U = [];
              for (const j of T) U.push(j[0]);
              const V = I(U);
              P = U.length === 1 ? { type: "Point", coordinates: V[0] } : { type: "MultiPoint", coordinates: V };
            } else if (this.type === 2) {
              const U = T.map(I);
              P = U.length === 1 ? { type: "LineString", coordinates: U[0] } : { type: "MultiLineString", coordinates: U };
            } else {
              if (this.type !== 3) throw new Error("unknown feature type");
              {
                const U = (function(j) {
                  const G = j.length;
                  if (G <= 1) return [j];
                  const Z = [];
                  let te, me;
                  for (let ce = 0; ce < G; ce++) {
                    const de = XE(j[ce]);
                    de !== 0 && (me === void 0 && (me = de < 0), me === de < 0 ? (te && Z.push(te), te = [j[ce]]) : te && te.push(j[ce]));
                  }
                  return te && Z.push(te), Z;
                })(T), V = [];
                for (const j of U) V.push(j.map(I));
                P = V.length === 1 ? { type: "Polygon", coordinates: V[0] } : { type: "MultiPolygon", coordinates: V };
              }
            }
            const D = { type: "Feature", geometry: P, properties: this.properties };
            return this.id != null && (D.id = this.id), D;
          }
        }
        function WE(c, n, l) {
          c === 1 ? n.id = l.readVarint() : c === 2 ? (function(f, _) {
            const b = f.readVarint() + f.pos;
            for (; f.pos < b; ) {
              const v = _._keys[f.readVarint()], T = _._values[f.readVarint()];
              _.properties[v] = T;
            }
          })(l, n) : c === 3 ? n.type = l.readVarint() : c === 4 && (n._geometry = l.pos);
        }
        function XE(c) {
          let n = 0;
          for (let l, f, _ = 0, b = c.length, v = b - 1; _ < b; v = _++) l = c[_], f = c[v], n += (f.x - l.x) * (l.y + f.y);
          return n;
        }
        xc.types = ["Unknown", "Point", "LineString", "Polygon"];
        class Ib {
          constructor(n, l) {
            this.version = 1, this.name = "", this.extent = 4096, this.length = 0, this._pbf = n, this._keys = [], this._values = [], this._features = [], n.readFields(qE, this, l), this.length = this._features.length;
          }
          feature(n) {
            if (n < 0 || n >= this._features.length) throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[n];
            const l = this._pbf.readVarint() + this._pbf.pos;
            return new xc(this._pbf, l, this.extent, this._keys, this._values);
          }
        }
        function qE(c, n, l) {
          c === 15 ? n.version = l.readVarint() : c === 1 ? n.name = l.readString() : c === 5 ? n.extent = l.readVarint() : c === 2 ? n._features.push(l.pos) : c === 3 ? n._keys.push(l.readString()) : c === 4 && n._values.push((function(f) {
            let _ = null;
            const b = f.readVarint() + f.pos;
            for (; f.pos < b; ) {
              const v = f.readVarint() >> 3;
              _ = v === 1 ? f.readString() : v === 2 ? f.readFloat() : v === 3 ? f.readDouble() : v === 4 ? f.readVarint64() : v === 5 ? f.readVarint() : v === 6 ? f.readSVarint() : v === 7 ? f.readBoolean() : null;
            }
            if (_ == null) throw new Error("unknown feature value");
            return _;
          })(l));
        }
        class Mb {
          constructor(n, l) {
            this.layers = n.readFields(ZE, {}, l);
          }
        }
        function ZE(c, n, l) {
          if (c === 3) {
            const f = new Ib(l, l.readVarint() + l.pos);
            f.length && (n[f.name] = f);
          }
        }
        const C_ = Math.pow(2, 13);
        function pu(c, n, l, f, _, b, v, T) {
          c.emplaceBack(n, l, 2 * Math.floor(f * C_) + v, _ * C_ * 2, b * C_ * 2, Math.round(T));
        }
        class I_ {
          constructor(n) {
            this.zoom = n.zoom, this.globalState = n.globalState, this.overscaling = n.overscaling, this.layers = n.layers, this.layerIds = this.layers.map(((l) => l.id)), this.index = n.index, this.hasPattern = !1, this.layoutVertexArray = new Ie(), this.centroidVertexArray = new oe(), this.indexArray = new ti(), this.programConfigurations = new ns(n.layers, n.zoom), this.segments = new Rt(), this.stateDependentLayerIds = this.layers.filter(((l) => l.isStateDependent())).map(((l) => l.id));
          }
          populate(n, l, f) {
            this.features = [], this.hasPattern = w_("fill-extrusion", this.layers, l);
            for (const { feature: _, id: b, index: v, sourceLayerIndex: T } of n) {
              const A = this.layers[0]._featureFilter.needGeometry, I = xn(_, A);
              if (!this.layers[0]._featureFilter.filter(new gi(this.zoom, { globalState: this.globalState }), I, f)) continue;
              const P = { id: b, sourceLayerIndex: T, index: v, geometry: A ? I.geometry : Kn(_), properties: _.properties, type: _.type, patterns: {} };
              this.hasPattern ? this.features.push(T_("fill-extrusion", this.layers, P, this.zoom, l)) : this.addFeature(P, P.geometry, v, f, {}, l.subdivisionGranularity), l.featureIndex.insert(_, P.geometry, v, T, this.index, !0);
            }
          }
          addFeatures(n, l, f) {
            for (const _ of this.features) {
              const { geometry: b } = _;
              this.addFeature(_, b, _.index, l, f, n.subdivisionGranularity);
            }
          }
          update(n, l, f) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(n, l, this.stateDependentLayers, f);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(n) {
            this.uploaded || (this.layoutVertexBuffer = n.createVertexBuffer(this.layoutVertexArray, GE), this.centroidVertexBuffer = n.createVertexBuffer(this.centroidVertexArray, $E.members, !0), this.indexBuffer = n.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(n), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
          }
          addFeature(n, l, f, _, b, v) {
            for (const T of Xa(l, 500)) {
              const A = { x: 0, y: 0, sampleCount: 0 }, I = this.layoutVertexArray.length;
              this.processPolygon(A, _, n, T, v);
              const P = this.layoutVertexArray.length - I, D = Math.floor(A.x / A.sampleCount), U = Math.floor(A.y / A.sampleCount);
              for (let V = 0; V < P; V++) this.centroidVertexArray.emplaceBack(D, U);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, n, f, b, _);
          }
          processPolygon(n, l, f, _, b) {
            if (_.length < 1 || Rb(_[0])) return;
            for (const D of _) D.length !== 0 && KE(n, D);
            const v = { segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray) }, T = b.fill.getGranularityForZoomLevel(l.z), A = xc.types[f.type] === "Polygon";
            for (const D of _) {
              if (D.length === 0 || Rb(D)) continue;
              const U = hl(D, T, A);
              this._generateSideFaces(U, v);
            }
            if (!A) return;
            const I = Ab(_, l, T, !1), P = this.layoutVertexArray;
            Eb(((D, U) => {
              pu(P, D, U, 0, 0, 1, 1, 0);
            }), this.segments, this.layoutVertexArray, this.indexArray, I.verticesFlattened, I.indicesTriangles);
          }
          _generateSideFaces(n, l) {
            let f = 0;
            for (let _ = 1; _ < n.length; _++) {
              const b = n[_], v = n[_ - 1];
              if (YE(b, v)) continue;
              l.segment.vertexLength + 4 > Rt.MAX_VERTEX_ARRAY_LENGTH && (l.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
              const T = b.sub(v)._perp()._unit(), A = v.dist(b);
              f + A > 32768 && (f = 0), pu(this.layoutVertexArray, b.x, b.y, T.x, T.y, 0, 0, f), pu(this.layoutVertexArray, b.x, b.y, T.x, T.y, 0, 1, f), f += A, pu(this.layoutVertexArray, v.x, v.y, T.x, T.y, 0, 0, f), pu(this.layoutVertexArray, v.x, v.y, T.x, T.y, 0, 1, f);
              const I = l.segment.vertexLength;
              this.indexArray.emplaceBack(I, I + 2, I + 1), this.indexArray.emplaceBack(I + 1, I + 2, I + 3), l.segment.vertexLength += 4, l.segment.primitiveLength += 2;
            }
          }
        }
        function KE(c, n) {
          for (let l = 0; l < n.length; l++) {
            const f = n[l];
            l === n.length - 1 && n[0].x === f.x && n[0].y === f.y || (c.x += f.x, c.y += f.y, c.sampleCount++);
          }
        }
        function YE(c, n) {
          return c.x === n.x && (c.x < 0 || c.x > Ht) || c.y === n.y && (c.y < 0 || c.y > Ht);
        }
        function Rb(c) {
          return c.every(((n) => n.x < 0)) || c.every(((n) => n.x > Ht)) || c.every(((n) => n.y < 0)) || c.every(((n) => n.y > Ht));
        }
        let Pb;
        nt("FillExtrusionBucket", I_, { omit: ["layers", "features"] });
        var JE = { get paint() {
          return Pb = Pb || new zr({ "fill-extrusion-opacity": new dt(ve["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new yt(ve["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new dt(ve["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new dt(ve["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new hc(ve["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new yt(ve["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new yt(ve["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new dt(ve["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) });
        } };
        class QE extends _s {
          constructor(n) {
            super(n, JE);
          }
          createBucket(n) {
            return new I_(n);
          }
          queryRadius() {
            return sf(this.paint.get("fill-extrusion-translate"));
          }
          is3D() {
            return !0;
          }
          queryIntersectsFeature({ queryGeometry: n, feature: l, featureState: f, geometry: _, transform: b, pixelsToTileUnits: v, pixelPosMatrix: T }) {
            const A = nf(n, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -b.bearingInRadians, v), I = this.paint.get("fill-extrusion-height").evaluate(l, f), P = this.paint.get("fill-extrusion-base").evaluate(l, f), D = (function(V, j) {
              const G = [];
              for (const Z of V) {
                const te = [Z.x, Z.y, 0, 1];
                Et(te, te, j), G.push(new w(te[0] / te[3], te[1] / te[3]));
              }
              return G;
            })(A, T), U = (function(V, j, G, Z) {
              const te = [], me = [], ce = Z[8] * j, de = Z[9] * j, Re = Z[10] * j, ke = Z[11] * j, je = Z[8] * G, it = Z[9] * G, Xe = Z[10] * G, Qe = Z[11] * G;
              for (const pt of V) {
                const Ye = [], et = [];
                for (const Ue of pt) {
                  const xt = Ue.x, At = Ue.y, gt = Z[0] * xt + Z[4] * At + Z[12], ut = Z[1] * xt + Z[5] * At + Z[13], Ut = Z[2] * xt + Z[6] * At + Z[14], Ci = Z[3] * xt + Z[7] * At + Z[15], tr = Ut + Re, Rr = Ci + ke, Vs = gt + je, as = ut + it, vr = Ut + Xe, xi = Ci + Qe, hr = new w((gt + ce) / Rr, (ut + de) / Rr);
                  hr.z = tr / Rr, Ye.push(hr);
                  const xr = new w(Vs / xi, as / xi);
                  xr.z = vr / xi, et.push(xr);
                }
                te.push(Ye), me.push(et);
              }
              return [te, me];
            })(_, P, I, T);
            return (function(V, j, G) {
              let Z = 1 / 0;
              nb(G, j) && (Z = Bb(G, j[0]));
              for (let te = 0; te < j.length; te++) {
                const me = j[te], ce = V[te];
                for (let de = 0; de < me.length - 1; de++) {
                  const Re = me[de], ke = [Re, me[de + 1], ce[de + 1], ce[de], Re];
                  sb(G, ke) && (Z = Math.min(Z, Bb(G, ke)));
                }
              }
              return Z !== 1 / 0 && Z;
            })(U[0], U[1], D);
          }
        }
        function _u(c, n) {
          return c.x * n.x + c.y * n.y;
        }
        function Bb(c, n) {
          if (c.length === 1) {
            let l = 0;
            const f = n[l++];
            let _;
            for (; !_ || f.equals(_); ) if (_ = n[l++], !_) return 1 / 0;
            for (; l < n.length; l++) {
              const b = n[l], v = c[0], T = _.sub(f), A = b.sub(f), I = v.sub(f), P = _u(T, T), D = _u(T, A), U = _u(A, A), V = _u(I, T), j = _u(I, A), G = P * U - D * D, Z = (U * V - D * j) / G, te = (P * j - D * V) / G, me = f.z * (1 - Z - te) + _.z * Z + b.z * te;
              if (isFinite(me)) return me;
            }
            return 1 / 0;
          }
          {
            let l = 1 / 0;
            for (const f of n) l = Math.min(l, f.z);
            return l;
          }
        }
        const eS = Di([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: tS } = eS, iS = Di([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: rS } = iS, sS = Math.cos(Math.PI / 180 * 37.5), Db = Math.pow(2, 14) / 0.5;
        class M_ {
          constructor(n) {
            this.zoom = n.zoom, this.globalState = n.globalState, this.overscaling = n.overscaling, this.layers = n.layers, this.layerIds = this.layers.map(((l) => l.id)), this.index = n.index, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(((l) => {
              this.gradients[l.id] = {};
            })), this.layoutVertexArray = new Me(), this.layoutVertexArray2 = new Oe(), this.indexArray = new ti(), this.programConfigurations = new ns(n.layers, n.zoom), this.segments = new Rt(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter(((l) => l.isStateDependent())).map(((l) => l.id));
          }
          populate(n, l, f) {
            this.hasPattern = w_("line", this.layers, l);
            const _ = this.layers[0].layout.get("line-sort-key"), b = !_.isConstant(), v = [];
            for (const { feature: T, id: A, index: I, sourceLayerIndex: P } of n) {
              const D = this.layers[0]._featureFilter.needGeometry, U = xn(T, D);
              if (!this.layers[0]._featureFilter.filter(new gi(this.zoom, { globalState: this.globalState }), U, f)) continue;
              const V = b ? _.evaluate(U, {}, f) : void 0, j = { id: A, properties: T.properties, type: T.type, sourceLayerIndex: P, index: I, geometry: D ? U.geometry : Kn(T), patterns: {}, sortKey: V };
              v.push(j);
            }
            b && v.sort(((T, A) => T.sortKey - A.sortKey));
            for (const T of v) {
              const { geometry: A, index: I, sourceLayerIndex: P } = T;
              if (this.hasPattern) {
                const D = T_("line", this.layers, T, this.zoom, l);
                this.patternFeatures.push(D);
              } else this.addFeature(T, A, I, f, {}, l.subdivisionGranularity);
              l.featureIndex.insert(n[I].feature, A, I, P, this.index);
            }
          }
          update(n, l, f) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(n, l, this.stateDependentLayers, f);
          }
          addFeatures(n, l, f) {
            for (const _ of this.patternFeatures) this.addFeature(_, _.geometry, _.index, l, f, n.subdivisionGranularity);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(n) {
            this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = n.createVertexBuffer(this.layoutVertexArray2, rS)), this.layoutVertexBuffer = n.createVertexBuffer(this.layoutVertexArray, tS), this.indexBuffer = n.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(n), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          lineFeatureClips(n) {
            if (n.properties && Object.prototype.hasOwnProperty.call(n.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(n.properties, "mapbox_clip_end")) return { start: +n.properties.mapbox_clip_start, end: +n.properties.mapbox_clip_end };
          }
          addFeature(n, l, f, _, b, v) {
            const T = this.layers[0].layout, A = T.get("line-join").evaluate(n, {}), I = T.get("line-cap"), P = T.get("line-miter-limit"), D = T.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(n);
            for (const U of l) this.addLine(U, n, A, I, P, D, _, v);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, n, f, b, _);
          }
          addLine(n, l, f, _, b, v, T, A) {
            if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, n = hl(n, T ? A.line.getGranularityForZoomLevel(T.z) : 1), this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (let ce = 0; ce < n.length - 1; ce++) this.totalDistance += n[ce].dist(n[ce + 1]);
              this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
            }
            const I = xc.types[l.type] === "Polygon";
            let P = n.length;
            for (; P >= 2 && n[P - 1].equals(n[P - 2]); ) P--;
            let D = 0;
            for (; D < P - 1 && n[D].equals(n[D + 1]); ) D++;
            if (P < (I ? 3 : 2)) return;
            f === "bevel" && (b = 1.05);
            const U = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, V = this.segments.prepareSegment(10 * P, this.layoutVertexArray, this.indexArray);
            let j, G, Z, te, me;
            this.e1 = this.e2 = -1, I && (j = n[P - 2], me = n[D].sub(j)._unit()._perp());
            for (let ce = D; ce < P; ce++) {
              if (Z = ce === P - 1 ? I ? n[D + 1] : void 0 : n[ce + 1], Z && n[ce].equals(Z)) continue;
              me && (te = me), j && (G = j), j = n[ce], me = Z ? Z.sub(j)._unit()._perp() : te, te = te || me;
              let de = te.add(me);
              de.x === 0 && de.y === 0 || de._unit();
              const Re = te.x * me.x + te.y * me.y, ke = de.x * me.x + de.y * me.y, je = ke !== 0 ? 1 / ke : 1 / 0, it = 2 * Math.sqrt(2 - 2 * ke), Xe = ke < sS && G && Z, Qe = te.x * me.y - te.y * me.x > 0;
              if (Xe && ce > D) {
                const et = j.dist(G);
                if (et > 2 * U) {
                  const Ue = j.sub(j.sub(G)._mult(U / et)._round());
                  this.updateDistance(G, Ue), this.addCurrentVertex(Ue, te, 0, 0, V), G = Ue;
                }
              }
              const pt = G && Z;
              let Ye = pt ? f : I ? "butt" : _;
              if (pt && Ye === "round" && (je < v ? Ye = "miter" : je <= 2 && (Ye = "fakeround")), Ye === "miter" && je > b && (Ye = "bevel"), Ye === "bevel" && (je > 2 && (Ye = "flipbevel"), je < b && (Ye = "miter")), G && this.updateDistance(G, j), Ye === "miter") de._mult(je), this.addCurrentVertex(j, de, 0, 0, V);
              else if (Ye === "flipbevel") {
                if (je > 100) de = me.mult(-1);
                else {
                  const et = je * te.add(me).mag() / te.sub(me).mag();
                  de._perp()._mult(et * (Qe ? -1 : 1));
                }
                this.addCurrentVertex(j, de, 0, 0, V), this.addCurrentVertex(j, de.mult(-1), 0, 0, V);
              } else if (Ye === "bevel" || Ye === "fakeround") {
                const et = -Math.sqrt(je * je - 1), Ue = Qe ? et : 0, xt = Qe ? 0 : et;
                if (G && this.addCurrentVertex(j, te, Ue, xt, V), Ye === "fakeround") {
                  const At = Math.round(180 * it / Math.PI / 20);
                  for (let gt = 1; gt < At; gt++) {
                    let ut = gt / At;
                    if (ut !== 0.5) {
                      const Ci = ut - 0.5;
                      ut += ut * Ci * (ut - 1) * ((1.0904 + Re * (Re * (3.55645 - 1.43519 * Re) - 3.2452)) * Ci * Ci + (0.848013 + Re * (0.215638 * Re - 1.06021)));
                    }
                    const Ut = me.sub(te)._mult(ut)._add(te)._unit()._mult(Qe ? -1 : 1);
                    this.addHalfVertex(j, Ut.x, Ut.y, !1, Qe, 0, V);
                  }
                }
                Z && this.addCurrentVertex(j, me, -Ue, -xt, V);
              } else if (Ye === "butt") this.addCurrentVertex(j, de, 0, 0, V);
              else if (Ye === "square") {
                const et = G ? 1 : -1;
                this.addCurrentVertex(j, de, et, et, V);
              } else Ye === "round" && (G && (this.addCurrentVertex(j, te, 0, 0, V), this.addCurrentVertex(j, te, 1, 1, V, !0)), Z && (this.addCurrentVertex(j, me, -1, -1, V, !0), this.addCurrentVertex(j, me, 0, 0, V)));
              if (Xe && ce < P - 1) {
                const et = j.dist(Z);
                if (et > 2 * U) {
                  const Ue = j.add(Z.sub(j)._mult(U / et)._round());
                  this.updateDistance(j, Ue), this.addCurrentVertex(Ue, me, 0, 0, V), j = Ue;
                }
              }
            }
          }
          addCurrentVertex(n, l, f, _, b, v = !1) {
            const T = l.y * _ - l.x, A = -l.y - l.x * _;
            this.addHalfVertex(n, l.x + l.y * f, l.y - l.x * f, v, !1, f, b), this.addHalfVertex(n, T, A, v, !0, -_, b), this.distance > Db / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(n, l, f, _, b, v));
          }
          addHalfVertex({ x: n, y: l }, f, _, b, v, T, A) {
            const I = 0.5 * (this.lineClips ? this.scaledDistance * (Db - 1) : this.scaledDistance);
            this.layoutVertexArray.emplaceBack((n << 1) + (b ? 1 : 0), (l << 1) + (v ? 1 : 0), Math.round(63 * f) + 128, Math.round(63 * _) + 128, 1 + (T === 0 ? 0 : T < 0 ? -1 : 1) | (63 & I) << 2, I >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
            const P = A.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, P, this.e2), A.primitiveLength++), v ? this.e2 = P : this.e1 = P;
          }
          updateScaledDistance() {
            this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
          }
          updateDistance(n, l) {
            this.distance += n.dist(l), this.updateScaledDistance();
          }
        }
        let Ob, Fb;
        nt("LineBucket", M_, { omit: ["layers", "patternFeatures"] });
        var kb = { get paint() {
          return Fb = Fb || new zr({ "line-opacity": new yt(ve.paint_line["line-opacity"]), "line-color": new yt(ve.paint_line["line-color"]), "line-translate": new dt(ve.paint_line["line-translate"]), "line-translate-anchor": new dt(ve.paint_line["line-translate-anchor"]), "line-width": new yt(ve.paint_line["line-width"]), "line-gap-width": new yt(ve.paint_line["line-gap-width"]), "line-offset": new yt(ve.paint_line["line-offset"]), "line-blur": new yt(ve.paint_line["line-blur"]), "line-dasharray": new Gn(ve.paint_line["line-dasharray"]), "line-pattern": new hc(ve.paint_line["line-pattern"]), "line-gradient": new uc(ve.paint_line["line-gradient"]) });
        }, get layout() {
          return Ob = Ob || new zr({ "line-cap": new dt(ve.layout_line["line-cap"]), "line-join": new yt(ve.layout_line["line-join"]), "line-miter-limit": new dt(ve.layout_line["line-miter-limit"]), "line-round-limit": new dt(ve.layout_line["line-round-limit"]), "line-sort-key": new yt(ve.layout_line["line-sort-key"]) });
        } };
        class nS extends yt {
          possiblyEvaluate(n, l) {
            return l = new gi(Math.floor(l.zoom), { now: l.now, fadeDuration: l.fadeDuration, zoomHistory: l.zoomHistory, transition: l.transition }), super.possiblyEvaluate(n, l);
          }
          evaluate(n, l, f, _) {
            return l = ji({}, l, { zoom: Math.floor(l.zoom) }), super.evaluate(n, l, f, _);
          }
        }
        let cf;
        class oS extends _s {
          constructor(n) {
            super(n, kb), this.gradientVersion = 0, cf || (cf = new nS(kb.paint.properties["line-width"].specification), cf.useIntegerZoom = !0);
          }
          _handleSpecialPaintPropertyUpdate(n) {
            if (n === "line-gradient") {
              const l = this.gradientExpression();
              this.stepInterpolant = !!(function(f) {
                return f._styleExpression !== void 0;
              })(l) && l._styleExpression.expression instanceof Bi, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
            }
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression;
          }
          recalculate(n, l) {
            super.recalculate(n, l), this.paint._values["line-floorwidth"] = cf.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, n);
          }
          createBucket(n) {
            return new M_(n);
          }
          queryRadius(n) {
            const l = n, f = Nb(ou("line-width", this, l), ou("line-gap-width", this, l)), _ = ou("line-offset", this, l);
            return f / 2 + Math.abs(_) + sf(this.paint.get("line-translate"));
          }
          queryIntersectsFeature({ queryGeometry: n, feature: l, featureState: f, geometry: _, transform: b, pixelsToTileUnits: v }) {
            const T = nf(n, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -b.bearingInRadians, v), A = v / 2 * Nb(this.paint.get("line-width").evaluate(l, f), this.paint.get("line-gap-width").evaluate(l, f)), I = this.paint.get("line-offset").evaluate(l, f);
            return I && (_ = (function(P, D) {
              const U = [];
              for (let V = 0; V < P.length; V++) {
                const j = P[V], G = [];
                for (let Z = 0; Z < j.length; Z++) {
                  const te = j[Z - 1], me = j[Z], ce = j[Z + 1], de = Z === 0 ? new w(0, 0) : me.sub(te)._unit()._perp(), Re = Z === j.length - 1 ? new w(0, 0) : ce.sub(me)._unit()._perp(), ke = de._add(Re)._unit(), je = ke.x * Re.x + ke.y * Re.y;
                  je !== 0 && ke._mult(1 / je), G.push(ke._mult(D)._add(me));
                }
                U.push(G);
              }
              return U;
            })(_, I * v)), (function(P, D, U) {
              for (let V = 0; V < D.length; V++) {
                const j = D[V];
                if (P.length >= 3) {
                  for (let G = 0; G < j.length; G++) if (mc(P, j[G])) return !0;
                }
                if (mE(P, j, U)) return !0;
              }
              return !1;
            })(T, _, A);
          }
          isTileClipped() {
            return !0;
          }
        }
        function Nb(c, n) {
          return n > 0 ? n + 2 * c : c;
        }
        const aS = Di([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), lS = Di([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
        Di([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
        const cS = Di([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_box_real", components: 2, type: "Int16" }]);
        Di([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
        const Lb = Di([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), hS = Di([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
        function uS(c, n, l) {
          return c.sections.forEach(((f) => {
            f.text = (function(_, b, v) {
              const T = b.layout.get("text-transform").evaluate(v, {});
              return T === "uppercase" ? _ = _.toLocaleUpperCase() : T === "lowercase" && (_ = _.toLocaleLowerCase()), ks.applyArabicShaping && (_ = ks.applyArabicShaping(_)), _;
            })(f.text, n, l);
          })), c;
        }
        Di([{ name: "triangle", components: 3, type: "Uint16" }]), Di([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), Di([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]), Di([{ type: "Float32", name: "offsetX" }]), Di([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]), Di([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]);
        const gu = { "!": "︕", "#": "＃", $: "＄", "%": "％", "&": "＆", "(": "︵", ")": "︶", "*": "＊", "+": "＋", ",": "︐", "-": "︲", ".": "・", "/": "／", ":": "︓", ";": "︔", "<": "︿", "=": "＝", ">": "﹀", "?": "︖", "@": "＠", "[": "﹇", "\\": "＼", "]": "﹈", "^": "＾", _: "︳", "`": "｀", "{": "︷", "|": "―", "}": "︸", "~": "～", "¢": "￠", "£": "￡", "¥": "￥", "¦": "￤", "¬": "￢", "¯": "￣", "–": "︲", "—": "︱", "‘": "﹃", "’": "﹄", "“": "﹁", "”": "﹂", "…": "︙", "‧": "・", "₩": "￦", "、": "︑", "。": "︒", "〈": "︿", "〉": "﹀", "《": "︽", "》": "︾", "「": "﹁", "」": "﹂", "『": "﹃", "』": "﹄", "【": "︻", "】": "︼", "〔": "︹", "〕": "︺", "〖": "︗", "〗": "︘", "！": "︕", "（": "︵", "）": "︶", "，": "︐", "－": "︲", "．": "・", "：": "︓", "；": "︔", "＜": "︿", "＞": "﹀", "？": "︖", "［": "﹇", "］": "﹈", "＿": "︳", "｛": "︷", "｜": "―", "｝": "︸", "｟": "︵", "｠": "︶", "｡": "︒", "｢": "﹁", "｣": "﹂" };
        var cr = 24;
        const R_ = 4294967296, Ub = 1 / R_, zb = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
        class P_ {
          constructor(n = new Uint8Array(16)) {
            this.buf = ArrayBuffer.isView(n) ? n : new Uint8Array(n), this.dataView = new DataView(this.buf.buffer), this.pos = 0, this.type = 0, this.length = this.buf.length;
          }
          readFields(n, l, f = this.length) {
            for (; this.pos < f; ) {
              const _ = this.readVarint(), b = _ >> 3, v = this.pos;
              this.type = 7 & _, n(b, l, this), this.pos === v && this.skip(_);
            }
            return l;
          }
          readMessage(n, l) {
            return this.readFields(n, l, this.readVarint() + this.pos);
          }
          readFixed32() {
            const n = this.dataView.getUint32(this.pos, !0);
            return this.pos += 4, n;
          }
          readSFixed32() {
            const n = this.dataView.getInt32(this.pos, !0);
            return this.pos += 4, n;
          }
          readFixed64() {
            const n = this.dataView.getUint32(this.pos, !0) + this.dataView.getUint32(this.pos + 4, !0) * R_;
            return this.pos += 8, n;
          }
          readSFixed64() {
            const n = this.dataView.getUint32(this.pos, !0) + this.dataView.getInt32(this.pos + 4, !0) * R_;
            return this.pos += 8, n;
          }
          readFloat() {
            const n = this.dataView.getFloat32(this.pos, !0);
            return this.pos += 4, n;
          }
          readDouble() {
            const n = this.dataView.getFloat64(this.pos, !0);
            return this.pos += 8, n;
          }
          readVarint(n) {
            const l = this.buf;
            let f, _;
            return _ = l[this.pos++], f = 127 & _, _ < 128 ? f : (_ = l[this.pos++], f |= (127 & _) << 7, _ < 128 ? f : (_ = l[this.pos++], f |= (127 & _) << 14, _ < 128 ? f : (_ = l[this.pos++], f |= (127 & _) << 21, _ < 128 ? f : (_ = l[this.pos], f |= (15 & _) << 28, (function(b, v, T) {
              const A = T.buf;
              let I, P;
              if (P = A[T.pos++], I = (112 & P) >> 4, P < 128 || (P = A[T.pos++], I |= (127 & P) << 3, P < 128) || (P = A[T.pos++], I |= (127 & P) << 10, P < 128) || (P = A[T.pos++], I |= (127 & P) << 17, P < 128) || (P = A[T.pos++], I |= (127 & P) << 24, P < 128) || (P = A[T.pos++], I |= (1 & P) << 31, P < 128)) return wc(b, I, v);
              throw new Error("Expected varint not more than 10 bytes");
            })(f, n, this)))));
          }
          readVarint64() {
            return this.readVarint(!0);
          }
          readSVarint() {
            const n = this.readVarint();
            return n % 2 == 1 ? (n + 1) / -2 : n / 2;
          }
          readBoolean() {
            return !!this.readVarint();
          }
          readString() {
            const n = this.readVarint() + this.pos, l = this.pos;
            return this.pos = n, n - l >= 12 && zb ? zb.decode(this.buf.subarray(l, n)) : (function(f, _, b) {
              let v = "", T = _;
              for (; T < b; ) {
                const A = f[T];
                let I, P, D, U = null, V = A > 239 ? 4 : A > 223 ? 3 : A > 191 ? 2 : 1;
                if (T + V > b) break;
                V === 1 ? A < 128 && (U = A) : V === 2 ? (I = f[T + 1], (192 & I) == 128 && (U = (31 & A) << 6 | 63 & I, U <= 127 && (U = null))) : V === 3 ? (I = f[T + 1], P = f[T + 2], (192 & I) == 128 && (192 & P) == 128 && (U = (15 & A) << 12 | (63 & I) << 6 | 63 & P, (U <= 2047 || U >= 55296 && U <= 57343) && (U = null))) : V === 4 && (I = f[T + 1], P = f[T + 2], D = f[T + 3], (192 & I) == 128 && (192 & P) == 128 && (192 & D) == 128 && (U = (15 & A) << 18 | (63 & I) << 12 | (63 & P) << 6 | 63 & D, (U <= 65535 || U >= 1114112) && (U = null))), U === null ? (U = 65533, V = 1) : U > 65535 && (U -= 65536, v += String.fromCharCode(U >>> 10 & 1023 | 55296), U = 56320 | 1023 & U), v += String.fromCharCode(U), T += V;
              }
              return v;
            })(this.buf, l, n);
          }
          readBytes() {
            const n = this.readVarint() + this.pos, l = this.buf.subarray(this.pos, n);
            return this.pos = n, l;
          }
          readPackedVarint(n = [], l) {
            const f = this.readPackedEnd();
            for (; this.pos < f; ) n.push(this.readVarint(l));
            return n;
          }
          readPackedSVarint(n = []) {
            const l = this.readPackedEnd();
            for (; this.pos < l; ) n.push(this.readSVarint());
            return n;
          }
          readPackedBoolean(n = []) {
            const l = this.readPackedEnd();
            for (; this.pos < l; ) n.push(this.readBoolean());
            return n;
          }
          readPackedFloat(n = []) {
            const l = this.readPackedEnd();
            for (; this.pos < l; ) n.push(this.readFloat());
            return n;
          }
          readPackedDouble(n = []) {
            const l = this.readPackedEnd();
            for (; this.pos < l; ) n.push(this.readDouble());
            return n;
          }
          readPackedFixed32(n = []) {
            const l = this.readPackedEnd();
            for (; this.pos < l; ) n.push(this.readFixed32());
            return n;
          }
          readPackedSFixed32(n = []) {
            const l = this.readPackedEnd();
            for (; this.pos < l; ) n.push(this.readSFixed32());
            return n;
          }
          readPackedFixed64(n = []) {
            const l = this.readPackedEnd();
            for (; this.pos < l; ) n.push(this.readFixed64());
            return n;
          }
          readPackedSFixed64(n = []) {
            const l = this.readPackedEnd();
            for (; this.pos < l; ) n.push(this.readSFixed64());
            return n;
          }
          readPackedEnd() {
            return this.type === 2 ? this.readVarint() + this.pos : this.pos + 1;
          }
          skip(n) {
            const l = 7 & n;
            if (l === 0) for (; this.buf[this.pos++] > 127; ) ;
            else if (l === 2) this.pos = this.readVarint() + this.pos;
            else if (l === 5) this.pos += 4;
            else {
              if (l !== 1) throw new Error(`Unimplemented type: ${l}`);
              this.pos += 8;
            }
          }
          writeTag(n, l) {
            this.writeVarint(n << 3 | l);
          }
          realloc(n) {
            let l = this.length || 16;
            for (; l < this.pos + n; ) l *= 2;
            if (l !== this.length) {
              const f = new Uint8Array(l);
              f.set(this.buf), this.buf = f, this.dataView = new DataView(f.buffer), this.length = l;
            }
          }
          finish() {
            return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
          }
          writeFixed32(n) {
            this.realloc(4), this.dataView.setInt32(this.pos, n, !0), this.pos += 4;
          }
          writeSFixed32(n) {
            this.realloc(4), this.dataView.setInt32(this.pos, n, !0), this.pos += 4;
          }
          writeFixed64(n) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & n, !0), this.dataView.setInt32(this.pos + 4, Math.floor(n * Ub), !0), this.pos += 8;
          }
          writeSFixed64(n) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & n, !0), this.dataView.setInt32(this.pos + 4, Math.floor(n * Ub), !0), this.pos += 8;
          }
          writeVarint(n) {
            (n = +n || 0) > 268435455 || n < 0 ? (function(l, f) {
              let _, b;
              if (l >= 0 ? (_ = l % 4294967296 | 0, b = l / 4294967296 | 0) : (_ = ~(-l % 4294967296), b = ~(-l / 4294967296), 4294967295 ^ _ ? _ = _ + 1 | 0 : (_ = 0, b = b + 1 | 0)), l >= 18446744073709552e3 || l < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
              f.realloc(10), (function(v, T, A) {
                A.buf[A.pos++] = 127 & v | 128, v >>>= 7, A.buf[A.pos++] = 127 & v | 128, v >>>= 7, A.buf[A.pos++] = 127 & v | 128, v >>>= 7, A.buf[A.pos++] = 127 & v | 128, A.buf[A.pos] = 127 & (v >>>= 7);
              })(_, 0, f), (function(v, T) {
                const A = (7 & v) << 4;
                T.buf[T.pos++] |= A | ((v >>>= 3) ? 128 : 0), v && (T.buf[T.pos++] = 127 & v | ((v >>>= 7) ? 128 : 0), v && (T.buf[T.pos++] = 127 & v | ((v >>>= 7) ? 128 : 0), v && (T.buf[T.pos++] = 127 & v | ((v >>>= 7) ? 128 : 0), v && (T.buf[T.pos++] = 127 & v | ((v >>>= 7) ? 128 : 0), v && (T.buf[T.pos++] = 127 & v)))));
              })(b, f);
            })(n, this) : (this.realloc(4), this.buf[this.pos++] = 127 & n | (n > 127 ? 128 : 0), n <= 127 || (this.buf[this.pos++] = 127 & (n >>>= 7) | (n > 127 ? 128 : 0), n <= 127 || (this.buf[this.pos++] = 127 & (n >>>= 7) | (n > 127 ? 128 : 0), n <= 127 || (this.buf[this.pos++] = n >>> 7 & 127))));
          }
          writeSVarint(n) {
            this.writeVarint(n < 0 ? 2 * -n - 1 : 2 * n);
          }
          writeBoolean(n) {
            this.writeVarint(+n);
          }
          writeString(n) {
            n = String(n), this.realloc(4 * n.length), this.pos++;
            const l = this.pos;
            this.pos = (function(_, b, v) {
              for (let T, A, I = 0; I < b.length; I++) {
                if (T = b.charCodeAt(I), T > 55295 && T < 57344) {
                  if (!A) {
                    T > 56319 || I + 1 === b.length ? (_[v++] = 239, _[v++] = 191, _[v++] = 189) : A = T;
                    continue;
                  }
                  if (T < 56320) {
                    _[v++] = 239, _[v++] = 191, _[v++] = 189, A = T;
                    continue;
                  }
                  T = A - 55296 << 10 | T - 56320 | 65536, A = null;
                } else A && (_[v++] = 239, _[v++] = 191, _[v++] = 189, A = null);
                T < 128 ? _[v++] = T : (T < 2048 ? _[v++] = T >> 6 | 192 : (T < 65536 ? _[v++] = T >> 12 | 224 : (_[v++] = T >> 18 | 240, _[v++] = T >> 12 & 63 | 128), _[v++] = T >> 6 & 63 | 128), _[v++] = 63 & T | 128);
              }
              return v;
            })(this.buf, n, this.pos);
            const f = this.pos - l;
            f >= 128 && Vb(l, f, this), this.pos = l - 1, this.writeVarint(f), this.pos += f;
          }
          writeFloat(n) {
            this.realloc(4), this.dataView.setFloat32(this.pos, n, !0), this.pos += 4;
          }
          writeDouble(n) {
            this.realloc(8), this.dataView.setFloat64(this.pos, n, !0), this.pos += 8;
          }
          writeBytes(n) {
            const l = n.length;
            this.writeVarint(l), this.realloc(l);
            for (let f = 0; f < l; f++) this.buf[this.pos++] = n[f];
          }
          writeRawMessage(n, l) {
            this.pos++;
            const f = this.pos;
            n(l, this);
            const _ = this.pos - f;
            _ >= 128 && Vb(f, _, this), this.pos = f - 1, this.writeVarint(_), this.pos += _;
          }
          writeMessage(n, l, f) {
            this.writeTag(n, 2), this.writeRawMessage(l, f);
          }
          writePackedVarint(n, l) {
            l.length && this.writeMessage(n, dS, l);
          }
          writePackedSVarint(n, l) {
            l.length && this.writeMessage(n, fS, l);
          }
          writePackedBoolean(n, l) {
            l.length && this.writeMessage(n, gS, l);
          }
          writePackedFloat(n, l) {
            l.length && this.writeMessage(n, pS, l);
          }
          writePackedDouble(n, l) {
            l.length && this.writeMessage(n, _S, l);
          }
          writePackedFixed32(n, l) {
            l.length && this.writeMessage(n, mS, l);
          }
          writePackedSFixed32(n, l) {
            l.length && this.writeMessage(n, yS, l);
          }
          writePackedFixed64(n, l) {
            l.length && this.writeMessage(n, bS, l);
          }
          writePackedSFixed64(n, l) {
            l.length && this.writeMessage(n, vS, l);
          }
          writeBytesField(n, l) {
            this.writeTag(n, 2), this.writeBytes(l);
          }
          writeFixed32Field(n, l) {
            this.writeTag(n, 5), this.writeFixed32(l);
          }
          writeSFixed32Field(n, l) {
            this.writeTag(n, 5), this.writeSFixed32(l);
          }
          writeFixed64Field(n, l) {
            this.writeTag(n, 1), this.writeFixed64(l);
          }
          writeSFixed64Field(n, l) {
            this.writeTag(n, 1), this.writeSFixed64(l);
          }
          writeVarintField(n, l) {
            this.writeTag(n, 0), this.writeVarint(l);
          }
          writeSVarintField(n, l) {
            this.writeTag(n, 0), this.writeSVarint(l);
          }
          writeStringField(n, l) {
            this.writeTag(n, 2), this.writeString(l);
          }
          writeFloatField(n, l) {
            this.writeTag(n, 5), this.writeFloat(l);
          }
          writeDoubleField(n, l) {
            this.writeTag(n, 1), this.writeDouble(l);
          }
          writeBooleanField(n, l) {
            this.writeVarintField(n, +l);
          }
        }
        function wc(c, n, l) {
          return l ? 4294967296 * n + (c >>> 0) : 4294967296 * (n >>> 0) + (c >>> 0);
        }
        function Vb(c, n, l) {
          const f = n <= 16383 ? 1 : n <= 2097151 ? 2 : n <= 268435455 ? 3 : Math.floor(Math.log(n) / (7 * Math.LN2));
          l.realloc(f);
          for (let _ = l.pos - 1; _ >= c; _--) l.buf[_ + f] = l.buf[_];
        }
        function dS(c, n) {
          for (let l = 0; l < c.length; l++) n.writeVarint(c[l]);
        }
        function fS(c, n) {
          for (let l = 0; l < c.length; l++) n.writeSVarint(c[l]);
        }
        function pS(c, n) {
          for (let l = 0; l < c.length; l++) n.writeFloat(c[l]);
        }
        function _S(c, n) {
          for (let l = 0; l < c.length; l++) n.writeDouble(c[l]);
        }
        function gS(c, n) {
          for (let l = 0; l < c.length; l++) n.writeBoolean(c[l]);
        }
        function mS(c, n) {
          for (let l = 0; l < c.length; l++) n.writeFixed32(c[l]);
        }
        function yS(c, n) {
          for (let l = 0; l < c.length; l++) n.writeSFixed32(c[l]);
        }
        function bS(c, n) {
          for (let l = 0; l < c.length; l++) n.writeFixed64(c[l]);
        }
        function vS(c, n) {
          for (let l = 0; l < c.length; l++) n.writeSFixed64(c[l]);
        }
        function xS(c, n, l) {
          c === 1 && l.readMessage(wS, n);
        }
        function wS(c, n, l) {
          if (c === 3) {
            const { id: f, bitmap: _, width: b, height: v, left: T, top: A, advance: I } = l.readMessage(TS, {});
            n.push({ id: f, bitmap: new au({ width: b + 6, height: v + 6 }, _), metrics: { width: b, height: v, left: T, top: A, advance: I } });
          }
        }
        function TS(c, n, l) {
          c === 1 ? n.id = l.readVarint() : c === 2 ? n.bitmap = l.readBytes() : c === 3 ? n.width = l.readVarint() : c === 4 ? n.height = l.readVarint() : c === 5 ? n.left = l.readSVarint() : c === 6 ? n.top = l.readSVarint() : c === 7 && (n.advance = l.readVarint());
        }
        function jb(c) {
          let n = 0, l = 0;
          for (const v of c) n += v.w * v.h, l = Math.max(l, v.w);
          c.sort(((v, T) => T.h - v.h));
          const f = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(n / 0.95)), l), h: 1 / 0 }];
          let _ = 0, b = 0;
          for (const v of c) for (let T = f.length - 1; T >= 0; T--) {
            const A = f[T];
            if (!(v.w > A.w || v.h > A.h)) {
              if (v.x = A.x, v.y = A.y, b = Math.max(b, v.y + v.h), _ = Math.max(_, v.x + v.w), v.w === A.w && v.h === A.h) {
                const I = f.pop();
                I && T < f.length && (f[T] = I);
              } else v.h === A.h ? (A.x += v.w, A.w -= v.w) : v.w === A.w ? (A.y += v.h, A.h -= v.h) : (f.push({ x: A.x + v.w, y: A.y, w: A.w - v.w, h: v.h }), A.y += v.h, A.h -= v.h);
              break;
            }
          }
          return { w: _, h: b, fill: n / (_ * b) || 0 };
        }
        class B_ {
          constructor(n, { pixelRatio: l, version: f, stretchX: _, stretchY: b, content: v, textFitWidth: T, textFitHeight: A }) {
            this.paddedRect = n, this.pixelRatio = l, this.stretchX = _, this.stretchY = b, this.content = v, this.version = f, this.textFitWidth = T, this.textFitHeight = A;
          }
          get tl() {
            return [this.paddedRect.x + 1, this.paddedRect.y + 1];
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
          }
          get tlbr() {
            return this.tl.concat(this.br);
          }
          get displaySize() {
            return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
          }
        }
        class Hb {
          constructor(n, l) {
            const f = {}, _ = {};
            this.haveRenderCallbacks = [];
            const b = [];
            this.addImages(n, f, b), this.addImages(l, _, b);
            const { w: v, h: T } = jb(b), A = new os({ width: v || 1, height: T || 1 });
            for (const I in n) {
              const P = n[I], D = f[I].paddedRect;
              os.copy(P.data, A, { x: 0, y: 0 }, { x: D.x + 1, y: D.y + 1 }, P.data);
            }
            for (const I in l) {
              const P = l[I], D = _[I].paddedRect, U = D.x + 1, V = D.y + 1, j = P.data.width, G = P.data.height;
              os.copy(P.data, A, { x: 0, y: 0 }, { x: U, y: V }, P.data), os.copy(P.data, A, { x: 0, y: G - 1 }, { x: U, y: V - 1 }, { width: j, height: 1 }), os.copy(P.data, A, { x: 0, y: 0 }, { x: U, y: V + G }, { width: j, height: 1 }), os.copy(P.data, A, { x: j - 1, y: 0 }, { x: U - 1, y: V }, { width: 1, height: G }), os.copy(P.data, A, { x: 0, y: 0 }, { x: U + j, y: V }, { width: 1, height: G });
            }
            this.image = A, this.iconPositions = f, this.patternPositions = _;
          }
          addImages(n, l, f) {
            for (const _ in n) {
              const b = n[_], v = { x: 0, y: 0, w: b.data.width + 2, h: b.data.height + 2 };
              f.push(v), l[_] = new B_(v, b), b.hasRenderCallback && this.haveRenderCallbacks.push(_);
            }
          }
          patchUpdatedImages(n, l) {
            n.dispatchRenderCallbacks(this.haveRenderCallbacks);
            for (const f in n.updatedImages) this.patchUpdatedImage(this.iconPositions[f], n.getImage(f), l), this.patchUpdatedImage(this.patternPositions[f], n.getImage(f), l);
          }
          patchUpdatedImage(n, l, f) {
            if (!n || !l || n.version === l.version) return;
            n.version = l.version;
            const [_, b] = n.tl;
            f.update(l.data, void 0, { x: _, y: b });
          }
        }
        var la;
        nt("ImagePosition", B_), nt("ImageAtlas", Hb), d.ao = void 0, (la = d.ao || (d.ao = {}))[la.none = 0] = "none", la[la.horizontal = 1] = "horizontal", la[la.vertical = 2] = "vertical", la[la.horizontalOnly = 3] = "horizontalOnly";
        class mu {
          constructor() {
            this.scale = 1, this.fontStack = "", this.imageName = null, this.verticalAlign = "bottom";
          }
          static forText(n, l, f) {
            const _ = new mu();
            return _.scale = n || 1, _.fontStack = l, _.verticalAlign = f || "bottom", _;
          }
          static forImage(n, l) {
            const f = new mu();
            return f.imageName = n, f.verticalAlign = l || "bottom", f;
          }
        }
        class Tc {
          constructor() {
            this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
          }
          static fromFeature(n, l) {
            const f = new Tc();
            for (let _ = 0; _ < n.sections.length; _++) {
              const b = n.sections[_];
              b.image ? f.addImageSection(b) : f.addTextSection(b, l);
            }
            return f;
          }
          length() {
            return this.text.length;
          }
          getSection(n) {
            return this.sections[this.sectionIndex[n]];
          }
          getSectionIndex(n) {
            return this.sectionIndex[n];
          }
          getCharCode(n) {
            return this.text.charCodeAt(n);
          }
          verticalizePunctuation() {
            this.text = (function(n) {
              let l = "";
              for (let f = 0; f < n.length; f++) {
                const _ = n.charCodeAt(f + 1) || null, b = n.charCodeAt(f - 1) || null;
                l += _ && qd(_) && !gu[n[f + 1]] || b && qd(b) && !gu[n[f - 1]] || !gu[n[f]] ? n[f] : gu[n[f]];
              }
              return l;
            })(this.text);
          }
          trim() {
            let n = 0;
            for (let f = 0; f < this.text.length && uf[this.text.charCodeAt(f)]; f++) n++;
            let l = this.text.length;
            for (let f = this.text.length - 1; f >= 0 && f >= n && uf[this.text.charCodeAt(f)]; f--) l--;
            this.text = this.text.substring(n, l), this.sectionIndex = this.sectionIndex.slice(n, l);
          }
          substring(n, l) {
            const f = new Tc();
            return f.text = this.text.substring(n, l), f.sectionIndex = this.sectionIndex.slice(n, l), f.sections = this.sections, f;
          }
          toString() {
            return this.text;
          }
          getMaxScale() {
            return this.sectionIndex.reduce(((n, l) => Math.max(n, this.sections[l].scale)), 0);
          }
          getMaxImageSize(n) {
            let l = 0, f = 0;
            for (let _ = 0; _ < this.length(); _++) {
              const b = this.getSection(_);
              if (b.imageName) {
                const v = n[b.imageName];
                if (!v) continue;
                const T = v.displaySize;
                l = Math.max(l, T[0]), f = Math.max(f, T[1]);
              }
            }
            return { maxImageWidth: l, maxImageHeight: f };
          }
          addTextSection(n, l) {
            this.text += n.text, this.sections.push(mu.forText(n.scale, n.fontStack || l, n.verticalAlign));
            const f = this.sections.length - 1;
            for (let _ = 0; _ < n.text.length; ++_) this.sectionIndex.push(f);
          }
          addImageSection(n) {
            const l = n.image ? n.image.name : "";
            if (l.length === 0) return void ai("Can't add FormattedSection with an empty image.");
            const f = this.getNextImageSectionCharCode();
            f ? (this.text += String.fromCharCode(f), this.sections.push(mu.forImage(l, n.verticalAlign)), this.sectionIndex.push(this.sections.length - 1)) : ai("Reached maximum number of images 6401");
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
          }
        }
        function hf(c, n, l, f, _, b, v, T, A, I, P, D, U, V, j) {
          const G = Tc.fromFeature(c, _);
          let Z;
          D === d.ao.vertical && G.verticalizePunctuation();
          const { processBidirectionalText: te, processStyledBidirectionalText: me } = ks;
          if (te && G.sections.length === 1) {
            Z = [];
            const Re = te(G.toString(), D_(G, I, b, n, f, V));
            for (const ke of Re) {
              const je = new Tc();
              je.text = ke, je.sections = G.sections;
              for (let it = 0; it < ke.length; it++) je.sectionIndex.push(0);
              Z.push(je);
            }
          } else if (me) {
            Z = [];
            const Re = me(G.text, G.sectionIndex, D_(G, I, b, n, f, V));
            for (const ke of Re) {
              const je = new Tc();
              je.text = ke[0], je.sectionIndex = ke[1], je.sections = G.sections, Z.push(je);
            }
          } else Z = (function(Re, ke) {
            const je = [], it = Re.text;
            let Xe = 0;
            for (const Qe of ke) je.push(Re.substring(Xe, Qe)), Xe = Qe;
            return Xe < it.length && je.push(Re.substring(Xe, it.length)), je;
          })(G, D_(G, I, b, n, f, V));
          const ce = [], de = { positionedLines: ce, text: G.toString(), top: P[1], bottom: P[1], left: P[0], right: P[0], writingMode: D, iconsInText: !1, verticalizable: !1 };
          return (function(Re, ke, je, it, Xe, Qe, pt, Ye, et, Ue, xt, At) {
            let gt = 0, ut = 0, Ut = 0, Ci = 0;
            const tr = Ye === "right" ? 1 : Ye === "left" ? 0 : 0.5, Rr = cr / At;
            let Vs = 0;
            for (const xi of Xe) {
              xi.trim();
              const hr = xi.getMaxScale(), xr = { positionedGlyphs: [], lineOffset: 0 };
              Re.positionedLines[Vs] = xr;
              const wr = xr.positionedGlyphs;
              let Zr = 0;
              if (!xi.length()) {
                ut += Qe, ++Vs;
                continue;
              }
              const js = CS(it, xi, Rr);
              for (let ls = 0; ls < xi.length(); ls++) {
                const ir = xi.getSection(ls), dr = xi.getSectionIndex(ls), fr = xi.getCharCode(ls), Zi = IS(et, xt, fr);
                let di;
                if (ir.imageName) {
                  if (Re.iconsInText = !0, ir.scale = ir.scale * Rr, di = RS(ir, Zi, hr, js, it), !di) continue;
                  Zr = Math.max(Zr, di.imageOffset);
                } else if (di = MS(ir, fr, Zi, js, ke, je), !di) continue;
                const { rect: wn, metrics: Cc, baselineOffset: Tn } = di;
                wr.push({ glyph: fr, imageName: ir.imageName, x: gt, y: ut + Tn + -17, vertical: Zi, scale: ir.scale, fontStack: ir.fontStack, sectionIndex: dr, metrics: Cc, rect: wn }), Zi ? (Re.verticalizable = !0, gt += (ir.imageName ? Cc.advance : cr) * ir.scale + Ue) : gt += Cc.advance * ir.scale + Ue;
              }
              wr.length !== 0 && (Ut = Math.max(gt - Ue, Ut), PS(wr, 0, wr.length - 1, tr)), gt = 0, xr.lineOffset = Math.max(Zr, (hr - 1) * cr);
              const ur = Qe * hr + Zr;
              ut += ur, Ci = Math.max(ur, Ci), ++Vs;
            }
            const { horizontalAlign: as, verticalAlign: vr } = O_(pt);
            (function(xi, hr, xr, wr, Zr, js, ur, ls, ir) {
              const dr = (hr - xr) * Zr;
              let fr = 0;
              fr = js !== ur ? -ls * wr - -17 : -wr * ir * ur + 0.5 * ur;
              for (const Zi of xi) for (const di of Zi.positionedGlyphs) di.x += dr, di.y += fr;
            })(Re.positionedLines, tr, as, vr, Ut, Ci, Qe, ut, Xe.length), Re.top += -vr * ut, Re.bottom = Re.top + ut, Re.left += -as * Ut, Re.right = Re.left + Ut;
          })(de, n, l, f, Z, v, T, A, D, I, U, j), !(function(Re) {
            for (const ke of Re) if (ke.positionedGlyphs.length !== 0) return !1;
            return !0;
          })(ce) && de;
        }
        const uf = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 }, AS = { 10: !0, 32: !0, 38: !0, 41: !0, 43: !0, 45: !0, 47: !0, 173: !0, 183: !0, 8203: !0, 8208: !0, 8211: !0, 8231: !0 }, ES = { 40: !0 };
        function $b(c, n, l, f, _, b) {
          if (n.imageName) {
            const v = f[n.imageName];
            return v ? v.displaySize[0] * n.scale * cr / b + _ : 0;
          }
          {
            const v = l[n.fontStack], T = v && v[c];
            return T ? T.metrics.advance * n.scale + _ : 0;
          }
        }
        function Gb(c, n, l, f) {
          const _ = Math.pow(c - n, 2);
          return f ? c < n ? _ / 2 : 2 * _ : _ + Math.abs(l) * l;
        }
        function SS(c, n, l) {
          let f = 0;
          return c === 10 && (f -= 1e4), l && (f += 150), c !== 40 && c !== 65288 || (f += 50), n !== 41 && n !== 65289 || (f += 50), f;
        }
        function Wb(c, n, l, f, _, b) {
          let v = null, T = Gb(n, l, _, b);
          for (const A of f) {
            const I = Gb(n - A.x, l, _, b) + A.badness;
            I <= T && (v = A, T = I);
          }
          return { index: c, x: n, priorBreak: v, badness: T };
        }
        function Xb(c) {
          return c ? Xb(c.priorBreak).concat(c.index) : [];
        }
        function D_(c, n, l, f, _, b) {
          if (!c) return [];
          const v = [], T = (function(D, U, V, j, G, Z) {
            let te = 0;
            for (let me = 0; me < D.length(); me++) {
              const ce = D.getSection(me);
              te += $b(D.getCharCode(me), ce, j, G, U, Z);
            }
            return te / Math.max(1, Math.ceil(te / V));
          })(c, n, l, f, _, b), A = c.text.indexOf("​") >= 0;
          let I = 0;
          for (let D = 0; D < c.length(); D++) {
            const U = c.getSection(D), V = c.getCharCode(D);
            if (uf[V] || (I += $b(V, U, f, _, n, b)), D < c.length() - 1) {
              const j = !((P = V) < 11904) && (!!Lt["CJK Compatibility Forms"](P) || !!Lt["CJK Compatibility"](P) || !!Lt["CJK Strokes"](P) || !!Lt["CJK Symbols and Punctuation"](P) || !!Lt["Enclosed CJK Letters and Months"](P) || !!Lt["Halfwidth and Fullwidth Forms"](P) || !!Lt["Ideographic Description Characters"](P) || !!Lt["Vertical Forms"](P) || Zh.test(String.fromCodePoint(P)));
              (AS[V] || j || U.imageName || D !== c.length() - 2 && ES[c.getCharCode(D + 1)]) && v.push(Wb(D + 1, I, T, v, SS(V, c.getCharCode(D + 1), j && A), !1));
            }
          }
          var P;
          return Xb(Wb(c.length(), I, T, v, 0, !0));
        }
        function O_(c) {
          let n = 0.5, l = 0.5;
          switch (c) {
            case "right":
            case "top-right":
            case "bottom-right":
              n = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              n = 0;
          }
          switch (c) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              l = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              l = 0;
          }
          return { horizontalAlign: n, verticalAlign: l };
        }
        function CS(c, n, l) {
          const f = n.getMaxScale() * cr, { maxImageWidth: _, maxImageHeight: b } = n.getMaxImageSize(c), v = Math.max(f, b * l);
          return { verticalLineContentWidth: Math.max(f, _ * l), horizontalLineContentHeight: v };
        }
        function qb(c) {
          switch (c) {
            case "top":
              return 0;
            case "center":
              return 0.5;
            default:
              return 1;
          }
        }
        function IS(c, n, l) {
          return !(c === d.ao.horizontal || !n && !Kh(l) || n && (uf[l] || (f = l, new RegExp("\\p{sc=Arab}", "u").test(String.fromCodePoint(f)))));
          var f;
        }
        function MS(c, n, l, f, _, b) {
          const v = b[c.fontStack], T = (function(I, P, D, U) {
            if (I && I.rect) return I;
            const V = P[D.fontStack], j = V && V[U];
            return j ? { rect: null, metrics: j.metrics } : null;
          })(v && v[n], _, c, n);
          if (T === null) return null;
          let A;
          if (l) A = f.verticalLineContentWidth - c.scale * cr;
          else {
            const I = qb(c.verticalAlign);
            A = (f.horizontalLineContentHeight - c.scale * cr) * I;
          }
          return { rect: T.rect, metrics: T.metrics, baselineOffset: A };
        }
        function RS(c, n, l, f, _) {
          const b = _[c.imageName];
          if (!b) return null;
          const v = b.paddedRect, T = b.displaySize, A = { width: T[0], height: T[1], left: 1, top: -3, advance: n ? T[1] : T[0] };
          let I;
          if (n) I = f.verticalLineContentWidth - T[1] * c.scale;
          else {
            const P = qb(c.verticalAlign);
            I = (f.horizontalLineContentHeight - T[1] * c.scale) * P;
          }
          return { rect: v, metrics: A, baselineOffset: I, imageOffset: (n ? T[0] : T[1]) * c.scale - cr * l };
        }
        function PS(c, n, l, f) {
          if (f === 0) return;
          const _ = c[l], b = (c[l].x + _.metrics.advance * _.scale) * f;
          for (let v = n; v <= l; v++) c[v].x -= b;
        }
        function BS(c, n, l) {
          const { horizontalAlign: f, verticalAlign: _ } = O_(l), b = n[0] - c.displaySize[0] * f, v = n[1] - c.displaySize[1] * _;
          return { image: c, top: v, bottom: v + c.displaySize[1], left: b, right: b + c.displaySize[0] };
        }
        function Zb(c) {
          var n, l;
          let f = c.left, _ = c.top, b = c.right - f, v = c.bottom - _;
          const T = (n = c.image.textFitWidth) !== null && n !== void 0 ? n : "stretchOrShrink", A = (l = c.image.textFitHeight) !== null && l !== void 0 ? l : "stretchOrShrink", I = (c.image.content[2] - c.image.content[0]) / (c.image.content[3] - c.image.content[1]);
          if (A === "proportional") {
            if (T === "stretchOnly" && b / v < I || T === "proportional") {
              const P = Math.ceil(v * I);
              f *= P / b, b = P;
            }
          } else if (T === "proportional" && A === "stretchOnly" && I !== 0 && b / v > I) {
            const P = Math.ceil(b / I);
            _ *= P / v, v = P;
          }
          return { x1: f, y1: _, x2: f + b, y2: _ + v };
        }
        function Kb(c, n, l, f, _, b) {
          const v = c.image;
          let T;
          if (v.content) {
            const Z = v.content, te = v.pixelRatio || 1;
            T = [Z[0] / te, Z[1] / te, v.displaySize[0] - Z[2] / te, v.displaySize[1] - Z[3] / te];
          }
          const A = n.left * b, I = n.right * b;
          let P, D, U, V;
          l === "width" || l === "both" ? (V = _[0] + A - f[3], D = _[0] + I + f[1]) : (V = _[0] + (A + I - v.displaySize[0]) / 2, D = V + v.displaySize[0]);
          const j = n.top * b, G = n.bottom * b;
          return l === "height" || l === "both" ? (P = _[1] + j - f[0], U = _[1] + G + f[2]) : (P = _[1] + (j + G - v.displaySize[1]) / 2, U = P + v.displaySize[1]), { image: v, top: P, right: D, bottom: U, left: V, collisionPadding: T };
        }
        const Io = 128, ca = 32640;
        function Yb(c, n) {
          const { expression: l } = n;
          if (l.kind === "constant") return { kind: "constant", layoutSize: l.evaluate(new gi(c + 1)) };
          if (l.kind === "source") return { kind: "source" };
          {
            const { zoomStops: f, interpolationType: _ } = l;
            let b = 0;
            for (; b < f.length && f[b] <= c; ) b++;
            b = Math.max(0, b - 1);
            let v = b;
            for (; v < f.length && f[v] < c + 1; ) v++;
            v = Math.min(f.length - 1, v);
            const T = f[b], A = f[v];
            return l.kind === "composite" ? { kind: "composite", minZoom: T, maxZoom: A, interpolationType: _ } : { kind: "camera", minZoom: T, maxZoom: A, minSize: l.evaluate(new gi(T)), maxSize: l.evaluate(new gi(A)), interpolationType: _ };
          }
        }
        function F_(c, n, l) {
          let f = "never";
          const _ = c.get(n);
          return _ ? f = _ : c.get(l) && (f = "always"), f;
        }
        const DS = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
        function df(c, n, l, f, _, b, v, T, A, I, P, D, U) {
          const V = T ? Math.min(ca, Math.round(T[0])) : 0, j = T ? Math.min(ca, Math.round(T[1])) : 0;
          c.emplaceBack(n, l, Math.round(32 * f), Math.round(32 * _), b, v, (V << 1) + (A ? 1 : 0), j, 16 * I, 16 * P, 256 * D, 256 * U);
        }
        function k_(c, n, l) {
          c.emplaceBack(n.x, n.y, l), c.emplaceBack(n.x, n.y, l), c.emplaceBack(n.x, n.y, l), c.emplaceBack(n.x, n.y, l);
        }
        function OS(c) {
          for (const n of c.sections) if (Yd(n.text)) return !0;
          return !1;
        }
        class N_ {
          constructor(n) {
            this.layoutVertexArray = new qe(), this.indexArray = new ti(), this.programConfigurations = n, this.segments = new Rt(), this.dynamicLayoutVertexArray = new Ve(), this.opacityVertexArray = new ht(), this.hasVisibleVertices = !1, this.placedSymbolArray = new H();
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
          }
          upload(n, l, f, _) {
            this.isEmpty() || (f && (this.layoutVertexBuffer = n.createVertexBuffer(this.layoutVertexArray, aS.members), this.indexBuffer = n.createIndexBuffer(this.indexArray, l), this.dynamicLayoutVertexBuffer = n.createVertexBuffer(this.dynamicLayoutVertexArray, lS.members, !0), this.opacityVertexBuffer = n.createVertexBuffer(this.opacityVertexArray, DS, !0), this.opacityVertexBuffer.itemSize = 1), (f || _) && this.programConfigurations.upload(n));
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
          }
        }
        nt("SymbolBuffers", N_);
        class L_ {
          constructor(n, l, f) {
            this.layoutVertexArray = new n(), this.layoutAttributes = l, this.indexArray = new f(), this.segments = new Rt(), this.collisionVertexArray = new Wt();
          }
          upload(n) {
            this.layoutVertexBuffer = n.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = n.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = n.createVertexBuffer(this.collisionVertexArray, cS.members, !0);
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
          }
        }
        nt("CollisionBuffers", L_);
        class Ac {
          constructor(n) {
            this.collisionBoxArray = n.collisionBoxArray, this.zoom = n.zoom, this.globalState = n.globalState, this.overscaling = n.overscaling, this.layers = n.layers, this.layerIds = this.layers.map(((v) => v.id)), this.index = n.index, this.pixelRatio = n.pixelRatio, this.sourceLayerIndex = n.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [];
            const l = this.layers[0]._unevaluatedLayout._values;
            this.textSizeData = Yb(this.zoom, l["text-size"]), this.iconSizeData = Yb(this.zoom, l["icon-size"]);
            const f = this.layers[0].layout, _ = f.get("symbol-sort-key"), b = f.get("symbol-z-order");
            this.canOverlap = F_(f, "text-overlap", "text-allow-overlap") !== "never" || F_(f, "icon-overlap", "icon-allow-overlap") !== "never" || f.get("text-ignore-placement") || f.get("icon-ignore-placement"), this.sortFeaturesByKey = b !== "viewport-y" && !_.isConstant(), this.sortFeaturesByY = (b === "viewport-y" || b === "auto" && !this.sortFeaturesByKey) && this.canOverlap, f.get("symbol-placement") === "point" && (this.writingModes = f.get("text-writing-mode").map(((v) => d.ao[v]))), this.stateDependentLayerIds = this.layers.filter(((v) => v.isStateDependent())).map(((v) => v.id)), this.sourceID = n.sourceID;
          }
          createArrays() {
            this.text = new N_(new ns(this.layers, this.zoom, ((n) => /^text/.test(n)))), this.icon = new N_(new ns(this.layers, this.zoom, ((n) => /^icon/.test(n)))), this.glyphOffsetArray = new J(), this.lineVertexArray = new ie(), this.symbolInstances = new K(), this.textAnchorOffsets = new se();
          }
          calculateGlyphDependencies(n, l, f, _, b) {
            for (let v = 0; v < n.length; v++) if (l[n.charCodeAt(v)] = !0, (f || _) && b) {
              const T = gu[n.charAt(v)];
              T && (l[T.charCodeAt(0)] = !0);
            }
          }
          populate(n, l, f) {
            const _ = this.layers[0], b = _.layout, v = b.get("text-font"), T = b.get("text-field"), A = b.get("icon-image"), I = (T.value.kind !== "constant" || T.value.value instanceof Nr && !T.value.value.isEmpty() || T.value.value.toString().length > 0) && (v.value.kind !== "constant" || v.value.value.length > 0), P = A.value.kind !== "constant" || !!A.value.value || Object.keys(A.parameters).length > 0, D = b.get("symbol-sort-key");
            if (this.features = [], !I && !P) return;
            const U = l.iconDependencies, V = l.glyphDependencies, j = l.availableImages, G = new gi(this.zoom, { globalState: this.globalState });
            for (const { feature: Z, id: te, index: me, sourceLayerIndex: ce } of n) {
              const de = _._featureFilter.needGeometry, Re = xn(Z, de);
              if (!_._featureFilter.filter(G, Re, f)) continue;
              let ke, je;
              if (de || (Re.geometry = Kn(Z)), I) {
                const Xe = _.getValueAndResolveTokens("text-field", Re, f, j), Qe = Nr.factory(Xe), pt = this.hasRTLText = this.hasRTLText || OS(Qe);
                (!pt || ks.getRTLTextPluginStatus() === "unavailable" || pt && ks.isParsed()) && (ke = uS(Qe, _, Re));
              }
              if (P) {
                const Xe = _.getValueAndResolveTokens("icon-image", Re, f, j);
                je = Xe instanceof rs ? Xe : rs.fromString(Xe);
              }
              if (!ke && !je) continue;
              const it = this.sortFeaturesByKey ? D.evaluate(Re, {}, f) : void 0;
              if (this.features.push({ id: te, text: ke, icon: je, index: me, sourceLayerIndex: ce, geometry: Re.geometry, properties: Z.properties, type: xc.types[Z.type], sortKey: it }), je && (U[je.name] = !0), ke) {
                const Xe = v.evaluate(Re, {}, f).join(","), Qe = b.get("text-rotation-alignment") !== "viewport" && b.get("symbol-placement") !== "point";
                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(d.ao.vertical) >= 0;
                for (const pt of ke.sections) if (pt.image) U[pt.image.name] = !0;
                else {
                  const Ye = ac(ke.toString()), et = pt.fontStack || Xe, Ue = V[et] = V[et] || {};
                  this.calculateGlyphDependencies(pt.text, Ue, Qe, this.allowVerticalPlacement, Ye);
                }
              }
            }
            b.get("symbol-placement") === "line" && (this.features = (function(Z) {
              const te = {}, me = {}, ce = [];
              let de = 0;
              function Re(Xe) {
                ce.push(Z[Xe]), de++;
              }
              function ke(Xe, Qe, pt) {
                const Ye = me[Xe];
                return delete me[Xe], me[Qe] = Ye, ce[Ye].geometry[0].pop(), ce[Ye].geometry[0] = ce[Ye].geometry[0].concat(pt[0]), Ye;
              }
              function je(Xe, Qe, pt) {
                const Ye = te[Qe];
                return delete te[Qe], te[Xe] = Ye, ce[Ye].geometry[0].shift(), ce[Ye].geometry[0] = pt[0].concat(ce[Ye].geometry[0]), Ye;
              }
              function it(Xe, Qe, pt) {
                const Ye = pt ? Qe[0][Qe[0].length - 1] : Qe[0][0];
                return `${Xe}:${Ye.x}:${Ye.y}`;
              }
              for (let Xe = 0; Xe < Z.length; Xe++) {
                const Qe = Z[Xe], pt = Qe.geometry, Ye = Qe.text ? Qe.text.toString() : null;
                if (!Ye) {
                  Re(Xe);
                  continue;
                }
                const et = it(Ye, pt), Ue = it(Ye, pt, !0);
                if (et in me && Ue in te && me[et] !== te[Ue]) {
                  const xt = je(et, Ue, pt), At = ke(et, Ue, ce[xt].geometry);
                  delete te[et], delete me[Ue], me[it(Ye, ce[At].geometry, !0)] = At, ce[xt].geometry = null;
                } else et in me ? ke(et, Ue, pt) : Ue in te ? je(et, Ue, pt) : (Re(Xe), te[et] = de - 1, me[Ue] = de - 1);
              }
              return ce.filter(((Xe) => Xe.geometry));
            })(this.features)), this.sortFeaturesByKey && this.features.sort(((Z, te) => Z.sortKey - te.sortKey));
          }
          update(n, l, f) {
            this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(n, l, this.layers, f), this.icon.programConfigurations.updatePaintArrays(n, l, this.layers, f));
          }
          isEmpty() {
            return this.symbolInstances.length === 0 && !this.hasRTLText;
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
          }
          upload(n) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(n), this.iconCollisionBox.upload(n)), this.text.upload(n, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(n, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
          }
          addToLineVertexArray(n, l) {
            const f = this.lineVertexArray.length;
            if (n.segment !== void 0) {
              let _ = n.dist(l[n.segment + 1]), b = n.dist(l[n.segment]);
              const v = {};
              for (let T = n.segment + 1; T < l.length; T++) v[T] = { x: l[T].x, y: l[T].y, tileUnitDistanceFromAnchor: _ }, T < l.length - 1 && (_ += l[T + 1].dist(l[T]));
              for (let T = n.segment || 0; T >= 0; T--) v[T] = { x: l[T].x, y: l[T].y, tileUnitDistanceFromAnchor: b }, T > 0 && (b += l[T - 1].dist(l[T]));
              for (let T = 0; T < l.length; T++) {
                const A = v[T];
                this.lineVertexArray.emplaceBack(A.x, A.y, A.tileUnitDistanceFromAnchor);
              }
            }
            return { lineStartIndex: f, lineLength: this.lineVertexArray.length - f };
          }
          addSymbols(n, l, f, _, b, v, T, A, I, P, D, U) {
            const V = n.indexArray, j = n.layoutVertexArray, G = n.segments.prepareSegment(4 * l.length, j, V, this.canOverlap ? v.sortKey : void 0), Z = this.glyphOffsetArray.length, te = G.vertexLength, me = this.allowVerticalPlacement && T === d.ao.vertical ? Math.PI / 2 : 0, ce = v.text && v.text.sections;
            for (let de = 0; de < l.length; de++) {
              const { tl: Re, tr: ke, bl: je, br: it, tex: Xe, pixelOffsetTL: Qe, pixelOffsetBR: pt, minFontScaleX: Ye, minFontScaleY: et, glyphOffset: Ue, isSDF: xt, sectionIndex: At } = l[de], gt = G.vertexLength, ut = Ue[1];
              df(j, A.x, A.y, Re.x, ut + Re.y, Xe.x, Xe.y, f, xt, Qe.x, Qe.y, Ye, et), df(j, A.x, A.y, ke.x, ut + ke.y, Xe.x + Xe.w, Xe.y, f, xt, pt.x, Qe.y, Ye, et), df(j, A.x, A.y, je.x, ut + je.y, Xe.x, Xe.y + Xe.h, f, xt, Qe.x, pt.y, Ye, et), df(j, A.x, A.y, it.x, ut + it.y, Xe.x + Xe.w, Xe.y + Xe.h, f, xt, pt.x, pt.y, Ye, et), k_(n.dynamicLayoutVertexArray, A, me), V.emplaceBack(gt, gt + 2, gt + 1), V.emplaceBack(gt + 1, gt + 2, gt + 3), G.vertexLength += 4, G.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(Ue[0]), de !== l.length - 1 && At === l[de + 1].sectionIndex || n.programConfigurations.populatePaintArrays(j.length, v, v.index, {}, U, ce && ce[At]);
            }
            n.placedSymbolArray.emplaceBack(A.x, A.y, Z, this.glyphOffsetArray.length - Z, te, I, P, A.segment, f ? f[0] : 0, f ? f[1] : 0, _[0], _[1], T, 0, !1, 0, D);
          }
          _addCollisionDebugVertex(n, l, f, _, b, v) {
            return l.emplaceBack(0, 0), n.emplaceBack(f.x, f.y, _, b, Math.round(v.x), Math.round(v.y));
          }
          addCollisionDebugVertices(n, l, f, _, b, v, T) {
            const A = b.segments.prepareSegment(4, b.layoutVertexArray, b.indexArray), I = A.vertexLength, P = b.layoutVertexArray, D = b.collisionVertexArray, U = T.anchorX, V = T.anchorY;
            this._addCollisionDebugVertex(P, D, v, U, V, new w(n, l)), this._addCollisionDebugVertex(P, D, v, U, V, new w(f, l)), this._addCollisionDebugVertex(P, D, v, U, V, new w(f, _)), this._addCollisionDebugVertex(P, D, v, U, V, new w(n, _)), A.vertexLength += 4;
            const j = b.indexArray;
            j.emplaceBack(I, I + 1), j.emplaceBack(I + 1, I + 2), j.emplaceBack(I + 2, I + 3), j.emplaceBack(I + 3, I), A.primitiveLength += 4;
          }
          addDebugCollisionBoxes(n, l, f, _) {
            for (let b = n; b < l; b++) {
              const v = this.collisionBoxArray.get(b);
              this.addCollisionDebugVertices(v.x1, v.y1, v.x2, v.y2, _ ? this.textCollisionBox : this.iconCollisionBox, v.anchorPoint, f);
            }
          }
          generateCollisionDebugBuffers() {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new L_(Bt, Lb.members, Yt), this.iconCollisionBox = new L_(Bt, Lb.members, Yt);
            for (let n = 0; n < this.symbolInstances.length; n++) {
              const l = this.symbolInstances.get(n);
              this.addDebugCollisionBoxes(l.textBoxStartIndex, l.textBoxEndIndex, l, !0), this.addDebugCollisionBoxes(l.verticalTextBoxStartIndex, l.verticalTextBoxEndIndex, l, !0), this.addDebugCollisionBoxes(l.iconBoxStartIndex, l.iconBoxEndIndex, l, !1), this.addDebugCollisionBoxes(l.verticalIconBoxStartIndex, l.verticalIconBoxEndIndex, l, !1);
            }
          }
          _deserializeCollisionBoxesForSymbol(n, l, f, _, b, v, T, A, I) {
            const P = {};
            for (let D = l; D < f; D++) {
              const U = n.get(D);
              P.textBox = { x1: U.x1, y1: U.y1, x2: U.x2, y2: U.y2, anchorPointX: U.anchorPointX, anchorPointY: U.anchorPointY }, P.textFeatureIndex = U.featureIndex;
              break;
            }
            for (let D = _; D < b; D++) {
              const U = n.get(D);
              P.verticalTextBox = { x1: U.x1, y1: U.y1, x2: U.x2, y2: U.y2, anchorPointX: U.anchorPointX, anchorPointY: U.anchorPointY }, P.verticalTextFeatureIndex = U.featureIndex;
              break;
            }
            for (let D = v; D < T; D++) {
              const U = n.get(D);
              P.iconBox = { x1: U.x1, y1: U.y1, x2: U.x2, y2: U.y2, anchorPointX: U.anchorPointX, anchorPointY: U.anchorPointY }, P.iconFeatureIndex = U.featureIndex;
              break;
            }
            for (let D = A; D < I; D++) {
              const U = n.get(D);
              P.verticalIconBox = { x1: U.x1, y1: U.y1, x2: U.x2, y2: U.y2, anchorPointX: U.anchorPointX, anchorPointY: U.anchorPointY }, P.verticalIconFeatureIndex = U.featureIndex;
              break;
            }
            return P;
          }
          deserializeCollisionBoxes(n) {
            this.collisionArrays = [];
            for (let l = 0; l < this.symbolInstances.length; l++) {
              const f = this.symbolInstances.get(l);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(n, f.textBoxStartIndex, f.textBoxEndIndex, f.verticalTextBoxStartIndex, f.verticalTextBoxEndIndex, f.iconBoxStartIndex, f.iconBoxEndIndex, f.verticalIconBoxStartIndex, f.verticalIconBoxEndIndex));
            }
          }
          hasTextData() {
            return this.text.segments.get().length > 0;
          }
          hasIconData() {
            return this.icon.segments.get().length > 0;
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox;
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
          }
          addIndicesForPlacedSymbol(n, l) {
            const f = n.placedSymbolArray.get(l), _ = f.vertexStartIndex + 4 * f.numGlyphs;
            for (let b = f.vertexStartIndex; b < _; b += 4) n.indexArray.emplaceBack(b, b + 2, b + 1), n.indexArray.emplaceBack(b + 1, b + 2, b + 3);
          }
          getSortedSymbolIndexes(n) {
            if (this.sortedAngle === n && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
            const l = Math.sin(n), f = Math.cos(n), _ = [], b = [], v = [];
            for (let T = 0; T < this.symbolInstances.length; ++T) {
              v.push(T);
              const A = this.symbolInstances.get(T);
              _.push(0 | Math.round(l * A.anchorX + f * A.anchorY)), b.push(A.featureIndex);
            }
            return v.sort(((T, A) => _[T] - _[A] || b[A] - b[T])), v;
          }
          addToSortKeyRanges(n, l) {
            const f = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            f && f.sortKey === l ? f.symbolInstanceEnd = n + 1 : this.sortKeyRanges.push({ sortKey: l, symbolInstanceStart: n, symbolInstanceEnd: n + 1 });
          }
          sortFeatures(n) {
            if (this.sortFeaturesByY && this.sortedAngle !== n && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(n), this.sortedAngle = n, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (const l of this.symbolInstanceIndexes) {
                const f = this.symbolInstances.get(l);
                this.featureSortOrder.push(f.featureIndex), [f.rightJustifiedTextSymbolIndex, f.centerJustifiedTextSymbolIndex, f.leftJustifiedTextSymbolIndex].forEach(((_, b, v) => {
                  _ >= 0 && v.indexOf(_) === b && this.addIndicesForPlacedSymbol(this.text, _);
                })), f.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, f.verticalPlacedTextSymbolIndex), f.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, f.placedIconSymbolIndex), f.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, f.verticalPlacedIconSymbolIndex);
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
            }
          }
        }
        let Jb, Qb;
        nt("SymbolBucket", Ac, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), Ac.MAX_GLYPHS = 65535, Ac.addDynamicAttributes = k_;
        var U_ = { get paint() {
          return Qb = Qb || new zr({ "icon-opacity": new yt(ve.paint_symbol["icon-opacity"]), "icon-color": new yt(ve.paint_symbol["icon-color"]), "icon-halo-color": new yt(ve.paint_symbol["icon-halo-color"]), "icon-halo-width": new yt(ve.paint_symbol["icon-halo-width"]), "icon-halo-blur": new yt(ve.paint_symbol["icon-halo-blur"]), "icon-translate": new dt(ve.paint_symbol["icon-translate"]), "icon-translate-anchor": new dt(ve.paint_symbol["icon-translate-anchor"]), "text-opacity": new yt(ve.paint_symbol["text-opacity"]), "text-color": new yt(ve.paint_symbol["text-color"], { runtimeType: $i, getOverride: (c) => c.textColor, hasOverride: (c) => !!c.textColor }), "text-halo-color": new yt(ve.paint_symbol["text-halo-color"]), "text-halo-width": new yt(ve.paint_symbol["text-halo-width"]), "text-halo-blur": new yt(ve.paint_symbol["text-halo-blur"]), "text-translate": new dt(ve.paint_symbol["text-translate"]), "text-translate-anchor": new dt(ve.paint_symbol["text-translate-anchor"]) });
        }, get layout() {
          return Jb = Jb || new zr({ "symbol-placement": new dt(ve.layout_symbol["symbol-placement"]), "symbol-spacing": new dt(ve.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new dt(ve.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new yt(ve.layout_symbol["symbol-sort-key"]), "symbol-z-order": new dt(ve.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new dt(ve.layout_symbol["icon-allow-overlap"]), "icon-overlap": new dt(ve.layout_symbol["icon-overlap"]), "icon-ignore-placement": new dt(ve.layout_symbol["icon-ignore-placement"]), "icon-optional": new dt(ve.layout_symbol["icon-optional"]), "icon-rotation-alignment": new dt(ve.layout_symbol["icon-rotation-alignment"]), "icon-size": new yt(ve.layout_symbol["icon-size"]), "icon-text-fit": new dt(ve.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new dt(ve.layout_symbol["icon-text-fit-padding"]), "icon-image": new yt(ve.layout_symbol["icon-image"]), "icon-rotate": new yt(ve.layout_symbol["icon-rotate"]), "icon-padding": new yt(ve.layout_symbol["icon-padding"]), "icon-keep-upright": new dt(ve.layout_symbol["icon-keep-upright"]), "icon-offset": new yt(ve.layout_symbol["icon-offset"]), "icon-anchor": new yt(ve.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new dt(ve.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new dt(ve.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new dt(ve.layout_symbol["text-rotation-alignment"]), "text-field": new yt(ve.layout_symbol["text-field"]), "text-font": new yt(ve.layout_symbol["text-font"]), "text-size": new yt(ve.layout_symbol["text-size"]), "text-max-width": new yt(ve.layout_symbol["text-max-width"]), "text-line-height": new dt(ve.layout_symbol["text-line-height"]), "text-letter-spacing": new yt(ve.layout_symbol["text-letter-spacing"]), "text-justify": new yt(ve.layout_symbol["text-justify"]), "text-radial-offset": new yt(ve.layout_symbol["text-radial-offset"]), "text-variable-anchor": new dt(ve.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new yt(ve.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new yt(ve.layout_symbol["text-anchor"]), "text-max-angle": new dt(ve.layout_symbol["text-max-angle"]), "text-writing-mode": new dt(ve.layout_symbol["text-writing-mode"]), "text-rotate": new yt(ve.layout_symbol["text-rotate"]), "text-padding": new dt(ve.layout_symbol["text-padding"]), "text-keep-upright": new dt(ve.layout_symbol["text-keep-upright"]), "text-transform": new yt(ve.layout_symbol["text-transform"]), "text-offset": new yt(ve.layout_symbol["text-offset"]), "text-allow-overlap": new dt(ve.layout_symbol["text-allow-overlap"]), "text-overlap": new dt(ve.layout_symbol["text-overlap"]), "text-ignore-placement": new dt(ve.layout_symbol["text-ignore-placement"]), "text-optional": new dt(ve.layout_symbol["text-optional"]) });
        } };
        class e0 {
          constructor(n) {
            if (n.property.overrides === void 0) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
            this.type = n.property.overrides ? n.property.overrides.runtimeType : Un, this.defaultValue = n;
          }
          evaluate(n) {
            if (n.formattedSection) {
              const l = this.defaultValue.property.overrides;
              if (l && l.hasOverride(n.formattedSection)) return l.getOverride(n.formattedSection);
            }
            return n.feature && n.featureState ? this.defaultValue.evaluate(n.feature, n.featureState) : this.defaultValue.property.specification.default;
          }
          eachChild(n) {
            this.defaultValue.isConstant() || n(this.defaultValue.value._styleExpression.expression);
          }
          outputDefined() {
            return !1;
          }
          serialize() {
            return null;
          }
        }
        nt("FormatSectionOverride", e0, { omit: ["defaultValue"] });
        class ff extends _s {
          constructor(n) {
            super(n, U_);
          }
          recalculate(n, l) {
            if (super.recalculate(n, l), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
              const f = this.layout.get("text-writing-mode");
              if (f) {
                const _ = [];
                for (const b of f) _.indexOf(b) < 0 && _.push(b);
                this.layout._values["text-writing-mode"] = _;
              } else this.layout._values["text-writing-mode"] = ["horizontal"];
            }
            this._setPaintOverrides();
          }
          getValueAndResolveTokens(n, l, f, _) {
            const b = this.layout.get(n).evaluate(l, {}, f, _), v = this._unevaluatedLayout._values[n];
            return v.isDataDriven() || Ql(v.value) || !b ? b : (function(T, A) {
              return A.replace(/{([^{}]+)}/g, ((I, P) => T && P in T ? String(T[P]) : ""));
            })(l.properties, b);
          }
          createBucket(n) {
            return new Ac(n);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            throw new Error("Should take a different path in FeatureIndex");
          }
          _setPaintOverrides() {
            for (const n of U_.paint.overridableProperties) {
              if (!ff.hasPaintOverride(this.layout, n)) continue;
              const l = this.paint.get(n), f = new e0(l), _ = new Nh(f, l.property.specification);
              let b = null;
              b = l.value.kind === "constant" || l.value.kind === "source" ? new Ja("source", _) : new Lh("composite", _, l.value.zoomStops), this.paint._values[n] = new an(l.property, b, l.parameters);
            }
          }
          _handleOverridablePaintPropertyUpdate(n, l, f) {
            return !(!this.layout || l.isDataDriven() || f.isDataDriven()) && ff.hasPaintOverride(this.layout, n);
          }
          static hasPaintOverride(n, l) {
            const f = n.get("text-field"), _ = U_.paint.properties[l];
            let b = !1;
            const v = (T) => {
              for (const A of T) if (_.overrides && _.overrides.hasOverride(A)) return void (b = !0);
            };
            if (f.value.kind === "constant" && f.value.value instanceof Nr) v(f.value.value.sections);
            else if (f.value.kind === "source") {
              const T = (I) => {
                b || (I instanceof mn && vt(I.value) === is ? v(I.value.sections) : I instanceof po ? v(I.sections) : I.eachChild(T));
              }, A = f.value;
              A._styleExpression && T(A._styleExpression.expression);
            }
            return b;
          }
        }
        let t0;
        var FS = { get paint() {
          return t0 = t0 || new zr({ "background-color": new dt(ve.paint_background["background-color"]), "background-pattern": new Gn(ve.paint_background["background-pattern"]), "background-opacity": new dt(ve.paint_background["background-opacity"]) });
        } };
        class kS extends _s {
          constructor(n) {
            super(n, FS);
          }
        }
        let i0;
        var NS = { get paint() {
          return i0 = i0 || new zr({ "raster-opacity": new dt(ve.paint_raster["raster-opacity"]), "raster-hue-rotate": new dt(ve.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new dt(ve.paint_raster["raster-brightness-min"]), "raster-brightness-max": new dt(ve.paint_raster["raster-brightness-max"]), "raster-saturation": new dt(ve.paint_raster["raster-saturation"]), "raster-contrast": new dt(ve.paint_raster["raster-contrast"]), "raster-resampling": new dt(ve.paint_raster["raster-resampling"]), "raster-fade-duration": new dt(ve.paint_raster["raster-fade-duration"]) });
        } };
        class LS extends _s {
          constructor(n) {
            super(n, NS);
          }
        }
        class US extends _s {
          constructor(n) {
            super(n, {}), this.onAdd = (l) => {
              this.implementation.onAdd && this.implementation.onAdd(l, l.painter.context.gl);
            }, this.onRemove = (l) => {
              this.implementation.onRemove && this.implementation.onRemove(l, l.painter.context.gl);
            }, this.implementation = n;
          }
          is3D() {
            return this.implementation.renderingMode === "3d";
          }
          hasOffscreenPass() {
            return this.implementation.prerender !== void 0;
          }
          recalculate() {
          }
          updateTransitions() {
          }
          hasTransition() {
            return !1;
          }
          serialize() {
            throw new Error("Custom layers cannot be serialized");
          }
        }
        class zS {
          constructor(n) {
            this._methodToThrottle = n, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
              this._triggered = !1, this._methodToThrottle();
            });
          }
          trigger() {
            this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout((() => {
              this._triggered = !1, this._methodToThrottle();
            }), 0));
          }
          remove() {
            delete this._channel, this._methodToThrottle = () => {
            };
          }
        }
        const VS = { once: !0 }, z_ = 63710088e-1;
        class ha {
          constructor(n, l) {
            if (isNaN(n) || isNaN(l)) throw new Error(`Invalid LngLat object: (${n}, ${l})`);
            if (this.lng = +n, this.lat = +l, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
          }
          wrap() {
            return new ha(Ri(this.lng, -180, 180), this.lat);
          }
          toArray() {
            return [this.lng, this.lat];
          }
          toString() {
            return `LngLat(${this.lng}, ${this.lat})`;
          }
          distanceTo(n) {
            const l = Math.PI / 180, f = this.lat * l, _ = n.lat * l, b = Math.sin(f) * Math.sin(_) + Math.cos(f) * Math.cos(_) * Math.cos((n.lng - this.lng) * l);
            return z_ * Math.acos(Math.min(b, 1));
          }
          static convert(n) {
            if (n instanceof ha) return n;
            if (Array.isArray(n) && (n.length === 2 || n.length === 3)) return new ha(Number(n[0]), Number(n[1]));
            if (!Array.isArray(n) && typeof n == "object" && n !== null) return new ha(Number("lng" in n ? n.lng : n.lon), Number(n.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
          }
        }
        const r0 = 2 * Math.PI * z_;
        function s0(c) {
          return r0 * Math.cos(c * Math.PI / 180);
        }
        function n0(c) {
          return (180 + c) / 360;
        }
        function o0(c) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + c * Math.PI / 360))) / 360;
        }
        function a0(c, n) {
          return c / s0(n);
        }
        function V_(c) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * c) * Math.PI / 180)) - 90;
        }
        function l0(c, n) {
          return c * s0(V_(n));
        }
        class yu {
          constructor(n, l, f = 0) {
            this.x = +n, this.y = +l, this.z = +f;
          }
          static fromLngLat(n, l = 0) {
            const f = ha.convert(n);
            return new yu(n0(f.lng), o0(f.lat), a0(l, f.lat));
          }
          toLngLat() {
            return new ha(360 * this.x - 180, V_(this.y));
          }
          toAltitude() {
            return l0(this.z, this.y);
          }
          meterInMercatorCoordinateUnits() {
            return 1 / r0 * (n = V_(this.y), 1 / Math.cos(n * Math.PI / 180));
            var n;
          }
        }
        function c0(c, n, l) {
          var f = 2 * Math.PI * 6378137 / 256 / Math.pow(2, l);
          return [c * f - 2 * Math.PI * 6378137 / 2, n * f - 2 * Math.PI * 6378137 / 2];
        }
        class j_ {
          constructor(n, l, f) {
            if (!(function(_, b, v) {
              return !(_ < 0 || _ > 25 || v < 0 || v >= Math.pow(2, _) || b < 0 || b >= Math.pow(2, _));
            })(n, l, f)) throw new Error(`x=${l}, y=${f}, z=${n} outside of bounds. 0<=x<${Math.pow(2, n)}, 0<=y<${Math.pow(2, n)} 0<=z<=25 `);
            this.z = n, this.x = l, this.y = f, this.key = Ec(0, n, n, l, f);
          }
          equals(n) {
            return this.z === n.z && this.x === n.x && this.y === n.y;
          }
          url(n, l, f) {
            const _ = (v = this.y, T = this.z, A = c0(256 * (b = this.x), 256 * (v = Math.pow(2, T) - v - 1), T), I = c0(256 * (b + 1), 256 * (v + 1), T), A[0] + "," + A[1] + "," + I[0] + "," + I[1]);
            var b, v, T, A, I;
            const P = (function(D, U, V) {
              let j, G = "";
              for (let Z = D; Z > 0; Z--) j = 1 << Z - 1, G += (U & j ? 1 : 0) + (V & j ? 2 : 0);
              return G;
            })(this.z, this.x, this.y);
            return n[(this.x + this.y) % n.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(f === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, l > 1 ? "@2x" : "").replace(/{quadkey}/g, P).replace(/{bbox-epsg-3857}/g, _);
          }
          isChildOf(n) {
            const l = this.z - n.z;
            return l > 0 && n.x === this.x >> l && n.y === this.y >> l;
          }
          getTilePoint(n) {
            const l = Math.pow(2, this.z);
            return new w((n.x * l - this.x) * Ht, (n.y * l - this.y) * Ht);
          }
          toString() {
            return `${this.z}/${this.x}/${this.y}`;
          }
        }
        class h0 {
          constructor(n, l) {
            this.wrap = n, this.canonical = l, this.key = Ec(n, l.z, l.z, l.x, l.y);
          }
        }
        class zs {
          constructor(n, l, f, _, b) {
            if (this.terrainRttPosMatrix32f = null, n < f) throw new Error(`overscaledZ should be >= z; overscaledZ = ${n}; z = ${f}`);
            this.overscaledZ = n, this.wrap = l, this.canonical = new j_(f, +_, +b), this.key = Ec(l, n, f, _, b);
          }
          clone() {
            return new zs(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          equals(n) {
            return this.overscaledZ === n.overscaledZ && this.wrap === n.wrap && this.canonical.equals(n.canonical);
          }
          scaledTo(n) {
            if (n > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${n}; overscaledZ = ${this.overscaledZ}`);
            const l = this.canonical.z - n;
            return n > this.canonical.z ? new zs(n, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new zs(n, this.wrap, n, this.canonical.x >> l, this.canonical.y >> l);
          }
          calculateScaledKey(n, l) {
            if (n > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${n}; overscaledZ = ${this.overscaledZ}`);
            const f = this.canonical.z - n;
            return n > this.canonical.z ? Ec(this.wrap * +l, n, this.canonical.z, this.canonical.x, this.canonical.y) : Ec(this.wrap * +l, n, n, this.canonical.x >> f, this.canonical.y >> f);
          }
          isChildOf(n) {
            if (n.wrap !== this.wrap) return !1;
            const l = this.canonical.z - n.canonical.z;
            return n.overscaledZ === 0 || n.overscaledZ < this.overscaledZ && n.canonical.x === this.canonical.x >> l && n.canonical.y === this.canonical.y >> l;
          }
          children(n) {
            if (this.overscaledZ >= n) return [new zs(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            const l = this.canonical.z + 1, f = 2 * this.canonical.x, _ = 2 * this.canonical.y;
            return [new zs(l, this.wrap, l, f, _), new zs(l, this.wrap, l, f + 1, _), new zs(l, this.wrap, l, f, _ + 1), new zs(l, this.wrap, l, f + 1, _ + 1)];
          }
          isLessThan(n) {
            return this.wrap < n.wrap || !(this.wrap > n.wrap) && (this.overscaledZ < n.overscaledZ || !(this.overscaledZ > n.overscaledZ) && (this.canonical.x < n.canonical.x || !(this.canonical.x > n.canonical.x) && this.canonical.y < n.canonical.y));
          }
          wrapped() {
            return new zs(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          unwrapTo(n) {
            return new zs(this.overscaledZ, n, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z);
          }
          toUnwrapped() {
            return new h0(this.wrap, this.canonical);
          }
          toString() {
            return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
          }
          getTilePoint(n) {
            return this.canonical.getTilePoint(new yu(n.x - this.wrap, n.y));
          }
        }
        function Ec(c, n, l, f, _) {
          (c *= 2) < 0 && (c = -1 * c - 1);
          const b = 1 << l;
          return (b * b * c + b * _ + f).toString(36) + l.toString(36) + n.toString(36);
        }
        function bu(c, n) {
          return n ? c.properties[n] : c.id;
        }
        nt("CanonicalTileID", j_), nt("OverscaledTileID", zs, { omit: ["terrainRttPosMatrix32f"] });
        class ul {
          constructor() {
            this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0;
          }
          extend(n) {
            return this.minX = Math.min(this.minX, n.x), this.minY = Math.min(this.minY, n.y), this.maxX = Math.max(this.maxX, n.x), this.maxY = Math.max(this.maxY, n.y), this;
          }
          expandBy(n) {
            return this.minX -= n, this.minY -= n, this.maxX += n, this.maxY += n, (this.minX > this.maxX || this.minY > this.maxY) && (this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0), this;
          }
          shrinkBy(n) {
            return this.expandBy(-n);
          }
          map(n) {
            const l = new ul();
            return l.extend(n(new w(this.minX, this.minY))), l.extend(n(new w(this.maxX, this.minY))), l.extend(n(new w(this.minX, this.maxY))), l.extend(n(new w(this.maxX, this.maxY))), l;
          }
          static fromPoints(n) {
            const l = new ul();
            for (const f of n) l.extend(f);
            return l;
          }
          contains(n) {
            return n.x >= this.minX && n.x <= this.maxX && n.y >= this.minY && n.y <= this.maxY;
          }
          empty() {
            return this.minX > this.maxX;
          }
          width() {
            return this.maxX - this.minX;
          }
          height() {
            return this.maxY - this.minY;
          }
          covers(n) {
            return !this.empty() && !n.empty() && n.minX >= this.minX && n.maxX <= this.maxX && n.minY >= this.minY && n.maxY <= this.maxY;
          }
          intersects(n) {
            return !this.empty() && !n.empty() && n.minX <= this.maxX && n.maxX >= this.minX && n.minY <= this.maxY && n.maxY >= this.minY;
          }
        }
        class u0 {
          constructor(n) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let l = 0; l < n.length; l++) {
              const f = n[l];
              this._stringToNumber[f] = l, this._numberToString[l] = f;
            }
          }
          encode(n) {
            return this._stringToNumber[n];
          }
          decode(n) {
            if (n >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${n} can't be >= this._numberToString.length ${this._numberToString.length}`);
            return this._numberToString[n];
          }
        }
        class d0 {
          constructor(n, l, f, _, b) {
            this.type = "Feature", this._vectorTileFeature = n, n._z = l, n._x = f, n._y = _, this.properties = n.properties, this.id = b;
          }
          get geometry() {
            return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
          }
          set geometry(n) {
            this._geometry = n;
          }
          toJSON() {
            const n = { geometry: this.geometry };
            for (const l in this) l !== "_geometry" && l !== "_vectorTileFeature" && (n[l] = this[l]);
            return n;
          }
        }
        class f0 {
          constructor(n, l) {
            this.tileID = n, this.x = n.canonical.x, this.y = n.canonical.y, this.z = n.canonical.z, this.grid = new nl(Ht, 16, 0), this.grid3D = new nl(Ht, 16, 0), this.featureIndexArray = new fe(), this.promoteId = l;
          }
          insert(n, l, f, _, b, v) {
            const T = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(f, _, b);
            const A = v ? this.grid3D : this.grid;
            for (let I = 0; I < l.length; I++) {
              const P = l[I], D = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let U = 0; U < P.length; U++) {
                const V = P[U];
                D[0] = Math.min(D[0], V.x), D[1] = Math.min(D[1], V.y), D[2] = Math.max(D[2], V.x), D[3] = Math.max(D[3], V.y);
              }
              D[0] < Ht && D[1] < Ht && D[2] >= 0 && D[3] >= 0 && A.insert(T, D[0], D[1], D[2], D[3]);
            }
          }
          loadVTLayers() {
            return this.vtLayers || (this.vtLayers = new Mb(new P_(this.rawTileData)).layers, this.sourceLayerCoder = new u0(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
          }
          query(n, l, f, _) {
            this.loadVTLayers();
            const b = n.params, v = Ht / n.tileSize / n.scale, T = vo(b.filter), A = n.queryGeometry, I = n.queryPadding * v, P = ul.fromPoints(A), D = this.grid.query(P.minX - I, P.minY - I, P.maxX + I, P.maxY + I), U = ul.fromPoints(n.cameraQueryGeometry).expandBy(I), V = this.grid3D.query(U.minX, U.minY, U.maxX, U.maxY, ((Z, te, me, ce) => (function(de, Re, ke, je, it) {
              for (const Qe of de) if (Re <= Qe.x && ke <= Qe.y && je >= Qe.x && it >= Qe.y) return !0;
              const Xe = [new w(Re, ke), new w(Re, it), new w(je, it), new w(je, ke)];
              if (de.length > 2) {
                for (const Qe of Xe) if (mc(de, Qe)) return !0;
              }
              for (let Qe = 0; Qe < de.length - 1; Qe++) if (bE(de[Qe], de[Qe + 1], Xe)) return !0;
              return !1;
            })(n.cameraQueryGeometry, Z - I, te - I, me + I, ce + I)));
            for (const Z of V) D.push(Z);
            D.sort(jS);
            const j = {};
            let G;
            for (let Z = 0; Z < D.length; Z++) {
              const te = D[Z];
              if (te === G) continue;
              G = te;
              const me = this.featureIndexArray.get(te);
              let ce = null;
              this.loadMatchingFeature(j, me.bucketIndex, me.sourceLayerIndex, me.featureIndex, T, b.layers, b.availableImages, l, f, _, ((de, Re, ke) => (ce || (ce = Kn(de)), Re.queryIntersectsFeature({ queryGeometry: A, feature: de, featureState: ke, geometry: ce, zoom: this.z, transform: n.transform, pixelsToTileUnits: v, pixelPosMatrix: n.pixelPosMatrix, unwrappedTileID: this.tileID.toUnwrapped(), getElevation: n.getElevation }))));
            }
            return j;
          }
          loadMatchingFeature(n, l, f, _, b, v, T, A, I, P, D) {
            const U = this.bucketLayerIDs[l];
            if (v && !U.some(((Z) => v.has(Z)))) return;
            const V = this.sourceLayerCoder.decode(f), j = this.vtLayers[V].feature(_);
            if (b.needGeometry) {
              const Z = xn(j, !0);
              if (!b.filter(new gi(this.tileID.overscaledZ), Z, this.tileID.canonical)) return;
            } else if (!b.filter(new gi(this.tileID.overscaledZ), j)) return;
            const G = this.getId(j, V);
            for (let Z = 0; Z < U.length; Z++) {
              const te = U[Z];
              if (v && !v.has(te)) continue;
              const me = A[te];
              if (!me) continue;
              let ce = {};
              G && P && (ce = P.getState(me.sourceLayer || "_geojsonTileLayer", G));
              const de = ji({}, I[te]);
              de.paint = p0(de.paint, me.paint, j, ce, T), de.layout = p0(de.layout, me.layout, j, ce, T);
              const Re = !D || D(j, me, ce);
              if (!Re) continue;
              const ke = new d0(j, this.z, this.x, this.y, G);
              ke.layer = de;
              let je = n[te];
              je === void 0 && (je = n[te] = []), je.push({ featureIndex: _, feature: ke, intersectionZ: Re });
            }
          }
          lookupSymbolFeatures(n, l, f, _, b, v, T, A) {
            const I = {};
            this.loadVTLayers();
            const P = vo(b);
            for (const D of n) this.loadMatchingFeature(I, f, _, D, P, v, T, A, l);
            return I;
          }
          hasLayer(n) {
            for (const l of this.bucketLayerIDs) for (const f of l) if (n === f) return !0;
            return !1;
          }
          getId(n, l) {
            var f;
            let _ = n.id;
            return this.promoteId && (_ = n.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[l]], typeof _ == "boolean" && (_ = Number(_)), _ === void 0 && (!((f = n.properties) === null || f === void 0) && f.cluster) && this.promoteId && (_ = Number(n.properties.cluster_id))), _;
          }
        }
        function p0(c, n, l, f, _) {
          return Fi(c, ((b, v) => {
            const T = n instanceof cc ? n.get(v) : null;
            return T && T.evaluate ? T.evaluate(l, f, _) : T;
          }));
        }
        function jS(c, n) {
          return n - c;
        }
        function _0(c, n, l, f, _) {
          const b = [];
          for (let v = 0; v < c.length; v++) {
            const T = c[v];
            let A;
            for (let I = 0; I < T.length - 1; I++) {
              let P = T[I], D = T[I + 1];
              P.x < n && D.x < n || (P.x < n ? P = new w(n, P.y + (n - P.x) / (D.x - P.x) * (D.y - P.y))._round() : D.x < n && (D = new w(n, P.y + (n - P.x) / (D.x - P.x) * (D.y - P.y))._round()), P.y < l && D.y < l || (P.y < l ? P = new w(P.x + (l - P.y) / (D.y - P.y) * (D.x - P.x), l)._round() : D.y < l && (D = new w(P.x + (l - P.y) / (D.y - P.y) * (D.x - P.x), l)._round()), P.x >= f && D.x >= f || (P.x >= f ? P = new w(f, P.y + (f - P.x) / (D.x - P.x) * (D.y - P.y))._round() : D.x >= f && (D = new w(f, P.y + (f - P.x) / (D.x - P.x) * (D.y - P.y))._round()), P.y >= _ && D.y >= _ || (P.y >= _ ? P = new w(P.x + (_ - P.y) / (D.y - P.y) * (D.x - P.x), _)._round() : D.y >= _ && (D = new w(P.x + (_ - P.y) / (D.y - P.y) * (D.x - P.x), _)._round()), A && P.equals(A[A.length - 1]) || (A = [P], b.push(A)), A.push(D)))));
            }
          }
          return b;
        }
        nt("FeatureIndex", f0, { omit: ["rawTileData", "sourceLayerCoder"] });
        class ua extends w {
          constructor(n, l, f, _) {
            super(n, l), this.angle = f, _ !== void 0 && (this.segment = _);
          }
          clone() {
            return new ua(this.x, this.y, this.angle, this.segment);
          }
        }
        function g0(c, n, l, f, _) {
          if (n.segment === void 0 || l === 0) return !0;
          let b = n, v = n.segment + 1, T = 0;
          for (; T > -l / 2; ) {
            if (v--, v < 0) return !1;
            T -= c[v].dist(b), b = c[v];
          }
          T += c[v].dist(c[v + 1]), v++;
          const A = [];
          let I = 0;
          for (; T < l / 2; ) {
            const P = c[v], D = c[v + 1];
            if (!D) return !1;
            let U = c[v - 1].angleTo(P) - P.angleTo(D);
            for (U = Math.abs((U + 3 * Math.PI) % (2 * Math.PI) - Math.PI), A.push({ distance: T, angleDelta: U }), I += U; T - A[0].distance > f; ) I -= A.shift().angleDelta;
            if (I > _) return !1;
            v++, T += P.dist(D);
          }
          return !0;
        }
        function m0(c) {
          let n = 0;
          for (let l = 0; l < c.length - 1; l++) n += c[l].dist(c[l + 1]);
          return n;
        }
        function y0(c, n, l) {
          return c ? 0.6 * n * l : 0;
        }
        function b0(c, n) {
          return Math.max(c ? c.right - c.left : 0, n ? n.right - n.left : 0);
        }
        function HS(c, n, l, f, _, b) {
          const v = y0(l, _, b), T = b0(l, f) * b;
          let A = 0;
          const I = m0(c) / 2;
          for (let P = 0; P < c.length - 1; P++) {
            const D = c[P], U = c[P + 1], V = D.dist(U);
            if (A + V > I) {
              const j = (I - A) / V, G = nn.number(D.x, U.x, j), Z = nn.number(D.y, U.y, j), te = new ua(G, Z, U.angleTo(D), P);
              return te._round(), !v || g0(c, te, T, v, n) ? te : void 0;
            }
            A += V;
          }
        }
        function $S(c, n, l, f, _, b, v, T, A) {
          const I = y0(f, b, v), P = b0(f, _), D = P * v, U = c[0].x === 0 || c[0].x === A || c[0].y === 0 || c[0].y === A;
          return n - D < n / 4 && (n = D + n / 4), v0(c, U ? n / 2 * T % n : (P / 2 + 2 * b) * v * T % n, n, I, l, D, U, !1, A);
        }
        function v0(c, n, l, f, _, b, v, T, A) {
          const I = b / 2, P = m0(c);
          let D = 0, U = n - l, V = [];
          for (let j = 0; j < c.length - 1; j++) {
            const G = c[j], Z = c[j + 1], te = G.dist(Z), me = Z.angleTo(G);
            for (; U + l < D + te; ) {
              U += l;
              const ce = (U - D) / te, de = nn.number(G.x, Z.x, ce), Re = nn.number(G.y, Z.y, ce);
              if (de >= 0 && de < A && Re >= 0 && Re < A && U - I >= 0 && U + I <= P) {
                const ke = new ua(de, Re, me, j);
                ke._round(), f && !g0(c, ke, b, f, _) || V.push(ke);
              }
            }
            D += te;
          }
          return T || V.length || v || (V = v0(c, D / 2, l, f, _, b, v, !0, A)), V;
        }
        function x0(c, n, l, f) {
          const _ = [], b = c.image, v = b.pixelRatio, T = b.paddedRect.w - 2, A = b.paddedRect.h - 2;
          let I = { x1: c.left, y1: c.top, x2: c.right, y2: c.bottom };
          const P = b.stretchX || [[0, T]], D = b.stretchY || [[0, A]], U = (Ue, xt) => Ue + xt[1] - xt[0], V = P.reduce(U, 0), j = D.reduce(U, 0), G = T - V, Z = A - j;
          let te = 0, me = V, ce = 0, de = j, Re = 0, ke = G, je = 0, it = Z;
          if (b.content && f) {
            const Ue = b.content, xt = Ue[2] - Ue[0], At = Ue[3] - Ue[1];
            (b.textFitWidth || b.textFitHeight) && (I = Zb(c)), te = pf(P, 0, Ue[0]), ce = pf(D, 0, Ue[1]), me = pf(P, Ue[0], Ue[2]), de = pf(D, Ue[1], Ue[3]), Re = Ue[0] - te, je = Ue[1] - ce, ke = xt - me, it = At - de;
          }
          const Xe = I.x1, Qe = I.y1, pt = I.x2 - Xe, Ye = I.y2 - Qe, et = (Ue, xt, At, gt) => {
            const ut = _f(Ue.stretch - te, me, pt, Xe), Ut = gf(Ue.fixed - Re, ke, Ue.stretch, V), Ci = _f(xt.stretch - ce, de, Ye, Qe), tr = gf(xt.fixed - je, it, xt.stretch, j), Rr = _f(At.stretch - te, me, pt, Xe), Vs = gf(At.fixed - Re, ke, At.stretch, V), as = _f(gt.stretch - ce, de, Ye, Qe), vr = gf(gt.fixed - je, it, gt.stretch, j), xi = new w(ut, Ci), hr = new w(Rr, Ci), xr = new w(Rr, as), wr = new w(ut, as), Zr = new w(Ut / v, tr / v), js = new w(Vs / v, vr / v), ur = n * Math.PI / 180;
            if (ur) {
              const dr = Math.sin(ur), fr = Math.cos(ur), Zi = [fr, -dr, dr, fr];
              xi._matMult(Zi), hr._matMult(Zi), wr._matMult(Zi), xr._matMult(Zi);
            }
            const ls = Ue.stretch + Ue.fixed, ir = xt.stretch + xt.fixed;
            return { tl: xi, tr: hr, bl: wr, br: xr, tex: { x: b.paddedRect.x + 1 + ls, y: b.paddedRect.y + 1 + ir, w: At.stretch + At.fixed - ls, h: gt.stretch + gt.fixed - ir }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: Zr, pixelOffsetBR: js, minFontScaleX: ke / v / pt, minFontScaleY: it / v / Ye, isSDF: l };
          };
          if (f && (b.stretchX || b.stretchY)) {
            const Ue = w0(P, G, V), xt = w0(D, Z, j);
            for (let At = 0; At < Ue.length - 1; At++) {
              const gt = Ue[At], ut = Ue[At + 1];
              for (let Ut = 0; Ut < xt.length - 1; Ut++) _.push(et(gt, xt[Ut], ut, xt[Ut + 1]));
            }
          } else _.push(et({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: T + 1 }, { fixed: 0, stretch: A + 1 }));
          return _;
        }
        function pf(c, n, l) {
          let f = 0;
          for (const _ of c) f += Math.max(n, Math.min(l, _[1])) - Math.max(n, Math.min(l, _[0]));
          return f;
        }
        function w0(c, n, l) {
          const f = [{ fixed: -1, stretch: 0 }];
          for (const [_, b] of c) {
            const v = f[f.length - 1];
            f.push({ fixed: _ - v.stretch, stretch: v.stretch }), f.push({ fixed: _ - v.stretch, stretch: v.stretch + (b - _) });
          }
          return f.push({ fixed: n + 1, stretch: l }), f;
        }
        function _f(c, n, l, f) {
          return c / n * l + f;
        }
        function gf(c, n, l, f) {
          return c - n * l / f;
        }
        nt("Anchor", ua);
        class mf {
          constructor(n, l, f, _, b, v, T, A, I, P) {
            var D;
            if (this.boxStartIndex = n.length, I) {
              let U = v.top, V = v.bottom;
              const j = v.collisionPadding;
              j && (U -= j[1], V += j[3]);
              let G = V - U;
              G > 0 && (G = Math.max(10, G), this.circleDiameter = G);
            } else {
              const U = !((D = v.image) === null || D === void 0) && D.content && (v.image.textFitWidth || v.image.textFitHeight) ? Zb(v) : { x1: v.left, y1: v.top, x2: v.right, y2: v.bottom };
              U.y1 = U.y1 * T - A[0], U.y2 = U.y2 * T + A[2], U.x1 = U.x1 * T - A[3], U.x2 = U.x2 * T + A[1];
              const V = v.collisionPadding;
              if (V && (U.x1 -= V[0] * T, U.y1 -= V[1] * T, U.x2 += V[2] * T, U.y2 += V[3] * T), P) {
                const j = new w(U.x1, U.y1), G = new w(U.x2, U.y1), Z = new w(U.x1, U.y2), te = new w(U.x2, U.y2), me = P * Math.PI / 180;
                j._rotate(me), G._rotate(me), Z._rotate(me), te._rotate(me), U.x1 = Math.min(j.x, G.x, Z.x, te.x), U.x2 = Math.max(j.x, G.x, Z.x, te.x), U.y1 = Math.min(j.y, G.y, Z.y, te.y), U.y2 = Math.max(j.y, G.y, Z.y, te.y);
              }
              n.emplaceBack(l.x, l.y, U.x1, U.y1, U.x2, U.y2, f, _, b);
            }
            this.boxEndIndex = n.length;
          }
        }
        class GS {
          constructor(n = [], l = (f, _) => f < _ ? -1 : f > _ ? 1 : 0) {
            if (this.data = n, this.length = this.data.length, this.compare = l, this.length > 0) for (let f = (this.length >> 1) - 1; f >= 0; f--) this._down(f);
          }
          push(n) {
            this.data.push(n), this._up(this.length++);
          }
          pop() {
            if (this.length === 0) return;
            const n = this.data[0], l = this.data.pop();
            return --this.length > 0 && (this.data[0] = l, this._down(0)), n;
          }
          peek() {
            return this.data[0];
          }
          _up(n) {
            const { data: l, compare: f } = this, _ = l[n];
            for (; n > 0; ) {
              const b = n - 1 >> 1, v = l[b];
              if (f(_, v) >= 0) break;
              l[n] = v, n = b;
            }
            l[n] = _;
          }
          _down(n) {
            const { data: l, compare: f } = this, _ = this.length >> 1, b = l[n];
            for (; n < _; ) {
              let v = 1 + (n << 1);
              const T = v + 1;
              if (T < this.length && f(l[T], l[v]) < 0 && (v = T), f(l[v], b) >= 0) break;
              l[n] = l[v], n = v;
            }
            l[n] = b;
          }
        }
        function WS(c, n = 1, l = !1) {
          const f = ul.fromPoints(c[0]), _ = Math.min(f.width(), f.height());
          let b = _ / 2;
          const v = new GS([], XS), { minX: T, minY: A, maxX: I, maxY: P } = f;
          if (_ === 0) return new w(T, A);
          for (let V = T; V < I; V += _) for (let j = A; j < P; j += _) v.push(new Sc(V + b, j + b, b, c));
          let D = (function(V) {
            let j = 0, G = 0, Z = 0;
            const te = V[0];
            for (let me = 0, ce = te.length, de = ce - 1; me < ce; de = me++) {
              const Re = te[me], ke = te[de], je = Re.x * ke.y - ke.x * Re.y;
              G += (Re.x + ke.x) * je, Z += (Re.y + ke.y) * je, j += 3 * je;
            }
            return new Sc(G / j, Z / j, 0, V);
          })(c), U = v.length;
          for (; v.length; ) {
            const V = v.pop();
            (V.d > D.d || !D.d) && (D = V, l && console.log("found best %d after %d probes", Math.round(1e4 * V.d) / 1e4, U)), V.max - D.d <= n || (b = V.h / 2, v.push(new Sc(V.p.x - b, V.p.y - b, b, c)), v.push(new Sc(V.p.x + b, V.p.y - b, b, c)), v.push(new Sc(V.p.x - b, V.p.y + b, b, c)), v.push(new Sc(V.p.x + b, V.p.y + b, b, c)), U += 4);
          }
          return l && (console.log(`num probes: ${U}`), console.log(`best distance: ${D.d}`)), D.p;
        }
        function XS(c, n) {
          return n.max - c.max;
        }
        function Sc(c, n, l, f) {
          this.p = new w(c, n), this.h = l, this.d = (function(_, b) {
            let v = !1, T = 1 / 0;
            for (let A = 0; A < b.length; A++) {
              const I = b[A];
              for (let P = 0, D = I.length, U = D - 1; P < D; U = P++) {
                const V = I[P], j = I[U];
                V.y > _.y != j.y > _.y && _.x < (j.x - V.x) * (_.y - V.y) / (j.y - V.y) + V.x && (v = !v), T = Math.min(T, ob(_, V, j));
              }
            }
            return (v ? 1 : -1) * Math.sqrt(T);
          })(this.p, f), this.max = this.d + this.h * Math.SQRT2;
        }
        var Mr;
        d.aE = void 0, (Mr = d.aE || (d.aE = {}))[Mr.center = 1] = "center", Mr[Mr.left = 2] = "left", Mr[Mr.right = 3] = "right", Mr[Mr.top = 4] = "top", Mr[Mr.bottom = 5] = "bottom", Mr[Mr["top-left"] = 6] = "top-left", Mr[Mr["top-right"] = 7] = "top-right", Mr[Mr["bottom-left"] = 8] = "bottom-left", Mr[Mr["bottom-right"] = 9] = "bottom-right";
        const H_ = Number.POSITIVE_INFINITY;
        function T0(c, n) {
          return n[1] !== H_ ? (function(l, f, _) {
            let b = 0, v = 0;
            switch (f = Math.abs(f), _ = Math.abs(_), l) {
              case "top-right":
              case "top-left":
              case "top":
                v = _ - 7;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                v = 7 - _;
            }
            switch (l) {
              case "top-right":
              case "bottom-right":
              case "right":
                b = -f;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                b = f;
            }
            return [b, v];
          })(c, n[0], n[1]) : (function(l, f) {
            let _ = 0, b = 0;
            f < 0 && (f = 0);
            const v = f / Math.SQRT2;
            switch (l) {
              case "top-right":
              case "top-left":
                b = v - 7;
                break;
              case "bottom-right":
              case "bottom-left":
                b = 7 - v;
                break;
              case "bottom":
                b = 7 - f;
                break;
              case "top":
                b = f - 7;
            }
            switch (l) {
              case "top-right":
              case "bottom-right":
                _ = -v;
                break;
              case "top-left":
              case "bottom-left":
                _ = v;
                break;
              case "left":
                _ = f;
                break;
              case "right":
                _ = -f;
            }
            return [_, b];
          })(c, n[0]);
        }
        function A0(c, n, l) {
          var f;
          const _ = c.layout, b = (f = _.get("text-variable-anchor-offset")) === null || f === void 0 ? void 0 : f.evaluate(n, {}, l);
          if (b) {
            const T = b.values, A = [];
            for (let I = 0; I < T.length; I += 2) {
              const P = A[I] = T[I], D = T[I + 1].map(((U) => U * cr));
              P.startsWith("top") ? D[1] -= 7 : P.startsWith("bottom") && (D[1] += 7), A[I + 1] = D;
            }
            return new Ur(A);
          }
          const v = _.get("text-variable-anchor");
          if (v) {
            let T;
            T = c._unevaluatedLayout.getValue("text-radial-offset") !== void 0 ? [_.get("text-radial-offset").evaluate(n, {}, l) * cr, H_] : _.get("text-offset").evaluate(n, {}, l).map(((I) => I * cr));
            const A = [];
            for (const I of v) A.push(I, T0(I, T));
            return new Ur(A);
          }
          return null;
        }
        function $_(c) {
          switch (c) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left";
          }
          return "center";
        }
        function qS(c, n, l, f, _, b, v, T, A, I, P, D) {
          let U = b.textMaxSize.evaluate(n, {});
          U === void 0 && (U = v);
          const V = c.layers[0].layout, j = V.get("icon-offset").evaluate(n, {}, P), G = S0(l.horizontal), Z = v / 24, te = c.tilePixelRatio * Z, me = c.tilePixelRatio * U / 24, ce = c.tilePixelRatio * T, de = c.tilePixelRatio * V.get("symbol-spacing"), Re = V.get("text-padding") * c.tilePixelRatio, ke = (function(At, gt, ut, Ut = 1) {
            const Ci = At.get("icon-padding").evaluate(gt, {}, ut), tr = Ci && Ci.values;
            return [tr[0] * Ut, tr[1] * Ut, tr[2] * Ut, tr[3] * Ut];
          })(V, n, P, c.tilePixelRatio), je = V.get("text-max-angle") / 180 * Math.PI, it = V.get("text-rotation-alignment") !== "viewport" && V.get("symbol-placement") !== "point", Xe = V.get("icon-rotation-alignment") === "map" && V.get("symbol-placement") !== "point", Qe = V.get("symbol-placement"), pt = de / 2, Ye = V.get("icon-text-fit");
          let et;
          f && Ye !== "none" && (c.allowVerticalPlacement && l.vertical && (et = Kb(f, l.vertical, Ye, V.get("icon-text-fit-padding"), j, Z)), G && (f = Kb(f, G, Ye, V.get("icon-text-fit-padding"), j, Z)));
          const Ue = P ? D.line.getGranularityForZoomLevel(P.z) : 1, xt = (At, gt) => {
            gt.x < 0 || gt.x >= Ht || gt.y < 0 || gt.y >= Ht || (function(ut, Ut, Ci, tr, Rr, Vs, as, vr, xi, hr, xr, wr, Zr, js, ur, ls, ir, dr, fr, Zi, di, wn, Cc, Tn, YS) {
              const Ic = ut.addToLineVertexArray(Ut, Ci);
              let dl, Mc, Rc, Pc, R0 = 0, P0 = 0, B0 = 0, D0 = 0, J_ = -1, Q_ = -1;
              const Mo = {};
              let O0 = oa("");
              if (ut.allowVerticalPlacement && tr.vertical) {
                const Hr = vr.layout.get("text-rotate").evaluate(di, {}, Tn) + 90;
                Rc = new mf(xi, Ut, hr, xr, wr, tr.vertical, Zr, js, ur, Hr), as && (Pc = new mf(xi, Ut, hr, xr, wr, as, ir, dr, ur, Hr));
              }
              if (Rr) {
                const Hr = vr.layout.get("icon-rotate").evaluate(di, {}), Hs = vr.layout.get("icon-text-fit") !== "none", fl = x0(Rr, Hr, Cc, Hs), En = as ? x0(as, Hr, Cc, Hs) : void 0;
                Mc = new mf(xi, Ut, hr, xr, wr, Rr, ir, dr, !1, Hr), R0 = 4 * fl.length;
                const pl = ut.iconSizeData;
                let Yn = null;
                pl.kind === "source" ? (Yn = [Io * vr.layout.get("icon-size").evaluate(di, {})], Yn[0] > ca && ai(`${ut.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : pl.kind === "composite" && (Yn = [Io * wn.compositeIconSizes[0].evaluate(di, {}, Tn), Io * wn.compositeIconSizes[1].evaluate(di, {}, Tn)], (Yn[0] > ca || Yn[1] > ca) && ai(`${ut.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), ut.addSymbols(ut.icon, fl, Yn, Zi, fr, di, d.ao.none, Ut, Ic.lineStartIndex, Ic.lineLength, -1, Tn), J_ = ut.icon.placedSymbolArray.length - 1, En && (P0 = 4 * En.length, ut.addSymbols(ut.icon, En, Yn, Zi, fr, di, d.ao.vertical, Ut, Ic.lineStartIndex, Ic.lineLength, -1, Tn), Q_ = ut.icon.placedSymbolArray.length - 1);
              }
              const F0 = Object.keys(tr.horizontal);
              for (const Hr of F0) {
                const Hs = tr.horizontal[Hr];
                if (!dl) {
                  O0 = oa(Hs.text);
                  const En = vr.layout.get("text-rotate").evaluate(di, {}, Tn);
                  dl = new mf(xi, Ut, hr, xr, wr, Hs, Zr, js, ur, En);
                }
                const fl = Hs.positionedLines.length === 1;
                if (B0 += E0(ut, Ut, Hs, Vs, vr, ur, di, ls, Ic, tr.vertical ? d.ao.horizontal : d.ao.horizontalOnly, fl ? F0 : [Hr], Mo, J_, wn, Tn), fl) break;
              }
              tr.vertical && (D0 += E0(ut, Ut, tr.vertical, Vs, vr, ur, di, ls, Ic, d.ao.vertical, ["vertical"], Mo, Q_, wn, Tn));
              const JS = dl ? dl.boxStartIndex : ut.collisionBoxArray.length, QS = dl ? dl.boxEndIndex : ut.collisionBoxArray.length, eC = Rc ? Rc.boxStartIndex : ut.collisionBoxArray.length, tC = Rc ? Rc.boxEndIndex : ut.collisionBoxArray.length, iC = Mc ? Mc.boxStartIndex : ut.collisionBoxArray.length, rC = Mc ? Mc.boxEndIndex : ut.collisionBoxArray.length, sC = Pc ? Pc.boxStartIndex : ut.collisionBoxArray.length, nC = Pc ? Pc.boxEndIndex : ut.collisionBoxArray.length;
              let An = -1;
              const bf = (Hr, Hs) => Hr && Hr.circleDiameter ? Math.max(Hr.circleDiameter, Hs) : Hs;
              An = bf(dl, An), An = bf(Rc, An), An = bf(Mc, An), An = bf(Pc, An);
              const k0 = An > -1 ? 1 : 0;
              k0 && (An *= YS / cr), ut.glyphOffsetArray.length >= Ac.MAX_GLYPHS && ai("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), di.sortKey !== void 0 && ut.addToSortKeyRanges(ut.symbolInstances.length, di.sortKey);
              const oC = A0(vr, di, Tn), [aC, lC] = (function(Hr, Hs) {
                const fl = Hr.length, En = Hs?.values;
                if (En?.length > 0) for (let pl = 0; pl < En.length; pl += 2) {
                  const Yn = En[pl + 1];
                  Hr.emplaceBack(d.aE[En[pl]], Yn[0], Yn[1]);
                }
                return [fl, Hr.length];
              })(ut.textAnchorOffsets, oC);
              ut.symbolInstances.emplaceBack(Ut.x, Ut.y, Mo.right >= 0 ? Mo.right : -1, Mo.center >= 0 ? Mo.center : -1, Mo.left >= 0 ? Mo.left : -1, Mo.vertical || -1, J_, Q_, O0, JS, QS, eC, tC, iC, rC, sC, nC, hr, B0, D0, R0, P0, k0, 0, Zr, An, aC, lC);
            })(c, gt, At, l, f, _, et, c.layers[0], c.collisionBoxArray, n.index, n.sourceLayerIndex, c.index, te, [Re, Re, Re, Re], it, A, ce, ke, Xe, j, n, b, I, P, v);
          };
          if (Qe === "line") for (const At of _0(n.geometry, 0, 0, Ht, Ht)) {
            const gt = hl(At, Ue), ut = $S(gt, de, je, l.vertical || G, f, 24, me, c.overscaling, Ht);
            for (const Ut of ut) G && ZS(c, G.text, pt, Ut) || xt(gt, Ut);
          }
          else if (Qe === "line-center") {
            for (const At of n.geometry) if (At.length > 1) {
              const gt = hl(At, Ue), ut = HS(gt, je, l.vertical || G, f, 24, me);
              ut && xt(gt, ut);
            }
          } else if (n.type === "Polygon") for (const At of Xa(n.geometry, 0)) {
            const gt = WS(At, 16);
            xt(hl(At[0], Ue, !0), new ua(gt.x, gt.y, 0));
          }
          else if (n.type === "LineString") for (const At of n.geometry) {
            const gt = hl(At, Ue);
            xt(gt, new ua(gt[0].x, gt[0].y, 0));
          }
          else if (n.type === "Point") for (const At of n.geometry) for (const gt of At) xt([gt], new ua(gt.x, gt.y, 0));
        }
        function E0(c, n, l, f, _, b, v, T, A, I, P, D, U, V, j) {
          const G = (function(me, ce, de, Re, ke, je, it, Xe) {
            const Qe = Re.layout.get("text-rotate").evaluate(je, {}) * Math.PI / 180, pt = [];
            for (const Ye of ce.positionedLines) for (const et of Ye.positionedGlyphs) {
              if (!et.rect) continue;
              const Ue = et.rect || {};
              let xt = 4, At = !0, gt = 1, ut = 0;
              const Ut = (ke || Xe) && et.vertical, Ci = et.metrics.advance * et.scale / 2;
              if (Xe && ce.verticalizable && (ut = Ye.lineOffset / 2 - (et.imageName ? -(cr - et.metrics.width * et.scale) / 2 : (et.scale - 1) * cr)), et.imageName) {
                const dr = it[et.imageName];
                At = dr.sdf, gt = dr.pixelRatio, xt = 1 / gt;
              }
              const tr = ke ? [et.x + Ci, et.y] : [0, 0];
              let Rr = ke ? [0, 0] : [et.x + Ci + de[0], et.y + de[1] - ut], Vs = [0, 0];
              Ut && (Vs = Rr, Rr = [0, 0]);
              const as = et.metrics.isDoubleResolution ? 2 : 1, vr = (et.metrics.left - xt) * et.scale - Ci + Rr[0], xi = (-et.metrics.top - xt) * et.scale + Rr[1], hr = vr + Ue.w / as * et.scale / gt, xr = xi + Ue.h / as * et.scale / gt, wr = new w(vr, xi), Zr = new w(hr, xi), js = new w(vr, xr), ur = new w(hr, xr);
              if (Ut) {
                const dr = new w(-Ci, Ci - -17), fr = -Math.PI / 2, Zi = 12 - Ci, di = new w(22 - Zi, -(et.imageName ? Zi : 0)), wn = new w(...Vs);
                wr._rotateAround(fr, dr)._add(di)._add(wn), Zr._rotateAround(fr, dr)._add(di)._add(wn), js._rotateAround(fr, dr)._add(di)._add(wn), ur._rotateAround(fr, dr)._add(di)._add(wn);
              }
              if (Qe) {
                const dr = Math.sin(Qe), fr = Math.cos(Qe), Zi = [fr, -dr, dr, fr];
                wr._matMult(Zi), Zr._matMult(Zi), js._matMult(Zi), ur._matMult(Zi);
              }
              const ls = new w(0, 0), ir = new w(0, 0);
              pt.push({ tl: wr, tr: Zr, bl: js, br: ur, tex: Ue, writingMode: ce.writingMode, glyphOffset: tr, sectionIndex: et.sectionIndex, isSDF: At, pixelOffsetTL: ls, pixelOffsetBR: ir, minFontScaleX: 0, minFontScaleY: 0 });
            }
            return pt;
          })(0, l, T, _, b, v, f, c.allowVerticalPlacement), Z = c.textSizeData;
          let te = null;
          Z.kind === "source" ? (te = [Io * _.layout.get("text-size").evaluate(v, {})], te[0] > ca && ai(`${c.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : Z.kind === "composite" && (te = [Io * V.compositeTextSizes[0].evaluate(v, {}, j), Io * V.compositeTextSizes[1].evaluate(v, {}, j)], (te[0] > ca || te[1] > ca) && ai(`${c.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), c.addSymbols(c.text, G, te, T, b, v, I, n, A.lineStartIndex, A.lineLength, U, j);
          for (const me of P) D[me] = c.text.placedSymbolArray.length - 1;
          return 4 * G.length;
        }
        function S0(c) {
          for (const n in c) return c[n];
          return null;
        }
        function ZS(c, n, l, f) {
          const _ = c.compareText;
          if (n in _) {
            const b = _[n];
            for (let v = b.length - 1; v >= 0; v--) if (f.dist(b[v]) < l) return !0;
          } else _[n] = [];
          return _[n].push(f), !1;
        }
        const C0 = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        class G_ {
          static from(n) {
            if (!(n instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
            const [l, f] = new Uint8Array(n, 0, 2);
            if (l !== 219) throw new Error("Data does not appear to be in a KDBush format.");
            const _ = f >> 4;
            if (_ !== 1) throw new Error(`Got v${_} data when expected v1.`);
            const b = C0[15 & f];
            if (!b) throw new Error("Unrecognized array type.");
            const [v] = new Uint16Array(n, 2, 1), [T] = new Uint32Array(n, 4, 1);
            return new G_(T, v, b, n);
          }
          constructor(n, l = 64, f = Float64Array, _) {
            if (isNaN(n) || n < 0) throw new Error(`Unpexpected numItems value: ${n}.`);
            this.numItems = +n, this.nodeSize = Math.min(Math.max(+l, 2), 65535), this.ArrayType = f, this.IndexArrayType = n < 65536 ? Uint16Array : Uint32Array;
            const b = C0.indexOf(this.ArrayType), v = 2 * n * this.ArrayType.BYTES_PER_ELEMENT, T = n * this.IndexArrayType.BYTES_PER_ELEMENT, A = (8 - T % 8) % 8;
            if (b < 0) throw new Error(`Unexpected typed array class: ${f}.`);
            _ && _ instanceof ArrayBuffer ? (this.data = _, this.ids = new this.IndexArrayType(this.data, 8, n), this.coords = new this.ArrayType(this.data, 8 + T + A, 2 * n), this._pos = 2 * n, this._finished = !0) : (this.data = new ArrayBuffer(8 + v + T + A), this.ids = new this.IndexArrayType(this.data, 8, n), this.coords = new this.ArrayType(this.data, 8 + T + A, 2 * n), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + b]), new Uint16Array(this.data, 2, 1)[0] = l, new Uint32Array(this.data, 4, 1)[0] = n);
          }
          add(n, l) {
            const f = this._pos >> 1;
            return this.ids[f] = f, this.coords[this._pos++] = n, this.coords[this._pos++] = l, f;
          }
          finish() {
            const n = this._pos >> 1;
            if (n !== this.numItems) throw new Error(`Added ${n} items when expected ${this.numItems}.`);
            return W_(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
          }
          range(n, l, f, _) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: b, coords: v, nodeSize: T } = this, A = [0, b.length - 1, 0], I = [];
            for (; A.length; ) {
              const P = A.pop() || 0, D = A.pop() || 0, U = A.pop() || 0;
              if (D - U <= T) {
                for (let Z = U; Z <= D; Z++) {
                  const te = v[2 * Z], me = v[2 * Z + 1];
                  te >= n && te <= f && me >= l && me <= _ && I.push(b[Z]);
                }
                continue;
              }
              const V = U + D >> 1, j = v[2 * V], G = v[2 * V + 1];
              j >= n && j <= f && G >= l && G <= _ && I.push(b[V]), (P === 0 ? n <= j : l <= G) && (A.push(U), A.push(V - 1), A.push(1 - P)), (P === 0 ? f >= j : _ >= G) && (A.push(V + 1), A.push(D), A.push(1 - P));
            }
            return I;
          }
          within(n, l, f) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: _, coords: b, nodeSize: v } = this, T = [0, _.length - 1, 0], A = [], I = f * f;
            for (; T.length; ) {
              const P = T.pop() || 0, D = T.pop() || 0, U = T.pop() || 0;
              if (D - U <= v) {
                for (let Z = U; Z <= D; Z++) M0(b[2 * Z], b[2 * Z + 1], n, l) <= I && A.push(_[Z]);
                continue;
              }
              const V = U + D >> 1, j = b[2 * V], G = b[2 * V + 1];
              M0(j, G, n, l) <= I && A.push(_[V]), (P === 0 ? n - f <= j : l - f <= G) && (T.push(U), T.push(V - 1), T.push(1 - P)), (P === 0 ? n + f >= j : l + f >= G) && (T.push(V + 1), T.push(D), T.push(1 - P));
            }
            return A;
          }
        }
        function W_(c, n, l, f, _, b) {
          if (_ - f <= l) return;
          const v = f + _ >> 1;
          I0(c, n, v, f, _, b), W_(c, n, l, f, v - 1, 1 - b), W_(c, n, l, v + 1, _, 1 - b);
        }
        function I0(c, n, l, f, _, b) {
          for (; _ > f; ) {
            if (_ - f > 600) {
              const I = _ - f + 1, P = l - f + 1, D = Math.log(I), U = 0.5 * Math.exp(2 * D / 3), V = 0.5 * Math.sqrt(D * U * (I - U) / I) * (P - I / 2 < 0 ? -1 : 1);
              I0(c, n, l, Math.max(f, Math.floor(l - P * U / I + V)), Math.min(_, Math.floor(l + (I - P) * U / I + V)), b);
            }
            const v = n[2 * l + b];
            let T = f, A = _;
            for (vu(c, n, f, l), n[2 * _ + b] > v && vu(c, n, f, _); T < A; ) {
              for (vu(c, n, T, A), T++, A--; n[2 * T + b] < v; ) T++;
              for (; n[2 * A + b] > v; ) A--;
            }
            n[2 * f + b] === v ? vu(c, n, f, A) : (A++, vu(c, n, A, _)), A <= l && (f = A + 1), l <= A && (_ = A - 1);
          }
        }
        function vu(c, n, l, f) {
          X_(c, l, f), X_(n, 2 * l, 2 * f), X_(n, 2 * l + 1, 2 * f + 1);
        }
        function X_(c, n, l) {
          const f = c[n];
          c[n] = c[l], c[l] = f;
        }
        function M0(c, n, l, f) {
          const _ = c - l, b = n - f;
          return _ * _ + b * b;
        }
        var q_;
        d.cx = void 0, (q_ = d.cx || (d.cx = {})).create = "create", q_.load = "load", q_.fullLoad = "fullLoad";
        let yf = null, xu = [];
        const Z_ = 1e3 / 60, K_ = "loadTime", Y_ = "fullLoadTime", KS = { mark(c) {
          performance.mark(c);
        }, frame(c) {
          const n = c;
          yf != null && xu.push(n - yf), yf = n;
        }, clearMetrics() {
          yf = null, xu = [], performance.clearMeasures(K_), performance.clearMeasures(Y_);
          for (const c in d.cx) performance.clearMarks(d.cx[c]);
        }, getPerformanceMetrics() {
          performance.measure(K_, d.cx.create, d.cx.load), performance.measure(Y_, d.cx.create, d.cx.fullLoad);
          const c = performance.getEntriesByName(K_)[0].duration, n = performance.getEntriesByName(Y_)[0].duration, l = xu.length, f = 1 / (xu.reduce(((b, v) => b + v), 0) / l / 1e3), _ = xu.filter(((b) => b > Z_)).reduce(((b, v) => b + (v - Z_) / Z_), 0);
          return { loadTime: c, fullLoadTime: n, fps: f, percentDroppedFrames: _ / (l + _) * 100, totalFrames: l };
        } };
        d.$ = Ht, d.A = Ce, d.B = function([c, n, l]) {
          return n += 90, n *= Math.PI / 180, l *= Math.PI / 180, { x: c * Math.cos(n) * Math.sin(l), y: c * Math.sin(n) * Math.sin(l), z: c * Math.cos(l) };
        }, d.C = nn, d.D = dt, d.E = lt, d.F = gi, d.G = rl, d.H = function(c) {
          if (Or == null) {
            const n = c.navigator ? c.navigator.userAgent : null;
            Or = !!c.safari || !(!n || !(/\b(iPad|iPhone|iPod)\b/.test(n) || n.match("Safari") && !n.match("Chrome")));
          }
          return Or;
        }, d.I = B_, d.J = class {
          constructor(c, n) {
            this.target = c, this.mapId = n, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new zS((() => this.process())), this.subscription = Ys(this.target, "message", ((l) => this.receive(l)), !1), this.globalScope = ki(self) ? c : window;
          }
          registerMessageHandler(c, n) {
            this.messageHandlers[c] = n;
          }
          sendAsync(c, n) {
            return new Promise(((l, f) => {
              const _ = Math.round(1e18 * Math.random()).toString(36).substring(0, 10), b = n ? Ys(n.signal, "abort", (() => {
                b?.unsubscribe(), delete this.resolveRejects[_];
                const A = { id: _, type: "<cancel>", origin: location.origin, targetMapId: c.targetMapId, sourceMapId: this.mapId };
                this.target.postMessage(A);
              }), VS) : null;
              this.resolveRejects[_] = { resolve: (A) => {
                b?.unsubscribe(), l(A);
              }, reject: (A) => {
                b?.unsubscribe(), f(A);
              } };
              const v = [], T = Object.assign(Object.assign({}, c), { id: _, sourceMapId: this.mapId, origin: location.origin, data: ea(c.data, v) });
              this.target.postMessage(T, { transfer: v });
            }));
          }
          receive(c) {
            const n = c.data, l = n.id;
            if (!(n.origin !== "file://" && location.origin !== "file://" && n.origin !== "resource://android" && location.origin !== "resource://android" && n.origin !== location.origin || n.targetMapId && this.mapId !== n.targetMapId)) {
              if (n.type === "<cancel>") {
                delete this.tasks[l];
                const f = this.abortControllers[l];
                return delete this.abortControllers[l], void (f && f.abort());
              }
              if (ki(self) || n.mustQueue) return this.tasks[l] = n, this.taskQueue.push(l), void this.invoker.trigger();
              this.processTask(l, n);
            }
          }
          process() {
            if (this.taskQueue.length === 0) return;
            const c = this.taskQueue.shift(), n = this.tasks[c];
            delete this.tasks[c], this.taskQueue.length > 0 && this.invoker.trigger(), n && this.processTask(c, n);
          }
          processTask(c, n) {
            return a(this, void 0, void 0, (function* () {
              if (n.type === "<response>") {
                const _ = this.resolveRejects[c];
                return delete this.resolveRejects[c], _ ? void (n.error ? _.reject(To(n.error)) : _.resolve(To(n.data))) : void 0;
              }
              if (!this.messageHandlers[n.type]) return void this.completeTask(c, new Error(`Could not find a registered handler for ${n.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
              const l = To(n.data), f = new AbortController();
              this.abortControllers[c] = f;
              try {
                const _ = yield this.messageHandlers[n.type](n.sourceMapId, l, f);
                this.completeTask(c, null, _);
              } catch (_) {
                this.completeTask(c, _);
              }
            }));
          }
          completeTask(c, n, l) {
            const f = [];
            delete this.abortControllers[c];
            const _ = { id: c, type: "<response>", sourceMapId: this.mapId, origin: location.origin, error: n ? ea(n) : null, data: ea(l, f) };
            this.target.postMessage(_, { transfer: f });
          }
          remove() {
            this.invoker.remove(), this.subscription.unsubscribe();
          }
        }, d.K = q, d.L = function() {
          var c = new Ce(16);
          return Ce != Float32Array && (c[1] = 0, c[2] = 0, c[3] = 0, c[4] = 0, c[6] = 0, c[7] = 0, c[8] = 0, c[9] = 0, c[11] = 0, c[12] = 0, c[13] = 0, c[14] = 0), c[0] = 1, c[5] = 1, c[10] = 1, c[15] = 1, c;
        }, d.M = function(c, n, l) {
          var f, _, b, v, T, A, I, P, D, U, V, j, G = l[0], Z = l[1], te = l[2];
          return n === c ? (c[12] = n[0] * G + n[4] * Z + n[8] * te + n[12], c[13] = n[1] * G + n[5] * Z + n[9] * te + n[13], c[14] = n[2] * G + n[6] * Z + n[10] * te + n[14], c[15] = n[3] * G + n[7] * Z + n[11] * te + n[15]) : (_ = n[1], b = n[2], v = n[3], T = n[4], A = n[5], I = n[6], P = n[7], D = n[8], U = n[9], V = n[10], j = n[11], c[0] = f = n[0], c[1] = _, c[2] = b, c[3] = v, c[4] = T, c[5] = A, c[6] = I, c[7] = P, c[8] = D, c[9] = U, c[10] = V, c[11] = j, c[12] = f * G + T * Z + D * te + n[12], c[13] = _ * G + A * Z + U * te + n[13], c[14] = b * G + I * Z + V * te + n[14], c[15] = v * G + P * Z + j * te + n[15]), c;
        }, d.N = function(c, n, l) {
          var f = l[0], _ = l[1], b = l[2];
          return c[0] = n[0] * f, c[1] = n[1] * f, c[2] = n[2] * f, c[3] = n[3] * f, c[4] = n[4] * _, c[5] = n[5] * _, c[6] = n[6] * _, c[7] = n[7] * _, c[8] = n[8] * b, c[9] = n[9] * b, c[10] = n[10] * b, c[11] = n[11] * b, c[12] = n[12], c[13] = n[13], c[14] = n[14], c[15] = n[15], c;
        }, d.O = function(c, n, l) {
          var f = n[0], _ = n[1], b = n[2], v = n[3], T = n[4], A = n[5], I = n[6], P = n[7], D = n[8], U = n[9], V = n[10], j = n[11], G = n[12], Z = n[13], te = n[14], me = n[15], ce = l[0], de = l[1], Re = l[2], ke = l[3];
          return c[0] = ce * f + de * T + Re * D + ke * G, c[1] = ce * _ + de * A + Re * U + ke * Z, c[2] = ce * b + de * I + Re * V + ke * te, c[3] = ce * v + de * P + Re * j + ke * me, c[4] = (ce = l[4]) * f + (de = l[5]) * T + (Re = l[6]) * D + (ke = l[7]) * G, c[5] = ce * _ + de * A + Re * U + ke * Z, c[6] = ce * b + de * I + Re * V + ke * te, c[7] = ce * v + de * P + Re * j + ke * me, c[8] = (ce = l[8]) * f + (de = l[9]) * T + (Re = l[10]) * D + (ke = l[11]) * G, c[9] = ce * _ + de * A + Re * U + ke * Z, c[10] = ce * b + de * I + Re * V + ke * te, c[11] = ce * v + de * P + Re * j + ke * me, c[12] = (ce = l[12]) * f + (de = l[13]) * T + (Re = l[14]) * D + (ke = l[15]) * G, c[13] = ce * _ + de * A + Re * U + ke * Z, c[14] = ce * b + de * I + Re * V + ke * te, c[15] = ce * v + de * P + Re * j + ke * me, c;
        }, d.P = w, d.Q = function(c, n) {
          const l = {};
          for (let f = 0; f < n.length; f++) {
            const _ = n[f];
            _ in c && (l[_] = c[_]);
          }
          return l;
        }, d.R = os, d.S = ha, d.T = x_, d.U = o0, d.V = n0, d.W = we, d.X = Se, d.Y = Ts, d.Z = zs, d._ = a, d.a = $, d.a$ = jt, d.a0 = function(c, n) {
          var l, f, _, b;
          if (!c) return n ?? {};
          if (!n) return c;
          const v = Object.assign({}, c);
          if (n.removeAll && (v.removeAll = !0), n.remove) {
            const T = new Set(v.remove ? v.remove.concat(n.remove) : n.remove);
            v.remove = Array.from(T.values());
          }
          if (n.add) {
            const T = v.add ? v.add.concat(n.add) : n.add, A = new Map(T.map(((I) => [I.id, I])));
            v.add = Array.from(A.values());
          }
          if (n.update) {
            const T = new Map((l = v.update) === null || l === void 0 ? void 0 : l.map(((A) => [A.id, A])));
            for (const A of n.update) {
              const I = (f = T.get(A.id)) !== null && f !== void 0 ? f : { id: A.id };
              A.newGeometry && (I.newGeometry = A.newGeometry), A.addOrUpdateProperties && (I.addOrUpdateProperties = ((_ = I.addOrUpdateProperties) !== null && _ !== void 0 ? _ : []).concat(A.addOrUpdateProperties)), A.removeProperties && (I.removeProperties = ((b = I.removeProperties) !== null && b !== void 0 ? b : []).concat(A.removeProperties)), A.removeAllProperties && (I.removeAllProperties = !0), T.set(A.id, I);
            }
            v.update = Array.from(T.values());
          }
          return v;
        }, d.a1 = yu, d.a2 = ul, d.a3 = 25, d.a4 = j_, d.a5 = (c) => {
          const n = window.document.createElement("video");
          return n.muted = !0, new Promise(((l) => {
            n.onloadstart = () => {
              l(n);
            };
            for (const f of c) {
              const _ = window.document.createElement("source");
              Pe(f) || (n.crossOrigin = "Anonymous"), _.src = f, n.appendChild(_);
            }
          }));
        }, d.a6 = Ge, d.a7 = function() {
          return qt++;
        }, d.a8 = O, d.a9 = Ac, d.aA = function(c) {
          let n = 1 / 0, l = 1 / 0, f = -1 / 0, _ = -1 / 0;
          for (const b of c) n = Math.min(n, b.x), l = Math.min(l, b.y), f = Math.max(f, b.x), _ = Math.max(_, b.y);
          return [n, l, f, _];
        }, d.aB = cr, d.aC = rr, d.aD = function(c, n, l, f, _ = !1) {
          if (!l[0] && !l[1]) return [0, 0];
          const b = _ ? f === "map" ? -c.bearingInRadians : 0 : f === "viewport" ? c.bearingInRadians : 0;
          if (b) {
            const v = Math.sin(b), T = Math.cos(b);
            l = [l[0] * T - l[1] * v, l[0] * v + l[1] * T];
          }
          return [_ ? l[0] : rr(n, l[0], c.zoom), _ ? l[1] : rr(n, l[1], c.zoom)];
        }, d.aF = F_, d.aG = $_, d.aH = O_, d.aI = G_, d.aJ = Di, d.aK = lf, d.aL = oe, d.aM = Rt, d.aN = ti, d.aO = Ri, d.aP = Js, d.aQ = l0, d.aR = ot, d.aS = st, d.aT = function(c) {
          var n = new Ce(3);
          return n[0] = c[0], n[1] = c[1], n[2] = c[2], n;
        }, d.aU = function(c, n, l) {
          return c[0] = n[0] - l[0], c[1] = n[1] - l[1], c[2] = n[2] - l[2], c;
        }, d.aV = function(c, n) {
          var l = n[0], f = n[1], _ = n[2], b = l * l + f * f + _ * _;
          return b > 0 && (b = 1 / Math.sqrt(b)), c[0] = n[0] * b, c[1] = n[1] * b, c[2] = n[2] * b, c;
        }, d.aW = bt, d.aX = function(c, n) {
          return c[0] * n[0] + c[1] * n[1] + c[2] * n[2];
        }, d.aY = function(c, n, l) {
          return c[0] = n[0] * l[0], c[1] = n[1] * l[1], c[2] = n[2] * l[2], c[3] = n[3] * l[3], c;
        }, d.aZ = ct, d.a_ = function(c, n, l) {
          const f = n[0] * l[0] + n[1] * l[1] + n[2] * l[2];
          return f === 0 ? null : (-(c[0] * l[0] + c[1] * l[1] + c[2] * l[2]) - l[3]) / f;
        }, d.aa = vo, d.ab = xn, d.ac = d0, d.ad = function(c) {
          const n = {};
          if (c.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, ((l, f, _, b) => {
            const v = _ || b;
            return n[f] = !v || v.toLowerCase(), "";
          })), n["max-age"]) {
            const l = parseInt(n["max-age"], 10);
            isNaN(l) ? delete n["max-age"] : n["max-age"] = l;
          }
          return n;
        }, d.ae = _n, d.af = function(c) {
          return Math.pow(2, c);
        }, d.ag = Ze, d.ah = Er, d.ai = 85.051129, d.aj = a0, d.ak = function(c) {
          return Math.log(c) / Math.LN2;
        }, d.al = function(c) {
          var n = c[0], l = c[1];
          return n * n + l * l;
        }, d.am = function(c, n) {
          const l = [];
          for (const f in c) f in n || l.push(f);
          return l;
        }, d.an = function(c, n) {
          let l = 0, f = 0;
          if (c.kind === "constant") f = c.layoutSize;
          else if (c.kind !== "source") {
            const { interpolationType: _, minZoom: b, maxZoom: v } = c, T = _ ? Er(br.interpolationFactor(_, n, b, v), 0, 1) : 0;
            c.kind === "camera" ? f = nn.number(c.minSize, c.maxSize, T) : l = T;
          }
          return { uSizeT: l, uSize: f };
        }, d.ap = function(c, { uSize: n, uSizeT: l }, { lowerSize: f, upperSize: _ }) {
          return c.kind === "source" ? f / Io : c.kind === "composite" ? nn.number(f / Io, _ / Io, l) : n;
        }, d.aq = function(c, n) {
          var l = n[0], f = n[1], _ = n[2], b = n[3], v = n[4], T = n[5], A = n[6], I = n[7], P = n[8], D = n[9], U = n[10], V = n[11], j = n[12], G = n[13], Z = n[14], te = n[15], me = l * T - f * v, ce = l * A - _ * v, de = l * I - b * v, Re = f * A - _ * T, ke = f * I - b * T, je = _ * I - b * A, it = P * G - D * j, Xe = P * Z - U * j, Qe = P * te - V * j, pt = D * Z - U * G, Ye = D * te - V * G, et = U * te - V * Z, Ue = me * et - ce * Ye + de * pt + Re * Qe - ke * Xe + je * it;
          return Ue ? (c[0] = (T * et - A * Ye + I * pt) * (Ue = 1 / Ue), c[1] = (_ * Ye - f * et - b * pt) * Ue, c[2] = (G * je - Z * ke + te * Re) * Ue, c[3] = (U * ke - D * je - V * Re) * Ue, c[4] = (A * Qe - v * et - I * Xe) * Ue, c[5] = (l * et - _ * Qe + b * Xe) * Ue, c[6] = (Z * de - j * je - te * ce) * Ue, c[7] = (P * je - U * de + V * ce) * Ue, c[8] = (v * Ye - T * Qe + I * it) * Ue, c[9] = (f * Qe - l * Ye - b * it) * Ue, c[10] = (j * ke - G * de + te * me) * Ue, c[11] = (D * de - P * ke - V * me) * Ue, c[12] = (T * Xe - v * pt - A * it) * Ue, c[13] = (l * pt - f * Xe + _ * it) * Ue, c[14] = (G * ce - j * Re - Z * me) * Ue, c[15] = (P * Re - D * ce + U * me) * Ue, c) : null;
        }, d.ar = gr, d.as = function(c) {
          return Math.hypot(c[0], c[1]);
        }, d.at = function(c) {
          return c[0] = 0, c[1] = 0, c;
        }, d.au = function(c, n, l) {
          return c[0] = n[0] * l, c[1] = n[1] * l, c;
        }, d.av = k_, d.aw = Et, d.ax = function(c, n, l, f) {
          const _ = n.y - c.y, b = n.x - c.x, v = f.y - l.y, T = f.x - l.x, A = v * b - T * _;
          if (A === 0) return null;
          const I = (T * (c.y - l.y) - v * (c.x - l.x)) / A;
          return new w(c.x + I * b, c.y + I * _);
        }, d.ay = _0, d.az = sb, d.b = es, d.b$ = class extends m {
        }, d.b0 = function(c, n, l) {
          return c[0] = n[0] * l, c[1] = n[1] * l, c[2] = n[2] * l, c[3] = n[3] * l, c;
        }, d.b1 = function(c, n) {
          return c[0] * n[0] + c[1] * n[1] + c[2] * n[2] + c[3];
        }, d.b2 = h0, d.b3 = Ec, d.b4 = function(c, n, l, f, _) {
          var b, v = 1 / Math.tan(n / 2);
          return c[0] = v / l, c[1] = 0, c[2] = 0, c[3] = 0, c[4] = 0, c[5] = v, c[6] = 0, c[7] = 0, c[8] = 0, c[9] = 0, c[11] = -1, c[12] = 0, c[13] = 0, c[15] = 0, _ != null && _ !== 1 / 0 ? (c[10] = (_ + f) * (b = 1 / (f - _)), c[14] = 2 * _ * f * b) : (c[10] = -1, c[14] = -2 * f), c;
        }, d.b5 = function(c) {
          var n = new Ce(16);
          return n[0] = c[0], n[1] = c[1], n[2] = c[2], n[3] = c[3], n[4] = c[4], n[5] = c[5], n[6] = c[6], n[7] = c[7], n[8] = c[8], n[9] = c[9], n[10] = c[10], n[11] = c[11], n[12] = c[12], n[13] = c[13], n[14] = c[14], n[15] = c[15], n;
        }, d.b6 = function(c, n, l) {
          var f = Math.sin(l), _ = Math.cos(l), b = n[0], v = n[1], T = n[2], A = n[3], I = n[4], P = n[5], D = n[6], U = n[7];
          return n !== c && (c[8] = n[8], c[9] = n[9], c[10] = n[10], c[11] = n[11], c[12] = n[12], c[13] = n[13], c[14] = n[14], c[15] = n[15]), c[0] = b * _ + I * f, c[1] = v * _ + P * f, c[2] = T * _ + D * f, c[3] = A * _ + U * f, c[4] = I * _ - b * f, c[5] = P * _ - v * f, c[6] = D * _ - T * f, c[7] = U * _ - A * f, c;
        }, d.b7 = function(c, n, l) {
          var f = Math.sin(l), _ = Math.cos(l), b = n[4], v = n[5], T = n[6], A = n[7], I = n[8], P = n[9], D = n[10], U = n[11];
          return n !== c && (c[0] = n[0], c[1] = n[1], c[2] = n[2], c[3] = n[3], c[12] = n[12], c[13] = n[13], c[14] = n[14], c[15] = n[15]), c[4] = b * _ + I * f, c[5] = v * _ + P * f, c[6] = T * _ + D * f, c[7] = A * _ + U * f, c[8] = I * _ - b * f, c[9] = P * _ - v * f, c[10] = D * _ - T * f, c[11] = U * _ - A * f, c;
        }, d.b8 = function() {
          const c = new Float32Array(16);
          return Ze(c), c;
        }, d.b9 = function() {
          const c = new Float64Array(16);
          return Ze(c), c;
        }, d.bA = function(c, n) {
          const l = wi(c, 360), f = wi(n, 360), _ = f - l, b = f > l ? _ - 360 : _ + 360;
          return Math.abs(_) < Math.abs(b) ? _ : b;
        }, d.bB = function(c) {
          return c[0] = 0, c[1] = 0, c[2] = 0, c;
        }, d.bC = function(c, n, l, f) {
          const _ = Math.sqrt(c * c + n * n), b = Math.sqrt(l * l + f * f);
          c /= _, n /= _, l /= b, f /= b;
          const v = Math.acos(c * l + n * f);
          return -n * l + c * f > 0 ? v : -v;
        }, d.bD = function(c, n) {
          const l = wi(c, 2 * Math.PI), f = wi(n, 2 * Math.PI);
          return Math.min(Math.abs(l - f), Math.abs(l - f + 2 * Math.PI), Math.abs(l - f - 2 * Math.PI));
        }, d.bE = function() {
          const c = {}, n = ve.$version;
          for (const l in ve.$root) {
            const f = ve.$root[l];
            if (f.required) {
              let _ = null;
              _ = l === "version" ? n : f.type === "array" ? [] : {}, _ != null && (c[l] = _);
            }
          }
          return c;
        }, d.bF = oc, d.bG = pe, d.bH = function c(n, l) {
          if (Array.isArray(n)) {
            if (!Array.isArray(l) || n.length !== l.length) return !1;
            for (let f = 0; f < n.length; f++) if (!c(n[f], l[f])) return !1;
            return !0;
          }
          if (typeof n == "object" && n !== null && l !== null) {
            if (typeof l != "object" || Object.keys(n).length !== Object.keys(l).length) return !1;
            for (const f in n) if (!c(n[f], l[f])) return !1;
            return !0;
          }
          return n === l;
        }, d.bI = function(c) {
          c = c.slice();
          const n = /* @__PURE__ */ Object.create(null);
          for (let l = 0; l < c.length; l++) n[c[l].id] = c[l];
          for (let l = 0; l < c.length; l++) "ref" in c[l] && (c[l] = Ot(c[l], n[c[l].ref]));
          return c;
        }, d.bJ = function(c) {
          if (c.type === "custom") return new US(c);
          switch (c.type) {
            case "background":
              return new kS(c);
            case "circle":
              return new xE(c);
            case "color-relief":
              return new CE(c);
            case "fill":
              return new jE(c);
            case "fill-extrusion":
              return new QE(c);
            case "heatmap":
              return new TE(c);
            case "hillshade":
              return new EE(c);
            case "line":
              return new oS(c);
            case "raster":
              return new LS(c);
            case "symbol":
              return new ff(c);
          }
        }, d.bK = Ji, d.bL = function(c, n) {
          if (!c) return [{ command: "setStyle", args: [n] }];
          let l = [];
          try {
            if (!ft(c.version, n.version)) return [{ command: "setStyle", args: [n] }];
            ft(c.center, n.center) || l.push({ command: "setCenter", args: [n.center] }), ft(c.state, n.state) || l.push({ command: "setGlobalState", args: [n.state] }), ft(c.centerAltitude, n.centerAltitude) || l.push({ command: "setCenterAltitude", args: [n.centerAltitude] }), ft(c.zoom, n.zoom) || l.push({ command: "setZoom", args: [n.zoom] }), ft(c.bearing, n.bearing) || l.push({ command: "setBearing", args: [n.bearing] }), ft(c.pitch, n.pitch) || l.push({ command: "setPitch", args: [n.pitch] }), ft(c.roll, n.roll) || l.push({ command: "setRoll", args: [n.roll] }), ft(c.sprite, n.sprite) || l.push({ command: "setSprite", args: [n.sprite] }), ft(c.glyphs, n.glyphs) || l.push({ command: "setGlyphs", args: [n.glyphs] }), ft(c.transition, n.transition) || l.push({ command: "setTransition", args: [n.transition] }), ft(c.light, n.light) || l.push({ command: "setLight", args: [n.light] }), ft(c.terrain, n.terrain) || l.push({ command: "setTerrain", args: [n.terrain] }), ft(c.sky, n.sky) || l.push({ command: "setSky", args: [n.sky] }), ft(c.projection, n.projection) || l.push({ command: "setProjection", args: [n.projection] });
            const f = {}, _ = [];
            (function(v, T, A, I) {
              let P;
              for (P in T = T || {}, v = v || {}) Object.prototype.hasOwnProperty.call(v, P) && (Object.prototype.hasOwnProperty.call(T, P) || Li(P, A, I));
              for (P in T) Object.prototype.hasOwnProperty.call(T, P) && (Object.prototype.hasOwnProperty.call(v, P) ? ft(v[P], T[P]) || (v[P].type === "geojson" && T[P].type === "geojson" && Ti(v, T, P) ? St(A, { command: "setGeoJSONSourceData", args: [P, T[P].data] }) : Ui(P, T, A, I)) : Kt(P, T, A));
            })(c.sources, n.sources, _, f);
            const b = [];
            c.layers && c.layers.forEach(((v) => {
              "source" in v && f[v.source] ? l.push({ command: "removeLayer", args: [v.id] }) : b.push(v);
            })), l = l.concat(_), (function(v, T, A) {
              T = T || [];
              const I = (v = v || []).map(Nt), P = T.map(Nt), D = v.reduce(Pi, {}), U = T.reduce(Pi, {}), V = I.slice(), j = /* @__PURE__ */ Object.create(null);
              let G, Z, te, me, ce;
              for (let de = 0, Re = 0; de < I.length; de++) G = I[de], Object.prototype.hasOwnProperty.call(U, G) ? Re++ : (St(A, { command: "removeLayer", args: [G] }), V.splice(V.indexOf(G, Re), 1));
              for (let de = 0, Re = 0; de < P.length; de++) G = P[P.length - 1 - de], V[V.length - 1 - de] !== G && (Object.prototype.hasOwnProperty.call(D, G) ? (St(A, { command: "removeLayer", args: [G] }), V.splice(V.lastIndexOf(G, V.length - Re), 1)) : Re++, me = V[V.length - de], St(A, { command: "addLayer", args: [U[G], me] }), V.splice(V.length - de, 0, G), j[G] = !0);
              for (let de = 0; de < P.length; de++) if (G = P[de], Z = D[G], te = U[G], !j[G] && !ft(Z, te)) if (ft(Z.source, te.source) && ft(Z["source-layer"], te["source-layer"]) && ft(Z.type, te.type)) {
                for (ce in Pt(Z.layout, te.layout, A, G, null, "setLayoutProperty"), Pt(Z.paint, te.paint, A, G, null, "setPaintProperty"), ft(Z.filter, te.filter) || St(A, { command: "setFilter", args: [G, te.filter] }), ft(Z.minzoom, te.minzoom) && ft(Z.maxzoom, te.maxzoom) || St(A, { command: "setLayerZoomRange", args: [G, te.minzoom, te.maxzoom] }), Z) Object.prototype.hasOwnProperty.call(Z, ce) && ce !== "layout" && ce !== "paint" && ce !== "filter" && ce !== "metadata" && ce !== "minzoom" && ce !== "maxzoom" && (ce.indexOf("paint.") === 0 ? Pt(Z[ce], te[ce], A, G, ce.slice(6), "setPaintProperty") : ft(Z[ce], te[ce]) || St(A, { command: "setLayerProperty", args: [G, ce, te[ce]] }));
                for (ce in te) Object.prototype.hasOwnProperty.call(te, ce) && !Object.prototype.hasOwnProperty.call(Z, ce) && ce !== "layout" && ce !== "paint" && ce !== "filter" && ce !== "metadata" && ce !== "minzoom" && ce !== "maxzoom" && (ce.indexOf("paint.") === 0 ? Pt(Z[ce], te[ce], A, G, ce.slice(6), "setPaintProperty") : ft(Z[ce], te[ce]) || St(A, { command: "setLayerProperty", args: [G, ce, te[ce]] }));
              } else St(A, { command: "removeLayer", args: [G] }), me = V[V.lastIndexOf(G) + 1], St(A, { command: "addLayer", args: [te, me] });
            })(b, n.layers, l);
          } catch (f) {
            console.warn("Unable to compute style diff:", f), l = [{ command: "setStyle", args: [n] }];
          }
          return l;
        }, d.bM = function(c) {
          const n = [], l = c.id;
          return l === void 0 && n.push({ message: `layers.${l}: missing required property "id"` }), c.render === void 0 && n.push({ message: `layers.${l}: missing required method "render"` }), c.renderingMode && c.renderingMode !== "2d" && c.renderingMode !== "3d" && n.push({ message: `layers.${l}: property "renderingMode" must be either "2d" or "3d"` }), n;
        }, d.bN = Fi, d.bO = ws, d.bP = class extends jr {
          constructor(c, n) {
            super(c, n), this.current = 0;
          }
          set(c) {
            this.current !== c && (this.current = c, this.gl.uniform1i(this.location, c));
          }
        }, d.bQ = er, d.bR = class extends jr {
          constructor(c, n) {
            super(c, n), this.current = gs;
          }
          set(c) {
            if (c[12] !== this.current[12] || c[0] !== this.current[0]) return this.current = c, void this.gl.uniformMatrix4fv(this.location, !1, c);
            for (let n = 1; n < 16; n++) if (c[n] !== this.current[n]) {
              this.current = c, this.gl.uniformMatrix4fv(this.location, !1, c);
              break;
            }
          }
        }, d.bS = Xi, d.bT = class extends jr {
          constructor(c, n) {
            super(c, n), this.current = [0, 0, 0];
          }
          set(c) {
            c[0] === this.current[0] && c[1] === this.current[1] && c[2] === this.current[2] || (this.current = c, this.gl.uniform3f(this.location, c[0], c[1], c[2]));
          }
        }, d.bU = class extends jr {
          constructor(c, n) {
            super(c, n), this.current = [0, 0];
          }
          set(c) {
            c[0] === this.current[0] && c[1] === this.current[1] || (this.current = c, this.gl.uniform2f(this.location, c[0], c[1]));
          }
        }, d.bV = Le, d.bW = function(c, n) {
          var l = Math.sin(n), f = Math.cos(n);
          return c[0] = f, c[1] = l, c[2] = 0, c[3] = -l, c[4] = f, c[5] = 0, c[6] = 0, c[7] = 0, c[8] = 1, c;
        }, d.bX = function(c, n, l) {
          var f = n[0], _ = n[1], b = n[2];
          return c[0] = f * l[0] + _ * l[3] + b * l[6], c[1] = f * l[1] + _ * l[4] + b * l[7], c[2] = f * l[2] + _ * l[5] + b * l[8], c;
        }, d.bY = function(c, n, l, f, _, b, v) {
          var T = 1 / (n - l), A = 1 / (f - _), I = 1 / (b - v);
          return c[0] = -2 * T, c[1] = 0, c[2] = 0, c[3] = 0, c[4] = 0, c[5] = -2 * A, c[6] = 0, c[7] = 0, c[8] = 0, c[9] = 0, c[10] = 2 * I, c[11] = 0, c[12] = (n + l) * T, c[13] = (_ + f) * A, c[14] = (v + b) * I, c[15] = 1, c;
        }, d.bZ = class extends jr {
          constructor(c, n) {
            super(c, n), this.current = new Array();
          }
          set(c) {
            if (c != this.current) {
              this.current = c;
              const n = new Float32Array(4 * c.length);
              for (let l = 0; l < c.length; l++) n[4 * l] = c[l].r, n[4 * l + 1] = c[l].g, n[4 * l + 2] = c[l].b, n[4 * l + 3] = c[l].a;
              this.gl.uniform4fv(this.location, n);
            }
          }
        }, d.b_ = class extends jr {
          constructor(c, n) {
            super(c, n), this.current = new Array();
          }
          set(c) {
            if (c != this.current) {
              this.current = c;
              const n = new Float32Array(c);
              this.gl.uniform1fv(this.location, n);
            }
          }
        }, d.ba = function() {
          return new Float64Array(16);
        }, d.bb = function(c, n, l) {
          const f = new Float64Array(4);
          return Dr(f, c, n - 90, l), f;
        }, d.bc = function(c, n, l, f) {
          var _, b, v, T, A, I = n[0], P = n[1], D = n[2], U = n[3], V = l[0], j = l[1], G = l[2], Z = l[3];
          return (b = I * V + P * j + D * G + U * Z) < 0 && (b = -b, V = -V, j = -j, G = -G, Z = -Z), 1 - b > Ee ? (_ = Math.acos(b), v = Math.sin(_), T = Math.sin((1 - f) * _) / v, A = Math.sin(f * _) / v) : (T = 1 - f, A = f), c[0] = T * I + A * V, c[1] = T * P + A * j, c[2] = T * D + A * G, c[3] = T * U + A * Z, c;
        }, d.bd = function(c) {
          const n = new Float64Array(9);
          var l, f, _, b, v, T, A, I, P, D, U, V, j, G, Z, te, me, ce;
          D = (_ = (f = c)[0]) * (A = _ + _), U = (b = f[1]) * A, j = (v = f[2]) * A, G = v * (I = b + b), te = (T = f[3]) * A, me = T * I, ce = T * (P = v + v), (l = n)[0] = 1 - (V = b * I) - (Z = v * P), l[3] = U - ce, l[6] = j + me, l[1] = U + ce, l[4] = 1 - D - Z, l[7] = G - te, l[2] = j - me, l[5] = G + te, l[8] = 1 - D - V;
          const de = Js(-Math.asin(Er(n[2], -1, 1)));
          let Re, ke;
          return Math.hypot(n[5], n[8]) < 1e-3 ? (Re = 0, ke = -Js(Math.atan2(n[3], n[4]))) : (Re = Js(n[5] === 0 && n[8] === 0 ? 0 : Math.atan2(n[5], n[8])), ke = Js(n[1] === 0 && n[0] === 0 ? 0 : Math.atan2(n[1], n[0]))), { roll: Re, pitch: de + 90, bearing: ke };
        }, d.be = function(c, n) {
          return c.roll == n.roll && c.pitch == n.pitch && c.bearing == n.bearing;
        }, d.bf = mt, d.bg = qn, d.bh = vc, d.bi = du, d.bj = bc, d.bk = sr, d.bl = cs, d.bm = Cr, d.bn = function(c, n, l, f, _) {
          return sr(f, _, Er((c - n) / (l - n), 0, 1));
        }, d.bo = wi, d.bp = function() {
          return new Float64Array(3);
        }, d.bq = function(c, n, l, f) {
          return c[0] = n[0] + l[0] * f, c[1] = n[1] + l[1] * f, c[2] = n[2] + l[2] * f, c;
        }, d.br = Dr, d.bs = function(c, n, l) {
          var f = l[0], _ = l[1], b = l[2], v = n[0], T = n[1], A = n[2], I = _ * A - b * T, P = b * v - f * A, D = f * T - _ * v, U = _ * D - b * P, V = b * I - f * D, j = f * P - _ * I, G = 2 * l[3];
          return P *= G, D *= G, V *= 2, j *= 2, c[0] = v + (I *= G) + (U *= 2), c[1] = T + P + V, c[2] = A + D + j, c;
        }, d.bt = function(c, n, l) {
          const f = (_ = [c[0], c[1], c[2], n[0], n[1], n[2], l[0], l[1], l[2]])[0] * ((P = _[8]) * (v = _[4]) - (T = _[5]) * (I = _[7])) + _[1] * (-P * (b = _[3]) + T * (A = _[6])) + _[2] * (I * b - v * A);
          var _, b, v, T, A, I, P;
          if (f === 0) return null;
          const D = bt([], [n[0], n[1], n[2]], [l[0], l[1], l[2]]), U = bt([], [l[0], l[1], l[2]], [c[0], c[1], c[2]]), V = bt([], [c[0], c[1], c[2]], [n[0], n[1], n[2]]), j = ot([], D, -c[3]);
          return st(j, j, ot([], U, -n[3])), st(j, j, ot([], V, -l[3])), ot(j, j, 1 / f), j;
        }, d.bu = z_, d.bv = function() {
          return new Float64Array(4);
        }, d.bw = function(c, n, l, f) {
          var _ = [], b = [];
          return _[0] = n[0] - l[0], _[1] = n[1] - l[1], _[2] = n[2] - l[2], b[0] = _[0] * Math.cos(f) - _[1] * Math.sin(f), b[1] = _[0] * Math.sin(f) + _[1] * Math.cos(f), b[2] = _[2], c[0] = b[0] + l[0], c[1] = b[1] + l[1], c[2] = b[2] + l[2], c;
        }, d.bx = function(c, n, l, f) {
          var _ = [], b = [];
          return _[0] = n[0] - l[0], _[1] = n[1] - l[1], _[2] = n[2] - l[2], b[0] = _[0], b[1] = _[1] * Math.cos(f) - _[2] * Math.sin(f), b[2] = _[1] * Math.sin(f) + _[2] * Math.cos(f), c[0] = b[0] + l[0], c[1] = b[1] + l[1], c[2] = b[2] + l[2], c;
        }, d.by = function(c, n, l, f) {
          var _ = [], b = [];
          return _[0] = n[0] - l[0], _[1] = n[1] - l[1], _[2] = n[2] - l[2], b[0] = _[2] * Math.sin(f) + _[0] * Math.cos(f), b[1] = _[1], b[2] = _[2] * Math.cos(f) - _[0] * Math.sin(f), c[0] = b[0] + l[0], c[1] = b[1] + l[1], c[2] = b[2] + l[2], c;
        }, d.bz = function(c, n, l) {
          var f = Math.sin(l), _ = Math.cos(l), b = n[0], v = n[1], T = n[2], A = n[3], I = n[8], P = n[9], D = n[10], U = n[11];
          return n !== c && (c[4] = n[4], c[5] = n[5], c[6] = n[6], c[7] = n[7], c[12] = n[12], c[13] = n[13], c[14] = n[14], c[15] = n[15]), c[0] = b * _ - I * f, c[1] = v * _ - P * f, c[2] = T * _ - D * f, c[3] = A * _ - U * f, c[8] = b * f + I * _, c[9] = v * f + P * _, c[10] = T * f + D * _, c[11] = A * f + U * _, c;
        }, d.c = _e, d.c0 = hS, d.c1 = class extends h {
        }, d.c2 = v_, d.c3 = function(c) {
          return c <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(c) / Math.LN2));
        }, d.c4 = pb, d.c5 = function(c, n, l) {
          var f = n[0], _ = n[1], b = n[2], v = l[3] * f + l[7] * _ + l[11] * b + l[15];
          return c[0] = (l[0] * f + l[4] * _ + l[8] * b + l[12]) / (v = v || 1), c[1] = (l[1] * f + l[5] * _ + l[9] * b + l[13]) / v, c[2] = (l[2] * f + l[6] * _ + l[10] * b + l[14]) / v, c;
        }, d.c6 = class extends tu {
        }, d.c7 = class extends R {
        }, d.c8 = function(c, n) {
          return c[0] === n[0] && c[1] === n[1] && c[2] === n[2] && c[3] === n[3] && c[4] === n[4] && c[5] === n[5] && c[6] === n[6] && c[7] === n[7] && c[8] === n[8] && c[9] === n[9] && c[10] === n[10] && c[11] === n[11] && c[12] === n[12] && c[13] === n[13] && c[14] === n[14] && c[15] === n[15];
        }, d.c9 = function(c, n) {
          var l = c[0], f = c[1], _ = c[2], b = c[3], v = c[4], T = c[5], A = c[6], I = c[7], P = c[8], D = c[9], U = c[10], V = c[11], j = c[12], G = c[13], Z = c[14], te = c[15], me = n[0], ce = n[1], de = n[2], Re = n[3], ke = n[4], je = n[5], it = n[6], Xe = n[7], Qe = n[8], pt = n[9], Ye = n[10], et = n[11], Ue = n[12], xt = n[13], At = n[14], gt = n[15];
          return Math.abs(l - me) <= Ee * Math.max(1, Math.abs(l), Math.abs(me)) && Math.abs(f - ce) <= Ee * Math.max(1, Math.abs(f), Math.abs(ce)) && Math.abs(_ - de) <= Ee * Math.max(1, Math.abs(_), Math.abs(de)) && Math.abs(b - Re) <= Ee * Math.max(1, Math.abs(b), Math.abs(Re)) && Math.abs(v - ke) <= Ee * Math.max(1, Math.abs(v), Math.abs(ke)) && Math.abs(T - je) <= Ee * Math.max(1, Math.abs(T), Math.abs(je)) && Math.abs(A - it) <= Ee * Math.max(1, Math.abs(A), Math.abs(it)) && Math.abs(I - Xe) <= Ee * Math.max(1, Math.abs(I), Math.abs(Xe)) && Math.abs(P - Qe) <= Ee * Math.max(1, Math.abs(P), Math.abs(Qe)) && Math.abs(D - pt) <= Ee * Math.max(1, Math.abs(D), Math.abs(pt)) && Math.abs(U - Ye) <= Ee * Math.max(1, Math.abs(U), Math.abs(Ye)) && Math.abs(V - et) <= Ee * Math.max(1, Math.abs(V), Math.abs(et)) && Math.abs(j - Ue) <= Ee * Math.max(1, Math.abs(j), Math.abs(Ue)) && Math.abs(G - xt) <= Ee * Math.max(1, Math.abs(G), Math.abs(xt)) && Math.abs(Z - At) <= Ee * Math.max(1, Math.abs(Z), Math.abs(At)) && Math.abs(te - gt) <= Ee * Math.max(1, Math.abs(te), Math.abs(gt));
        }, d.cA = function(c, n) {
          $.REGISTERED_PROTOCOLS[c] = n;
        }, d.cB = function(c) {
          delete $.REGISTERED_PROTOCOLS[c];
        }, d.cC = function(c, n) {
          const l = {};
          for (let _ = 0; _ < c.length; _++) {
            const b = n && n[c[_].id] || l_(c[_]);
            n && (n[c[_].id] = b);
            let v = l[b];
            v || (v = l[b] = []), v.push(c[_]);
          }
          const f = [];
          for (const _ in l) f.push(l[_]);
          return f;
        }, d.cD = nt, d.cE = u0, d.cF = f0, d.cG = Hb, d.cH = function(c) {
          c.bucket.createArrays(), c.bucket.tilePixelRatio = Ht / (512 * c.bucket.overscaling), c.bucket.compareText = {}, c.bucket.iconsNeedLinear = !1;
          const n = c.bucket.layers[0], l = n.layout, f = n._unevaluatedLayout._values, _ = { layoutIconSize: f["icon-size"].possiblyEvaluate(new gi(c.bucket.zoom + 1), c.canonical), layoutTextSize: f["text-size"].possiblyEvaluate(new gi(c.bucket.zoom + 1), c.canonical), textMaxSize: f["text-size"].possiblyEvaluate(new gi(18)) };
          if (c.bucket.textSizeData.kind === "composite") {
            const { minZoom: I, maxZoom: P } = c.bucket.textSizeData;
            _.compositeTextSizes = [f["text-size"].possiblyEvaluate(new gi(I), c.canonical), f["text-size"].possiblyEvaluate(new gi(P), c.canonical)];
          }
          if (c.bucket.iconSizeData.kind === "composite") {
            const { minZoom: I, maxZoom: P } = c.bucket.iconSizeData;
            _.compositeIconSizes = [f["icon-size"].possiblyEvaluate(new gi(I), c.canonical), f["icon-size"].possiblyEvaluate(new gi(P), c.canonical)];
          }
          const b = l.get("text-line-height") * cr, v = l.get("text-rotation-alignment") !== "viewport" && l.get("symbol-placement") !== "point", T = l.get("text-keep-upright"), A = l.get("text-size");
          for (const I of c.bucket.features) {
            const P = l.get("text-font").evaluate(I, {}, c.canonical).join(","), D = A.evaluate(I, {}, c.canonical), U = _.layoutTextSize.evaluate(I, {}, c.canonical), V = _.layoutIconSize.evaluate(I, {}, c.canonical), j = { horizontal: {}, vertical: void 0 }, G = I.text;
            let Z, te = [0, 0];
            if (G) {
              const de = G.toString(), Re = l.get("text-letter-spacing").evaluate(I, {}, c.canonical) * cr, ke = d_(de) ? Re : 0, je = l.get("text-anchor").evaluate(I, {}, c.canonical), it = A0(n, I, c.canonical);
              if (!it) {
                const Ye = l.get("text-radial-offset").evaluate(I, {}, c.canonical);
                te = Ye ? T0(je, [Ye * cr, H_]) : l.get("text-offset").evaluate(I, {}, c.canonical).map(((et) => et * cr));
              }
              let Xe = v ? "center" : l.get("text-justify").evaluate(I, {}, c.canonical);
              const Qe = l.get("symbol-placement") === "point" ? l.get("text-max-width").evaluate(I, {}, c.canonical) * cr : 1 / 0, pt = () => {
                c.bucket.allowVerticalPlacement && ac(de) && (j.vertical = hf(G, c.glyphMap, c.glyphPositions, c.imagePositions, P, Qe, b, je, "left", ke, te, d.ao.vertical, !0, U, D));
              };
              if (!v && it) {
                const Ye = /* @__PURE__ */ new Set();
                if (Xe === "auto") for (let Ue = 0; Ue < it.values.length; Ue += 2) Ye.add($_(it.values[Ue]));
                else Ye.add(Xe);
                let et = !1;
                for (const Ue of Ye) if (!j.horizontal[Ue]) if (et) j.horizontal[Ue] = j.horizontal[0];
                else {
                  const xt = hf(G, c.glyphMap, c.glyphPositions, c.imagePositions, P, Qe, b, "center", Ue, ke, te, d.ao.horizontal, !1, U, D);
                  xt && (j.horizontal[Ue] = xt, et = xt.positionedLines.length === 1);
                }
                pt();
              } else {
                Xe === "auto" && (Xe = $_(je));
                const Ye = hf(G, c.glyphMap, c.glyphPositions, c.imagePositions, P, Qe, b, je, Xe, ke, te, d.ao.horizontal, !1, U, D);
                Ye && (j.horizontal[Xe] = Ye), pt(), ac(de) && v && T && (j.vertical = hf(G, c.glyphMap, c.glyphPositions, c.imagePositions, P, Qe, b, je, Xe, ke, te, d.ao.vertical, !1, U, D));
              }
            }
            let me = !1;
            if (I.icon && I.icon.name) {
              const de = c.imageMap[I.icon.name];
              de && (Z = BS(c.imagePositions[I.icon.name], l.get("icon-offset").evaluate(I, {}, c.canonical), l.get("icon-anchor").evaluate(I, {}, c.canonical)), me = !!de.sdf, c.bucket.sdfIcons === void 0 ? c.bucket.sdfIcons = me : c.bucket.sdfIcons !== me && ai("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (de.pixelRatio !== c.bucket.pixelRatio || l.get("icon-rotate").constantOr(1) !== 0) && (c.bucket.iconsNeedLinear = !0));
            }
            const ce = S0(j.horizontal) || j.vertical;
            c.bucket.iconsInText = !!ce && ce.iconsInText, (ce || Z) && qS(c.bucket, I, j, Z, c.imageMap, _, U, V, te, me, c.canonical, c.subdivisionGranularity);
          }
          c.showCollisionBoxes && c.bucket.generateCollisionDebugBuffers();
        }, d.cI = M_, d.cJ = S_, d.cK = I_, d.cL = Mb, d.cM = P_, d.cN = class {
          constructor(c) {
            this._marks = { start: [c.url, "start"].join("#"), end: [c.url, "end"].join("#"), measure: c.url.toString() }, performance.mark(this._marks.start);
          }
          finish() {
            performance.mark(this._marks.end);
            let c = performance.getEntriesByName(this._marks.measure);
            return c.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), c = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), c;
          }
        }, d.cO = function(c, n, l, f, _) {
          return a(this, void 0, void 0, (function* () {
            if (Se()) try {
              return yield Ts(c, n, l, f, _);
            } catch {
            }
            return (function(b, v, T, A, I) {
              const P = b.width, D = b.height;
              Ni && Ks || (Ni = new OffscreenCanvas(P, D), Ks = Ni.getContext("2d", { willReadFrequently: !0 })), Ni.width = P, Ni.height = D, Ks.drawImage(b, 0, 0, P, D);
              const U = Ks.getImageData(v, T, A, I);
              return Ks.clearRect(0, 0, P, D), U.data;
            })(c, n, l, f, _);
          }));
        }, d.cP = mb, d.cQ = S, d.cR = Ib, d.cS = xc, d.cT = Ya, d.cU = function(c, n) {
          const l = /* @__PURE__ */ new Map();
          if (c != null) if (c.type === "Feature") l.set(bu(c, n), c);
          else for (const f of c.features) l.set(bu(f, n), f);
          return l;
        }, d.cV = function(c, n) {
          if (c == null) return !0;
          if (c.type === "Feature") return bu(c, n) != null;
          if (c.type === "FeatureCollection") {
            const l = /* @__PURE__ */ new Set();
            for (const f of c.features) {
              const _ = bu(f, n);
              if (_ == null || l.has(_)) return !1;
              l.add(_);
            }
            return !0;
          }
          return !1;
        }, d.cW = function(c, n, l) {
          var f, _, b, v;
          if (n.removeAll && c.clear(), n.remove) for (const T of n.remove) c.delete(T);
          if (n.add) for (const T of n.add) {
            const A = bu(T, l);
            A != null && c.set(A, T);
          }
          if (n.update) for (const T of n.update) {
            let A = c.get(T.id);
            if (A == null) continue;
            const I = !T.removeAllProperties && (((f = T.removeProperties) === null || f === void 0 ? void 0 : f.length) > 0 || ((_ = T.addOrUpdateProperties) === null || _ === void 0 ? void 0 : _.length) > 0);
            if ((T.newGeometry || T.removeAllProperties || I) && (A = Object.assign({}, A), c.set(T.id, A), I && (A.properties = Object.assign({}, A.properties))), T.newGeometry && (A.geometry = T.newGeometry), T.removeAllProperties) A.properties = {};
            else if (((b = T.removeProperties) === null || b === void 0 ? void 0 : b.length) > 0) for (const P of T.removeProperties) Object.prototype.hasOwnProperty.call(A.properties, P) && delete A.properties[P];
            if (((v = T.addOrUpdateProperties) === null || v === void 0 ? void 0 : v.length) > 0) for (const { key: P, value: D } of T.addOrUpdateProperties) A.properties[P] = D;
          }
        }, d.cX = ks, d.ca = function(c, n) {
          return c[0] = n[0], c[1] = n[1], c[2] = n[2], c[3] = n[3], c[4] = n[4], c[5] = n[5], c[6] = n[6], c[7] = n[7], c[8] = n[8], c[9] = n[9], c[10] = n[10], c[11] = n[11], c[12] = n[12], c[13] = n[13], c[14] = n[14], c[15] = n[15], c;
        }, d.cb = (c) => c.type === "symbol", d.cc = (c) => c.type === "circle", d.cd = (c) => c.type === "heatmap", d.ce = (c) => c.type === "line", d.cf = (c) => c.type === "fill", d.cg = (c) => c.type === "fill-extrusion", d.ch = (c) => c.type === "hillshade", d.ci = (c) => c.type === "color-relief", d.cj = (c) => c.type === "raster", d.ck = (c) => c.type === "background", d.cl = (c) => c.type === "custom", d.cm = hs, d.cn = function(c, n, l) {
          const f = Ln(n.x - l.x, n.y - l.y), _ = Ln(c.x - l.x, c.y - l.y);
          var b, v;
          return Js(Math.atan2(f[0] * _[1] - f[1] * _[0], (b = f)[0] * (v = _)[0] + b[1] * v[1]));
        }, d.co = pn, d.cp = function(c, n) {
          return As[n] && (c instanceof MouseEvent || c instanceof WheelEvent);
        }, d.cq = function(c, n) {
          return Qs[n] && "touches" in c;
        }, d.cr = function(c) {
          return Qs[c] || As[c];
        }, d.cs = function(c, n, l) {
          var f = n[0], _ = n[1];
          return c[0] = l[0] * f + l[4] * _ + l[12], c[1] = l[1] * f + l[5] * _ + l[13], c;
        }, d.ct = function(c, n) {
          const { x: l, y: f } = yu.fromLngLat(n);
          return !(c < 0 || c > 25 || f < 0 || f >= 1 || l < 0 || l >= 1);
        }, d.cu = function(c, n) {
          return c[0] = n[0], c[1] = 0, c[2] = 0, c[3] = 0, c[4] = 0, c[5] = n[1], c[6] = 0, c[7] = 0, c[8] = 0, c[9] = 0, c[10] = n[2], c[11] = 0, c[12] = 0, c[13] = 0, c[14] = 0, c[15] = 1, c;
        }, d.cv = class extends ra {
        }, d.cw = KS, d.cy = function(c) {
          return c.message === gn;
        }, d.cz = ae, d.d = Pe, d.e = ji, d.f = (c) => a(void 0, void 0, void 0, (function* () {
          if (c.byteLength === 0) return createImageBitmap(new ImageData(1, 1));
          const n = new Blob([new Uint8Array(c)], { type: "image/png" });
          try {
            return createImageBitmap(n);
          } catch (l) {
            throw new Error(`Could not load image because of ${l.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`);
          }
        })), d.g = W, d.h = (c) => new Promise(((n, l) => {
          const f = new Image();
          f.onload = () => {
            n(f), URL.revokeObjectURL(f.src), f.onload = null, window.requestAnimationFrame((() => {
              f.src = ts;
            }));
          }, f.onerror = () => l(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          const _ = new Blob([new Uint8Array(c)], { type: "image/png" });
          f.src = c.byteLength ? URL.createObjectURL(_) : ts;
        })), d.i = ki, d.j = (c, n) => ge(ji(c, { type: "json" }), n), d.k = ze, d.l = He, d.m = ge, d.n = (c, n) => ge(ji(c, { type: "arrayBuffer" }), n), d.o = function(c) {
          return new P_(c).readFields(xS, []);
        }, d.p = jb, d.q = au, d.r = zr, d.s = Ys, d.t = Jd, d.u = Lt, d.v = ve, d.w = ai, d.x = c_, d.y = sl, d.z = Qo;
      })), o("worker", ["./shared"], (function(d) {
        class a {
          constructor($) {
            this.keyCache = {}, $ && this.replace($);
          }
          replace($) {
            this._layerConfigs = {}, this._layers = {}, this.update($, []);
          }
          update($, W) {
            for (const ae of $) {
              this._layerConfigs[ae.id] = ae;
              const pe = this._layers[ae.id] = d.bJ(ae);
              pe._featureFilter = d.aa(pe.filter), this.keyCache[ae.id] && delete this.keyCache[ae.id];
            }
            for (const ae of W) delete this.keyCache[ae], delete this._layerConfigs[ae], delete this._layers[ae];
            this.familiesBySource = {};
            const q = d.cC(Object.values(this._layerConfigs), this.keyCache);
            for (const ae of q) {
              const pe = ae.map(((ze) => this._layers[ze.id])), ge = pe[0];
              if (ge.visibility === "none") continue;
              const Pe = ge.source || "";
              let ye = this.familiesBySource[Pe];
              ye || (ye = this.familiesBySource[Pe] = {});
              const Ne = ge.sourceLayer || "_geojsonTileLayer";
              let He = ye[Ne];
              He || (He = ye[Ne] = []), He.push(pe);
            }
          }
        }
        class w {
          constructor($) {
            const W = {}, q = [];
            for (const Pe in $) {
              const ye = $[Pe], Ne = W[Pe] = {};
              for (const He in ye) {
                const ze = ye[+He];
                if (!ze || ze.bitmap.width === 0 || ze.bitmap.height === 0) continue;
                const lt = { x: 0, y: 0, w: ze.bitmap.width + 2, h: ze.bitmap.height + 2 };
                q.push(lt), Ne[He] = { rect: lt, metrics: ze.metrics };
              }
            }
            const { w: ae, h: pe } = d.p(q), ge = new d.q({ width: ae || 1, height: pe || 1 });
            for (const Pe in $) {
              const ye = $[Pe];
              for (const Ne in ye) {
                const He = ye[+Ne];
                if (!He || He.bitmap.width === 0 || He.bitmap.height === 0) continue;
                const ze = W[Pe][Ne].rect;
                d.q.copy(He.bitmap, ge, { x: 0, y: 0 }, { x: ze.x + 1, y: ze.y + 1 }, He.bitmap);
              }
            }
            this.image = ge, this.positions = W;
          }
        }
        d.cD("GlyphAtlas", w);
        class S {
          constructor($) {
            this.tileID = new d.Z($.tileID.overscaledZ, $.tileID.wrap, $.tileID.canonical.z, $.tileID.canonical.x, $.tileID.canonical.y), this.uid = $.uid, this.zoom = $.zoom, this.pixelRatio = $.pixelRatio, this.tileSize = $.tileSize, this.source = $.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = $.showCollisionBoxes, this.collectResourceTiming = !!$.collectResourceTiming, this.returnDependencies = !!$.returnDependencies, this.promoteId = $.promoteId, this.inFlightDependencies = [], this.globalState = $.globalState;
          }
          parse($, W, q, ae, pe) {
            return d._(this, void 0, void 0, (function* () {
              this.status = "parsing", this.data = $, this.collisionBoxArray = new d.a8();
              const ge = new d.cE(Object.keys($.layers).sort()), Pe = new d.cF(this.tileID, this.promoteId);
              Pe.bucketLayerIDs = [];
              const ye = {}, Ne = { featureIndex: Pe, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: q, subdivisionGranularity: pe }, He = W.familiesBySource[this.source];
              for (const Pt in He) {
                const Nt = $.layers[Pt];
                if (!Nt) continue;
                Nt.version === 1 && d.w(`Vector tile source "${this.source}" layer "${Pt}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                const Pi = ge.encode(Pt), Ge = [];
                for (let Hi = 0; Hi < Nt.length; Hi++) {
                  const _i = Nt.feature(Hi), Es = Pe.getId(_i, Pt);
                  Ge.push({ feature: _i, id: Es, index: Hi, sourceLayerIndex: Pi });
                }
                for (const Hi of He[Pt]) {
                  const _i = Hi[0];
                  _i.source !== this.source && d.w(`layer.source = ${_i.source} does not equal this.source = ${this.source}`), _i.minzoom && this.zoom < Math.floor(_i.minzoom) || _i.maxzoom && this.zoom >= _i.maxzoom || _i.visibility !== "none" && (M(Hi, this.zoom, q), (ye[_i.id] = _i.createBucket({ index: Pe.bucketLayerIDs.length, layers: Hi, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: Pi, sourceID: this.source, globalState: this.globalState })).populate(Ge, Ne, this.tileID.canonical), Pe.bucketLayerIDs.push(Hi.map(((Es) => Es.id))));
                }
              }
              const ze = d.bN(Ne.glyphDependencies, ((Pt) => Object.keys(Pt).map(Number)));
              this.inFlightDependencies.forEach(((Pt) => Pt?.abort())), this.inFlightDependencies = [];
              let lt = Promise.resolve({});
              if (Object.keys(ze).length) {
                const Pt = new AbortController();
                this.inFlightDependencies.push(Pt), lt = ae.sendAsync({ type: "GG", data: { stacks: ze, source: this.source, tileID: this.tileID, type: "glyphs" } }, Pt);
              }
              const ve = Object.keys(Ne.iconDependencies);
              let wt = Promise.resolve({});
              if (ve.length) {
                const Pt = new AbortController();
                this.inFlightDependencies.push(Pt), wt = ae.sendAsync({ type: "GI", data: { icons: ve, source: this.source, tileID: this.tileID, type: "icons" } }, Pt);
              }
              const Ot = Object.keys(Ne.patternDependencies);
              let ft = Promise.resolve({});
              if (Ot.length) {
                const Pt = new AbortController();
                this.inFlightDependencies.push(Pt), ft = ae.sendAsync({ type: "GI", data: { icons: Ot, source: this.source, tileID: this.tileID, type: "patterns" } }, Pt);
              }
              const [St, Kt, Li] = yield Promise.all([lt, wt, ft]), Ui = new w(St), Ti = new d.cG(Kt, Li);
              for (const Pt in ye) {
                const Nt = ye[Pt];
                Nt instanceof d.a9 ? (M(Nt.layers, this.zoom, q), d.cH({ bucket: Nt, glyphMap: St, glyphPositions: Ui.positions, imageMap: Kt, imagePositions: Ti.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical, subdivisionGranularity: Ne.subdivisionGranularity })) : Nt.hasPattern && (Nt instanceof d.cI || Nt instanceof d.cJ || Nt instanceof d.cK) && (M(Nt.layers, this.zoom, q), Nt.addFeatures(Ne, this.tileID.canonical, Ti.patternPositions));
              }
              return this.status = "done", { buckets: Object.values(ye).filter(((Pt) => !Pt.isEmpty())), featureIndex: Pe, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: Ui.image, imageAtlas: Ti, glyphMap: this.returnDependencies ? St : null, iconMap: this.returnDependencies ? Kt : null, glyphPositions: this.returnDependencies ? Ui.positions : null };
            }));
          }
        }
        function M(_e, $, W) {
          const q = new d.F($);
          for (const ae of _e) ae.recalculate(q, W);
        }
        class F {
          constructor($, W, q) {
            this.actor = $, this.layerIndex = W, this.availableImages = q, this.fetching = {}, this.loading = {}, this.loaded = {};
          }
          loadVectorTile($, W) {
            return d._(this, void 0, void 0, (function* () {
              const q = yield d.n($.request, W);
              try {
                return { vectorTile: new d.cL(new d.cM(q.data)), rawData: q.data, cacheControl: q.cacheControl, expires: q.expires };
              } catch (ae) {
                const pe = new Uint8Array(q.data);
                let ge = `Unable to parse the tile at ${$.request.url}, `;
                throw ge += pe[0] === 31 && pe[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${ae.message}`, new Error(ge);
              }
            }));
          }
          loadTile($) {
            return d._(this, void 0, void 0, (function* () {
              const W = $.uid, q = !!($ && $.request && $.request.collectResourceTiming) && new d.cN($.request), ae = new S($);
              this.loading[W] = ae;
              const pe = new AbortController();
              ae.abort = pe;
              try {
                const ge = yield this.loadVectorTile($, pe);
                if (delete this.loading[W], !ge) return null;
                const Pe = ge.rawData, ye = {};
                ge.expires && (ye.expires = ge.expires), ge.cacheControl && (ye.cacheControl = ge.cacheControl);
                const Ne = {};
                if (q) {
                  const ze = q.finish();
                  ze && (Ne.resourceTiming = JSON.parse(JSON.stringify(ze)));
                }
                ae.vectorTile = ge.vectorTile;
                const He = ae.parse(ge.vectorTile, this.layerIndex, this.availableImages, this.actor, $.subdivisionGranularity);
                this.loaded[W] = ae, this.fetching[W] = { rawTileData: Pe, cacheControl: ye, resourceTiming: Ne };
                try {
                  const ze = yield He;
                  return d.e({ rawTileData: Pe.slice(0) }, ze, ye, Ne);
                } finally {
                  delete this.fetching[W];
                }
              } catch (ge) {
                throw delete this.loading[W], ae.status = "done", this.loaded[W] = ae, ge;
              }
            }));
          }
          reloadTile($) {
            return d._(this, void 0, void 0, (function* () {
              const W = $.uid;
              if (!this.loaded || !this.loaded[W]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
              const q = this.loaded[W];
              if (q.showCollisionBoxes = $.showCollisionBoxes, q.globalState = $.globalState, q.status === "parsing") {
                const ae = yield q.parse(q.vectorTile, this.layerIndex, this.availableImages, this.actor, $.subdivisionGranularity);
                let pe;
                if (this.fetching[W]) {
                  const { rawTileData: ge, cacheControl: Pe, resourceTiming: ye } = this.fetching[W];
                  delete this.fetching[W], pe = d.e({ rawTileData: ge.slice(0) }, ae, Pe, ye);
                } else pe = ae;
                return pe;
              }
              if (q.status === "done" && q.vectorTile) return q.parse(q.vectorTile, this.layerIndex, this.availableImages, this.actor, $.subdivisionGranularity);
            }));
          }
          abortTile($) {
            return d._(this, void 0, void 0, (function* () {
              const W = this.loading, q = $.uid;
              W && W[q] && W[q].abort && (W[q].abort.abort(), delete W[q]);
            }));
          }
          removeTile($) {
            return d._(this, void 0, void 0, (function* () {
              this.loaded && this.loaded[$.uid] && delete this.loaded[$.uid];
            }));
          }
        }
        class N {
          constructor() {
            this.loaded = {};
          }
          loadTile($) {
            return d._(this, void 0, void 0, (function* () {
              const { uid: W, encoding: q, rawImageData: ae, redFactor: pe, greenFactor: ge, blueFactor: Pe, baseShift: ye } = $, Ne = ae.width + 2, He = ae.height + 2, ze = d.b(ae) ? new d.R({ width: Ne, height: He }, yield d.cO(ae, -1, -1, Ne, He)) : ae, lt = new d.cP(W, ze, q, pe, ge, Pe, ye);
              return this.loaded = this.loaded || {}, this.loaded[W] = lt, lt;
            }));
          }
          removeTile($) {
            const W = this.loaded, q = $.uid;
            W && W[q] && delete W[q];
          }
        }
        var L, re, ne = (function() {
          if (re) return L;
          function _e(W, q) {
            if (W.length !== 0) {
              $(W[0], q);
              for (var ae = 1; ae < W.length; ae++) $(W[ae], !q);
            }
          }
          function $(W, q) {
            for (var ae = 0, pe = 0, ge = 0, Pe = W.length, ye = Pe - 1; ge < Pe; ye = ge++) {
              var Ne = (W[ge][0] - W[ye][0]) * (W[ye][1] + W[ge][1]), He = ae + Ne;
              pe += Math.abs(ae) >= Math.abs(Ne) ? ae - He + Ne : Ne - He + ae, ae = He;
            }
            ae + pe >= 0 != !!q && W.reverse();
          }
          return re = 1, L = function W(q, ae) {
            var pe, ge = q && q.type;
            if (ge === "FeatureCollection") for (pe = 0; pe < q.features.length; pe++) W(q.features[pe], ae);
            else if (ge === "GeometryCollection") for (pe = 0; pe < q.geometries.length; pe++) W(q.geometries[pe], ae);
            else if (ge === "Feature") W(q.geometry, ae);
            else if (ge === "Polygon") _e(q.coordinates, ae);
            else if (ge === "MultiPolygon") for (pe = 0; pe < q.coordinates.length; pe++) _e(q.coordinates[pe], ae);
            return q;
          };
        })(), we = d.cQ(ne);
        class Se extends d.cS {
          constructor($, W) {
            super(new d.cM(), 0, W, [], []), this.feature = $, this.type = $.type, this.properties = $.tags ? $.tags : {}, "id" in $ && (typeof $.id == "string" ? this.id = parseInt($.id, 10) : typeof $.id != "number" || isNaN($.id) || (this.id = $.id));
          }
          loadGeometry() {
            const $ = [], W = this.feature.type === 1 ? [this.feature.geometry] : this.feature.geometry;
            for (const q of W) {
              const ae = [];
              for (const pe of q) ae.push(new d.P(pe[0], pe[1]));
              $.push(ae);
            }
            return $;
          }
        }
        class Ee extends d.cR {
          constructor($, W) {
            super(new d.cM()), this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.version = W ? W.version : 1, this.extent = W ? W.extent : 4096, this.length = $.length, this.features = $;
          }
          feature($) {
            return new Se(this.features[$], this.extent);
          }
        }
        function Ce(_e, $) {
          $.writeVarintField(15, _e.version || 1), $.writeStringField(1, _e.name || ""), $.writeVarintField(5, _e.extent || 4096);
          const W = { keys: [], values: [], keycache: {}, valuecache: {} };
          for (let pe = 0; pe < _e.length; pe++) W.feature = _e.feature(pe), $.writeMessage(2, Le, W);
          const q = W.keys;
          for (const pe of q) $.writeStringField(3, pe);
          const ae = W.values;
          for (const pe of ae) $.writeMessage(4, st, pe);
        }
        function Le(_e, $) {
          if (!_e.feature) return;
          const W = _e.feature;
          W.id !== void 0 && $.writeVarintField(1, W.id), $.writeMessage(2, Ze, _e), $.writeVarintField(3, W.type), $.writeMessage(4, _t, W);
        }
        function Ze(_e, $) {
          for (const W in _e.feature?.properties) {
            let q = _e.feature.properties[W], ae = _e.keycache[W];
            if (q === null) continue;
            ae === void 0 && (_e.keys.push(W), ae = _e.keys.length - 1, _e.keycache[W] = ae), $.writeVarint(ae), typeof q != "string" && typeof q != "boolean" && typeof q != "number" && (q = JSON.stringify(q));
            const pe = typeof q + ":" + q;
            let ge = _e.valuecache[pe];
            ge === void 0 && (_e.values.push(q), ge = _e.values.length - 1, _e.valuecache[pe] = ge), $.writeVarint(ge);
          }
        }
        function Ke(_e, $) {
          return ($ << 3) + (7 & _e);
        }
        function ct(_e) {
          return _e << 1 ^ _e >> 31;
        }
        function _t(_e, $) {
          const W = _e.loadGeometry(), q = _e.type;
          let ae = 0, pe = 0;
          for (const ge of W) {
            let Pe = 1;
            q === 1 && (Pe = ge.length), $.writeVarint(Ke(1, Pe));
            const ye = q === 3 ? ge.length - 1 : ge.length;
            for (let Ne = 0; Ne < ye; Ne++) {
              Ne === 1 && q !== 1 && $.writeVarint(Ke(2, ye - 1));
              const He = ge[Ne].x - ae, ze = ge[Ne].y - pe;
              $.writeVarint(ct(He)), $.writeVarint(ct(ze)), ae += He, pe += ze;
            }
            _e.type === 3 && $.writeVarint(Ke(7, 1));
          }
        }
        function st(_e, $) {
          const W = typeof _e;
          W === "string" ? $.writeStringField(1, _e) : W === "boolean" ? $.writeBooleanField(7, _e) : W === "number" && (_e % 1 != 0 ? $.writeDoubleField(3, _e) : _e < 0 ? $.writeSVarintField(6, _e) : $.writeVarintField(5, _e));
        }
        const ot = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: !1, generateId: !1, reduce: null, map: (_e) => _e }, bt = Math.fround || (Ft = new Float32Array(1), (_e) => (Ft[0] = +_e, Ft[0]));
        var Ft;
        class jt {
          constructor($) {
            this.options = Object.assign(Object.create(ot), $), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
          }
          load($) {
            const { log: W, minZoom: q, maxZoom: ae } = this.options;
            W && console.time("total time");
            const pe = `prepare ${$.length} points`;
            W && console.time(pe), this.points = $;
            const ge = [];
            for (let ye = 0; ye < $.length; ye++) {
              const Ne = $[ye];
              if (!Ne.geometry) continue;
              const [He, ze] = Ne.geometry.coordinates, lt = bt(Dr(He)), ve = bt(gr(ze));
              ge.push(lt, ve, 1 / 0, ye, -1, 1), this.options.reduce && ge.push(0);
            }
            let Pe = this.trees[ae + 1] = this._createTree(ge);
            W && console.timeEnd(pe);
            for (let ye = ae; ye >= q; ye--) {
              const Ne = +Date.now();
              Pe = this.trees[ye] = this._createTree(this._cluster(Pe, ye)), W && console.log("z%d: %d clusters in %dms", ye, Pe.numItems, +Date.now() - Ne);
            }
            return W && console.timeEnd("total time"), this;
          }
          getClusters($, W) {
            let q = (($[0] + 180) % 360 + 360) % 360 - 180;
            const ae = Math.max(-90, Math.min(90, $[1]));
            let pe = $[2] === 180 ? 180 : (($[2] + 180) % 360 + 360) % 360 - 180;
            const ge = Math.max(-90, Math.min(90, $[3]));
            if ($[2] - $[0] >= 360) q = -180, pe = 180;
            else if (q > pe) {
              const ze = this.getClusters([q, ae, 180, ge], W), lt = this.getClusters([-180, ae, pe, ge], W);
              return ze.concat(lt);
            }
            const Pe = this.trees[this._limitZoom(W)], ye = Pe.range(Dr(q), gr(ge), Dr(pe), gr(ae)), Ne = Pe.data, He = [];
            for (const ze of ye) {
              const lt = this.stride * ze;
              He.push(Ne[lt + 5] > 1 ? Et(Ne, lt, this.clusterProps) : this.points[Ne[lt + 3]]);
            }
            return He;
          }
          getChildren($) {
            const W = this._getOriginId($), q = this._getOriginZoom($), ae = "No cluster with the specified id.", pe = this.trees[q];
            if (!pe) throw new Error(ae);
            const ge = pe.data;
            if (W * this.stride >= ge.length) throw new Error(ae);
            const Pe = this.options.radius / (this.options.extent * Math.pow(2, q - 1)), ye = pe.within(ge[W * this.stride], ge[W * this.stride + 1], Pe), Ne = [];
            for (const He of ye) {
              const ze = He * this.stride;
              ge[ze + 4] === $ && Ne.push(ge[ze + 5] > 1 ? Et(ge, ze, this.clusterProps) : this.points[ge[ze + 3]]);
            }
            if (Ne.length === 0) throw new Error(ae);
            return Ne;
          }
          getLeaves($, W, q) {
            const ae = [];
            return this._appendLeaves(ae, $, W = W || 10, q = q || 0, 0), ae;
          }
          getTile($, W, q) {
            const ae = this.trees[this._limitZoom($)], pe = Math.pow(2, $), { extent: ge, radius: Pe } = this.options, ye = Pe / ge, Ne = (q - ye) / pe, He = (q + 1 + ye) / pe, ze = { features: [] };
            return this._addTileFeatures(ae.range((W - ye) / pe, Ne, (W + 1 + ye) / pe, He), ae.data, W, q, pe, ze), W === 0 && this._addTileFeatures(ae.range(1 - ye / pe, Ne, 1, He), ae.data, pe, q, pe, ze), W === pe - 1 && this._addTileFeatures(ae.range(0, Ne, ye / pe, He), ae.data, -1, q, pe, ze), ze.features.length ? ze : null;
          }
          getClusterExpansionZoom($) {
            let W = this._getOriginZoom($) - 1;
            for (; W <= this.options.maxZoom; ) {
              const q = this.getChildren($);
              if (W++, q.length !== 1) break;
              $ = q[0].properties.cluster_id;
            }
            return W;
          }
          _appendLeaves($, W, q, ae, pe) {
            const ge = this.getChildren(W);
            for (const Pe of ge) {
              const ye = Pe.properties;
              if (ye && ye.cluster ? pe + ye.point_count <= ae ? pe += ye.point_count : pe = this._appendLeaves($, ye.cluster_id, q, ae, pe) : pe < ae ? pe++ : $.push(Pe), $.length === q) break;
            }
            return pe;
          }
          _createTree($) {
            const W = new d.aI($.length / this.stride | 0, this.options.nodeSize, Float32Array);
            for (let q = 0; q < $.length; q += this.stride) W.add($[q], $[q + 1]);
            return W.finish(), W.data = $, W;
          }
          _addTileFeatures($, W, q, ae, pe, ge) {
            for (const Pe of $) {
              const ye = Pe * this.stride, Ne = W[ye + 5] > 1;
              let He, ze, lt;
              if (Ne) He = bi(W, ye, this.clusterProps), ze = W[ye], lt = W[ye + 1];
              else {
                const Ot = this.points[W[ye + 3]];
                He = Ot.properties;
                const [ft, St] = Ot.geometry.coordinates;
                ze = Dr(ft), lt = gr(St);
              }
              const ve = { type: 1, geometry: [[Math.round(this.options.extent * (ze * pe - q)), Math.round(this.options.extent * (lt * pe - ae))]], tags: He };
              let wt;
              wt = Ne || this.options.generateId ? W[ye + 3] : this.points[W[ye + 3]].id, wt !== void 0 && (ve.id = wt), ge.features.push(ve);
            }
          }
          _limitZoom($) {
            return Math.max(this.options.minZoom, Math.min(Math.floor(+$), this.options.maxZoom + 1));
          }
          _cluster($, W) {
            const { radius: q, extent: ae, reduce: pe, minPoints: ge } = this.options, Pe = q / (ae * Math.pow(2, W)), ye = $.data, Ne = [], He = this.stride;
            for (let ze = 0; ze < ye.length; ze += He) {
              if (ye[ze + 2] <= W) continue;
              ye[ze + 2] = W;
              const lt = ye[ze], ve = ye[ze + 1], wt = $.within(ye[ze], ye[ze + 1], Pe), Ot = ye[ze + 5];
              let ft = Ot;
              for (const St of wt) {
                const Kt = St * He;
                ye[Kt + 2] > W && (ft += ye[Kt + 5]);
              }
              if (ft > Ot && ft >= ge) {
                let St, Kt = lt * Ot, Li = ve * Ot, Ui = -1;
                const Ti = (ze / He << 5) + (W + 1) + this.points.length;
                for (const Pt of wt) {
                  const Nt = Pt * He;
                  if (ye[Nt + 2] <= W) continue;
                  ye[Nt + 2] = W;
                  const Pi = ye[Nt + 5];
                  Kt += ye[Nt] * Pi, Li += ye[Nt + 1] * Pi, ye[Nt + 4] = Ti, pe && (St || (St = this._map(ye, ze, !0), Ui = this.clusterProps.length, this.clusterProps.push(St)), pe(St, this._map(ye, Nt)));
                }
                ye[ze + 4] = Ti, Ne.push(Kt / ft, Li / ft, 1 / 0, Ti, -1, ft), pe && Ne.push(Ui);
              } else {
                for (let St = 0; St < He; St++) Ne.push(ye[ze + St]);
                if (ft > 1) for (const St of wt) {
                  const Kt = St * He;
                  if (!(ye[Kt + 2] <= W)) {
                    ye[Kt + 2] = W;
                    for (let Li = 0; Li < He; Li++) Ne.push(ye[Kt + Li]);
                  }
                }
              }
            }
            return Ne;
          }
          _getOriginId($) {
            return $ - this.points.length >> 5;
          }
          _getOriginZoom($) {
            return ($ - this.points.length) % 32;
          }
          _map($, W, q) {
            if ($[W + 5] > 1) {
              const ge = this.clusterProps[$[W + 6]];
              return q ? Object.assign({}, ge) : ge;
            }
            const ae = this.points[$[W + 3]].properties, pe = this.options.map(ae);
            return q && pe === ae ? Object.assign({}, pe) : pe;
          }
        }
        function Et(_e, $, W) {
          return { type: "Feature", id: _e[$ + 3], properties: bi(_e, $, W), geometry: { type: "Point", coordinates: [(q = _e[$], 360 * (q - 0.5)), Ln(_e[$ + 1])] } };
          var q;
        }
        function bi(_e, $, W) {
          const q = _e[$ + 5], ae = q >= 1e4 ? `${Math.round(q / 1e3)}k` : q >= 1e3 ? Math.round(q / 100) / 10 + "k" : q, pe = _e[$ + 6], ge = pe === -1 ? {} : Object.assign({}, W[pe]);
          return Object.assign(ge, { cluster: !0, cluster_id: _e[$ + 3], point_count: q, point_count_abbreviated: ae });
        }
        function Dr(_e) {
          return _e / 360 + 0.5;
        }
        function gr(_e) {
          const $ = Math.sin(_e * Math.PI / 180), W = 0.5 - 0.25 * Math.log((1 + $) / (1 - $)) / Math.PI;
          return W < 0 ? 0 : W > 1 ? 1 : W;
        }
        function Ln(_e) {
          const $ = (180 - 360 * _e) * Math.PI / 180;
          return 360 * Math.atan(Math.exp($)) / Math.PI - 90;
        }
        function Ht(_e, $, W, q) {
          let ae = q;
          const pe = $ + (W - $ >> 1);
          let ge, Pe = W - $;
          const ye = _e[$], Ne = _e[$ + 1], He = _e[W], ze = _e[W + 1];
          for (let lt = $ + 3; lt < W; lt += 3) {
            const ve = rr(_e[lt], _e[lt + 1], ye, Ne, He, ze);
            if (ve > ae) ge = lt, ae = ve;
            else if (ve === ae) {
              const wt = Math.abs(lt - pe);
              wt < Pe && (ge = lt, Pe = wt);
            }
          }
          ae > q && (ge - $ > 3 && Ht(_e, $, ge, q), _e[ge + 2] = ae, W - ge > 3 && Ht(_e, ge, W, q));
        }
        function rr(_e, $, W, q, ae, pe) {
          let ge = ae - W, Pe = pe - q;
          if (ge !== 0 || Pe !== 0) {
            const ye = ((_e - W) * ge + ($ - q) * Pe) / (ge * ge + Pe * Pe);
            ye > 1 ? (W = ae, q = pe) : ye > 0 && (W += ge * ye, q += Pe * ye);
          }
          return ge = _e - W, Pe = $ - q, ge * ge + Pe * Pe;
        }
        function wi(_e, $, W, q) {
          const ae = { id: _e ?? null, type: $, geometry: W, tags: q, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
          if ($ === "Point" || $ === "MultiPoint" || $ === "LineString") sr(ae, W);
          else if ($ === "Polygon") sr(ae, W[0]);
          else if ($ === "MultiLineString") for (const pe of W) sr(ae, pe);
          else if ($ === "MultiPolygon") for (const pe of W) sr(ae, pe[0]);
          return ae;
        }
        function sr(_e, $) {
          for (let W = 0; W < $.length; W += 3) _e.minX = Math.min(_e.minX, $[W]), _e.minY = Math.min(_e.minY, $[W + 1]), _e.maxX = Math.max(_e.maxX, $[W]), _e.maxY = Math.max(_e.maxY, $[W + 1]);
        }
        function cs(_e, $, W, q) {
          if (!$.geometry) return;
          const ae = $.geometry.coordinates;
          if (ae && ae.length === 0) return;
          const pe = $.geometry.type, ge = Math.pow(W.tolerance / ((1 << W.maxZoom) * W.extent), 2);
          let Pe = [], ye = $.id;
          if (W.promoteId ? ye = $.properties[W.promoteId] : W.generateId && (ye = q || 0), pe === "Point") hs(ae, Pe);
          else if (pe === "MultiPoint") for (const Ne of ae) hs(Ne, Pe);
          else if (pe === "LineString") pn(ae, Pe, ge, !1);
          else if (pe === "MultiLineString") {
            if (W.lineMetrics) {
              for (const Ne of ae) Pe = [], pn(Ne, Pe, ge, !1), _e.push(wi(ye, "LineString", Pe, $.properties));
              return;
            }
            Er(ae, Pe, ge, !1);
          } else if (pe === "Polygon") Er(ae, Pe, ge, !0);
          else {
            if (pe !== "MultiPolygon") {
              if (pe === "GeometryCollection") {
                for (const Ne of $.geometry.geometries) cs(_e, { id: ye, geometry: Ne, properties: $.properties }, W, q);
                return;
              }
              throw new Error("Input data is not a valid GeoJSON object.");
            }
            for (const Ne of ae) {
              const He = [];
              Er(Ne, He, ge, !0), Pe.push(He);
            }
          }
          _e.push(wi(ye, pe, Pe, $.properties));
        }
        function hs(_e, $) {
          $.push(Ri(_e[0]), ji(_e[1]), 0);
        }
        function pn(_e, $, W, q) {
          let ae, pe, ge = 0;
          for (let ye = 0; ye < _e.length; ye++) {
            const Ne = Ri(_e[ye][0]), He = ji(_e[ye][1]);
            $.push(Ne, He, 0), ye > 0 && (ge += q ? (ae * He - Ne * pe) / 2 : Math.sqrt(Math.pow(Ne - ae, 2) + Math.pow(He - pe, 2))), ae = Ne, pe = He;
          }
          const Pe = $.length - 3;
          $[2] = 1, Ht($, 0, Pe, W), $[Pe + 2] = 1, $.size = Math.abs(ge), $.start = 0, $.end = $.size;
        }
        function Er(_e, $, W, q) {
          for (let ae = 0; ae < _e.length; ae++) {
            const pe = [];
            pn(_e[ae], pe, W, q), $.push(pe);
          }
        }
        function Ri(_e) {
          return _e / 360 + 0.5;
        }
        function ji(_e) {
          const $ = Math.sin(_e * Math.PI / 180), W = 0.5 - 0.25 * Math.log((1 + $) / (1 - $)) / Math.PI;
          return W < 0 ? 0 : W > 1 ? 1 : W;
        }
        function qt(_e, $, W, q, ae, pe, ge, Pe) {
          if (q /= $, pe >= (W /= $) && ge < q) return _e;
          if (ge < W || pe >= q) return null;
          const ye = [];
          for (const Ne of _e) {
            const He = Ne.geometry;
            let ze = Ne.type;
            const lt = ae === 0 ? Ne.minX : Ne.minY, ve = ae === 0 ? Ne.maxX : Ne.maxY;
            if (lt >= W && ve < q) {
              ye.push(Ne);
              continue;
            }
            if (ve < W || lt >= q) continue;
            let wt = [];
            if (ze === "Point" || ze === "MultiPoint") Fi(He, wt, W, q, ae);
            else if (ze === "LineString") ws(He, wt, W, q, ae, !1, Pe.lineMetrics);
            else if (ze === "MultiLineString") ni(He, wt, W, q, ae, !1);
            else if (ze === "Polygon") ni(He, wt, W, q, ae, !0);
            else if (ze === "MultiPolygon") for (const Ot of He) {
              const ft = [];
              ni(Ot, ft, W, q, ae, !0), ft.length && wt.push(ft);
            }
            if (wt.length) {
              if (Pe.lineMetrics && ze === "LineString") {
                for (const Ot of wt) ye.push(wi(Ne.id, ze, Ot, Ne.tags));
                continue;
              }
              ze !== "LineString" && ze !== "MultiLineString" || (wt.length === 1 ? (ze = "LineString", wt = wt[0]) : ze = "MultiLineString"), ze !== "Point" && ze !== "MultiPoint" || (ze = wt.length === 3 ? "Point" : "MultiPoint"), ye.push(wi(Ne.id, ze, wt, Ne.tags));
            }
          }
          return ye.length ? ye : null;
        }
        function Fi(_e, $, W, q, ae) {
          for (let pe = 0; pe < _e.length; pe += 3) {
            const ge = _e[pe + ae];
            ge >= W && ge <= q && ai($, _e[pe], _e[pe + 1], _e[pe + 2]);
          }
        }
        function ws(_e, $, W, q, ae, pe, ge) {
          let Pe = Ji(_e);
          const ye = ae === 0 ? mr : ki;
          let Ne, He, ze = _e.start;
          for (let ft = 0; ft < _e.length - 3; ft += 3) {
            const St = _e[ft], Kt = _e[ft + 1], Li = _e[ft + 2], Ui = _e[ft + 3], Ti = _e[ft + 4], Pt = ae === 0 ? St : Kt, Nt = ae === 0 ? Ui : Ti;
            let Pi = !1;
            ge && (Ne = Math.sqrt(Math.pow(St - Ui, 2) + Math.pow(Kt - Ti, 2))), Pt < W ? Nt > W && (He = ye(Pe, St, Kt, Ui, Ti, W), ge && (Pe.start = ze + Ne * He)) : Pt > q ? Nt < q && (He = ye(Pe, St, Kt, Ui, Ti, q), ge && (Pe.start = ze + Ne * He)) : ai(Pe, St, Kt, Li), Nt < W && Pt >= W && (He = ye(Pe, St, Kt, Ui, Ti, W), Pi = !0), Nt > q && Pt <= q && (He = ye(Pe, St, Kt, Ui, Ti, q), Pi = !0), !pe && Pi && (ge && (Pe.end = ze + Ne * He), $.push(Pe), Pe = Ji(_e)), ge && (ze += Ne);
          }
          let lt = _e.length - 3;
          const ve = _e[lt], wt = _e[lt + 1], Ot = ae === 0 ? ve : wt;
          Ot >= W && Ot <= q && ai(Pe, ve, wt, _e[lt + 2]), lt = Pe.length - 3, pe && lt >= 3 && (Pe[lt] !== Pe[0] || Pe[lt + 1] !== Pe[1]) && ai(Pe, Pe[0], Pe[1], Pe[2]), Pe.length && $.push(Pe);
        }
        function Ji(_e) {
          const $ = [];
          return $.size = _e.size, $.start = _e.start, $.end = _e.end, $;
        }
        function ni(_e, $, W, q, ae, pe) {
          for (const ge of _e) ws(ge, $, W, q, ae, pe, !1);
        }
        function ai(_e, $, W, q) {
          _e.push($, W, q);
        }
        function mr(_e, $, W, q, ae, pe) {
          const ge = (pe - $) / (q - $);
          return ai(_e, pe, W + (ae - W) * ge, 1), ge;
        }
        function ki(_e, $, W, q, ae, pe) {
          const ge = (pe - W) / (ae - W);
          return ai(_e, $ + (q - $) * ge, pe, 1), ge;
        }
        function Or(_e, $) {
          const W = [];
          for (let q = 0; q < _e.length; q++) {
            const ae = _e[q], pe = ae.type;
            let ge;
            if (pe === "Point" || pe === "MultiPoint" || pe === "LineString") ge = es(ae.geometry, $);
            else if (pe === "MultiLineString" || pe === "Polygon") {
              ge = [];
              for (const Pe of ae.geometry) ge.push(es(Pe, $));
            } else if (pe === "MultiPolygon") {
              ge = [];
              for (const Pe of ae.geometry) {
                const ye = [];
                for (const Ne of Pe) ye.push(es(Ne, $));
                ge.push(ye);
              }
            }
            W.push(wi(ae.id, pe, ge, ae.tags));
          }
          return W;
        }
        function es(_e, $) {
          const W = [];
          W.size = _e.size, _e.start !== void 0 && (W.start = _e.start, W.end = _e.end);
          for (let q = 0; q < _e.length; q += 3) W.push(_e[q] + $, _e[q + 1], _e[q + 2]);
          return W;
        }
        function ts(_e, $) {
          if (_e.transformed) return _e;
          const W = 1 << _e.z, q = _e.x, ae = _e.y;
          for (const pe of _e.features) {
            const ge = pe.geometry, Pe = pe.type;
            if (pe.geometry = [], Pe === 1) for (let ye = 0; ye < ge.length; ye += 2) pe.geometry.push(Ts(ge[ye], ge[ye + 1], $, W, q, ae));
            else for (let ye = 0; ye < ge.length; ye++) {
              const Ne = [];
              for (let He = 0; He < ge[ye].length; He += 2) Ne.push(Ts(ge[ye][He], ge[ye][He + 1], $, W, q, ae));
              pe.geometry.push(Ne);
            }
          }
          return _e.transformed = !0, _e;
        }
        function Ts(_e, $, W, q, ae, pe) {
          return [Math.round(W * (_e * q - ae)), Math.round(W * ($ * q - pe))];
        }
        function Ni(_e, $, W, q, ae) {
          const pe = $ === ae.maxZoom ? 0 : ae.tolerance / ((1 << $) * ae.extent), ge = { features: [], numPoints: 0, numSimplified: 0, numFeatures: _e.length, source: null, x: W, y: q, z: $, transformed: !1, minX: 2, minY: 1, maxX: -1, maxY: 0 };
          for (const Pe of _e) Ks(ge, Pe, pe, ae);
          return ge;
        }
        function Ks(_e, $, W, q) {
          const ae = $.geometry, pe = $.type, ge = [];
          if (_e.minX = Math.min(_e.minX, $.minX), _e.minY = Math.min(_e.minY, $.minY), _e.maxX = Math.max(_e.maxX, $.maxX), _e.maxY = Math.max(_e.maxY, $.maxY), pe === "Point" || pe === "MultiPoint") for (let Pe = 0; Pe < ae.length; Pe += 3) ge.push(ae[Pe], ae[Pe + 1]), _e.numPoints++, _e.numSimplified++;
          else if (pe === "LineString") Ys(ge, ae, _e, W, !1, !1);
          else if (pe === "MultiLineString" || pe === "Polygon") for (let Pe = 0; Pe < ae.length; Pe++) Ys(ge, ae[Pe], _e, W, pe === "Polygon", Pe === 0);
          else if (pe === "MultiPolygon") for (let Pe = 0; Pe < ae.length; Pe++) {
            const ye = ae[Pe];
            for (let Ne = 0; Ne < ye.length; Ne++) Ys(ge, ye[Ne], _e, W, !0, Ne === 0);
          }
          if (ge.length) {
            let Pe = $.tags || null;
            if (pe === "LineString" && q.lineMetrics) {
              Pe = {};
              for (const Ne in $.tags) Pe[Ne] = $.tags[Ne];
              Pe.mapbox_clip_start = ae.start / ae.size, Pe.mapbox_clip_end = ae.end / ae.size;
            }
            const ye = { geometry: ge, type: pe === "Polygon" || pe === "MultiPolygon" ? 3 : pe === "LineString" || pe === "MultiLineString" ? 2 : 1, tags: Pe };
            $.id !== null && (ye.id = $.id), _e.features.push(ye);
          }
        }
        function Ys(_e, $, W, q, ae, pe) {
          const ge = q * q;
          if (q > 0 && $.size < (ae ? ge : q)) return void (W.numPoints += $.length / 3);
          const Pe = [];
          for (let ye = 0; ye < $.length; ye += 3) (q === 0 || $[ye + 2] > ge) && (W.numSimplified++, Pe.push($[ye], $[ye + 1])), W.numPoints++;
          ae && (function(ye, Ne) {
            let He = 0;
            for (let ze = 0, lt = ye.length, ve = lt - 2; ze < lt; ve = ze, ze += 2) He += (ye[ze] - ye[ve]) * (ye[ze + 1] + ye[ve + 1]);
            if (He > 0 === Ne) for (let ze = 0, lt = ye.length; ze < lt / 2; ze += 2) {
              const ve = ye[ze], wt = ye[ze + 1];
              ye[ze] = ye[lt - 2 - ze], ye[ze + 1] = ye[lt - 1 - ze], ye[lt - 2 - ze] = ve, ye[lt - 1 - ze] = wt;
            }
          })(Pe, pe), _e.push(Pe);
        }
        const _n = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: !1, promoteId: null, generateId: !1, debug: 0 };
        class Js {
          constructor($, W) {
            const q = (W = this.options = (function(pe, ge) {
              for (const Pe in ge) pe[Pe] = ge[Pe];
              return pe;
            })(Object.create(_n), W)).debug;
            if (q && console.time("preprocess data"), W.maxZoom < 0 || W.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
            if (W.promoteId && W.generateId) throw new Error("promoteId and generateId cannot be used together.");
            let ae = (function(pe, ge) {
              const Pe = [];
              if (pe.type === "FeatureCollection") for (let ye = 0; ye < pe.features.length; ye++) cs(Pe, pe.features[ye], ge, ye);
              else cs(Pe, pe.type === "Feature" ? pe : { geometry: pe }, ge);
              return Pe;
            })($, W);
            this.tiles = {}, this.tileCoords = [], q && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", W.indexMaxZoom, W.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), ae = (function(pe, ge) {
              const Pe = ge.buffer / ge.extent;
              let ye = pe;
              const Ne = qt(pe, 1, -1 - Pe, Pe, 0, -1, 2, ge), He = qt(pe, 1, 1 - Pe, 2 + Pe, 0, -1, 2, ge);
              return (Ne || He) && (ye = qt(pe, 1, -Pe, 1 + Pe, 0, -1, 2, ge) || [], Ne && (ye = Or(Ne, 1).concat(ye)), He && (ye = ye.concat(Or(He, -1)))), ye;
            })(ae, W), ae.length && this.splitTile(ae, 0, 0, 0), q && (ae.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
          }
          splitTile($, W, q, ae, pe, ge, Pe) {
            const ye = [$, W, q, ae], Ne = this.options, He = Ne.debug;
            for (; ye.length; ) {
              ae = ye.pop(), q = ye.pop(), W = ye.pop(), $ = ye.pop();
              const ze = 1 << W, lt = Qs(W, q, ae);
              let ve = this.tiles[lt];
              if (!ve && (He > 1 && console.time("creation"), ve = this.tiles[lt] = Ni($, W, q, ae, Ne), this.tileCoords.push({ z: W, x: q, y: ae }), He)) {
                He > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", W, q, ae, ve.numFeatures, ve.numPoints, ve.numSimplified), console.timeEnd("creation"));
                const Pi = `z${W}`;
                this.stats[Pi] = (this.stats[Pi] || 0) + 1, this.total++;
              }
              if (ve.source = $, pe == null) {
                if (W === Ne.indexMaxZoom || ve.numPoints <= Ne.indexMaxPoints) continue;
              } else {
                if (W === Ne.maxZoom || W === pe) continue;
                if (pe != null) {
                  const Pi = pe - W;
                  if (q !== ge >> Pi || ae !== Pe >> Pi) continue;
                }
              }
              if (ve.source = null, $.length === 0) continue;
              He > 1 && console.time("clipping");
              const wt = 0.5 * Ne.buffer / Ne.extent, Ot = 0.5 - wt, ft = 0.5 + wt, St = 1 + wt;
              let Kt = null, Li = null, Ui = null, Ti = null, Pt = qt($, ze, q - wt, q + ft, 0, ve.minX, ve.maxX, Ne), Nt = qt($, ze, q + Ot, q + St, 0, ve.minX, ve.maxX, Ne);
              $ = null, Pt && (Kt = qt(Pt, ze, ae - wt, ae + ft, 1, ve.minY, ve.maxY, Ne), Li = qt(Pt, ze, ae + Ot, ae + St, 1, ve.minY, ve.maxY, Ne), Pt = null), Nt && (Ui = qt(Nt, ze, ae - wt, ae + ft, 1, ve.minY, ve.maxY, Ne), Ti = qt(Nt, ze, ae + Ot, ae + St, 1, ve.minY, ve.maxY, Ne), Nt = null), He > 1 && console.timeEnd("clipping"), ye.push(Kt || [], W + 1, 2 * q, 2 * ae), ye.push(Li || [], W + 1, 2 * q, 2 * ae + 1), ye.push(Ui || [], W + 1, 2 * q + 1, 2 * ae), ye.push(Ti || [], W + 1, 2 * q + 1, 2 * ae + 1);
            }
          }
          getTile($, W, q) {
            $ = +$, W = +W, q = +q;
            const ae = this.options, { extent: pe, debug: ge } = ae;
            if ($ < 0 || $ > 24) return null;
            const Pe = 1 << $, ye = Qs($, W = W + Pe & Pe - 1, q);
            if (this.tiles[ye]) return ts(this.tiles[ye], pe);
            ge > 1 && console.log("drilling down to z%d-%d-%d", $, W, q);
            let Ne, He = $, ze = W, lt = q;
            for (; !Ne && He > 0; ) He--, ze >>= 1, lt >>= 1, Ne = this.tiles[Qs(He, ze, lt)];
            return Ne && Ne.source ? (ge > 1 && (console.log("found parent tile z%d-%d-%d", He, ze, lt), console.time("drilling down")), this.splitTile(Ne.source, He, ze, lt, $, W, q), ge > 1 && console.timeEnd("drilling down"), this.tiles[ye] ? ts(this.tiles[ye], pe) : null) : null;
          }
        }
        function Qs(_e, $, W) {
          return 32 * ((1 << _e) * W + $) + _e;
        }
        class As extends F {
          constructor() {
            super(...arguments), this._dataUpdateable = /* @__PURE__ */ new Map();
          }
          loadVectorTile($, W) {
            return d._(this, void 0, void 0, (function* () {
              const q = $.tileID.canonical;
              if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
              const ae = this._geoJSONIndex.getTile(q.z, q.x, q.y);
              if (!ae) return null;
              const pe = new Ee(ae.features, { version: 2, extent: d.$ });
              let ge = (function(Pe) {
                const ye = new d.cM();
                return (function(Ne, He) {
                  for (const ze in Ne.layers) He.writeMessage(3, Ce, Ne.layers[ze]);
                })(Pe, ye), ye.finish();
              })(pe);
              return ge.byteOffset === 0 && ge.byteLength === ge.buffer.byteLength || (ge = new Uint8Array(ge)), { vectorTile: pe, rawData: ge.buffer };
            }));
          }
          loadData($) {
            return d._(this, void 0, void 0, (function* () {
              var W;
              (W = this._pendingRequest) === null || W === void 0 || W.abort();
              const q = !!($ && $.request && $.request.collectResourceTiming) && new d.cN($.request);
              this._pendingRequest = new AbortController();
              try {
                this._pendingData = this.loadAndProcessGeoJSON($, this._pendingRequest);
                const ae = yield this._pendingData;
                this._geoJSONIndex = $.cluster ? new jt((function({ superclusterOptions: ge, clusterProperties: Pe }) {
                  if (!Pe || !ge) return ge;
                  const ye = {}, Ne = {}, He = { accumulated: null, zoom: 0 }, ze = { properties: null }, lt = Object.keys(Pe);
                  for (const ve of lt) {
                    const [wt, Ot] = Pe[ve], ft = d.cT(Ot), St = d.cT(typeof wt == "string" ? [wt, ["accumulated"], ["get", ve]] : wt);
                    ye[ve] = ft.value, Ne[ve] = St.value;
                  }
                  return ge.map = (ve) => {
                    ze.properties = ve;
                    const wt = {};
                    for (const Ot of lt) wt[Ot] = ye[Ot].evaluate(He, ze);
                    return wt;
                  }, ge.reduce = (ve, wt) => {
                    ze.properties = wt;
                    for (const Ot of lt) He.accumulated = ve[Ot], ve[Ot] = Ne[Ot].evaluate(He, ze);
                  }, ge;
                })($)).load(ae.features) : (function(ge, Pe) {
                  return new Js(ge, Pe);
                })(ae, $.geojsonVtOptions), this.loaded = {};
                const pe = { data: ae };
                if (q) {
                  const ge = q.finish();
                  ge && (pe.resourceTiming = {}, pe.resourceTiming[$.source] = JSON.parse(JSON.stringify(ge)));
                }
                return pe;
              } catch (ae) {
                if (delete this._pendingRequest, d.cy(ae)) return { abandoned: !0 };
                throw ae;
              }
            }));
          }
          getData() {
            return d._(this, void 0, void 0, (function* () {
              return this._pendingData;
            }));
          }
          reloadTile($) {
            const W = this.loaded;
            return W && W[$.uid] ? super.reloadTile($) : this.loadTile($);
          }
          loadAndProcessGeoJSON($, W) {
            return d._(this, void 0, void 0, (function* () {
              let q = yield this.loadGeoJSON($, W);
              if (delete this._pendingRequest, typeof q != "object") throw new Error(`Input data given to '${$.source}' is not a valid GeoJSON object.`);
              if (we(q, !0), $.filter) {
                const ae = d.cT($.filter, { type: "boolean", "property-type": "data-driven", overridable: !1, transition: !1 });
                if (ae.result === "error") throw new Error(ae.value.map(((ge) => `${ge.key}: ${ge.message}`)).join(", "));
                q = { type: "FeatureCollection", features: q.features.filter(((ge) => ae.value.evaluate({ zoom: 0 }, ge))) };
              }
              return q;
            }));
          }
          loadGeoJSON($, W) {
            return d._(this, void 0, void 0, (function* () {
              const { promoteId: q } = $;
              if ($.request) {
                const ae = yield d.j($.request, W);
                return this._dataUpdateable = d.cV(ae.data, q) ? d.cU(ae.data, q) : void 0, ae.data;
              }
              if (typeof $.data == "string") try {
                const ae = JSON.parse($.data);
                return this._dataUpdateable = d.cV(ae, q) ? d.cU(ae, q) : void 0, ae;
              } catch {
                throw new Error(`Input data given to '${$.source}' is not a valid GeoJSON object.`);
              }
              if (!$.dataDiff) throw new Error(`Input data given to '${$.source}' is not a valid GeoJSON object.`);
              if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${$.source}`);
              return d.cW(this._dataUpdateable, $.dataDiff, q), { type: "FeatureCollection", features: Array.from(this._dataUpdateable.values()) };
            }));
          }
          removeSource($) {
            return d._(this, void 0, void 0, (function* () {
              this._pendingRequest && this._pendingRequest.abort();
            }));
          }
          getClusterExpansionZoom($) {
            return this._geoJSONIndex.getClusterExpansionZoom($.clusterId);
          }
          getClusterChildren($) {
            return this._geoJSONIndex.getChildren($.clusterId);
          }
          getClusterLeaves($) {
            return this._geoJSONIndex.getLeaves($.clusterId, $.limit, $.offset);
          }
        }
        class gn {
          constructor($) {
            this.self = $, this.actor = new d.J($), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.self.registerWorkerSource = (W, q) => {
              if (this.externalWorkerSourceTypes[W]) throw new Error(`Worker source with name "${W}" already registered.`);
              this.externalWorkerSourceTypes[W] = q;
            }, this.self.addProtocol = d.cA, this.self.removeProtocol = d.cB, this.self.registerRTLTextPlugin = (W) => {
              d.cX.setMethods(W);
            }, this.actor.registerMessageHandler("LDT", ((W, q) => this._getDEMWorkerSource(W, q.source).loadTile(q))), this.actor.registerMessageHandler("RDT", ((W, q) => d._(this, void 0, void 0, (function* () {
              this._getDEMWorkerSource(W, q.source).removeTile(q);
            })))), this.actor.registerMessageHandler("GCEZ", ((W, q) => d._(this, void 0, void 0, (function* () {
              return this._getWorkerSource(W, q.type, q.source).getClusterExpansionZoom(q);
            })))), this.actor.registerMessageHandler("GCC", ((W, q) => d._(this, void 0, void 0, (function* () {
              return this._getWorkerSource(W, q.type, q.source).getClusterChildren(q);
            })))), this.actor.registerMessageHandler("GCL", ((W, q) => d._(this, void 0, void 0, (function* () {
              return this._getWorkerSource(W, q.type, q.source).getClusterLeaves(q);
            })))), this.actor.registerMessageHandler("LD", ((W, q) => this._getWorkerSource(W, q.type, q.source).loadData(q))), this.actor.registerMessageHandler("GD", ((W, q) => this._getWorkerSource(W, q.type, q.source).getData())), this.actor.registerMessageHandler("LT", ((W, q) => this._getWorkerSource(W, q.type, q.source).loadTile(q))), this.actor.registerMessageHandler("RT", ((W, q) => this._getWorkerSource(W, q.type, q.source).reloadTile(q))), this.actor.registerMessageHandler("AT", ((W, q) => this._getWorkerSource(W, q.type, q.source).abortTile(q))), this.actor.registerMessageHandler("RMT", ((W, q) => this._getWorkerSource(W, q.type, q.source).removeTile(q))), this.actor.registerMessageHandler("RS", ((W, q) => d._(this, void 0, void 0, (function* () {
              if (!this.workerSources[W] || !this.workerSources[W][q.type] || !this.workerSources[W][q.type][q.source]) return;
              const ae = this.workerSources[W][q.type][q.source];
              delete this.workerSources[W][q.type][q.source], ae.removeSource !== void 0 && ae.removeSource(q);
            })))), this.actor.registerMessageHandler("RM", ((W) => d._(this, void 0, void 0, (function* () {
              delete this.layerIndexes[W], delete this.availableImages[W], delete this.workerSources[W], delete this.demWorkerSources[W];
            })))), this.actor.registerMessageHandler("SR", ((W, q) => d._(this, void 0, void 0, (function* () {
              this.referrer = q;
            })))), this.actor.registerMessageHandler("SRPS", ((W, q) => this._syncRTLPluginState(W, q))), this.actor.registerMessageHandler("IS", ((W, q) => d._(this, void 0, void 0, (function* () {
              this.self.importScripts(q);
            })))), this.actor.registerMessageHandler("SI", ((W, q) => this._setImages(W, q))), this.actor.registerMessageHandler("UL", ((W, q) => d._(this, void 0, void 0, (function* () {
              this._getLayerIndex(W).update(q.layers, q.removedIds);
            })))), this.actor.registerMessageHandler("SL", ((W, q) => d._(this, void 0, void 0, (function* () {
              this._getLayerIndex(W).replace(q);
            }))));
          }
          _setImages($, W) {
            return d._(this, void 0, void 0, (function* () {
              this.availableImages[$] = W;
              for (const q in this.workerSources[$]) {
                const ae = this.workerSources[$][q];
                for (const pe in ae) ae[pe].availableImages = W;
              }
            }));
          }
          _syncRTLPluginState($, W) {
            return d._(this, void 0, void 0, (function* () {
              return yield d.cX.syncState(W, this.self.importScripts);
            }));
          }
          _getAvailableImages($) {
            let W = this.availableImages[$];
            return W || (W = []), W;
          }
          _getLayerIndex($) {
            let W = this.layerIndexes[$];
            return W || (W = this.layerIndexes[$] = new a()), W;
          }
          _getWorkerSource($, W, q) {
            if (this.workerSources[$] || (this.workerSources[$] = {}), this.workerSources[$][W] || (this.workerSources[$][W] = {}), !this.workerSources[$][W][q]) {
              const ae = { sendAsync: (pe, ge) => (pe.targetMapId = $, this.actor.sendAsync(pe, ge)) };
              switch (W) {
                case "vector":
                  this.workerSources[$][W][q] = new F(ae, this._getLayerIndex($), this._getAvailableImages($));
                  break;
                case "geojson":
                  this.workerSources[$][W][q] = new As(ae, this._getLayerIndex($), this._getAvailableImages($));
                  break;
                default:
                  this.workerSources[$][W][q] = new this.externalWorkerSourceTypes[W](ae, this._getLayerIndex($), this._getAvailableImages($));
              }
            }
            return this.workerSources[$][W][q];
          }
          _getDEMWorkerSource($, W) {
            return this.demWorkerSources[$] || (this.demWorkerSources[$] = {}), this.demWorkerSources[$][W] || (this.demWorkerSources[$][W] = new N()), this.demWorkerSources[$][W];
          }
        }
        return d.i(self) && (self.worker = new gn(self)), gn;
      })), o("index", ["exports", "./shared"], (function(d, a) {
        var w = "5.6.2";
        function S() {
          var m = new a.A(4);
          return a.A != Float32Array && (m[1] = 0, m[2] = 0), m[0] = 1, m[3] = 1, m;
        }
        let M, F;
        const N = { now: typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), frame(m, r, h) {
          const p = requestAnimationFrame(((y) => {
            g(), r(y);
          })), { unsubscribe: g } = a.s(m.signal, "abort", (() => {
            g(), cancelAnimationFrame(p), h(a.c());
          }), !1);
        }, frameAsync(m) {
          return new Promise(((r, h) => {
            this.frame(m, r, h);
          }));
        }, getImageData(m, r = 0) {
          return this.getImageCanvasContext(m).getImageData(-r, -r, m.width + 2 * r, m.height + 2 * r);
        }, getImageCanvasContext(m) {
          const r = window.document.createElement("canvas"), h = r.getContext("2d", { willReadFrequently: !0 });
          if (!h) throw new Error("failed to create canvas 2d context");
          return r.width = m.width, r.height = m.height, h.drawImage(m, 0, 0, m.width, m.height), h;
        }, resolveURL: (m) => (M || (M = document.createElement("a")), M.href = m, M.href), hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
          return !!matchMedia && (F == null && (F = matchMedia("(prefers-reduced-motion: reduce)")), F.matches);
        } };
        class L {
          static testProp(r) {
            if (!L.docStyle) return r[0];
            for (let h = 0; h < r.length; h++) if (r[h] in L.docStyle) return r[h];
            return r[0];
          }
          static create(r, h, p) {
            const g = window.document.createElement(r);
            return h !== void 0 && (g.className = h), p && p.appendChild(g), g;
          }
          static createNS(r, h) {
            return window.document.createElementNS(r, h);
          }
          static disableDrag() {
            L.docStyle && L.selectProp && (L.userSelect = L.docStyle[L.selectProp], L.docStyle[L.selectProp] = "none");
          }
          static enableDrag() {
            L.docStyle && L.selectProp && (L.docStyle[L.selectProp] = L.userSelect);
          }
          static setTransform(r, h) {
            r.style[L.transformProp] = h;
          }
          static addEventListener(r, h, p, g = {}) {
            r.addEventListener(h, p, "passive" in g ? g : g.capture);
          }
          static removeEventListener(r, h, p, g = {}) {
            r.removeEventListener(h, p, "passive" in g ? g : g.capture);
          }
          static suppressClickInternal(r) {
            r.preventDefault(), r.stopPropagation(), window.removeEventListener("click", L.suppressClickInternal, !0);
          }
          static suppressClick() {
            window.addEventListener("click", L.suppressClickInternal, !0), window.setTimeout((() => {
              window.removeEventListener("click", L.suppressClickInternal, !0);
            }), 0);
          }
          static getScale(r) {
            const h = r.getBoundingClientRect();
            return { x: h.width / r.offsetWidth || 1, y: h.height / r.offsetHeight || 1, boundingClientRect: h };
          }
          static getPoint(r, h, p) {
            const g = h.boundingClientRect;
            return new a.P((p.clientX - g.left) / h.x - r.clientLeft, (p.clientY - g.top) / h.y - r.clientTop);
          }
          static mousePos(r, h) {
            const p = L.getScale(r);
            return L.getPoint(r, p, h);
          }
          static touchPos(r, h) {
            const p = [], g = L.getScale(r);
            for (let y = 0; y < h.length; y++) p.push(L.getPoint(r, g, h[y]));
            return p;
          }
          static mouseButton(r) {
            return r.button;
          }
          static remove(r) {
            r.parentNode && r.parentNode.removeChild(r);
          }
          static sanitize(r) {
            const h = new DOMParser().parseFromString(r, "text/html").body || document.createElement("body"), p = h.querySelectorAll("script");
            for (const g of p) g.remove();
            return L.clean(h), h.innerHTML;
          }
          static isPossiblyDangerous(r, h) {
            const p = h.replace(/\s+/g, "").toLowerCase();
            return !(!["src", "href", "xlink:href"].includes(r) || !p.includes("javascript:") && !p.includes("data:")) || !!r.startsWith("on") || void 0;
          }
          static clean(r) {
            const h = r.children;
            for (const p of h) L.removeAttributes(p), L.clean(p);
          }
          static removeAttributes(r) {
            for (const { name: h, value: p } of r.attributes) L.isPossiblyDangerous(h, p) && r.removeAttribute(h);
          }
        }
        L.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, L.selectProp = L.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), L.transformProp = L.testProp(["transform", "WebkitTransform"]);
        const re = { supported: !1, testSupport: function(m) {
          !Se && we && (Ee ? Ce(m) : ne = m);
        } };
        let ne, we, Se = !1, Ee = !1;
        function Ce(m) {
          const r = m.createTexture();
          m.bindTexture(m.TEXTURE_2D, r);
          try {
            if (m.texImage2D(m.TEXTURE_2D, 0, m.RGBA, m.RGBA, m.UNSIGNED_BYTE, we), m.isContextLost()) return;
            re.supported = !0;
          } catch {
          }
          m.deleteTexture(r), Se = !0;
        }
        var Le;
        typeof document < "u" && (we = document.createElement("img"), we.onload = () => {
          ne && Ce(ne), ne = null, Ee = !0;
        }, we.onerror = () => {
          Se = !0, ne = null;
        }, we.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), (function(m) {
          let r, h, p, g;
          m.resetRequestQueue = () => {
            r = [], h = 0, p = 0, g = {};
          }, m.addThrottleControl = (C) => {
            const R = p++;
            return g[R] = C, R;
          }, m.removeThrottleControl = (C) => {
            delete g[C], x();
          }, m.getImage = (C, R, B = !0) => new Promise(((k, O) => {
            re.supported && (C.headers || (C.headers = {}), C.headers.accept = "image/webp,*/*"), a.e(C, { type: "image" }), r.push({ abortController: R, requestParameters: C, supportImageRefresh: B, state: "queued", onError: (z) => {
              O(z);
            }, onSuccess: (z) => {
              k(z);
            } }), x();
          }));
          const y = (C) => a._(this, void 0, void 0, (function* () {
            C.state = "running";
            const { requestParameters: R, supportImageRefresh: B, onError: k, onSuccess: O, abortController: z } = C, H = B === !1 && !a.i(self) && !a.g(R.url) && (!R.headers || Object.keys(R.headers).reduce(((J, ie) => J && ie === "accept"), !0));
            h++;
            const Y = H ? E(R, z) : a.m(R, z);
            try {
              const J = yield Y;
              delete C.abortController, C.state = "completed", J.data instanceof HTMLImageElement || a.b(J.data) ? O(J) : J.data && O({ data: yield (K = J.data, typeof createImageBitmap == "function" ? a.f(K) : a.h(K)), cacheControl: J.cacheControl, expires: J.expires });
            } catch (J) {
              delete C.abortController, k(J);
            } finally {
              h--, x();
            }
            var K;
          })), x = () => {
            const C = (() => {
              for (const R of Object.keys(g)) if (g[R]()) return !0;
              return !1;
            })() ? a.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : a.a.MAX_PARALLEL_IMAGE_REQUESTS;
            for (let R = h; R < C && r.length > 0; R++) {
              const B = r.shift();
              B.abortController.signal.aborted ? R-- : y(B);
            }
          }, E = (C, R) => new Promise(((B, k) => {
            const O = new Image(), z = C.url, H = C.credentials;
            H && H === "include" ? O.crossOrigin = "use-credentials" : (H && H === "same-origin" || !a.d(z)) && (O.crossOrigin = "anonymous"), R.signal.addEventListener("abort", (() => {
              O.src = "", k(a.c());
            })), O.fetchPriority = "high", O.onload = () => {
              O.onerror = O.onload = null, B({ data: O });
            }, O.onerror = () => {
              O.onerror = O.onload = null, R.signal.aborted || k(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            }, O.src = z;
          }));
        })(Le || (Le = {})), Le.resetRequestQueue();
        class Ze {
          constructor(r) {
            this._transformRequestFn = r ?? null;
          }
          transformRequest(r, h) {
            return this._transformRequestFn && this._transformRequestFn(r, h) || { url: r };
          }
          setTransformRequest(r) {
            this._transformRequestFn = r;
          }
        }
        function Ke(m) {
          const r = [];
          if (typeof m == "string") r.push({ id: "default", url: m });
          else if (m && m.length > 0) {
            const h = [];
            for (const { id: p, url: g } of m) {
              const y = `${p}${g}`;
              h.indexOf(y) === -1 && (h.push(y), r.push({ id: p, url: g }));
            }
          }
          return r;
        }
        function ct(m, r, h) {
          try {
            const p = new URL(m);
            return p.pathname += `${r}${h}`, p.toString();
          } catch {
            throw new Error(`Invalid sprite URL "${m}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`);
          }
        }
        function _t(m) {
          const { userImage: r } = m;
          return !!(r && r.render && r.render()) && (m.data.replace(new Uint8Array(r.data.buffer)), !0);
        }
        class st extends a.E {
          constructor() {
            super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new a.R({ width: 1, height: 1 }), this.dirty = !0;
          }
          isLoaded() {
            return this.loaded;
          }
          setLoaded(r) {
            if (this.loaded !== r && (this.loaded = r, r)) {
              for (const { ids: h, promiseResolve: p } of this.requestors) p(this._getImagesForIds(h));
              this.requestors = [];
            }
          }
          getImage(r) {
            const h = this.images[r];
            if (h && !h.data && h.spriteData) {
              const p = h.spriteData;
              h.data = new a.R({ width: p.width, height: p.height }, p.context.getImageData(p.x, p.y, p.width, p.height).data), h.spriteData = null;
            }
            return h;
          }
          addImage(r, h) {
            if (this.images[r]) throw new Error(`Image id ${r} already exist, use updateImage instead`);
            this._validate(r, h) && (this.images[r] = h);
          }
          _validate(r, h) {
            let p = !0;
            const g = h.data || h.spriteData;
            return this._validateStretch(h.stretchX, g && g.width) || (this.fire(new a.k(new Error(`Image "${r}" has invalid "stretchX" value`))), p = !1), this._validateStretch(h.stretchY, g && g.height) || (this.fire(new a.k(new Error(`Image "${r}" has invalid "stretchY" value`))), p = !1), this._validateContent(h.content, h) || (this.fire(new a.k(new Error(`Image "${r}" has invalid "content" value`))), p = !1), p;
          }
          _validateStretch(r, h) {
            if (!r) return !0;
            let p = 0;
            for (const g of r) {
              if (g[0] < p || g[1] < g[0] || h < g[1]) return !1;
              p = g[1];
            }
            return !0;
          }
          _validateContent(r, h) {
            if (!r) return !0;
            if (r.length !== 4) return !1;
            const p = h.spriteData, g = p && p.width || h.data.width, y = p && p.height || h.data.height;
            return !(r[0] < 0 || g < r[0] || r[1] < 0 || y < r[1] || r[2] < 0 || g < r[2] || r[3] < 0 || y < r[3] || r[2] < r[0] || r[3] < r[1]);
          }
          updateImage(r, h, p = !0) {
            const g = this.getImage(r);
            if (p && (g.data.width !== h.data.width || g.data.height !== h.data.height)) throw new Error(`size mismatch between old image (${g.data.width}x${g.data.height}) and new image (${h.data.width}x${h.data.height}).`);
            h.version = g.version + 1, this.images[r] = h, this.updatedImages[r] = !0;
          }
          removeImage(r) {
            const h = this.images[r];
            delete this.images[r], delete this.patterns[r], h.userImage && h.userImage.onRemove && h.userImage.onRemove();
          }
          listImages() {
            return Object.keys(this.images);
          }
          getImages(r) {
            return new Promise(((h, p) => {
              let g = !0;
              if (!this.isLoaded()) for (const y of r) this.images[y] || (g = !1);
              this.isLoaded() || g ? h(this._getImagesForIds(r)) : this.requestors.push({ ids: r, promiseResolve: h });
            }));
          }
          _getImagesForIds(r) {
            const h = {};
            for (const p of r) {
              let g = this.getImage(p);
              g || (this.fire(new a.l("styleimagemissing", { id: p })), g = this.getImage(p)), g ? h[p] = { data: g.data.clone(), pixelRatio: g.pixelRatio, sdf: g.sdf, version: g.version, stretchX: g.stretchX, stretchY: g.stretchY, content: g.content, textFitWidth: g.textFitWidth, textFitHeight: g.textFitHeight, hasRenderCallback: !!(g.userImage && g.userImage.render) } : a.w(`Image "${p}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
            }
            return h;
          }
          getPixelSize() {
            const { width: r, height: h } = this.atlasImage;
            return { width: r, height: h };
          }
          getPattern(r) {
            const h = this.patterns[r], p = this.getImage(r);
            if (!p) return null;
            if (h && h.position.version === p.version) return h.position;
            if (h) h.position.version = p.version;
            else {
              const g = { w: p.data.width + 2, h: p.data.height + 2, x: 0, y: 0 }, y = new a.I(g, p);
              this.patterns[r] = { bin: g, position: y };
            }
            return this._updatePatternAtlas(), this.patterns[r].position;
          }
          bind(r) {
            const h = r.gl;
            this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new a.T(r, this.atlasImage, h.RGBA), this.atlasTexture.bind(h.LINEAR, h.CLAMP_TO_EDGE);
          }
          _updatePatternAtlas() {
            const r = [];
            for (const y in this.patterns) r.push(this.patterns[y].bin);
            const { w: h, h: p } = a.p(r), g = this.atlasImage;
            g.resize({ width: h || 1, height: p || 1 });
            for (const y in this.patterns) {
              const { bin: x } = this.patterns[y], E = x.x + 1, C = x.y + 1, R = this.getImage(y).data, B = R.width, k = R.height;
              a.R.copy(R, g, { x: 0, y: 0 }, { x: E, y: C }, { width: B, height: k }), a.R.copy(R, g, { x: 0, y: k - 1 }, { x: E, y: C - 1 }, { width: B, height: 1 }), a.R.copy(R, g, { x: 0, y: 0 }, { x: E, y: C + k }, { width: B, height: 1 }), a.R.copy(R, g, { x: B - 1, y: 0 }, { x: E - 1, y: C }, { width: 1, height: k }), a.R.copy(R, g, { x: 0, y: 0 }, { x: E + B, y: C }, { width: 1, height: k });
            }
            this.dirty = !0;
          }
          beginFrame() {
            this.callbackDispatchedThisFrame = {};
          }
          dispatchRenderCallbacks(r) {
            for (const h of r) {
              if (this.callbackDispatchedThisFrame[h]) continue;
              this.callbackDispatchedThisFrame[h] = !0;
              const p = this.getImage(h);
              p || a.w(`Image with ID: "${h}" was not found`), _t(p) && this.updateImage(h, p);
            }
          }
        }
        const ot = 1e20;
        function bt(m, r, h, p, g, y, x, E, C) {
          for (let R = r; R < r + p; R++) Ft(m, h * y + R, y, g, x, E, C);
          for (let R = h; R < h + g; R++) Ft(m, R * y + r, 1, p, x, E, C);
        }
        function Ft(m, r, h, p, g, y, x) {
          y[0] = 0, x[0] = -ot, x[1] = ot, g[0] = m[r];
          for (let E = 1, C = 0, R = 0; E < p; E++) {
            g[E] = m[r + E * h];
            const B = E * E;
            do {
              const k = y[C];
              R = (g[E] - g[k] + B - k * k) / (E - k) / 2;
            } while (R <= x[C] && --C > -1);
            C++, y[C] = E, x[C] = R, x[C + 1] = ot;
          }
          for (let E = 0, C = 0; E < p; E++) {
            for (; x[C + 1] < E; ) C++;
            const R = y[C], B = E - R;
            m[r + E * h] = g[R] + B * B;
          }
        }
        class jt {
          constructor(r, h) {
            this.requestManager = r, this.localIdeographFontFamily = h, this.entries = {};
          }
          setURL(r) {
            this.url = r;
          }
          getGlyphs(r) {
            return a._(this, void 0, void 0, (function* () {
              const h = [];
              for (const y in r) for (const x of r[y]) h.push(this._getAndCacheGlyphsPromise(y, x));
              const p = yield Promise.all(h), g = {};
              for (const { stack: y, id: x, glyph: E } of p) g[y] || (g[y] = {}), g[y][x] = E && { id: E.id, bitmap: E.bitmap.clone(), metrics: E.metrics };
              return g;
            }));
          }
          _getAndCacheGlyphsPromise(r, h) {
            return a._(this, void 0, void 0, (function* () {
              let p = this.entries[r];
              p || (p = this.entries[r] = { glyphs: {}, requests: {}, ranges: {} });
              let g = p.glyphs[h];
              if (g !== void 0) return { stack: r, id: h, glyph: g };
              if (g = this._tinySDF(p, r, h), g) return p.glyphs[h] = g, { stack: r, id: h, glyph: g };
              const y = Math.floor(h / 256);
              if (256 * y > 65535) throw new Error("glyphs > 65535 not supported");
              if (p.ranges[y]) return { stack: r, id: h, glyph: g };
              if (!this.url) throw new Error("glyphsUrl is not set");
              if (!p.requests[y]) {
                const E = jt.loadGlyphRange(r, y, this.url, this.requestManager);
                p.requests[y] = E;
              }
              const x = yield p.requests[y];
              for (const E in x) this._doesCharSupportLocalGlyph(+E) || (p.glyphs[+E] = x[+E]);
              return p.ranges[y] = !0, { stack: r, id: h, glyph: x[h] || null };
            }));
          }
          _doesCharSupportLocalGlyph(r) {
            return !!this.localIdeographFontFamily && (new RegExp("\\p{Ideo}|\\p{sc=Hang}|\\p{sc=Hira}|\\p{sc=Kana}", "u").test(String.fromCodePoint(r)) || a.u["CJK Unified Ideographs"](r) || a.u["Hangul Syllables"](r) || a.u.Hiragana(r) || a.u.Katakana(r) || a.u["CJK Symbols and Punctuation"](r) || a.u["Halfwidth and Fullwidth Forms"](r));
          }
          _tinySDF(r, h, p) {
            const g = this.localIdeographFontFamily;
            if (!g || !this._doesCharSupportLocalGlyph(p)) return;
            let y = r.tinySDF;
            if (!y) {
              let E = "400";
              /bold/i.test(h) ? E = "900" : /medium/i.test(h) ? E = "500" : /light/i.test(h) && (E = "200"), y = r.tinySDF = new jt.TinySDF({ fontSize: 48, buffer: 6, radius: 16, cutoff: 0.25, fontFamily: g, fontWeight: E });
            }
            const x = y.draw(String.fromCharCode(p));
            return { id: p, bitmap: new a.q({ width: x.width || 60, height: x.height || 60 }, x.data), metrics: { width: x.glyphWidth / 2 || 24, height: x.glyphHeight / 2 || 24, left: x.glyphLeft / 2 + 0.5 || 0, top: x.glyphTop / 2 - 27.5 || -8, advance: x.glyphAdvance / 2 || 24, isDoubleResolution: !0 } };
          }
        }
        jt.loadGlyphRange = function(m, r, h, p) {
          return a._(this, void 0, void 0, (function* () {
            const g = 256 * r, y = g + 255, x = p.transformRequest(h.replace("{fontstack}", m).replace("{range}", `${g}-${y}`), "Glyphs"), E = yield a.n(x, new AbortController());
            if (!E || !E.data) throw new Error(`Could not load glyph range. range: ${r}, ${g}-${y}`);
            const C = {};
            for (const R of a.o(E.data)) C[R.id] = R;
            return C;
          }));
        }, jt.TinySDF = class {
          constructor({ fontSize: m = 24, buffer: r = 3, radius: h = 8, cutoff: p = 0.25, fontFamily: g = "sans-serif", fontWeight: y = "normal", fontStyle: x = "normal", lang: E = null } = {}) {
            this.buffer = r, this.cutoff = p, this.radius = h, this.lang = E;
            const C = this.size = m + 4 * r, R = this._createCanvas(C), B = this.ctx = R.getContext("2d", { willReadFrequently: !0 });
            B.font = `${x} ${y} ${m}px ${g}`, B.textBaseline = "alphabetic", B.textAlign = "left", B.fillStyle = "black", this.gridOuter = new Float64Array(C * C), this.gridInner = new Float64Array(C * C), this.f = new Float64Array(C), this.z = new Float64Array(C + 1), this.v = new Uint16Array(C);
          }
          _createCanvas(m) {
            const r = document.createElement("canvas");
            return r.width = r.height = m, r;
          }
          draw(m) {
            const { width: r, actualBoundingBoxAscent: h, actualBoundingBoxDescent: p, actualBoundingBoxLeft: g, actualBoundingBoxRight: y } = this.ctx.measureText(m), x = Math.ceil(h), E = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(y - g))), C = Math.min(this.size - this.buffer, x + Math.ceil(p)), R = E + 2 * this.buffer, B = C + 2 * this.buffer, k = Math.max(R * B, 0), O = new Uint8ClampedArray(k), z = { data: O, width: R, height: B, glyphWidth: E, glyphHeight: C, glyphTop: x, glyphLeft: 0, glyphAdvance: r };
            if (E === 0 || C === 0) return z;
            const { ctx: H, buffer: Y, gridInner: K, gridOuter: J } = this;
            this.lang && (H.lang = this.lang), H.clearRect(Y, Y, E, C), H.fillText(m, Y, Y + x);
            const ie = H.getImageData(Y, Y, E, C);
            J.fill(ot, 0, k), K.fill(0, 0, k);
            for (let le = 0; le < C; le++) for (let se = 0; se < E; se++) {
              const he = ie.data[4 * (le * E + se) + 3] / 255;
              if (he === 0) continue;
              const fe = (le + Y) * R + se + Y;
              if (he === 1) J[fe] = 0, K[fe] = ot;
              else {
                const oe = 0.5 - he;
                J[fe] = oe > 0 ? oe * oe : 0, K[fe] = oe < 0 ? oe * oe : 0;
              }
            }
            bt(J, 0, 0, R, B, R, this.f, this.v, this.z), bt(K, Y, Y, E, C, R, this.f, this.v, this.z);
            for (let le = 0; le < k; le++) {
              const se = Math.sqrt(J[le]) - Math.sqrt(K[le]);
              O[le] = Math.round(255 - 255 * (se / this.radius + this.cutoff));
            }
            return z;
          }
        };
        class Et {
          constructor() {
            this.specification = a.v.light.position;
          }
          possiblyEvaluate(r, h) {
            return a.B(r.expression.evaluate(h));
          }
          interpolate(r, h, p) {
            return { x: a.C.number(r.x, h.x, p), y: a.C.number(r.y, h.y, p), z: a.C.number(r.z, h.z, p) };
          }
        }
        let bi;
        class Dr extends a.E {
          constructor(r) {
            super(), bi = bi || new a.r({ anchor: new a.D(a.v.light.anchor), position: new Et(), color: new a.D(a.v.light.color), intensity: new a.D(a.v.light.intensity) }), this._transitionable = new a.t(bi), this.setLight(r), this._transitioning = this._transitionable.untransitioned();
          }
          getLight() {
            return this._transitionable.serialize();
          }
          setLight(r, h = {}) {
            if (!this._validate(a.x, r, h)) for (const p in r) {
              const g = r[p];
              p.endsWith("-transition") ? this._transitionable.setTransition(p.slice(0, -11), g) : this._transitionable.setValue(p, g);
            }
          }
          updateTransitions(r) {
            this._transitioning = this._transitionable.transitioned(r, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(r) {
            this.properties = this._transitioning.possiblyEvaluate(r);
          }
          _validate(r, h, p) {
            return (!p || p.validate !== !1) && a.y(this, r.call(a.z, { value: h, style: { glyphs: !0, sprite: !0 }, styleSpec: a.v }));
          }
        }
        const gr = new a.r({ "sky-color": new a.D(a.v.sky["sky-color"]), "horizon-color": new a.D(a.v.sky["horizon-color"]), "fog-color": new a.D(a.v.sky["fog-color"]), "fog-ground-blend": new a.D(a.v.sky["fog-ground-blend"]), "horizon-fog-blend": new a.D(a.v.sky["horizon-fog-blend"]), "sky-horizon-blend": new a.D(a.v.sky["sky-horizon-blend"]), "atmosphere-blend": new a.D(a.v.sky["atmosphere-blend"]) });
        class Ln extends a.E {
          constructor(r) {
            super(), this._transitionable = new a.t(gr), this.setSky(r), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new a.F(0));
          }
          setSky(r, h = {}) {
            if (!this._validate(a.G, r, h)) {
              r || (r = { "sky-color": "transparent", "horizon-color": "transparent", "fog-color": "transparent", "fog-ground-blend": 1, "atmosphere-blend": 0 });
              for (const p in r) {
                const g = r[p];
                p.endsWith("-transition") ? this._transitionable.setTransition(p.slice(0, -11), g) : this._transitionable.setValue(p, g);
              }
            }
          }
          getSky() {
            return this._transitionable.serialize();
          }
          updateTransitions(r) {
            this._transitioning = this._transitionable.transitioned(r, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(r) {
            this.properties = this._transitioning.possiblyEvaluate(r);
          }
          _validate(r, h, p = {}) {
            return p?.validate !== !1 && a.y(this, r.call(a.z, a.e({ value: h, style: { glyphs: !0, sprite: !0 }, styleSpec: a.v })));
          }
          calculateFogBlendOpacity(r) {
            return r < 60 ? 0 : r < 70 ? (r - 60) / 10 : 1;
          }
        }
        class Ht {
          constructor(r, h) {
            this.width = r, this.height = h, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
          }
          getDash(r, h) {
            const p = r.join(",") + String(h);
            return this.dashEntry[p] || (this.dashEntry[p] = this.addDash(r, h)), this.dashEntry[p];
          }
          getDashRanges(r, h, p) {
            const g = [];
            let y = r.length % 2 == 1 ? -r[r.length - 1] * p : 0, x = r[0] * p, E = !0;
            g.push({ left: y, right: x, isDash: E, zeroLength: r[0] === 0 });
            let C = r[0];
            for (let R = 1; R < r.length; R++) {
              E = !E;
              const B = r[R];
              y = C * p, C += B, x = C * p, g.push({ left: y, right: x, isDash: E, zeroLength: B === 0 });
            }
            return g;
          }
          addRoundDash(r, h, p) {
            const g = h / 2;
            for (let y = -p; y <= p; y++) {
              const x = this.width * (this.nextRow + p + y);
              let E = 0, C = r[E];
              for (let R = 0; R < this.width; R++) {
                R / C.right > 1 && (C = r[++E]);
                const B = Math.abs(R - C.left), k = Math.abs(R - C.right), O = Math.min(B, k);
                let z;
                const H = y / p * (g + 1);
                if (C.isDash) {
                  const Y = g - Math.abs(H);
                  z = Math.sqrt(O * O + Y * Y);
                } else z = g - Math.sqrt(O * O + H * H);
                this.data[x + R] = Math.max(0, Math.min(255, z + 128));
              }
            }
          }
          addRegularDash(r) {
            for (let E = r.length - 1; E >= 0; --E) {
              const C = r[E], R = r[E + 1];
              C.zeroLength ? r.splice(E, 1) : R && R.isDash === C.isDash && (R.left = C.left, r.splice(E, 1));
            }
            const h = r[0], p = r[r.length - 1];
            h.isDash === p.isDash && (h.left = p.left - this.width, p.right = h.right + this.width);
            const g = this.width * this.nextRow;
            let y = 0, x = r[y];
            for (let E = 0; E < this.width; E++) {
              E / x.right > 1 && (x = r[++y]);
              const C = Math.abs(E - x.left), R = Math.abs(E - x.right), B = Math.min(C, R);
              this.data[g + E] = Math.max(0, Math.min(255, (x.isDash ? B : -B) + 128));
            }
          }
          addDash(r, h) {
            const p = h ? 7 : 0, g = 2 * p + 1;
            if (this.nextRow + g > this.height) return a.w("LineAtlas out of space"), null;
            let y = 0;
            for (let E = 0; E < r.length; E++) y += r[E];
            if (y !== 0) {
              const E = this.width / y, C = this.getDashRanges(r, this.width, E);
              h ? this.addRoundDash(C, E, p) : this.addRegularDash(C);
            }
            const x = { y: (this.nextRow + p + 0.5) / this.height, height: 2 * p / this.height, width: y };
            return this.nextRow += g, this.dirty = !0, x;
          }
          bind(r) {
            const h = r.gl;
            this.texture ? (h.bindTexture(h.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, h.texSubImage2D(h.TEXTURE_2D, 0, 0, 0, this.width, this.height, h.ALPHA, h.UNSIGNED_BYTE, this.data))) : (this.texture = h.createTexture(), h.bindTexture(h.TEXTURE_2D, this.texture), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_S, h.REPEAT), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_T, h.REPEAT), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MIN_FILTER, h.LINEAR), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MAG_FILTER, h.LINEAR), h.texImage2D(h.TEXTURE_2D, 0, h.ALPHA, this.width, this.height, 0, h.ALPHA, h.UNSIGNED_BYTE, this.data));
          }
        }
        const rr = "maplibre_preloaded_worker_pool";
        class wi {
          constructor() {
            this.active = {};
          }
          acquire(r) {
            if (!this.workers) for (this.workers = []; this.workers.length < wi.workerCount; ) this.workers.push(new Worker(a.a.WORKER_URL));
            return this.active[r] = !0, this.workers.slice();
          }
          release(r) {
            delete this.active[r], this.numActive() === 0 && (this.workers.forEach(((h) => {
              h.terminate();
            })), this.workers = null);
          }
          isPreloaded() {
            return !!this.active[rr];
          }
          numActive() {
            return Object.keys(this.active).length;
          }
        }
        const sr = Math.floor(N.hardwareConcurrency / 2);
        let cs, hs;
        function pn() {
          return cs || (cs = new wi()), cs;
        }
        wi.workerCount = a.H(globalThis) ? Math.max(Math.min(sr, 3), 1) : 1;
        class Er {
          constructor(r, h) {
            this.workerPool = r, this.actors = [], this.currentActor = 0, this.id = h;
            const p = this.workerPool.acquire(h);
            for (let g = 0; g < p.length; g++) {
              const y = new a.J(p[g], h);
              y.name = `Worker ${g}`, this.actors.push(y);
            }
            if (!this.actors.length) throw new Error("No actors found");
          }
          broadcast(r, h) {
            const p = [];
            for (const g of this.actors) p.push(g.sendAsync({ type: r, data: h }));
            return Promise.all(p);
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
          }
          remove(r = !0) {
            this.actors.forEach(((h) => {
              h.remove();
            })), this.actors = [], r && this.workerPool.release(this.id);
          }
          registerMessageHandler(r, h) {
            for (const p of this.actors) p.registerMessageHandler(r, h);
          }
        }
        function Ri() {
          return hs || (hs = new Er(pn(), a.K), hs.registerMessageHandler("GR", ((m, r, h) => a.m(r, h)))), hs;
        }
        function ji(m, r) {
          const h = a.L();
          return a.M(h, h, [1, 1, 0]), a.N(h, h, [0.5 * m.width, 0.5 * m.height, 1]), m.calculatePosMatrix ? a.O(h, h, m.calculatePosMatrix(r.toUnwrapped())) : h;
        }
        function qt(m, r, h, p, g, y, x) {
          var E;
          const C = (function(O, z, H) {
            if (O) for (const Y of O) {
              const K = z[Y];
              if (K && K.source === H && K.type === "fill-extrusion") return !0;
            }
            else for (const Y in z) {
              const K = z[Y];
              if (K.source === H && K.type === "fill-extrusion") return !0;
            }
            return !1;
          })((E = g?.layers) !== null && E !== void 0 ? E : null, r, m.id), R = y.maxPitchScaleFactor(), B = m.tilesIn(p, R, C);
          B.sort(Fi);
          const k = [];
          for (const O of B) k.push({ wrappedTileID: O.tileID.wrapped().key, queryResults: O.tile.queryRenderedFeatures(r, h, m._state, O.queryGeometry, O.cameraQueryGeometry, O.scale, g, y, R, ji(m.transform, O.tileID), x ? (z, H) => x(O.tileID, z, H) : void 0) });
          return (function(O, z) {
            for (const H in O) for (const Y of O[H]) ws(Y, z);
            return O;
          })((function(O) {
            const z = {}, H = {};
            for (const Y of O) {
              const K = Y.queryResults, J = Y.wrappedTileID, ie = H[J] = H[J] || {};
              for (const le in K) {
                const se = K[le], he = ie[le] = ie[le] || {}, fe = z[le] = z[le] || [];
                for (const oe of se) he[oe.featureIndex] || (he[oe.featureIndex] = !0, fe.push(oe));
              }
            }
            return z;
          })(k), m);
        }
        function Fi(m, r) {
          const h = m.tileID, p = r.tileID;
          return h.overscaledZ - p.overscaledZ || h.canonical.y - p.canonical.y || h.wrap - p.wrap || h.canonical.x - p.canonical.x;
        }
        function ws(m, r) {
          const h = m.feature, p = r.getFeatureState(h.layer["source-layer"], h.id);
          h.source = h.layer.source, h.layer["source-layer"] && (h.sourceLayer = h.layer["source-layer"]), h.state = p;
        }
        function Ji(m, r, h) {
          return a._(this, void 0, void 0, (function* () {
            let p = m;
            if (m.url ? p = (yield a.j(r.transformRequest(m.url, "Source"), h)).data : yield N.frameAsync(h), !p) return null;
            const g = a.Q(a.e(p, m), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
            return "vector_layers" in p && p.vector_layers && (g.vectorLayerIds = p.vector_layers.map(((y) => y.id))), g;
          }));
        }
        class ni {
          constructor(r, h) {
            r && (h ? this.setSouthWest(r).setNorthEast(h) : Array.isArray(r) && (r.length === 4 ? this.setSouthWest([r[0], r[1]]).setNorthEast([r[2], r[3]]) : this.setSouthWest(r[0]).setNorthEast(r[1])));
          }
          setNorthEast(r) {
            return this._ne = r instanceof a.S ? new a.S(r.lng, r.lat) : a.S.convert(r), this;
          }
          setSouthWest(r) {
            return this._sw = r instanceof a.S ? new a.S(r.lng, r.lat) : a.S.convert(r), this;
          }
          extend(r) {
            const h = this._sw, p = this._ne;
            let g, y;
            if (r instanceof a.S) g = r, y = r;
            else {
              if (!(r instanceof ni)) return Array.isArray(r) ? r.length === 4 || r.every(Array.isArray) ? this.extend(ni.convert(r)) : this.extend(a.S.convert(r)) : r && ("lng" in r || "lon" in r) && "lat" in r ? this.extend(a.S.convert(r)) : this;
              if (g = r._sw, y = r._ne, !g || !y) return this;
            }
            return h || p ? (h.lng = Math.min(g.lng, h.lng), h.lat = Math.min(g.lat, h.lat), p.lng = Math.max(y.lng, p.lng), p.lat = Math.max(y.lat, p.lat)) : (this._sw = new a.S(g.lng, g.lat), this._ne = new a.S(y.lng, y.lat)), this;
          }
          getCenter() {
            return new a.S((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
          }
          getSouthWest() {
            return this._sw;
          }
          getNorthEast() {
            return this._ne;
          }
          getNorthWest() {
            return new a.S(this.getWest(), this.getNorth());
          }
          getSouthEast() {
            return new a.S(this.getEast(), this.getSouth());
          }
          getWest() {
            return this._sw.lng;
          }
          getSouth() {
            return this._sw.lat;
          }
          getEast() {
            return this._ne.lng;
          }
          getNorth() {
            return this._ne.lat;
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()];
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
          }
          isEmpty() {
            return !(this._sw && this._ne);
          }
          contains(r) {
            const { lng: h, lat: p } = a.S.convert(r);
            let g = this._sw.lng <= h && h <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (g = this._sw.lng >= h && h >= this._ne.lng), this._sw.lat <= p && p <= this._ne.lat && g;
          }
          static convert(r) {
            return r instanceof ni ? r : r && new ni(r);
          }
          static fromLngLat(r, h = 0) {
            const p = 360 * h / 40075017, g = p / Math.cos(Math.PI / 180 * r.lat);
            return new ni(new a.S(r.lng - g, r.lat - p), new a.S(r.lng + g, r.lat + p));
          }
          adjustAntiMeridian() {
            const r = new a.S(this._sw.lng, this._sw.lat), h = new a.S(this._ne.lng, this._ne.lat);
            return new ni(r, r.lng > h.lng ? new a.S(h.lng + 360, h.lat) : h);
          }
        }
        class ai {
          constructor(r, h, p) {
            this.bounds = ni.convert(this.validateBounds(r)), this.minzoom = h || 0, this.maxzoom = p || 24;
          }
          validateBounds(r) {
            return Array.isArray(r) && r.length === 4 ? [Math.max(-180, r[0]), Math.max(-90, r[1]), Math.min(180, r[2]), Math.min(90, r[3])] : [-180, -90, 180, 90];
          }
          contains(r) {
            const h = Math.pow(2, r.z), p = Math.floor(a.V(this.bounds.getWest()) * h), g = Math.floor(a.U(this.bounds.getNorth()) * h), y = Math.ceil(a.V(this.bounds.getEast()) * h), x = Math.ceil(a.U(this.bounds.getSouth()) * h);
            return r.x >= p && r.x < y && r.y >= g && r.y < x;
          }
        }
        class mr extends a.E {
          constructor(r, h, p, g) {
            if (super(), this.id = r, this.dispatcher = p, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, a.e(this, a.Q(h, ["url", "scheme", "tileSize", "promoteId"])), this._options = a.e({ type: "vector" }, h), this._collectResourceTiming = h.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(g);
          }
          load() {
            return a._(this, void 0, void 0, (function* () {
              this._loaded = !1, this.fire(new a.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
              try {
                const r = yield Ji(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = !0, this.map.style.sourceCaches[this.id].clearTiles(), r && (a.e(this, r), r.bounds && (this.tileBounds = new ai(r.bounds, this.minzoom, this.maxzoom)), this.fire(new a.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new a.l("data", { dataType: "source", sourceDataType: "content" })));
              } catch (r) {
                this._tileJSONRequest = null, this.fire(new a.k(r));
              }
            }));
          }
          loaded() {
            return this._loaded;
          }
          hasTile(r) {
            return !this.tileBounds || this.tileBounds.contains(r.canonical);
          }
          onAdd(r) {
            this.map = r, this.load();
          }
          setSourceProperty(r) {
            this._tileJSONRequest && this._tileJSONRequest.abort(), r(), this.load();
          }
          setTiles(r) {
            return this.setSourceProperty((() => {
              this._options.tiles = r;
            })), this;
          }
          setUrl(r) {
            return this.setSourceProperty((() => {
              this.url = r, this._options.url = r;
            })), this;
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
          }
          serialize() {
            return a.e({}, this._options);
          }
          loadTile(r) {
            return a._(this, void 0, void 0, (function* () {
              const h = r.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), p = { request: this.map._requestManager.transformRequest(h, "Tile"), uid: r.uid, tileID: r.tileID, zoom: r.tileID.overscaledZ, tileSize: this.tileSize * r.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity, globalState: this.map.getGlobalState() };
              p.request.collectResourceTiming = this._collectResourceTiming;
              let g = "RT";
              if (r.actor && r.state !== "expired") {
                if (r.state === "loading") return new Promise(((y, x) => {
                  r.reloadPromise = { resolve: y, reject: x };
                }));
              } else r.actor = this.dispatcher.getActor(), g = "LT";
              r.abortController = new AbortController();
              try {
                const y = yield r.actor.sendAsync({ type: g, data: p }, r.abortController);
                if (delete r.abortController, r.aborted) return;
                this._afterTileLoadWorkerResponse(r, y);
              } catch (y) {
                if (delete r.abortController, r.aborted) return;
                if (y && y.status !== 404) throw y;
                this._afterTileLoadWorkerResponse(r, null);
              }
            }));
          }
          _afterTileLoadWorkerResponse(r, h) {
            if (h && h.resourceTiming && (r.resourceTiming = h.resourceTiming), h && this.map._refreshExpiredTiles && r.setExpiryData(h), r.loadVectorData(h, this.map.painter), r.reloadPromise) {
              const p = r.reloadPromise;
              r.reloadPromise = null, this.loadTile(r).then(p.resolve).catch(p.reject);
            }
          }
          abortTile(r) {
            return a._(this, void 0, void 0, (function* () {
              r.abortController && (r.abortController.abort(), delete r.abortController), r.actor && (yield r.actor.sendAsync({ type: "AT", data: { uid: r.uid, type: this.type, source: this.id } }));
            }));
          }
          unloadTile(r) {
            return a._(this, void 0, void 0, (function* () {
              r.unloadVectorData(), r.actor && (yield r.actor.sendAsync({ type: "RMT", data: { uid: r.uid, type: this.type, source: this.id } }));
            }));
          }
          hasTransition() {
            return !1;
          }
        }
        class ki extends a.E {
          constructor(r, h, p, g) {
            super(), this.id = r, this.dispatcher = p, this.setEventedParent(g), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = a.e({ type: "raster" }, h), a.e(this, a.Q(h, ["url", "scheme", "tileSize"]));
          }
          load() {
            return a._(this, arguments, void 0, (function* (r = !1) {
              this._loaded = !1, this.fire(new a.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
              try {
                const h = yield Ji(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = !0, h && (a.e(this, h), h.bounds && (this.tileBounds = new ai(h.bounds, this.minzoom, this.maxzoom)), this.fire(new a.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new a.l("data", { dataType: "source", sourceDataType: "content", sourceDataChanged: r })));
              } catch (h) {
                this._tileJSONRequest = null, this.fire(new a.k(h));
              }
            }));
          }
          loaded() {
            return this._loaded;
          }
          onAdd(r) {
            this.map = r, this.load();
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
          }
          setSourceProperty(r) {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), r(), this.load(!0);
          }
          setTiles(r) {
            return this.setSourceProperty((() => {
              this._options.tiles = r;
            })), this;
          }
          setUrl(r) {
            return this.setSourceProperty((() => {
              this.url = r, this._options.url = r;
            })), this;
          }
          serialize() {
            return a.e({}, this._options);
          }
          hasTile(r) {
            return !this.tileBounds || this.tileBounds.contains(r.canonical);
          }
          loadTile(r) {
            return a._(this, void 0, void 0, (function* () {
              const h = r.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
              r.abortController = new AbortController();
              try {
                const p = yield Le.getImage(this.map._requestManager.transformRequest(h, "Tile"), r.abortController, this.map._refreshExpiredTiles);
                if (delete r.abortController, r.aborted) return void (r.state = "unloaded");
                if (p && p.data) {
                  this.map._refreshExpiredTiles && (p.cacheControl || p.expires) && r.setExpiryData({ cacheControl: p.cacheControl, expires: p.expires });
                  const g = this.map.painter.context, y = g.gl, x = p.data;
                  r.texture = this.map.painter.getTileTexture(x.width), r.texture ? r.texture.update(x, { useMipmap: !0 }) : (r.texture = new a.T(g, x, y.RGBA, { useMipmap: !0 }), r.texture.bind(y.LINEAR, y.CLAMP_TO_EDGE, y.LINEAR_MIPMAP_NEAREST)), r.state = "loaded";
                }
              } catch (p) {
                if (delete r.abortController, r.aborted) r.state = "unloaded";
                else if (p) throw r.state = "errored", p;
              }
            }));
          }
          abortTile(r) {
            return a._(this, void 0, void 0, (function* () {
              r.abortController && (r.abortController.abort(), delete r.abortController);
            }));
          }
          unloadTile(r) {
            return a._(this, void 0, void 0, (function* () {
              r.texture && this.map.painter.saveTileTexture(r.texture);
            }));
          }
          hasTransition() {
            return !1;
          }
        }
        class Or extends ki {
          constructor(r, h, p, g) {
            super(r, h, p, g), this.type = "raster-dem", this.maxzoom = 22, this._options = a.e({ type: "raster-dem" }, h), this.encoding = h.encoding || "mapbox", this.redFactor = h.redFactor, this.greenFactor = h.greenFactor, this.blueFactor = h.blueFactor, this.baseShift = h.baseShift;
          }
          loadTile(r) {
            return a._(this, void 0, void 0, (function* () {
              const h = r.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), p = this.map._requestManager.transformRequest(h, "Tile");
              r.neighboringTiles = this._getNeighboringTiles(r.tileID), r.abortController = new AbortController();
              try {
                const g = yield Le.getImage(p, r.abortController, this.map._refreshExpiredTiles);
                if (delete r.abortController, r.aborted) return void (r.state = "unloaded");
                if (g && g.data) {
                  const y = g.data;
                  this.map._refreshExpiredTiles && (g.cacheControl || g.expires) && r.setExpiryData({ cacheControl: g.cacheControl, expires: g.expires });
                  const x = a.b(y) && a.W() ? y : yield this.readImageNow(y), E = { type: this.type, uid: r.uid, source: this.id, rawImageData: x, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
                  if (!r.actor || r.state === "expired") {
                    r.actor = this.dispatcher.getActor();
                    const C = yield r.actor.sendAsync({ type: "LDT", data: E });
                    r.dem = C, r.needsHillshadePrepare = !0, r.needsTerrainPrepare = !0, r.state = "loaded";
                  }
                }
              } catch (g) {
                if (delete r.abortController, r.aborted) r.state = "unloaded";
                else if (g) throw r.state = "errored", g;
              }
            }));
          }
          readImageNow(r) {
            return a._(this, void 0, void 0, (function* () {
              if (typeof VideoFrame < "u" && a.X()) {
                const h = r.width + 2, p = r.height + 2;
                try {
                  return new a.R({ width: h, height: p }, yield a.Y(r, -1, -1, h, p));
                } catch {
                }
              }
              return N.getImageData(r, 1);
            }));
          }
          _getNeighboringTiles(r) {
            const h = r.canonical, p = Math.pow(2, h.z), g = (h.x - 1 + p) % p, y = h.x === 0 ? r.wrap - 1 : r.wrap, x = (h.x + 1 + p) % p, E = h.x + 1 === p ? r.wrap + 1 : r.wrap, C = {};
            return C[new a.Z(r.overscaledZ, y, h.z, g, h.y).key] = { backfilled: !1 }, C[new a.Z(r.overscaledZ, E, h.z, x, h.y).key] = { backfilled: !1 }, h.y > 0 && (C[new a.Z(r.overscaledZ, y, h.z, g, h.y - 1).key] = { backfilled: !1 }, C[new a.Z(r.overscaledZ, r.wrap, h.z, h.x, h.y - 1).key] = { backfilled: !1 }, C[new a.Z(r.overscaledZ, E, h.z, x, h.y - 1).key] = { backfilled: !1 }), h.y + 1 < p && (C[new a.Z(r.overscaledZ, y, h.z, g, h.y + 1).key] = { backfilled: !1 }, C[new a.Z(r.overscaledZ, r.wrap, h.z, h.x, h.y + 1).key] = { backfilled: !1 }, C[new a.Z(r.overscaledZ, E, h.z, x, h.y + 1).key] = { backfilled: !1 }), C;
          }
          unloadTile(r) {
            return a._(this, void 0, void 0, (function* () {
              r.demTexture && this.map.painter.saveTileTexture(r.demTexture), r.fbo && (r.fbo.destroy(), delete r.fbo), r.dem && delete r.dem, delete r.neighboringTiles, r.state = "unloaded", r.actor && (yield r.actor.sendAsync({ type: "RDT", data: { type: this.type, uid: r.uid, source: this.id } }));
            }));
          }
        }
        class es extends a.E {
          constructor(r, h, p, g) {
            super(), this.id = r, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._isUpdatingWorker = !1, this._pendingWorkerUpdate = { data: h.data }, this.actor = p.getActor(), this.setEventedParent(g), this._data = h.data, this._options = a.e({}, h), this._collectResourceTiming = h.collectResourceTiming, h.maxzoom !== void 0 && (this.maxzoom = h.maxzoom), h.type && (this.type = h.type), h.attribution && (this.attribution = h.attribution), this.promoteId = h.promoteId, h.clusterMaxZoom !== void 0 && this.maxzoom <= h.clusterMaxZoom && a.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${h.clusterMaxZoom}".`), this.workerOptions = a.e({ source: this.id, cluster: h.cluster || !1, geojsonVtOptions: { buffer: this._pixelsToTileUnits(h.buffer !== void 0 ? h.buffer : 128), tolerance: this._pixelsToTileUnits(h.tolerance !== void 0 ? h.tolerance : 0.375), extent: a.$, maxZoom: this.maxzoom, lineMetrics: h.lineMetrics || !1, generateId: h.generateId || !1 }, superclusterOptions: { maxZoom: this._getClusterMaxZoom(h.clusterMaxZoom), minPoints: Math.max(2, h.clusterMinPoints || 2), extent: a.$, radius: this._pixelsToTileUnits(h.clusterRadius || 50), log: !1, generateId: h.generateId || !1 }, clusterProperties: h.clusterProperties, filter: h.filter }, h.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId);
          }
          _pixelsToTileUnits(r) {
            return r * (a.$ / this.tileSize);
          }
          _getClusterMaxZoom(r) {
            const h = r ? Math.round(r) : this.maxzoom - 1;
            return Number.isInteger(r) || r === void 0 || a.w(`Integer expected for option 'clusterMaxZoom': provided value "${r}" rounded to "${h}"`), h;
          }
          load() {
            return a._(this, void 0, void 0, (function* () {
              yield this._updateWorkerData();
            }));
          }
          onAdd(r) {
            this.map = r, this.load();
          }
          setData(r) {
            return this._data = r, this._pendingWorkerUpdate = { data: r }, this._updateWorkerData(), this;
          }
          updateData(r) {
            return this._pendingWorkerUpdate.diff = a.a0(this._pendingWorkerUpdate.diff, r), this._updateWorkerData(), this;
          }
          getData() {
            return a._(this, void 0, void 0, (function* () {
              const r = a.e({ type: this.type }, this.workerOptions);
              return this.actor.sendAsync({ type: "GD", data: r });
            }));
          }
          getCoordinatesFromGeometry(r) {
            return r.type === "GeometryCollection" ? r.geometries.map(((h) => h.coordinates)).flat(1 / 0) : r.coordinates.flat(1 / 0);
          }
          getBounds() {
            return a._(this, void 0, void 0, (function* () {
              const r = new ni(), h = yield this.getData();
              let p;
              switch (h.type) {
                case "FeatureCollection":
                  p = h.features.map(((g) => this.getCoordinatesFromGeometry(g.geometry))).flat(1 / 0);
                  break;
                case "Feature":
                  p = this.getCoordinatesFromGeometry(h.geometry);
                  break;
                default:
                  p = this.getCoordinatesFromGeometry(h);
              }
              if (p.length == 0) return r;
              for (let g = 0; g < p.length - 1; g += 2) r.extend([p[g], p[g + 1]]);
              return r;
            }));
          }
          setClusterOptions(r) {
            return this.workerOptions.cluster = r.cluster, r && (r.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(r.clusterRadius)), r.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = this._getClusterMaxZoom(r.clusterMaxZoom))), this._updateWorkerData(), this;
          }
          getClusterExpansionZoom(r) {
            return this.actor.sendAsync({ type: "GCEZ", data: { type: this.type, clusterId: r, source: this.id } });
          }
          getClusterChildren(r) {
            return this.actor.sendAsync({ type: "GCC", data: { type: this.type, clusterId: r, source: this.id } });
          }
          getClusterLeaves(r, h, p) {
            return this.actor.sendAsync({ type: "GCL", data: { type: this.type, source: this.id, clusterId: r, limit: h, offset: p } });
          }
          _updateWorkerData() {
            return a._(this, void 0, void 0, (function* () {
              if (this._isUpdatingWorker) return;
              const { data: r, diff: h } = this._pendingWorkerUpdate;
              if (!r && !h) return void a.w(`No data or diff provided to GeoJSONSource ${this.id}.`);
              const p = a.e({ type: this.type }, this.workerOptions);
              r ? (typeof r == "string" ? (p.request = this.map._requestManager.transformRequest(N.resolveURL(r), "Source"), p.request.collectResourceTiming = this._collectResourceTiming) : p.data = JSON.stringify(r), this._pendingWorkerUpdate.data = void 0) : h && (p.dataDiff = h, this._pendingWorkerUpdate.diff = void 0), this._isUpdatingWorker = !0, this.fire(new a.l("dataloading", { dataType: "source" }));
              try {
                const g = yield this.actor.sendAsync({ type: "LD", data: p });
                if (this._isUpdatingWorker = !1, this._removed || g.abandoned) return void this.fire(new a.l("dataabort", { dataType: "source" }));
                this._data = g.data;
                let y = null;
                g.resourceTiming && g.resourceTiming[this.id] && (y = g.resourceTiming[this.id].slice(0));
                const x = { dataType: "source" };
                this._collectResourceTiming && y && y.length > 0 && a.e(x, { resourceTiming: y }), this.fire(new a.l("data", Object.assign(Object.assign({}, x), { sourceDataType: "metadata" }))), this.fire(new a.l("data", Object.assign(Object.assign({}, x), { sourceDataType: "content" })));
              } catch (g) {
                if (this._isUpdatingWorker = !1, this._removed) return void this.fire(new a.l("dataabort", { dataType: "source" }));
                this.fire(new a.k(g));
              } finally {
                (this._pendingWorkerUpdate.data || this._pendingWorkerUpdate.diff) && this._updateWorkerData();
              }
            }));
          }
          loaded() {
            return !this._isUpdatingWorker && this._pendingWorkerUpdate.data === void 0 && this._pendingWorkerUpdate.diff === void 0;
          }
          loadTile(r) {
            return a._(this, void 0, void 0, (function* () {
              const h = r.actor ? "RT" : "LT";
              r.actor = this.actor;
              const p = { type: this.type, uid: r.uid, tileID: r.tileID, zoom: r.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity, globalState: this.map.getGlobalState() };
              r.abortController = new AbortController();
              const g = yield this.actor.sendAsync({ type: h, data: p }, r.abortController);
              delete r.abortController, r.unloadVectorData(), r.aborted || r.loadVectorData(g, this.map.painter, h === "RT");
            }));
          }
          abortTile(r) {
            return a._(this, void 0, void 0, (function* () {
              r.abortController && (r.abortController.abort(), delete r.abortController), r.aborted = !0;
            }));
          }
          unloadTile(r) {
            return a._(this, void 0, void 0, (function* () {
              r.unloadVectorData(), yield this.actor.sendAsync({ type: "RMT", data: { uid: r.uid, type: this.type, source: this.id } });
            }));
          }
          onRemove() {
            this._removed = !0, this.actor.sendAsync({ type: "RS", data: { type: this.type, source: this.id } });
          }
          serialize() {
            return a.e({}, this._options, { type: this.type, data: this._data });
          }
          hasTransition() {
            return !1;
          }
        }
        class ts extends a.E {
          constructor(r, h, p, g) {
            super(), this.flippedWindingOrder = !1, this.id = r, this.dispatcher = p, this.coordinates = h.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(g), this.options = h;
          }
          load(r) {
            return a._(this, void 0, void 0, (function* () {
              this._loaded = !1, this.fire(new a.l("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController();
              try {
                const h = yield Le.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
                this._request = null, this._loaded = !0, h && h.data && (this.image = h.data, r && (this.coordinates = r), this._finishLoading());
              } catch (h) {
                this._request = null, this._loaded = !0, this.fire(new a.k(h));
              }
            }));
          }
          loaded() {
            return this._loaded;
          }
          updateImage(r) {
            return r.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = r.url, this.load(r.coordinates).finally((() => {
              this.texture = null;
            })), this) : this;
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new a.l("data", { dataType: "source", sourceDataType: "metadata" })));
          }
          onAdd(r) {
            this.map = r, this.load();
          }
          onRemove() {
            this._request && (this._request.abort(), this._request = null);
          }
          setCoordinates(r) {
            this.coordinates = r;
            const h = r.map(a.a1.fromLngLat);
            var p;
            return this.tileID = (function(g) {
              const y = a.a2.fromPoints(g), x = y.width(), E = y.height(), C = Math.max(x, E), R = Math.max(0, Math.floor(-Math.log(C) / Math.LN2)), B = Math.pow(2, R);
              return new a.a4(R, Math.floor((y.minX + y.maxX) / 2 * B), Math.floor((y.minY + y.maxY) / 2 * B));
            })(h), this.terrainTileRanges = this._getOverlappingTileRanges(h), this.minzoom = this.maxzoom = this.tileID.z, this.tileCoords = h.map(((g) => this.tileID.getTilePoint(g)._round())), this.flippedWindingOrder = ((p = this.tileCoords)[1].x - p[0].x) * (p[2].y - p[0].y) - (p[1].y - p[0].y) * (p[2].x - p[0].x) < 0, this.fire(new a.l("data", { dataType: "source", sourceDataType: "content" })), this;
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || !this.image) return;
            const r = this.map.painter.context, h = r.gl;
            this.texture || (this.texture = new a.T(r, this.image, h.RGBA), this.texture.bind(h.LINEAR, h.CLAMP_TO_EDGE));
            let p = !1;
            for (const g in this.tiles) {
              const y = this.tiles[g];
              y.state !== "loaded" && (y.state = "loaded", y.texture = this.texture, p = !0);
            }
            p && this.fire(new a.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          loadTile(r) {
            return a._(this, void 0, void 0, (function* () {
              this.tileID && this.tileID.equals(r.tileID.canonical) ? (this.tiles[String(r.tileID.wrap)] = r, r.buckets = {}) : r.state = "errored";
            }));
          }
          serialize() {
            return { type: "image", url: this.options.url, coordinates: this.coordinates };
          }
          hasTransition() {
            return !1;
          }
          _getOverlappingTileRanges(r) {
            const { minX: h, minY: p, maxX: g, maxY: y } = a.a2.fromPoints(r), x = {};
            for (let E = 0; E <= a.a3; E++) {
              const C = Math.pow(2, E), R = Math.floor(h * C), B = Math.floor(p * C), k = Math.floor(g * C), O = Math.floor(y * C);
              x[E] = { minTileX: R, minTileY: B, maxTileX: k, maxTileY: O };
            }
            return x;
          }
        }
        class Ts extends ts {
          constructor(r, h, p, g) {
            super(r, h, p, g), this.roundZoom = !0, this.type = "video", this.options = h;
          }
          load() {
            return a._(this, void 0, void 0, (function* () {
              this._loaded = !1;
              const r = this.options;
              this.urls = [];
              for (const h of r.urls) this.urls.push(this.map._requestManager.transformRequest(h, "Source").url);
              try {
                const h = yield a.a5(this.urls);
                if (this._loaded = !0, !h) return;
                this.video = h, this.video.loop = !0, this.video.addEventListener("playing", (() => {
                  this.map.triggerRepaint();
                })), this.map && this.video.play(), this._finishLoading();
              } catch (h) {
                this.fire(new a.k(h));
              }
            }));
          }
          pause() {
            this.video && this.video.pause();
          }
          play() {
            this.video && this.video.play();
          }
          seek(r) {
            if (this.video) {
              const h = this.video.seekable;
              r < h.start(0) || r > h.end(0) ? this.fire(new a.k(new a.a6(`sources.${this.id}`, null, `Playback for this video can be set only between the ${h.start(0)} and ${h.end(0)}-second mark.`))) : this.video.currentTime = r;
            }
          }
          getVideo() {
            return this.video;
          }
          onAdd(r) {
            this.map || (this.map = r, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
            const r = this.map.painter.context, h = r.gl;
            this.texture ? this.video.paused || (this.texture.bind(h.LINEAR, h.CLAMP_TO_EDGE), h.texSubImage2D(h.TEXTURE_2D, 0, 0, 0, h.RGBA, h.UNSIGNED_BYTE, this.video)) : (this.texture = new a.T(r, this.video, h.RGBA), this.texture.bind(h.LINEAR, h.CLAMP_TO_EDGE));
            let p = !1;
            for (const g in this.tiles) {
              const y = this.tiles[g];
              y.state !== "loaded" && (y.state = "loaded", y.texture = this.texture, p = !0);
            }
            p && this.fire(new a.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          serialize() {
            return { type: "video", urls: this.urls, coordinates: this.coordinates };
          }
          hasTransition() {
            return this.video && !this.video.paused;
          }
        }
        class Ni extends ts {
          constructor(r, h, p, g) {
            super(r, h, p, g), h.coordinates ? Array.isArray(h.coordinates) && h.coordinates.length === 4 && !h.coordinates.some(((y) => !Array.isArray(y) || y.length !== 2 || y.some(((x) => typeof x != "number")))) || this.fire(new a.k(new a.a6(`sources.${r}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new a.k(new a.a6(`sources.${r}`, null, 'missing required property "coordinates"'))), h.animate && typeof h.animate != "boolean" && this.fire(new a.k(new a.a6(`sources.${r}`, null, 'optional "animate" property must be a boolean value'))), h.canvas ? typeof h.canvas == "string" || h.canvas instanceof HTMLCanvasElement || this.fire(new a.k(new a.a6(`sources.${r}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new a.k(new a.a6(`sources.${r}`, null, 'missing required property "canvas"'))), this.options = h, this.animate = h.animate === void 0 || h.animate;
          }
          load() {
            return a._(this, void 0, void 0, (function* () {
              this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new a.k(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                this._playing = !0, this.map.triggerRepaint();
              }, this.pause = function() {
                this._playing && (this.prepare(), this._playing = !1);
              }, this._finishLoading());
            }));
          }
          getCanvas() {
            return this.canvas;
          }
          onAdd(r) {
            this.map = r, this.load(), this.canvas && this.animate && this.play();
          }
          onRemove() {
            this.pause();
          }
          prepare() {
            let r = !1;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, r = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, r = !0), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
            const h = this.map.painter.context, p = h.gl;
            this.texture ? (r || this._playing) && this.texture.update(this.canvas, { premultiply: !0 }) : this.texture = new a.T(h, this.canvas, p.RGBA, { premultiply: !0 });
            let g = !1;
            for (const y in this.tiles) {
              const x = this.tiles[y];
              x.state !== "loaded" && (x.state = "loaded", x.texture = this.texture, g = !0);
            }
            g && this.fire(new a.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          serialize() {
            return { type: "canvas", coordinates: this.coordinates };
          }
          hasTransition() {
            return this._playing;
          }
          _hasInvalidDimensions() {
            for (const r of [this.canvas.width, this.canvas.height]) if (isNaN(r) || r <= 0) return !0;
            return !1;
          }
        }
        const Ks = {}, Ys = (m) => {
          switch (m) {
            case "geojson":
              return es;
            case "image":
              return ts;
            case "raster":
              return ki;
            case "raster-dem":
              return Or;
            case "vector":
              return mr;
            case "video":
              return Ts;
            case "canvas":
              return Ni;
          }
          return Ks[m];
        }, _n = "RTLPluginLoaded";
        class Js extends a.E {
          constructor() {
            super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = Ri();
          }
          _syncState(r) {
            return this.status = r, this.dispatcher.broadcast("SRPS", { pluginStatus: r, pluginURL: this.url }).catch(((h) => {
              throw this.status = "error", h;
            }));
          }
          getRTLTextPluginStatus() {
            return this.status;
          }
          clearRTLTextPlugin() {
            this.status = "unavailable", this.url = null;
          }
          setRTLTextPlugin(r) {
            return a._(this, arguments, void 0, (function* (h, p = !1) {
              if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
              if (this.url = N.resolveURL(h), !this.url) throw new Error(`requested url ${h} is invalid`);
              if (this.status === "unavailable") {
                if (!p) return this._requestImport();
                this.status = "deferred", this._syncState(this.status);
              } else if (this.status === "requested") return this._requestImport();
            }));
          }
          _requestImport() {
            return a._(this, void 0, void 0, (function* () {
              yield this._syncState("loading"), this.status = "loaded", this.fire(new a.l(_n));
            }));
          }
          lazyLoad() {
            this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport();
          }
        }
        let Qs = null;
        function As() {
          return Qs || (Qs = new Js()), Qs;
        }
        class gn {
          constructor(r, h) {
            this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = r, this.uid = a.a7(), this.uses = 0, this.tileSize = h, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
          }
          registerFadeDuration(r) {
            const h = r + this.timeAdded;
            h < this.fadeEndTime || (this.fadeEndTime = h);
          }
          wasRequested() {
            return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
          }
          clearTextures(r) {
            this.demTexture && r.saveTileTexture(this.demTexture), this.demTexture = null;
          }
          loadVectorData(r, h, p) {
            if (this.hasData() && this.unloadVectorData(), this.state = "loaded", r) {
              r.featureIndex && (this.latestFeatureIndex = r.featureIndex, r.rawTileData ? (this.latestRawTileData = r.rawTileData, this.latestFeatureIndex.rawTileData = r.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = r.collisionBoxArray, this.buckets = (function(g, y) {
                const x = {};
                if (!y) return x;
                for (const E of g) {
                  const C = E.layerIds.map(((R) => y.getLayer(R))).filter(Boolean);
                  if (C.length !== 0) {
                    E.layers = C, E.stateDependentLayerIds && (E.stateDependentLayers = E.stateDependentLayerIds.map(((R) => C.filter(((B) => B.id === R))[0])));
                    for (const R of C) x[R.id] = E;
                  }
                }
                return x;
              })(r.buckets, h?.style), this.hasSymbolBuckets = !1;
              for (const g in this.buckets) {
                const y = this.buckets[g];
                if (y instanceof a.a9) {
                  if (this.hasSymbolBuckets = !0, !p) break;
                  y.justReloaded = !0;
                }
              }
              if (this.hasRTLText = !1, this.hasSymbolBuckets) for (const g in this.buckets) {
                const y = this.buckets[g];
                if (y instanceof a.a9 && y.hasRTLText) {
                  this.hasRTLText = !0, As().lazyLoad();
                  break;
                }
              }
              this.queryPadding = 0;
              for (const g in this.buckets) {
                const y = this.buckets[g];
                this.queryPadding = Math.max(this.queryPadding, h.style.getLayer(g).queryRadius(y));
              }
              r.imageAtlas && (this.imageAtlas = r.imageAtlas), r.glyphAtlasImage && (this.glyphAtlasImage = r.glyphAtlasImage);
            } else this.collisionBoxArray = new a.a8();
          }
          unloadVectorData() {
            for (const r in this.buckets) this.buckets[r].destroy();
            this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
          }
          getBucket(r) {
            return this.buckets[r.id];
          }
          upload(r) {
            for (const p in this.buckets) {
              const g = this.buckets[p];
              g.uploadPending() && g.upload(r);
            }
            const h = r.gl;
            this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new a.T(r, this.imageAtlas.image, h.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new a.T(r, this.glyphAtlasImage, h.ALPHA), this.glyphAtlasImage = null);
          }
          prepare(r) {
            this.imageAtlas && this.imageAtlas.patchUpdatedImages(r, this.imageAtlasTexture);
          }
          queryRenderedFeatures(r, h, p, g, y, x, E, C, R, B, k) {
            return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: g, cameraQueryGeometry: y, scale: x, tileSize: this.tileSize, pixelPosMatrix: B, transform: C, params: E, queryPadding: this.queryPadding * R, getElevation: k }, r, h, p) : {};
          }
          querySourceFeatures(r, h) {
            const p = this.latestFeatureIndex;
            if (!p || !p.rawTileData) return;
            const g = p.loadVTLayers(), y = h && h.sourceLayer ? h.sourceLayer : "", x = g._geojsonTileLayer || g[y];
            if (!x) return;
            const E = a.aa(h && h.filter), { z: C, x: R, y: B } = this.tileID.canonical, k = { z: C, x: R, y: B };
            for (let O = 0; O < x.length; O++) {
              const z = x.feature(O);
              if (E.needGeometry) {
                const K = a.ab(z, !0);
                if (!E.filter(new a.F(this.tileID.overscaledZ), K, this.tileID.canonical)) continue;
              } else if (!E.filter(new a.F(this.tileID.overscaledZ), z)) continue;
              const H = p.getId(z, y), Y = new a.ac(z, C, R, B, H);
              Y.tile = k, r.push(Y);
            }
          }
          hasData() {
            return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
          }
          patternsLoaded() {
            return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
          }
          setExpiryData(r) {
            const h = this.expirationTime;
            if (r.cacheControl) {
              const p = a.ad(r.cacheControl);
              p["max-age"] && (this.expirationTime = Date.now() + 1e3 * p["max-age"]);
            } else r.expires && (this.expirationTime = new Date(r.expires).getTime());
            if (this.expirationTime) {
              const p = Date.now();
              let g = !1;
              if (this.expirationTime > p) g = !1;
              else if (h) if (this.expirationTime < h) g = !0;
              else {
                const y = this.expirationTime - h;
                y ? this.expirationTime = p + Math.max(y, 3e4) : g = !0;
              }
              else g = !0;
              g ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
          }
          setFeatureState(r, h) {
            if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(r).length === 0) return;
            const p = this.latestFeatureIndex.loadVTLayers();
            for (const g in this.buckets) {
              if (!h.style.hasLayer(g)) continue;
              const y = this.buckets[g], x = y.layers[0].sourceLayer || "_geojsonTileLayer", E = p[x], C = r[x];
              if (!E || !C || Object.keys(C).length === 0) continue;
              y.update(C, E, this.imageAtlas && this.imageAtlas.patternPositions || {});
              const R = h && h.style && h.style.getLayer(g);
              R && (this.queryPadding = Math.max(this.queryPadding, R.queryRadius(y)));
            }
          }
          holdingForFade() {
            return this.symbolFadeHoldUntil !== void 0;
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < N.now();
          }
          clearFadeHold() {
            this.symbolFadeHoldUntil = void 0;
          }
          setHoldDuration(r) {
            this.symbolFadeHoldUntil = N.now() + r;
          }
          setDependencies(r, h) {
            const p = {};
            for (const g of h) p[g] = !0;
            this.dependencies[r] = p;
          }
          hasDependency(r, h) {
            for (const p of r) {
              const g = this.dependencies[p];
              if (g) {
                for (const y of h) if (g[y]) return !0;
              }
            }
            return !1;
          }
        }
        class _e {
          constructor(r, h) {
            this.max = r, this.onRemove = h, this.reset();
          }
          reset() {
            for (const r in this.data) for (const h of this.data[r]) h.timeout && clearTimeout(h.timeout), this.onRemove(h.value);
            return this.data = {}, this.order = [], this;
          }
          add(r, h, p) {
            const g = r.wrapped().key;
            this.data[g] === void 0 && (this.data[g] = []);
            const y = { value: h, timeout: void 0 };
            if (p !== void 0 && (y.timeout = setTimeout((() => {
              this.remove(r, y);
            }), p)), this.data[g].push(y), this.order.push(g), this.order.length > this.max) {
              const x = this._getAndRemoveByKey(this.order[0]);
              x && this.onRemove(x);
            }
            return this;
          }
          has(r) {
            return r.wrapped().key in this.data;
          }
          getAndRemove(r) {
            return this.has(r) ? this._getAndRemoveByKey(r.wrapped().key) : null;
          }
          _getAndRemoveByKey(r) {
            const h = this.data[r].shift();
            return h.timeout && clearTimeout(h.timeout), this.data[r].length === 0 && delete this.data[r], this.order.splice(this.order.indexOf(r), 1), h.value;
          }
          getByKey(r) {
            const h = this.data[r];
            return h ? h[0].value : null;
          }
          get(r) {
            return this.has(r) ? this.data[r.wrapped().key][0].value : null;
          }
          remove(r, h) {
            if (!this.has(r)) return this;
            const p = r.wrapped().key, g = h === void 0 ? 0 : this.data[p].indexOf(h), y = this.data[p][g];
            return this.data[p].splice(g, 1), y.timeout && clearTimeout(y.timeout), this.data[p].length === 0 && delete this.data[p], this.onRemove(y.value), this.order.splice(this.order.indexOf(p), 1), this;
          }
          setMaxSize(r) {
            for (this.max = r; this.order.length > this.max; ) {
              const h = this._getAndRemoveByKey(this.order[0]);
              h && this.onRemove(h);
            }
            return this;
          }
          filter(r) {
            const h = [];
            for (const p in this.data) for (const g of this.data[p]) r(g.value) || h.push(g);
            for (const p of h) this.remove(p.value.tileID, p);
          }
        }
        class $ {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {};
          }
          updateState(r, h, p) {
            const g = String(h);
            if (this.stateChanges[r] = this.stateChanges[r] || {}, this.stateChanges[r][g] = this.stateChanges[r][g] || {}, a.e(this.stateChanges[r][g], p), this.deletedStates[r] === null) {
              this.deletedStates[r] = {};
              for (const y in this.state[r]) y !== g && (this.deletedStates[r][y] = null);
            } else if (this.deletedStates[r] && this.deletedStates[r][g] === null) {
              this.deletedStates[r][g] = {};
              for (const y in this.state[r][g]) p[y] || (this.deletedStates[r][g][y] = null);
            } else for (const y in p) this.deletedStates[r] && this.deletedStates[r][g] && this.deletedStates[r][g][y] === null && delete this.deletedStates[r][g][y];
          }
          removeFeatureState(r, h, p) {
            if (this.deletedStates[r] === null) return;
            const g = String(h);
            if (this.deletedStates[r] = this.deletedStates[r] || {}, p && h !== void 0) this.deletedStates[r][g] !== null && (this.deletedStates[r][g] = this.deletedStates[r][g] || {}, this.deletedStates[r][g][p] = null);
            else if (h !== void 0) if (this.stateChanges[r] && this.stateChanges[r][g]) for (p in this.deletedStates[r][g] = {}, this.stateChanges[r][g]) this.deletedStates[r][g][p] = null;
            else this.deletedStates[r][g] = null;
            else this.deletedStates[r] = null;
          }
          getState(r, h) {
            const p = String(h), g = a.e({}, (this.state[r] || {})[p], (this.stateChanges[r] || {})[p]);
            if (this.deletedStates[r] === null) return {};
            if (this.deletedStates[r]) {
              const y = this.deletedStates[r][h];
              if (y === null) return {};
              for (const x in y) delete g[x];
            }
            return g;
          }
          initializeTileState(r, h) {
            r.setFeatureState(this.state, h);
          }
          coalesceChanges(r, h) {
            const p = {};
            for (const g in this.stateChanges) {
              this.state[g] = this.state[g] || {};
              const y = {};
              for (const x in this.stateChanges[g]) this.state[g][x] || (this.state[g][x] = {}), a.e(this.state[g][x], this.stateChanges[g][x]), y[x] = this.state[g][x];
              p[g] = y;
            }
            for (const g in this.deletedStates) {
              this.state[g] = this.state[g] || {};
              const y = {};
              if (this.deletedStates[g] === null) for (const x in this.state[g]) y[x] = {}, this.state[g][x] = {};
              else for (const x in this.deletedStates[g]) {
                if (this.deletedStates[g][x] === null) this.state[g][x] = {};
                else for (const E of Object.keys(this.deletedStates[g][x])) delete this.state[g][x][E];
                y[x] = this.state[g][x];
              }
              p[g] = p[g] || {}, a.e(p[g], y);
            }
            if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(p).length !== 0) for (const g in r) r[g].setFeatureState(p, h);
          }
        }
        const W = 89.25;
        function q(m, r) {
          const h = a.ah(r.lat, -a.ai, a.ai);
          return new a.P(a.V(r.lng) * m, a.U(h) * m);
        }
        function ae(m, r) {
          return new a.a1(r.x / m, r.y / m).toLngLat();
        }
        function pe(m) {
          return m.cameraToCenterDistance * Math.min(0.85 * Math.tan(a.ae(90 - m.pitch)), Math.tan(a.ae(W - m.pitch)));
        }
        function ge(m, r) {
          const h = m.canonical, p = r / a.af(h.z), g = h.x + Math.pow(2, h.z) * m.wrap, y = a.ag(new Float64Array(16));
          return a.M(y, y, [g * p, h.y * p, 0]), a.N(y, y, [p / a.$, p / a.$, 1]), y;
        }
        function Pe(m, r, h, p, g) {
          const y = a.a1.fromLngLat(m, r), x = g * a.aj(1, m.lat), E = x * Math.cos(a.ae(h)), C = Math.sqrt(x * x - E * E), R = C * Math.sin(a.ae(-p)), B = C * Math.cos(a.ae(-p));
          return new a.a1(y.x + R, y.y + B, y.z + E);
        }
        function ye(m, r, h) {
          const p = r.intersectsFrustum(m);
          if (!h || p === 0) return p;
          const g = r.intersectsPlane(h);
          return g === 0 ? 0 : p === 2 && g === 2 ? 2 : 1;
        }
        function Ne(m, r, h) {
          let p = 0;
          const g = (h - r) / 10;
          for (let y = 0; y < 10; y++) p += g * Math.pow(Math.cos(r + (y + 0.5) / 10 * (h - r)), m);
          return p;
        }
        function He(m, r) {
          return function(h, p, g, y, x) {
            const E = 2 * ((m - 1) / a.ak(Math.cos(a.ae(W - x)) / Math.cos(a.ae(W))) - 1), C = Math.acos(g / y), R = 2 * Ne(E - 1, 0, a.ae(x / 2)), B = Math.min(a.ae(W), C + a.ae(x / 2)), k = Ne(E - 1, Math.min(B, C - a.ae(x / 2)), B), O = Math.atan(p / g), z = Math.hypot(p, g);
            let H = h;
            return H += a.ak(y / z / Math.max(0.5, Math.cos(a.ae(x / 2)))), H += E * a.ak(Math.cos(O)) / 2, H -= a.ak(Math.max(1, k / R / r)) / 2, H;
          };
        }
        const ze = He(9.314, 3);
        function lt(m, r) {
          const h = (r.roundZoom ? Math.round : Math.floor)(m.zoom + a.ak(m.tileSize / r.tileSize));
          return Math.max(0, h);
        }
        function ve(m, r) {
          const h = m.getCameraFrustum(), p = m.getClippingPlane(), g = m.screenPointToMercatorCoordinate(m.getCameraPoint()), y = a.a1.fromLngLat(m.center, m.elevation);
          g.z = y.z + Math.cos(m.pitchInRadians) * m.cameraToCenterDistance / m.worldSize;
          const x = m.getCoveringTilesDetailsProvider(), E = x.allowVariableZoom(m, r), C = lt(m, r), R = r.minzoom || 0, B = r.maxzoom !== void 0 ? r.maxzoom : m.maxZoom, k = Math.min(Math.max(0, C), B), O = Math.pow(2, k), z = [O * g.x, O * g.y, 0], H = [O * y.x, O * y.y, 0], Y = Math.hypot(y.x - g.x, y.y - g.y), K = Math.abs(y.z - g.z), J = Math.hypot(Y, K), ie = (he) => ({ zoom: 0, x: 0, y: 0, wrap: he, fullyVisible: !1 }), le = [], se = [];
          if (m.renderWorldCopies && x.allowWorldCopies()) for (let he = 1; he <= 3; he++) le.push(ie(-he)), le.push(ie(he));
          for (le.push(ie(0)); le.length > 0; ) {
            const he = le.pop(), fe = he.x, oe = he.y;
            let be = he.fullyVisible;
            const Fe = { x: fe, y: oe, z: he.zoom }, Ie = x.getTileBoundingVolume(Fe, he.wrap, m.elevation, r);
            if (!be) {
              const qe = ye(h, Ie, p);
              if (qe === 0) continue;
              be = qe === 2;
            }
            const Me = x.distanceToTile2d(g.x, g.y, Fe, Ie);
            let Oe = C;
            E && (Oe = (r.calculateTileZoom || ze)(m.zoom + a.ak(m.tileSize / r.tileSize), Me, K, J, m.fov)), Oe = (r.roundZoom ? Math.round : Math.floor)(Oe), Oe = Math.max(0, Oe);
            const We = Math.min(Oe, B);
            if (he.wrap = x.getWrap(y, Fe, he.wrap), he.zoom >= We) {
              if (he.zoom < R) continue;
              const qe = k - he.zoom, Ve = z[0] - 0.5 - (fe << qe), ht = z[1] - 0.5 - (oe << qe), Bt = r.reparseOverscaled ? Math.max(he.zoom, Oe) : he.zoom;
              se.push({ tileID: new a.Z(he.zoom === B ? Bt : he.zoom, he.wrap, he.zoom, fe, oe), distanceSq: a.al([H[0] - 0.5 - fe, H[1] - 0.5 - oe]), tileDistanceToCamera: Math.sqrt(Ve * Ve + ht * ht) });
            } else for (let qe = 0; qe < 4; qe++) le.push({ zoom: he.zoom + 1, x: (fe << 1) + qe % 2, y: (oe << 1) + (qe >> 1), wrap: he.wrap, fullyVisible: be });
          }
          return se.sort(((he, fe) => he.distanceSq - fe.distanceSq)).map(((he) => he.tileID));
        }
        const wt = a.a2.fromPoints([new a.P(0, 0), new a.P(a.$, a.$)]);
        class Ot extends a.E {
          constructor(r, h, p) {
            super(), this.id = r, this.dispatcher = p, this.on("data", ((g) => this._dataHandler(g))), this.on("dataloading", (() => {
              this._sourceErrored = !1;
            })), this.on("error", (() => {
              this._sourceErrored = this._source.loaded();
            })), this._source = ((g, y, x, E) => {
              const C = new (Ys(y.type))(g, y, x, E);
              if (C.id !== g) throw new Error(`Expected Source id to be ${g} instead of ${C.id}`);
              return C;
            })(r, h, p, this), this._tiles = {}, this._cache = new _e(0, ((g) => this._unloadTile(g))), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new $(), this._didEmitContent = !1, this._updated = !1;
          }
          onAdd(r) {
            this.map = r, this._maxTileCacheSize = r ? r._maxTileCacheSize : null, this._maxTileCacheZoomLevels = r ? r._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(r);
          }
          onRemove(r) {
            this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(r);
          }
          loaded() {
            if (this._sourceErrored) return !0;
            if (!this._sourceLoaded || !this._source.loaded()) return !1;
            if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain)) return !0;
            if (!this._updated) return !1;
            for (const r in this._tiles) {
              const h = this._tiles[r];
              if (h.state !== "loaded" && h.state !== "errored") return !1;
            }
            return !0;
          }
          getSource() {
            return this._source;
          }
          pause() {
            this._paused = !0;
          }
          resume() {
            if (!this._paused) return;
            const r = this._shouldReloadOnResume;
            this._paused = !1, this._shouldReloadOnResume = !1, r && this.reload(), this.transform && this.update(this.transform, this.terrain);
          }
          _loadTile(r, h, p) {
            return a._(this, void 0, void 0, (function* () {
              try {
                yield this._source.loadTile(r), this._tileLoaded(r, h, p);
              } catch (g) {
                r.state = "errored", g.status !== 404 ? this._source.fire(new a.k(g, { tile: r })) : this.update(this.transform, this.terrain);
              }
            }));
          }
          _unloadTile(r) {
            this._source.unloadTile && this._source.unloadTile(r);
          }
          _abortTile(r) {
            this._source.abortTile && this._source.abortTile(r), this._source.fire(new a.l("dataabort", { tile: r, coord: r.tileID, dataType: "source" }));
          }
          serialize() {
            return this._source.serialize();
          }
          prepare(r) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
            for (const h in this._tiles) {
              const p = this._tiles[h];
              p.upload(r), p.prepare(this.map.style.imageManager);
            }
          }
          getIds() {
            return Object.values(this._tiles).map(((r) => r.tileID)).sort(ft).map(((r) => r.key));
          }
          getRenderableIds(r) {
            const h = [];
            for (const p in this._tiles) this._isIdRenderable(p, r) && h.push(this._tiles[p]);
            return r ? h.sort(((p, g) => {
              const y = p.tileID, x = g.tileID, E = new a.P(y.canonical.x, y.canonical.y)._rotate(-this.transform.bearingInRadians), C = new a.P(x.canonical.x, x.canonical.y)._rotate(-this.transform.bearingInRadians);
              return y.overscaledZ - x.overscaledZ || C.y - E.y || C.x - E.x;
            })).map(((p) => p.tileID.key)) : h.map(((p) => p.tileID)).sort(ft).map(((p) => p.key));
          }
          hasRenderableParent(r) {
            const h = this.findLoadedParent(r, 0);
            return !!h && this._isIdRenderable(h.tileID.key);
          }
          _isIdRenderable(r, h) {
            return this._tiles[r] && this._tiles[r].hasData() && !this._coveredTiles[r] && (h || !this._tiles[r].holdingForFade());
          }
          reload(r) {
            if (this._paused) this._shouldReloadOnResume = !0;
            else {
              this._cache.reset();
              for (const h in this._tiles) r ? this._reloadTile(h, "expired") : this._tiles[h].state !== "errored" && this._reloadTile(h, "reloading");
            }
          }
          _reloadTile(r, h) {
            return a._(this, void 0, void 0, (function* () {
              const p = this._tiles[r];
              p && (p.state !== "loading" && (p.state = h), yield this._loadTile(p, r, h));
            }));
          }
          _tileLoaded(r, h, p) {
            r.timeAdded = N.now(), p === "expired" && (r.refreshedUponExpiration = !0), this._setTileReloadTimer(h, r), this.getSource().type === "raster-dem" && r.dem && this._backfillDEM(r), this._state.initializeTileState(r, this.map ? this.map.painter : null), r.aborted || this._source.fire(new a.l("data", { dataType: "source", tile: r, coord: r.tileID }));
          }
          _backfillDEM(r) {
            const h = this.getRenderableIds();
            for (let g = 0; g < h.length; g++) {
              const y = h[g];
              if (r.neighboringTiles && r.neighboringTiles[y]) {
                const x = this.getTileByID(y);
                p(r, x), p(x, r);
              }
            }
            function p(g, y) {
              g.needsHillshadePrepare = !0, g.needsTerrainPrepare = !0;
              let x = y.tileID.canonical.x - g.tileID.canonical.x;
              const E = y.tileID.canonical.y - g.tileID.canonical.y, C = Math.pow(2, g.tileID.canonical.z), R = y.tileID.key;
              x === 0 && E === 0 || Math.abs(E) > 1 || (Math.abs(x) > 1 && (Math.abs(x + C) === 1 ? x += C : Math.abs(x - C) === 1 && (x -= C)), y.dem && g.dem && (g.dem.backfillBorder(y.dem, x, E), g.neighboringTiles && g.neighboringTiles[R] && (g.neighboringTiles[R].backfilled = !0)));
            }
          }
          getTile(r) {
            return this.getTileByID(r.key);
          }
          getTileByID(r) {
            return this._tiles[r];
          }
          _retainLoadedChildren(r, h, p, g) {
            for (const y in this._tiles) {
              let x = this._tiles[y];
              if (g[y] || !x.hasData() || x.tileID.overscaledZ <= h || x.tileID.overscaledZ > p) continue;
              let E = x.tileID;
              for (; x && x.tileID.overscaledZ > h + 1; ) {
                const R = x.tileID.scaledTo(x.tileID.overscaledZ - 1);
                x = this._tiles[R.key], x && x.hasData() && (E = R);
              }
              let C = E;
              for (; C.overscaledZ > h; ) if (C = C.scaledTo(C.overscaledZ - 1), r[C.key] || r[C.canonical.key]) {
                g[E.key] = E;
                break;
              }
            }
          }
          findLoadedParent(r, h) {
            if (r.key in this._loadedParentTiles) {
              const p = this._loadedParentTiles[r.key];
              return p && p.tileID.overscaledZ >= h ? p : null;
            }
            for (let p = r.overscaledZ - 1; p >= h; p--) {
              const g = r.scaledTo(p), y = this._getLoadedTile(g);
              if (y) return y;
            }
          }
          findLoadedSibling(r) {
            return this._getLoadedTile(r);
          }
          _getLoadedTile(r) {
            const h = this._tiles[r.key];
            return h && h.hasData() ? h : this._cache.getByKey(r.wrapped().key);
          }
          updateCacheSize(r) {
            const h = Math.ceil(r.width / this._source.tileSize) + 1, p = Math.ceil(r.height / this._source.tileSize) + 1, g = Math.floor(h * p * (this._maxTileCacheZoomLevels === null ? a.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), y = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, g) : g;
            this._cache.setMaxSize(y);
          }
          handleWrapJump(r) {
            const h = Math.round((r - (this._prevLng === void 0 ? r : this._prevLng)) / 360);
            if (this._prevLng = r, h) {
              const p = {};
              for (const g in this._tiles) {
                const y = this._tiles[g];
                y.tileID = y.tileID.unwrapTo(y.tileID.wrap + h), p[y.tileID.key] = y;
              }
              this._tiles = p;
              for (const g in this._timers) clearTimeout(this._timers[g]), delete this._timers[g];
              for (const g in this._tiles) this._setTileReloadTimer(g, this._tiles[g]);
            }
          }
          _updateCoveredAndRetainedTiles(r, h, p, g, y, x) {
            const E = {}, C = {}, R = Object.keys(r), B = N.now();
            for (const k of R) {
              const O = r[k], z = this._tiles[k];
              if (!z || z.fadeEndTime !== 0 && z.fadeEndTime <= B) continue;
              const H = this.findLoadedParent(O, h), Y = this.findLoadedSibling(O), K = H || Y || null;
              K && (this._addTile(K.tileID), E[K.tileID.key] = K.tileID), C[k] = O;
            }
            this._retainLoadedChildren(C, g, p, r);
            for (const k in E) r[k] || (this._coveredTiles[k] = !0, r[k] = E[k]);
            if (x) {
              const k = {}, O = {};
              for (const z of y) this._tiles[z.key].hasData() ? k[z.key] = z : O[z.key] = z;
              for (const z in O) {
                const H = O[z].children(this._source.maxzoom);
                this._tiles[H[0].key] && this._tiles[H[1].key] && this._tiles[H[2].key] && this._tiles[H[3].key] && (k[H[0].key] = r[H[0].key] = H[0], k[H[1].key] = r[H[1].key] = H[1], k[H[2].key] = r[H[2].key] = H[2], k[H[3].key] = r[H[3].key] = H[3], delete O[z]);
              }
              for (const z in O) {
                const H = O[z], Y = this.findLoadedParent(H, this._source.minzoom), K = this.findLoadedSibling(H), J = Y || K || null;
                if (J) {
                  k[J.tileID.key] = r[J.tileID.key] = J.tileID;
                  for (const ie in k) k[ie].isChildOf(J.tileID) && delete k[ie];
                }
              }
              for (const z in this._tiles) k[z] || (this._coveredTiles[z] = !0);
            }
          }
          update(r, h) {
            if (!this._sourceLoaded || this._paused) return;
            let p;
            this.transform = r, this.terrain = h, this.updateCacheSize(r), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? p = r.getVisibleUnwrappedCoordinates(this._source.tileID).map(((B) => new a.Z(B.canonical.z, B.wrap, B.canonical.z, B.canonical.x, B.canonical.y))) : (p = ve(r, { tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: h, calculateTileZoom: this._source.calculateTileZoom }), this._source.hasTile && (p = p.filter(((B) => this._source.hasTile(B))))) : p = [];
            const g = lt(r, this._source), y = Math.max(g - Ot.maxOverzooming, this._source.minzoom), x = Math.max(g + Ot.maxUnderzooming, this._source.minzoom);
            if (this.usedForTerrain) {
              const B = {};
              for (const k of p) if (k.canonical.z > this._source.minzoom) {
                const O = k.scaledTo(k.canonical.z - 1);
                B[O.key] = O;
                const z = k.scaledTo(Math.max(this._source.minzoom, Math.min(k.canonical.z, 5)));
                B[z.key] = z;
              }
              p = p.concat(Object.values(B));
            }
            const E = p.length === 0 && !this._updated && this._didEmitContent;
            this._updated = !0, E && this.fire(new a.l("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
            const C = this._updateRetainedTiles(p, g);
            St(this._source.type) && this._updateCoveredAndRetainedTiles(C, y, x, g, p, h);
            for (const B in C) this._tiles[B].clearFadeHold();
            const R = a.am(this._tiles, C);
            for (const B of R) {
              const k = this._tiles[B];
              k.hasSymbolBuckets && !k.holdingForFade() ? k.setHoldDuration(this.map._fadeDuration) : k.hasSymbolBuckets && !k.symbolFadeFinished() || this._removeTile(B);
            }
            this._updateLoadedParentTileCache(), this._updateLoadedSiblingTileCache();
          }
          releaseSymbolFadeTiles() {
            for (const r in this._tiles) this._tiles[r].holdingForFade() && this._removeTile(r);
          }
          _updateRetainedTiles(r, h) {
            var p;
            const g = {}, y = {}, x = Math.max(h - Ot.maxOverzooming, this._source.minzoom), E = Math.max(h + Ot.maxUnderzooming, this._source.minzoom), C = {};
            for (const R of r) {
              const B = this._addTile(R);
              g[R.key] = R, B.hasData() || h < this._source.maxzoom && (C[R.key] = R);
            }
            this._retainLoadedChildren(C, h, E, g);
            for (const R of r) {
              let B = this._tiles[R.key];
              if (B.hasData()) continue;
              if (h + 1 > this._source.maxzoom) {
                const O = R.children(this._source.maxzoom)[0], z = this.getTile(O);
                if (z && z.hasData()) {
                  g[O.key] = O;
                  continue;
                }
              } else {
                const O = R.children(this._source.maxzoom);
                if (g[O[0].key] && g[O[1].key] && g[O[2].key] && g[O[3].key]) continue;
              }
              let k = B.wasRequested();
              for (let O = R.overscaledZ - 1; O >= x; --O) {
                const z = R.scaledTo(O);
                if (y[z.key]) break;
                if (y[z.key] = !0, B = this.getTile(z), !B && k && (B = this._addTile(z)), B) {
                  const H = B.hasData();
                  if ((H || !(!((p = this.map) === null || p === void 0) && p.cancelPendingTileRequestsWhileZooming) || k) && (g[z.key] = z), k = B.wasRequested(), H) break;
                }
              }
            }
            return g;
          }
          _updateLoadedParentTileCache() {
            this._loadedParentTiles = {};
            for (const r in this._tiles) {
              const h = [];
              let p, g = this._tiles[r].tileID;
              for (; g.overscaledZ > 0; ) {
                if (g.key in this._loadedParentTiles) {
                  p = this._loadedParentTiles[g.key];
                  break;
                }
                h.push(g.key);
                const y = g.scaledTo(g.overscaledZ - 1);
                if (p = this._getLoadedTile(y), p) break;
                g = y;
              }
              for (const y of h) this._loadedParentTiles[y] = p;
            }
          }
          _updateLoadedSiblingTileCache() {
            this._loadedSiblingTiles = {};
            for (const r in this._tiles) {
              const h = this._tiles[r].tileID, p = this._getLoadedTile(h);
              this._loadedSiblingTiles[h.key] = p;
            }
          }
          _addTile(r) {
            let h = this._tiles[r.key];
            if (h) return h;
            h = this._cache.getAndRemove(r), h && (this._setTileReloadTimer(r.key, h), h.tileID = r, this._state.initializeTileState(h, this.map ? this.map.painter : null), this._cacheTimers[r.key] && (clearTimeout(this._cacheTimers[r.key]), delete this._cacheTimers[r.key], this._setTileReloadTimer(r.key, h)));
            const p = h;
            return h || (h = new gn(r, this._source.tileSize * r.overscaleFactor()), this._loadTile(h, r.key, h.state)), h.uses++, this._tiles[r.key] = h, p || this._source.fire(new a.l("dataloading", { tile: h, coord: h.tileID, dataType: "source" })), h;
          }
          _setTileReloadTimer(r, h) {
            r in this._timers && (clearTimeout(this._timers[r]), delete this._timers[r]);
            const p = h.getExpiryTimeout();
            p && (this._timers[r] = setTimeout((() => {
              this._reloadTile(r, "expired"), delete this._timers[r];
            }), p));
          }
          refreshTiles(r) {
            for (const h in this._tiles) (this._isIdRenderable(h) || this._tiles[h].state == "errored") && r.some(((p) => p.equals(this._tiles[h].tileID.canonical))) && this._reloadTile(h, "expired");
          }
          _removeTile(r) {
            const h = this._tiles[r];
            h && (h.uses--, delete this._tiles[r], this._timers[r] && (clearTimeout(this._timers[r]), delete this._timers[r]), h.uses > 0 || (h.hasData() && h.state !== "reloading" ? this._cache.add(h.tileID, h, h.getExpiryTimeout()) : (h.aborted = !0, this._abortTile(h), this._unloadTile(h))));
          }
          _dataHandler(r) {
            const h = r.sourceDataType;
            r.dataType === "source" && h === "metadata" && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && r.dataType === "source" && h === "content" && (this.reload(r.sourceDataChanged), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = !0);
          }
          clearTiles() {
            this._shouldReloadOnResume = !1, this._paused = !1;
            for (const r in this._tiles) this._removeTile(r);
            this._cache.reset();
          }
          tilesIn(r, h, p) {
            const g = [], y = this.transform;
            if (!y) return g;
            const x = y.getCoveringTilesDetailsProvider().allowWorldCopies(), E = p ? y.getCameraQueryGeometry(r) : r, C = (z) => y.screenPointToMercatorCoordinate(z, this.terrain), R = this.transformBbox(r, C, !x), B = this.transformBbox(E, C, !x), k = this.getIds(), O = a.a2.fromPoints(B);
            for (let z = 0; z < k.length; z++) {
              const H = this._tiles[k[z]];
              if (H.holdingForFade()) continue;
              const Y = x ? [H.tileID] : [H.tileID.unwrapTo(-1), H.tileID.unwrapTo(0)], K = Math.pow(2, y.zoom - H.tileID.overscaledZ), J = h * H.queryPadding * a.$ / H.tileSize / K;
              for (const ie of Y) {
                const le = O.map(((se) => ie.getTilePoint(new a.a1(se.x, se.y))));
                if (le.expandBy(J), le.intersects(wt)) {
                  const se = R.map(((fe) => ie.getTilePoint(fe))), he = B.map(((fe) => ie.getTilePoint(fe)));
                  g.push({ tile: H, tileID: x ? ie : ie.unwrapTo(0), queryGeometry: se, cameraQueryGeometry: he, scale: K });
                }
              }
            }
            return g;
          }
          transformBbox(r, h, p) {
            let g = r.map(h);
            if (p) {
              const y = a.a2.fromPoints(r);
              y.shrinkBy(1e-3 * Math.min(y.width(), y.height()));
              const x = y.map(h);
              a.a2.fromPoints(g).covers(x) || (g = g.map(((E) => E.x > 0.5 ? new a.a1(E.x - 1, E.y, E.z) : E)));
            }
            return g;
          }
          getVisibleCoordinates(r) {
            const h = this.getRenderableIds(r).map(((p) => this._tiles[p].tileID));
            return this.transform && this.transform.populateCache(h), h;
          }
          hasTransition() {
            if (this._source.hasTransition()) return !0;
            if (St(this._source.type)) {
              const r = N.now();
              for (const h in this._tiles) if (this._tiles[h].fadeEndTime >= r) return !0;
            }
            return !1;
          }
          setFeatureState(r, h, p) {
            this._state.updateState(r = r || "_geojsonTileLayer", h, p);
          }
          removeFeatureState(r, h, p) {
            this._state.removeFeatureState(r = r || "_geojsonTileLayer", h, p);
          }
          getFeatureState(r, h) {
            return this._state.getState(r = r || "_geojsonTileLayer", h);
          }
          setDependencies(r, h, p) {
            const g = this._tiles[r];
            g && g.setDependencies(h, p);
          }
          reloadTilesForDependencies(r, h) {
            for (const p in this._tiles) this._tiles[p].hasDependency(r, h) && this._reloadTile(p, "reloading");
            this._cache.filter(((p) => !p.hasDependency(r, h)));
          }
        }
        function ft(m, r) {
          const h = Math.abs(2 * m.wrap) - +(m.wrap < 0), p = Math.abs(2 * r.wrap) - +(r.wrap < 0);
          return m.overscaledZ - r.overscaledZ || p - h || r.canonical.y - m.canonical.y || r.canonical.x - m.canonical.x;
        }
        function St(m) {
          return m === "raster" || m === "image" || m === "video";
        }
        Ot.maxOverzooming = 10, Ot.maxUnderzooming = 3;
        class Kt {
          constructor(r, h) {
            this.reset(r, h);
          }
          reset(r, h) {
            this.points = r || [], this._distances = [0];
            for (let p = 1; p < this.points.length; p++) this._distances[p] = this._distances[p - 1] + this.points[p].dist(this.points[p - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(h || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
          }
          lerp(r) {
            if (this.points.length === 1) return this.points[0];
            r = a.ah(r, 0, 1);
            let h = 1, p = this._distances[h];
            const g = r * this.paddedLength + this.padding;
            for (; p < g && h < this._distances.length; ) p = this._distances[++h];
            const y = h - 1, x = this._distances[y], E = p - x, C = E > 0 ? (g - x) / E : 0;
            return this.points[y].mult(1 - C).add(this.points[h].mult(C));
          }
        }
        function Li(m, r) {
          let h = !0;
          return m === "always" || m !== "never" && r !== "never" || (h = !1), h;
        }
        class Ui {
          constructor(r, h, p) {
            const g = this.boxCells = [], y = this.circleCells = [];
            this.xCellCount = Math.ceil(r / p), this.yCellCount = Math.ceil(h / p);
            for (let x = 0; x < this.xCellCount * this.yCellCount; x++) g.push([]), y.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = r, this.height = h, this.xScale = this.xCellCount / r, this.yScale = this.yCellCount / h, this.boxUid = 0, this.circleUid = 0;
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length;
          }
          insert(r, h, p, g, y) {
            this._forEachCell(h, p, g, y, this._insertBoxCell, this.boxUid++), this.boxKeys.push(r), this.bboxes.push(h), this.bboxes.push(p), this.bboxes.push(g), this.bboxes.push(y);
          }
          insertCircle(r, h, p, g) {
            this._forEachCell(h - g, p - g, h + g, p + g, this._insertCircleCell, this.circleUid++), this.circleKeys.push(r), this.circles.push(h), this.circles.push(p), this.circles.push(g);
          }
          _insertBoxCell(r, h, p, g, y, x) {
            this.boxCells[y].push(x);
          }
          _insertCircleCell(r, h, p, g, y, x) {
            this.circleCells[y].push(x);
          }
          _query(r, h, p, g, y, x, E) {
            if (p < 0 || r > this.width || g < 0 || h > this.height) return [];
            const C = [];
            if (r <= 0 && h <= 0 && this.width <= p && this.height <= g) {
              if (y) return [{ key: null, x1: r, y1: h, x2: p, y2: g }];
              for (let R = 0; R < this.boxKeys.length; R++) C.push({ key: this.boxKeys[R], x1: this.bboxes[4 * R], y1: this.bboxes[4 * R + 1], x2: this.bboxes[4 * R + 2], y2: this.bboxes[4 * R + 3] });
              for (let R = 0; R < this.circleKeys.length; R++) {
                const B = this.circles[3 * R], k = this.circles[3 * R + 1], O = this.circles[3 * R + 2];
                C.push({ key: this.circleKeys[R], x1: B - O, y1: k - O, x2: B + O, y2: k + O });
              }
            } else this._forEachCell(r, h, p, g, this._queryCell, C, { hitTest: y, overlapMode: x, seenUids: { box: {}, circle: {} } }, E);
            return C;
          }
          query(r, h, p, g) {
            return this._query(r, h, p, g, !1, null);
          }
          hitTest(r, h, p, g, y, x) {
            return this._query(r, h, p, g, !0, y, x).length > 0;
          }
          hitTestCircle(r, h, p, g, y) {
            const x = r - p, E = r + p, C = h - p, R = h + p;
            if (E < 0 || x > this.width || R < 0 || C > this.height) return !1;
            const B = [];
            return this._forEachCell(x, C, E, R, this._queryCellCircle, B, { hitTest: !0, overlapMode: g, circle: { x: r, y: h, radius: p }, seenUids: { box: {}, circle: {} } }, y), B.length > 0;
          }
          _queryCell(r, h, p, g, y, x, E, C) {
            const { seenUids: R, hitTest: B, overlapMode: k } = E, O = this.boxCells[y];
            if (O !== null) {
              const H = this.bboxes;
              for (const Y of O) if (!R.box[Y]) {
                R.box[Y] = !0;
                const K = 4 * Y, J = this.boxKeys[Y];
                if (r <= H[K + 2] && h <= H[K + 3] && p >= H[K + 0] && g >= H[K + 1] && (!C || C(J)) && (!B || !Li(k, J.overlapMode)) && (x.push({ key: J, x1: H[K], y1: H[K + 1], x2: H[K + 2], y2: H[K + 3] }), B)) return !0;
              }
            }
            const z = this.circleCells[y];
            if (z !== null) {
              const H = this.circles;
              for (const Y of z) if (!R.circle[Y]) {
                R.circle[Y] = !0;
                const K = 3 * Y, J = this.circleKeys[Y];
                if (this._circleAndRectCollide(H[K], H[K + 1], H[K + 2], r, h, p, g) && (!C || C(J)) && (!B || !Li(k, J.overlapMode))) {
                  const ie = H[K], le = H[K + 1], se = H[K + 2];
                  if (x.push({ key: J, x1: ie - se, y1: le - se, x2: ie + se, y2: le + se }), B) return !0;
                }
              }
            }
            return !1;
          }
          _queryCellCircle(r, h, p, g, y, x, E, C) {
            const { circle: R, seenUids: B, overlapMode: k } = E, O = this.boxCells[y];
            if (O !== null) {
              const H = this.bboxes;
              for (const Y of O) if (!B.box[Y]) {
                B.box[Y] = !0;
                const K = 4 * Y, J = this.boxKeys[Y];
                if (this._circleAndRectCollide(R.x, R.y, R.radius, H[K + 0], H[K + 1], H[K + 2], H[K + 3]) && (!C || C(J)) && !Li(k, J.overlapMode)) return x.push(!0), !0;
              }
            }
            const z = this.circleCells[y];
            if (z !== null) {
              const H = this.circles;
              for (const Y of z) if (!B.circle[Y]) {
                B.circle[Y] = !0;
                const K = 3 * Y, J = this.circleKeys[Y];
                if (this._circlesCollide(H[K], H[K + 1], H[K + 2], R.x, R.y, R.radius) && (!C || C(J)) && !Li(k, J.overlapMode)) return x.push(!0), !0;
              }
            }
          }
          _forEachCell(r, h, p, g, y, x, E, C) {
            const R = this._convertToXCellCoord(r), B = this._convertToYCellCoord(h), k = this._convertToXCellCoord(p), O = this._convertToYCellCoord(g);
            for (let z = R; z <= k; z++) for (let H = B; H <= O; H++) if (y.call(this, r, h, p, g, this.xCellCount * H + z, x, E, C)) return;
          }
          _convertToXCellCoord(r) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(r * this.xScale)));
          }
          _convertToYCellCoord(r) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(r * this.yScale)));
          }
          _circlesCollide(r, h, p, g, y, x) {
            const E = g - r, C = y - h, R = p + x;
            return R * R > E * E + C * C;
          }
          _circleAndRectCollide(r, h, p, g, y, x, E) {
            const C = (x - g) / 2, R = Math.abs(r - (g + C));
            if (R > C + p) return !1;
            const B = (E - y) / 2, k = Math.abs(h - (y + B));
            if (k > B + p) return !1;
            if (R <= C || k <= B) return !0;
            const O = R - C, z = k - B;
            return O * O + z * z <= p * p;
          }
        }
        function Ti(m, r, h) {
          const p = a.L();
          if (!m) {
            const { vecSouth: k, vecEast: O } = Nt(r), z = S();
            z[0] = O[0], z[1] = O[1], z[2] = k[0], z[3] = k[1], g = z, (B = (x = (y = z)[0]) * (R = y[3]) - (C = y[2]) * (E = y[1])) && (g[0] = R * (B = 1 / B), g[1] = -E * B, g[2] = -C * B, g[3] = x * B), p[0] = z[0], p[1] = z[1], p[4] = z[2], p[5] = z[3];
          }
          var g, y, x, E, C, R, B;
          return a.N(p, p, [1 / h, 1 / h, 1]), p;
        }
        function Pt(m, r, h, p) {
          if (m) {
            const g = a.L();
            if (!r) {
              const { vecSouth: y, vecEast: x } = Nt(h);
              g[0] = x[0], g[1] = x[1], g[4] = y[0], g[5] = y[1];
            }
            return a.N(g, g, [p, p, 1]), g;
          }
          return h.pixelsToClipSpaceMatrix;
        }
        function Nt(m) {
          const r = Math.cos(m.rollInRadians), h = Math.sin(m.rollInRadians), p = Math.cos(m.pitchInRadians), g = Math.cos(m.bearingInRadians), y = Math.sin(m.bearingInRadians), x = a.ar();
          x[0] = -g * p * h - y * r, x[1] = -y * p * h + g * r;
          const E = a.as(x);
          E < 1e-9 ? a.at(x) : a.au(x, x, 1 / E);
          const C = a.ar();
          C[0] = g * p * r - y * h, C[1] = y * p * r + g * h;
          const R = a.as(C);
          return R < 1e-9 ? a.at(C) : a.au(C, C, 1 / R), { vecEast: C, vecSouth: x };
        }
        function Pi(m, r, h, p) {
          let g;
          p ? (g = [m, r, p(m, r), 1], a.aw(g, g, h)) : (g = [m, r, 0, 1], Vn(g, g, h));
          const y = g[3];
          return { point: new a.P(g[0] / y, g[1] / y), signedDistanceFromCamera: y, isOccluded: !1 };
        }
        function Ge(m, r) {
          return 0.5 + m / r * 0.5;
        }
        function Hi(m, r) {
          return m.x >= -r[0] && m.x <= r[0] && m.y >= -r[1] && m.y <= r[1];
        }
        function _i(m, r, h, p, g, y, x, E, C, R, B, k, O) {
          const z = h ? m.textSizeData : m.iconSizeData, H = a.an(z, r.transform.zoom), Y = [256 / r.width * 2 + 1, 256 / r.height * 2 + 1], K = h ? m.text.dynamicLayoutVertexArray : m.icon.dynamicLayoutVertexArray;
          K.clear();
          const J = m.lineVertexArray, ie = h ? m.text.placedSymbolArray : m.icon.placedSymbolArray, le = r.transform.width / r.transform.height;
          let se = !1;
          for (let he = 0; he < ie.length; he++) {
            const fe = ie.get(he);
            if (fe.hidden || fe.writingMode === a.ao.vertical && !se) {
              us(fe.numGlyphs, K);
              continue;
            }
            se = !1;
            const oe = new a.P(fe.anchorX, fe.anchorY), be = { getElevation: O, pitchedLabelPlaneMatrix: p, lineVertexArray: J, pitchWithMap: y, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, transform: r.transform, tileAnchorPoint: oe, unwrappedTileID: C, width: R, height: B, translation: k }, Fe = Sr(fe.anchorX, fe.anchorY, be);
            if (!Hi(Fe.point, Y)) {
              us(fe.numGlyphs, K);
              continue;
            }
            const Ie = Ge(r.transform.cameraToCenterDistance, Fe.signedDistanceFromCamera), Me = a.ap(z, H, fe), Oe = y ? Me * r.transform.getPitchedTextCorrection(fe.anchorX, fe.anchorY, C) / Ie : Me * Ie, We = tt({ projectionContext: be, pitchedLabelPlaneMatrixInverse: g, symbol: fe, fontSize: Oe, flip: !1, keepUpright: x, glyphOffsetArray: m.glyphOffsetArray, dynamicLayoutVertexArray: K, aspectRatio: le, rotateToLine: E });
            se = We.useVertical, (We.notEnoughRoom || se || We.needsFlipping && tt({ projectionContext: be, pitchedLabelPlaneMatrixInverse: g, symbol: fe, fontSize: Oe, flip: !0, keepUpright: x, glyphOffsetArray: m.glyphOffsetArray, dynamicLayoutVertexArray: K, aspectRatio: le, rotateToLine: E }).notEnoughRoom) && us(fe.numGlyphs, K);
          }
          h ? m.text.dynamicLayoutVertexBuffer.updateData(K) : m.icon.dynamicLayoutVertexBuffer.updateData(K);
        }
        function Es(m, r, h, p, g, y, x, E) {
          const C = y.glyphStartIndex + y.numGlyphs, R = y.lineStartIndex, B = y.lineStartIndex + y.lineLength, k = r.getoffsetX(y.glyphStartIndex), O = r.getoffsetX(C - 1), z = is(m * k, h, p, g, y.segment, R, B, E, x);
          if (!z) return null;
          const H = is(m * O, h, p, g, y.segment, R, B, E, x);
          return H ? E.projectionCache.anyProjectionOccluded ? null : { first: z, last: H } : null;
        }
        function Un(m, r, h, p) {
          return m === a.ao.horizontal && Math.abs(h.y - r.y) > Math.abs(h.x - r.x) * p ? { useVertical: !0 } : (m === a.ao.vertical ? r.y < h.y : r.x > h.x) ? { needsFlipping: !0 } : null;
        }
        function tt(m) {
          const { projectionContext: r, pitchedLabelPlaneMatrixInverse: h, symbol: p, fontSize: g, flip: y, keepUpright: x, glyphOffsetArray: E, dynamicLayoutVertexArray: C, aspectRatio: R, rotateToLine: B } = m, k = g / 24, O = p.lineOffsetX * k, z = p.lineOffsetY * k;
          let H;
          if (p.numGlyphs > 1) {
            const Y = p.glyphStartIndex + p.numGlyphs, K = p.lineStartIndex, J = p.lineStartIndex + p.lineLength, ie = Es(k, E, O, z, y, p, B, r);
            if (!ie) return { notEnoughRoom: !0 };
            const le = Ss(ie.first.point.x, ie.first.point.y, r, h), se = Ss(ie.last.point.x, ie.last.point.y, r, h);
            if (x && !y) {
              const he = Un(p.writingMode, le, se, R);
              if (he) return he;
            }
            H = [ie.first];
            for (let he = p.glyphStartIndex + 1; he < Y - 1; he++) {
              const fe = is(k * E.getoffsetX(he), O, z, y, p.segment, K, J, r, B);
              if (!fe) return { notEnoughRoom: !0 };
              H.push(fe);
            }
            H.push(ie.last);
          } else {
            if (x && !y) {
              const K = $i(r.tileAnchorPoint.x, r.tileAnchorPoint.y, r).point, J = p.lineStartIndex + p.segment + 1, ie = new a.P(r.lineVertexArray.getx(J), r.lineVertexArray.gety(J)), le = $i(ie.x, ie.y, r), se = le.signedDistanceFromCamera > 0 ? le.point : Dt(r.tileAnchorPoint, ie, K, 1, r), he = Ss(K.x, K.y, r, h), fe = Ss(se.x, se.y, r, h), oe = Un(p.writingMode, he, fe, R);
              if (oe) return oe;
            }
            const Y = is(k * E.getoffsetX(p.glyphStartIndex), O, z, y, p.segment, p.lineStartIndex, p.lineStartIndex + p.lineLength, r, B);
            if (!Y || r.projectionCache.anyProjectionOccluded) return { notEnoughRoom: !0 };
            H = [Y];
          }
          for (const Y of H) a.av(C, Y.point, Y.angle);
          return {};
        }
        function Dt(m, r, h, p, g) {
          const y = m.add(m.sub(r)._unit()), x = $i(y.x, y.y, g).point, E = h.sub(x);
          return h.add(E._mult(p / E.mag()));
        }
        function Ct(m, r, h) {
          const p = r.projectionCache;
          if (p.projections[m]) return p.projections[m];
          const g = new a.P(r.lineVertexArray.getx(m), r.lineVertexArray.gety(m)), y = $i(g.x, g.y, r);
          if (y.signedDistanceFromCamera > 0) return p.projections[m] = y.point, p.anyProjectionOccluded = p.anyProjectionOccluded || y.isOccluded, y.point;
          const x = m - h.direction;
          return Dt(h.distanceFromAnchor === 0 ? r.tileAnchorPoint : new a.P(r.lineVertexArray.getx(x), r.lineVertexArray.gety(x)), g, h.previousVertex, h.absOffsetX - h.distanceFromAnchor + 1, r);
        }
        function $i(m, r, h) {
          const p = m + h.translation[0], g = r + h.translation[1];
          let y;
          return h.pitchWithMap ? (y = Pi(p, g, h.pitchedLabelPlaneMatrix, h.getElevation), y.isOccluded = !1) : (y = h.transform.projectTileCoordinates(p, g, h.unwrappedTileID, h.getElevation), y.point.x = (0.5 * y.point.x + 0.5) * h.width, y.point.y = (0.5 * -y.point.y + 0.5) * h.height), y;
        }
        function Ss(m, r, h, p) {
          if (h.pitchWithMap) {
            const g = [m, r, 0, 1];
            return a.aw(g, g, p), h.transform.projectTileCoordinates(g[0] / g[3], g[1] / g[3], h.unwrappedTileID, h.getElevation).point;
          }
          return { x: m / h.width * 2 - 1, y: 1 - r / h.height * 2 };
        }
        function Sr(m, r, h) {
          return h.transform.projectTileCoordinates(m, r, h.unwrappedTileID, h.getElevation);
        }
        function Tt(m, r, h) {
          return m._unit()._perp()._mult(r * h);
        }
        function en(m, r, h, p, g, y, x, E, C) {
          if (E.projectionCache.offsets[m]) return E.projectionCache.offsets[m];
          const R = h.add(r);
          if (m + C.direction < p || m + C.direction >= g) return E.projectionCache.offsets[m] = R, R;
          const B = Ct(m + C.direction, E, C), k = Tt(B.sub(h), x, C.direction), O = h.add(k), z = B.add(k);
          return E.projectionCache.offsets[m] = a.ax(y, R, O, z) || R, E.projectionCache.offsets[m];
        }
        function is(m, r, h, p, g, y, x, E, C) {
          const R = p ? m - r : m + r;
          let B = R > 0 ? 1 : -1, k = 0;
          p && (B *= -1, k = Math.PI), B < 0 && (k += Math.PI);
          let O, z = B > 0 ? y + g : y + g + 1;
          E.projectionCache.cachedAnchorPoint ? O = E.projectionCache.cachedAnchorPoint : (O = $i(E.tileAnchorPoint.x, E.tileAnchorPoint.y, E).point, E.projectionCache.cachedAnchorPoint = O);
          let H, Y, K = O, J = O, ie = 0, le = 0;
          const se = Math.abs(R), he = [];
          let fe;
          for (; ie + le <= se; ) {
            if (z += B, z < y || z >= x) return null;
            ie += le, J = K, Y = H;
            const Fe = { absOffsetX: se, direction: B, distanceFromAnchor: ie, previousVertex: J };
            if (K = Ct(z, E, Fe), h === 0) he.push(J), fe = K.sub(J);
            else {
              let Ie;
              const Me = K.sub(J);
              Ie = Me.mag() === 0 ? Tt(Ct(z + B, E, Fe).sub(K), h, B) : Tt(Me, h, B), Y || (Y = J.add(Ie)), H = en(z, Ie, K, y, x, Y, h, E, Fe), he.push(Y), fe = H.sub(Y);
            }
            le = fe.mag();
          }
          const oe = fe._mult((se - ie) / le)._add(Y || J), be = k + Math.atan2(K.y - J.y, K.x - J.x);
          return he.push(oe), { point: oe, angle: C ? be : 0, path: he };
        }
        const zn = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
        function us(m, r) {
          for (let h = 0; h < m; h++) {
            const p = r.length;
            r.resize(p + 4), r.float32.set(zn, 3 * p);
          }
        }
        function Vn(m, r, h) {
          const p = r[0], g = r[1];
          return m[0] = h[0] * p + h[4] * g + h[12], m[1] = h[1] * p + h[5] * g + h[13], m[3] = h[3] * p + h[7] * g + h[15], m;
        }
        const li = 100;
        class yr {
          constructor(r, h = new Ui(r.width + 200, r.height + 200, 25), p = new Ui(r.width + 200, r.height + 200, 25)) {
            this.transform = r, this.grid = h, this.ignoredGrid = p, this.pitchFactor = Math.cos(r.pitch * Math.PI / 180) * r.cameraToCenterDistance, this.screenRightBoundary = r.width + li, this.screenBottomBoundary = r.height + li, this.gridRightBoundary = r.width + 200, this.gridBottomBoundary = r.height + 200, this.perspectiveRatioCutoff = 0.6;
          }
          placeCollisionBox(r, h, p, g, y, x, E, C, R, B, k, O) {
            const z = this.projectAndGetPerspectiveRatio(r.anchorPointX + C[0], r.anchorPointY + C[1], y, B, O), H = p * z.perspectiveRatio;
            let Y;
            if (x || E) Y = this._projectCollisionBox(r, H, g, y, x, E, C, z, B, k, O);
            else {
              const fe = z.x + (k ? k.x * H : 0), oe = z.y + (k ? k.y * H : 0);
              Y = { allPointsOccluded: !1, box: [fe + r.x1 * H, oe + r.y1 * H, fe + r.x2 * H, oe + r.y2 * H] };
            }
            const [K, J, ie, le] = Y.box, se = x ? Y.allPointsOccluded : z.isOccluded;
            let he = se;
            return he || (he = z.perspectiveRatio < this.perspectiveRatioCutoff), he || (he = !this.isInsideGrid(K, J, ie, le)), he || h !== "always" && this.grid.hitTest(K, J, ie, le, h, R) ? { box: [K, J, ie, le], placeable: !1, offscreen: !1, occluded: se } : { box: [K, J, ie, le], placeable: !0, offscreen: this.isOffscreen(K, J, ie, le), occluded: se };
          }
          placeCollisionCircles(r, h, p, g, y, x, E, C, R, B, k, O, z, H) {
            const Y = [], K = new a.P(h.anchorX, h.anchorY), J = this.getPerspectiveRatio(K.x, K.y, x, H), ie = (R ? y * this.transform.getPitchedTextCorrection(h.anchorX, h.anchorY, x) / J : y * J) / a.aB, le = { getElevation: H, pitchedLabelPlaneMatrix: E, lineVertexArray: p, pitchWithMap: R, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, transform: this.transform, tileAnchorPoint: K, unwrappedTileID: x, width: this.transform.width, height: this.transform.height, translation: z }, se = Es(ie, g, h.lineOffsetX * ie, h.lineOffsetY * ie, !1, h, !1, le);
            let he = !1, fe = !1, oe = !0;
            if (se) {
              const be = 0.5 * k * J + O, Fe = new a.P(-100, -100), Ie = new a.P(this.screenRightBoundary, this.screenBottomBoundary), Me = new Kt(), Oe = se.first, We = se.last;
              let qe = [];
              for (let Bt = Oe.path.length - 1; Bt >= 1; Bt--) qe.push(Oe.path[Bt]);
              for (let Bt = 1; Bt < We.path.length; Bt++) qe.push(We.path[Bt]);
              const Ve = 2.5 * be;
              if (R) {
                const Bt = this.projectPathToScreenSpace(qe, le);
                qe = Bt.some(((Wt) => Wt.signedDistanceFromCamera <= 0)) ? [] : Bt.map(((Wt) => Wt.point));
              }
              let ht = [];
              if (qe.length > 0) {
                const Bt = qe[0].clone(), Wt = qe[0].clone();
                for (let ti = 1; ti < qe.length; ti++) Bt.x = Math.min(Bt.x, qe[ti].x), Bt.y = Math.min(Bt.y, qe[ti].y), Wt.x = Math.max(Wt.x, qe[ti].x), Wt.y = Math.max(Wt.y, qe[ti].y);
                ht = Bt.x >= Fe.x && Wt.x <= Ie.x && Bt.y >= Fe.y && Wt.y <= Ie.y ? [qe] : Wt.x < Fe.x || Bt.x > Ie.x || Wt.y < Fe.y || Bt.y > Ie.y ? [] : a.ay([qe], Fe.x, Fe.y, Ie.x, Ie.y);
              }
              for (const Bt of ht) {
                Me.reset(Bt, 0.25 * be);
                let Wt = 0;
                Wt = Me.length <= 0.5 * be ? 1 : Math.ceil(Me.paddedLength / Ve) + 1;
                for (let ti = 0; ti < Wt; ti++) {
                  const Yt = ti / Math.max(Wt - 1, 1), vi = Me.lerp(Yt), Si = vi.x + li, Rt = vi.y + li;
                  Y.push(Si, Rt, be, 0);
                  const ii = Si - be, Wi = Rt - be, Qi = Si + be, lr = Rt + be;
                  if (oe = oe && this.isOffscreen(ii, Wi, Qi, lr), fe = fe || this.isInsideGrid(ii, Wi, Qi, lr), r !== "always" && this.grid.hitTestCircle(Si, Rt, be, r, B) && (he = !0, !C)) return { circles: [], offscreen: !1, collisionDetected: he };
                }
              }
            }
            return { circles: !C && he || !fe || J < this.perspectiveRatioCutoff ? [] : Y, offscreen: oe, collisionDetected: he };
          }
          projectPathToScreenSpace(r, h) {
            const p = (function(g, y) {
              const x = a.L();
              return a.aq(x, y.pitchedLabelPlaneMatrix), g.map(((E) => {
                const C = Pi(E.x, E.y, x, y.getElevation), R = y.transform.projectTileCoordinates(C.point.x, C.point.y, y.unwrappedTileID, y.getElevation);
                return R.point.x = (0.5 * R.point.x + 0.5) * y.width, R.point.y = (0.5 * -R.point.y + 0.5) * y.height, R;
              }));
            })(r, h);
            return (function(g) {
              let y = 0, x = 0, E = 0, C = 0;
              for (let R = 0; R < g.length; R++) g[R].isOccluded ? (E = R + 1, C = 0) : (C++, C > x && (x = C, y = E));
              return g.slice(y, y + x);
            })(p);
          }
          queryRenderedSymbols(r) {
            if (r.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
            const h = [], p = new a.a2();
            for (const k of r) {
              const O = new a.P(k.x + li, k.y + li);
              p.extend(O), h.push(O);
            }
            const { minX: g, minY: y, maxX: x, maxY: E } = p, C = this.grid.query(g, y, x, E).concat(this.ignoredGrid.query(g, y, x, E)), R = {}, B = {};
            for (const k of C) {
              const O = k.key;
              if (R[O.bucketInstanceId] === void 0 && (R[O.bucketInstanceId] = {}), R[O.bucketInstanceId][O.featureIndex]) continue;
              const z = [new a.P(k.x1, k.y1), new a.P(k.x2, k.y1), new a.P(k.x2, k.y2), new a.P(k.x1, k.y2)];
              a.az(h, z) && (R[O.bucketInstanceId][O.featureIndex] = !0, B[O.bucketInstanceId] === void 0 && (B[O.bucketInstanceId] = []), B[O.bucketInstanceId].push(O.featureIndex));
            }
            return B;
          }
          insertCollisionBox(r, h, p, g, y, x) {
            (p ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: g, featureIndex: y, collisionGroupID: x, overlapMode: h }, r[0], r[1], r[2], r[3]);
          }
          insertCollisionCircles(r, h, p, g, y, x) {
            const E = p ? this.ignoredGrid : this.grid, C = { bucketInstanceId: g, featureIndex: y, collisionGroupID: x, overlapMode: h };
            for (let R = 0; R < r.length; R += 4) E.insertCircle(C, r[R], r[R + 1], r[R + 2]);
          }
          projectAndGetPerspectiveRatio(r, h, p, g, y) {
            if (y) {
              let x;
              g ? (x = [r, h, g(r, h), 1], a.aw(x, x, y)) : (x = [r, h, 0, 1], Vn(x, x, y));
              const E = x[3];
              return { x: (x[0] / E + 1) / 2 * this.transform.width + li, y: (-x[1] / E + 1) / 2 * this.transform.height + li, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / E * 0.5, isOccluded: !1, signedDistanceFromCamera: E };
            }
            {
              const x = this.transform.projectTileCoordinates(r, h, p, g);
              return { x: (x.point.x + 1) / 2 * this.transform.width + li, y: (1 - x.point.y) / 2 * this.transform.height + li, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / x.signedDistanceFromCamera * 0.5, isOccluded: x.isOccluded, signedDistanceFromCamera: x.signedDistanceFromCamera };
            }
          }
          getPerspectiveRatio(r, h, p, g) {
            const y = this.transform.projectTileCoordinates(r, h, p, g);
            return 0.5 + this.transform.cameraToCenterDistance / y.signedDistanceFromCamera * 0.5;
          }
          isOffscreen(r, h, p, g) {
            return p < li || r >= this.screenRightBoundary || g < li || h > this.screenBottomBoundary;
          }
          isInsideGrid(r, h, p, g) {
            return p >= 0 && r < this.gridRightBoundary && g >= 0 && h < this.gridBottomBoundary;
          }
          getViewportMatrix() {
            const r = a.ag([]);
            return a.M(r, r, [-100, -100, 0]), r;
          }
          _projectCollisionBox(r, h, p, g, y, x, E, C, R, B, k) {
            let O = 1, z = 0, H = 0, Y = 1;
            const K = r.anchorPointX + E[0], J = r.anchorPointY + E[1];
            if (x && !y) {
              const qe = this.projectAndGetPerspectiveRatio(K + 1, J, g, R, k), Ve = qe.x - C.x, ht = Math.atan((qe.y - C.y) / Ve) + (Ve < 0 ? Math.PI : 0), Bt = Math.sin(ht), Wt = Math.cos(ht);
              O = Wt, z = Bt, H = -Bt, Y = Wt;
            } else if (!x && y) {
              const qe = Nt(this.transform);
              O = qe.vecEast[0], z = qe.vecEast[1], H = qe.vecSouth[0], Y = qe.vecSouth[1];
            }
            let ie = C.x, le = C.y, se = h;
            y && (ie = K, le = J, se = Math.pow(2, -(this.transform.zoom - p.overscaledZ)), se *= this.transform.getPitchedTextCorrection(K, J, g), B || (se *= a.ah(0.5 + C.signedDistanceFromCamera / this.transform.cameraToCenterDistance * 0.5, 0, 4))), B && (ie += O * B.x * se + H * B.y * se, le += z * B.x * se + Y * B.y * se);
            const he = r.x1 * se, fe = r.x2 * se, oe = (he + fe) / 2, be = r.y1 * se, Fe = r.y2 * se, Ie = (be + Fe) / 2, Me = [{ offsetX: he, offsetY: be }, { offsetX: oe, offsetY: be }, { offsetX: fe, offsetY: be }, { offsetX: fe, offsetY: Ie }, { offsetX: fe, offsetY: Fe }, { offsetX: oe, offsetY: Fe }, { offsetX: he, offsetY: Fe }, { offsetX: he, offsetY: Ie }];
            let Oe = [];
            for (const { offsetX: qe, offsetY: Ve } of Me) Oe.push(new a.P(ie + O * qe + H * Ve, le + z * qe + Y * Ve));
            let We = !1;
            if (y) {
              const qe = Oe.map(((Ve) => this.projectAndGetPerspectiveRatio(Ve.x, Ve.y, g, R, k)));
              We = qe.some(((Ve) => !Ve.isOccluded)), Oe = qe.map(((Ve) => new a.P(Ve.x, Ve.y)));
            } else We = !0;
            return { box: a.aA(Oe), allPointsOccluded: !We };
          }
        }
        class zi {
          constructor(r, h, p, g) {
            this.opacity = r ? Math.max(0, Math.min(1, r.opacity + (r.placed ? h : -h))) : g && p ? 1 : 0, this.placed = p;
          }
          isHidden() {
            return this.opacity === 0 && !this.placed;
          }
        }
        class zt {
          constructor(r, h, p, g, y) {
            this.text = new zi(r ? r.text : null, h, p, y), this.icon = new zi(r ? r.icon : null, h, g, y);
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden();
          }
        }
        class ds {
          constructor(r, h, p) {
            this.text = r, this.icon = h, this.skipFade = p;
          }
        }
        class Cs {
          constructor(r, h, p, g, y) {
            this.bucketInstanceId = r, this.featureIndex = h, this.sourceLayerIndex = p, this.bucketIndex = g, this.tileID = y;
          }
        }
        class $r {
          constructor(r) {
            this.crossSourceCollisions = r, this.maxGroupID = 0, this.collisionGroups = {};
          }
          get(r) {
            if (this.crossSourceCollisions) return { ID: 0, predicate: null };
            if (!this.collisionGroups[r]) {
              const h = ++this.maxGroupID;
              this.collisionGroups[r] = { ID: h, predicate: (p) => p.collisionGroupID === h };
            }
            return this.collisionGroups[r];
          }
        }
        function nr(m, r, h, p, g) {
          const { horizontalAlign: y, verticalAlign: x } = a.aH(m);
          return new a.P(-(y - 0.5) * r + p[0] * g, -(x - 0.5) * h + p[1] * g);
        }
        class Is {
          constructor(r, h, p, g, y) {
            this.transform = r.clone(), this.terrain = h, this.collisionIndex = new yr(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = p, this.retainedQueryData = {}, this.collisionGroups = new $r(g), this.collisionCircleArrays = {}, this.collisionBoxArrays = /* @__PURE__ */ new Map(), this.prevPlacement = y, y && (y.prevPlacement = void 0), this.placedOrientations = {};
          }
          _getTerrainElevationFunc(r) {
            const h = this.terrain;
            return h ? (p, g) => h.getElevation(r, p, g) : null;
          }
          getBucketParts(r, h, p, g) {
            const y = p.getBucket(h), x = p.latestFeatureIndex;
            if (!y || !x || h.id !== y.layerIds[0]) return;
            const E = p.collisionBoxArray, C = y.layers[0].layout, R = y.layers[0].paint, B = Math.pow(2, this.transform.zoom - p.tileID.overscaledZ), k = p.tileSize / a.$, O = p.tileID.toUnwrapped(), z = C.get("text-rotation-alignment") === "map", H = a.aC(p, 1, this.transform.zoom), Y = a.aD(this.collisionIndex.transform, p, R.get("text-translate"), R.get("text-translate-anchor")), K = a.aD(this.collisionIndex.transform, p, R.get("icon-translate"), R.get("icon-translate-anchor")), J = Ti(z, this.transform, H);
            this.retainedQueryData[y.bucketInstanceId] = new Cs(y.bucketInstanceId, x, y.sourceLayerIndex, y.index, p.tileID);
            const ie = { bucket: y, layout: C, translationText: Y, translationIcon: K, unwrappedTileID: O, pitchedLabelPlaneMatrix: J, scale: B, textPixelRatio: k, holdingForFade: p.holdingForFade(), collisionBoxArray: E, partiallyEvaluatedTextSize: a.an(y.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(y.sourceID) };
            if (g) for (const le of y.sortKeyRanges) {
              const { sortKey: se, symbolInstanceStart: he, symbolInstanceEnd: fe } = le;
              r.push({ sortKey: se, symbolInstanceStart: he, symbolInstanceEnd: fe, parameters: ie });
            }
            else r.push({ symbolInstanceStart: 0, symbolInstanceEnd: y.symbolInstances.length, parameters: ie });
          }
          attemptAnchorPlacement(r, h, p, g, y, x, E, C, R, B, k, O, z, H, Y, K, J, ie, le, se) {
            const he = a.aE[r.textAnchor], fe = [r.textOffset0, r.textOffset1], oe = nr(he, p, g, fe, y), be = this.collisionIndex.placeCollisionBox(h, O, C, R, B, E, x, K, k.predicate, le, oe, se);
            if ((!ie || this.collisionIndex.placeCollisionBox(ie, O, C, R, B, E, x, J, k.predicate, le, oe, se).placeable) && be.placeable) {
              let Fe;
              if (this.prevPlacement && this.prevPlacement.variableOffsets[z.crossTileID] && this.prevPlacement.placements[z.crossTileID] && this.prevPlacement.placements[z.crossTileID].text && (Fe = this.prevPlacement.variableOffsets[z.crossTileID].anchor), z.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
              return this.variableOffsets[z.crossTileID] = { textOffset: fe, width: p, height: g, anchor: he, textBoxScale: y, prevAnchor: Fe }, this.markUsedJustification(H, he, z, Y), H.allowVerticalPlacement && (this.markUsedOrientation(H, Y, z), this.placedOrientations[z.crossTileID] = Y), { shift: oe, placedGlyphBoxes: be };
            }
          }
          placeLayerBucketPart(r, h, p) {
            const { bucket: g, layout: y, translationText: x, translationIcon: E, unwrappedTileID: C, pitchedLabelPlaneMatrix: R, textPixelRatio: B, holdingForFade: k, collisionBoxArray: O, partiallyEvaluatedTextSize: z, collisionGroup: H } = r.parameters, Y = y.get("text-optional"), K = y.get("icon-optional"), J = a.aF(y, "text-overlap", "text-allow-overlap"), ie = J === "always", le = a.aF(y, "icon-overlap", "icon-allow-overlap"), se = le === "always", he = y.get("text-rotation-alignment") === "map", fe = y.get("text-pitch-alignment") === "map", oe = y.get("icon-text-fit") !== "none", be = y.get("symbol-z-order") === "viewport-y", Fe = ie && (se || !g.hasIconData() || K), Ie = se && (ie || !g.hasTextData() || Y);
            !g.collisionArrays && O && g.deserializeCollisionBoxes(O);
            const Me = this.retainedQueryData[g.bucketInstanceId].tileID, Oe = this._getTerrainElevationFunc(Me), We = this.transform.getFastPathSimpleProjectionMatrix(Me), qe = (Ve, ht, Bt) => {
              var Wt, ti;
              if (h[Ve.crossTileID]) return;
              if (k) return void (this.placements[Ve.crossTileID] = new ds(!1, !1, !1));
              let Yt = !1, vi = !1, Si = !0, Rt = null, ii = { box: null, placeable: !1, offscreen: null, occluded: !1 }, Wi = { placeable: !1 }, Qi = null, lr = null, Vr = null, Ns = 0, Wn = 0, Xn = 0;
              ht.textFeatureIndex ? Ns = ht.textFeatureIndex : Ve.useRuntimeCollisionCircles && (Ns = Ve.featureIndex), ht.verticalTextFeatureIndex && (Wn = ht.verticalTextFeatureIndex);
              const na = ht.textBox;
              if (na) {
                const qr = (Xi) => {
                  let er = a.ao.horizontal;
                  if (g.allowVerticalPlacement && !Xi && this.prevPlacement) {
                    const gs = this.prevPlacement.placedOrientations[Ve.crossTileID];
                    gs && (this.placedOrientations[Ve.crossTileID] = gs, er = gs, this.markUsedOrientation(g, er, Ve));
                  }
                  return er;
                }, Ls = (Xi, er) => {
                  if (g.allowVerticalPlacement && Ve.numVerticalGlyphVertices > 0 && ht.verticalTextBox) {
                    for (const gs of g.writingModes) if (gs === a.ao.vertical ? (ii = er(), Wi = ii) : ii = Xi(), ii && ii.placeable) break;
                  } else ii = Xi();
                }, jr = Ve.textAnchorOffsetStartIndex, qn = Ve.textAnchorOffsetEndIndex;
                if (qn === jr) {
                  const Xi = (er, gs) => {
                    const qi = this.collisionIndex.placeCollisionBox(er, J, B, Me, C, fe, he, x, H.predicate, Oe, void 0, We);
                    return qi && qi.placeable && (this.markUsedOrientation(g, gs, Ve), this.placedOrientations[Ve.crossTileID] = gs), qi;
                  };
                  Ls((() => Xi(na, a.ao.horizontal)), (() => {
                    const er = ht.verticalTextBox;
                    return g.allowVerticalPlacement && Ve.numVerticalGlyphVertices > 0 && er ? Xi(er, a.ao.vertical) : { box: null, offscreen: null };
                  })), qr(ii && ii.placeable);
                } else {
                  let Xi = a.aE[(ti = (Wt = this.prevPlacement) === null || Wt === void 0 ? void 0 : Wt.variableOffsets[Ve.crossTileID]) === null || ti === void 0 ? void 0 : ti.anchor];
                  const er = (qi, ll, aa) => {
                    const vn = qi.x2 - qi.x1, Us = qi.y2 - qi.y1, Zn = Ve.textBoxScale, tf = oe && le === "never" ? ll : null;
                    let ns = null, rf = J === "never" ? 1 : 2, nu = "never";
                    Xi && rf++;
                    for (let _c = 0; _c < rf; _c++) {
                      for (let gc = jr; gc < qn; gc++) {
                        const Kn = g.textAnchorOffsets.get(gc);
                        if (Xi && Kn.textAnchor !== Xi) continue;
                        const xn = this.attemptAnchorPlacement(Kn, qi, vn, Us, Zn, he, fe, B, Me, C, H, nu, Ve, g, aa, x, E, tf, Oe);
                        if (xn && (ns = xn.placedGlyphBoxes, ns && ns.placeable)) return Yt = !0, Rt = xn.shift, ns;
                      }
                      Xi ? Xi = null : nu = J;
                    }
                    return p && !ns && (ns = { box: this.collisionIndex.placeCollisionBox(na, "always", B, Me, C, fe, he, x, H.predicate, Oe, void 0, We).box, offscreen: !1, placeable: !1, occluded: !1 }), ns;
                  };
                  Ls((() => er(na, ht.iconBox, a.ao.horizontal)), (() => {
                    const qi = ht.verticalTextBox;
                    return g.allowVerticalPlacement && (!ii || !ii.placeable) && Ve.numVerticalGlyphVertices > 0 && qi ? er(qi, ht.verticalIconBox, a.ao.vertical) : { box: null, occluded: !0, offscreen: null };
                  })), ii && (Yt = ii.placeable, Si = ii.offscreen);
                  const gs = qr(ii && ii.placeable);
                  if (!Yt && this.prevPlacement) {
                    const qi = this.prevPlacement.variableOffsets[Ve.crossTileID];
                    qi && (this.variableOffsets[Ve.crossTileID] = qi, this.markUsedJustification(g, qi.anchor, Ve, gs));
                  }
                }
              }
              if (Qi = ii, Yt = Qi && Qi.placeable, Si = Qi && Qi.offscreen, Ve.useRuntimeCollisionCircles) {
                const qr = g.text.placedSymbolArray.get(Ve.centerJustifiedTextSymbolIndex), Ls = a.ap(g.textSizeData, z, qr), jr = y.get("text-padding");
                lr = this.collisionIndex.placeCollisionCircles(J, qr, g.lineVertexArray, g.glyphOffsetArray, Ls, C, R, p, fe, H.predicate, Ve.collisionCircleDiameter, jr, x, Oe), lr.circles.length && lr.collisionDetected && !p && a.w("Collisions detected, but collision boxes are not shown"), Yt = ie || lr.circles.length > 0 && !lr.collisionDetected, Si = Si && lr.offscreen;
              }
              if (ht.iconFeatureIndex && (Xn = ht.iconFeatureIndex), ht.iconBox) {
                const qr = (Ls) => this.collisionIndex.placeCollisionBox(Ls, le, B, Me, C, fe, he, E, H.predicate, Oe, oe && Rt ? Rt : void 0, We);
                Wi && Wi.placeable && ht.verticalIconBox ? (Vr = qr(ht.verticalIconBox), vi = Vr.placeable) : (Vr = qr(ht.iconBox), vi = Vr.placeable), Si = Si && Vr.offscreen;
              }
              const oa = Y || Ve.numHorizontalGlyphVertices === 0 && Ve.numVerticalGlyphVertices === 0, So = K || Ve.numIconVertices === 0;
              oa || So ? So ? oa || (vi = vi && Yt) : Yt = vi && Yt : vi = Yt = vi && Yt;
              const Co = vi && Vr.placeable;
              if (Yt && Qi.placeable && this.collisionIndex.insertCollisionBox(Qi.box, J, y.get("text-ignore-placement"), g.bucketInstanceId, Wi && Wi.placeable && Wn ? Wn : Ns, H.ID), Co && this.collisionIndex.insertCollisionBox(Vr.box, le, y.get("icon-ignore-placement"), g.bucketInstanceId, Xn, H.ID), lr && Yt && this.collisionIndex.insertCollisionCircles(lr.circles, J, y.get("text-ignore-placement"), g.bucketInstanceId, Ns, H.ID), p && this.storeCollisionData(g.bucketInstanceId, Bt, ht, Qi, Vr, lr), Ve.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
              if (g.bucketInstanceId === 0) throw new Error("bucket.bucketInstanceId can't be 0");
              this.placements[Ve.crossTileID] = new ds((Yt || Fe) && !Qi?.occluded, (vi || Ie) && !Vr?.occluded, Si || g.justReloaded), h[Ve.crossTileID] = !0;
            };
            if (be) {
              if (r.symbolInstanceStart !== 0) throw new Error("bucket.bucketInstanceId should be 0");
              const Ve = g.getSortedSymbolIndexes(-this.transform.bearingInRadians);
              for (let ht = Ve.length - 1; ht >= 0; --ht) {
                const Bt = Ve[ht];
                qe(g.symbolInstances.get(Bt), g.collisionArrays[Bt], Bt);
              }
            } else for (let Ve = r.symbolInstanceStart; Ve < r.symbolInstanceEnd; Ve++) qe(g.symbolInstances.get(Ve), g.collisionArrays[Ve], Ve);
            g.justReloaded = !1;
          }
          storeCollisionData(r, h, p, g, y, x) {
            if (p.textBox || p.iconBox) {
              let E, C;
              this.collisionBoxArrays.has(r) ? E = this.collisionBoxArrays.get(r) : (E = /* @__PURE__ */ new Map(), this.collisionBoxArrays.set(r, E)), E.has(h) ? C = E.get(h) : (C = { text: null, icon: null }, E.set(h, C)), p.textBox && (C.text = g.box), p.iconBox && (C.icon = y.box);
            }
            if (x) {
              let E = this.collisionCircleArrays[r];
              E === void 0 && (E = this.collisionCircleArrays[r] = []);
              for (let C = 0; C < x.circles.length; C += 4) E.push(x.circles[C + 0] - li), E.push(x.circles[C + 1] - li), E.push(x.circles[C + 2]), E.push(x.collisionDetected ? 1 : 0);
            }
          }
          markUsedJustification(r, h, p, g) {
            let y;
            y = g === a.ao.vertical ? p.verticalPlacedTextSymbolIndex : { left: p.leftJustifiedTextSymbolIndex, center: p.centerJustifiedTextSymbolIndex, right: p.rightJustifiedTextSymbolIndex }[a.aG(h)];
            const x = [p.leftJustifiedTextSymbolIndex, p.centerJustifiedTextSymbolIndex, p.rightJustifiedTextSymbolIndex, p.verticalPlacedTextSymbolIndex];
            for (const E of x) E >= 0 && (r.text.placedSymbolArray.get(E).crossTileID = y >= 0 && E !== y ? 0 : p.crossTileID);
          }
          markUsedOrientation(r, h, p) {
            const g = h === a.ao.horizontal || h === a.ao.horizontalOnly ? h : 0, y = h === a.ao.vertical ? h : 0, x = [p.leftJustifiedTextSymbolIndex, p.centerJustifiedTextSymbolIndex, p.rightJustifiedTextSymbolIndex];
            for (const E of x) r.text.placedSymbolArray.get(E).placedOrientation = g;
            p.verticalPlacedTextSymbolIndex && (r.text.placedSymbolArray.get(p.verticalPlacedTextSymbolIndex).placedOrientation = y);
          }
          commit(r) {
            this.commitTime = r, this.zoomAtLastRecencyCheck = this.transform.zoom;
            const h = this.prevPlacement;
            let p = !1;
            this.prevZoomAdjustment = h ? h.zoomAdjustment(this.transform.zoom) : 0;
            const g = h ? h.symbolFadeChange(r) : 1, y = h ? h.opacities : {}, x = h ? h.variableOffsets : {}, E = h ? h.placedOrientations : {};
            for (const C in this.placements) {
              const R = this.placements[C], B = y[C];
              B ? (this.opacities[C] = new zt(B, g, R.text, R.icon), p = p || R.text !== B.text.placed || R.icon !== B.icon.placed) : (this.opacities[C] = new zt(null, g, R.text, R.icon, R.skipFade), p = p || R.text || R.icon);
            }
            for (const C in y) {
              const R = y[C];
              if (!this.opacities[C]) {
                const B = new zt(R, g, !1, !1);
                B.isHidden() || (this.opacities[C] = B, p = p || R.text.placed || R.icon.placed);
              }
            }
            for (const C in x) this.variableOffsets[C] || !this.opacities[C] || this.opacities[C].isHidden() || (this.variableOffsets[C] = x[C]);
            for (const C in E) this.placedOrientations[C] || !this.opacities[C] || this.opacities[C].isHidden() || (this.placedOrientations[C] = E[C]);
            if (h && h.lastPlacementChangeTime === void 0) throw new Error("Last placement time for previous placement is not defined");
            p ? this.lastPlacementChangeTime = r : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = h ? h.lastPlacementChangeTime : r);
          }
          updateLayerOpacities(r, h) {
            const p = {};
            for (const g of h) {
              const y = g.getBucket(r);
              y && g.latestFeatureIndex && r.id === y.layerIds[0] && this.updateBucketOpacities(y, g.tileID, p, g.collisionBoxArray);
            }
          }
          updateBucketOpacities(r, h, p, g) {
            r.hasTextData() && (r.text.opacityVertexArray.clear(), r.text.hasVisibleVertices = !1), r.hasIconData() && (r.icon.opacityVertexArray.clear(), r.icon.hasVisibleVertices = !1), r.hasIconCollisionBoxData() && r.iconCollisionBox.collisionVertexArray.clear(), r.hasTextCollisionBoxData() && r.textCollisionBox.collisionVertexArray.clear();
            const y = r.layers[0], x = y.layout, E = new zt(null, 0, !1, !1, !0), C = x.get("text-allow-overlap"), R = x.get("icon-allow-overlap"), B = y._unevaluatedLayout.hasValue("text-variable-anchor") || y._unevaluatedLayout.hasValue("text-variable-anchor-offset"), k = x.get("text-rotation-alignment") === "map", O = x.get("text-pitch-alignment") === "map", z = x.get("icon-text-fit") !== "none", H = new zt(null, 0, C && (R || !r.hasIconData() || x.get("icon-optional")), R && (C || !r.hasTextData() || x.get("text-optional")), !0);
            !r.collisionArrays && g && (r.hasIconCollisionBoxData() || r.hasTextCollisionBoxData()) && r.deserializeCollisionBoxes(g);
            const Y = (J, ie, le) => {
              for (let se = 0; se < ie / 4; se++) J.opacityVertexArray.emplaceBack(le);
              J.hasVisibleVertices = J.hasVisibleVertices || le !== Fr;
            }, K = this.collisionBoxArrays.get(r.bucketInstanceId);
            for (let J = 0; J < r.symbolInstances.length; J++) {
              const ie = r.symbolInstances.get(J), { numHorizontalGlyphVertices: le, numVerticalGlyphVertices: se, crossTileID: he } = ie;
              let fe = this.opacities[he];
              p[he] ? fe = E : fe || (fe = H, this.opacities[he] = fe), p[he] = !0;
              const oe = ie.numIconVertices > 0, be = this.placedOrientations[ie.crossTileID], Fe = be === a.ao.vertical, Ie = be === a.ao.horizontal || be === a.ao.horizontalOnly;
              if (le > 0 || se > 0) {
                const Oe = jn(fe.text);
                Y(r.text, le, Fe ? Fr : Oe), Y(r.text, se, Ie ? Fr : Oe);
                const We = fe.text.isHidden();
                [ie.rightJustifiedTextSymbolIndex, ie.centerJustifiedTextSymbolIndex, ie.leftJustifiedTextSymbolIndex].forEach(((ht) => {
                  ht >= 0 && (r.text.placedSymbolArray.get(ht).hidden = We || Fe ? 1 : 0);
                })), ie.verticalPlacedTextSymbolIndex >= 0 && (r.text.placedSymbolArray.get(ie.verticalPlacedTextSymbolIndex).hidden = We || Ie ? 1 : 0);
                const qe = this.variableOffsets[ie.crossTileID];
                qe && this.markUsedJustification(r, qe.anchor, ie, be);
                const Ve = this.placedOrientations[ie.crossTileID];
                Ve && (this.markUsedJustification(r, "left", ie, Ve), this.markUsedOrientation(r, Ve, ie));
              }
              if (oe) {
                const Oe = jn(fe.icon), We = !(z && ie.verticalPlacedIconSymbolIndex && Fe);
                ie.placedIconSymbolIndex >= 0 && (Y(r.icon, ie.numIconVertices, We ? Oe : Fr), r.icon.placedSymbolArray.get(ie.placedIconSymbolIndex).hidden = fe.icon.isHidden()), ie.verticalPlacedIconSymbolIndex >= 0 && (Y(r.icon, ie.numVerticalIconVertices, We ? Fr : Oe), r.icon.placedSymbolArray.get(ie.verticalPlacedIconSymbolIndex).hidden = fe.icon.isHidden());
              }
              const Me = K && K.has(J) ? K.get(J) : { text: null, icon: null };
              if (r.hasIconCollisionBoxData() || r.hasTextCollisionBoxData()) {
                const Oe = r.collisionArrays[J];
                if (Oe) {
                  let We = new a.P(0, 0);
                  if (Oe.textBox || Oe.verticalTextBox) {
                    let qe = !0;
                    if (B) {
                      const Ve = this.variableOffsets[he];
                      Ve ? (We = nr(Ve.anchor, Ve.width, Ve.height, Ve.textOffset, Ve.textBoxScale), k && We._rotate(O ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : qe = !1;
                    }
                    if (Oe.textBox || Oe.verticalTextBox) {
                      let Ve;
                      Oe.textBox && (Ve = Fe), Oe.verticalTextBox && (Ve = Ie), Uo(r.textCollisionBox.collisionVertexArray, fe.text.placed, !qe || Ve, Me.text, We.x, We.y);
                    }
                  }
                  if (Oe.iconBox || Oe.verticalIconBox) {
                    const qe = !!(!Ie && Oe.verticalIconBox);
                    let Ve;
                    Oe.iconBox && (Ve = qe), Oe.verticalIconBox && (Ve = !qe), Uo(r.iconCollisionBox.collisionVertexArray, fe.icon.placed, Ve, Me.icon, z ? We.x : 0, z ? We.y : 0);
                  }
                }
              }
            }
            if (r.sortFeatures(-this.transform.bearingInRadians), this.retainedQueryData[r.bucketInstanceId] && (this.retainedQueryData[r.bucketInstanceId].featureSortOrder = r.featureSortOrder), r.hasTextData() && r.text.opacityVertexBuffer && r.text.opacityVertexBuffer.updateData(r.text.opacityVertexArray), r.hasIconData() && r.icon.opacityVertexBuffer && r.icon.opacityVertexBuffer.updateData(r.icon.opacityVertexArray), r.hasIconCollisionBoxData() && r.iconCollisionBox.collisionVertexBuffer && r.iconCollisionBox.collisionVertexBuffer.updateData(r.iconCollisionBox.collisionVertexArray), r.hasTextCollisionBoxData() && r.textCollisionBox.collisionVertexBuffer && r.textCollisionBox.collisionVertexBuffer.updateData(r.textCollisionBox.collisionVertexArray), r.text.opacityVertexArray.length !== r.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${r.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${r.text.layoutVertexArray.length}) / 4`);
            if (r.icon.opacityVertexArray.length !== r.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${r.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${r.icon.layoutVertexArray.length}) / 4`);
            r.bucketInstanceId in this.collisionCircleArrays && (r.collisionCircleArray = this.collisionCircleArrays[r.bucketInstanceId], delete this.collisionCircleArrays[r.bucketInstanceId]);
          }
          symbolFadeChange(r) {
            return this.fadeDuration === 0 ? 1 : (r - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
          }
          zoomAdjustment(r) {
            return Math.max(0, (this.transform.zoom - r) / 1.5);
          }
          hasTransitions(r) {
            return this.stale || r - this.lastPlacementChangeTime < this.fadeDuration;
          }
          stillRecent(r, h) {
            const p = this.zoomAtLastRecencyCheck === h ? 1 - this.zoomAdjustment(h) : 1;
            return this.zoomAtLastRecencyCheck = h, this.commitTime + this.fadeDuration * p > r;
          }
          setStale() {
            this.stale = !0;
          }
        }
        function Uo(m, r, h, p, g, y) {
          p && p.length !== 0 || (p = [0, 0, 0, 0]);
          const x = p[0] - li, E = p[1] - li, C = p[2] - li, R = p[3] - li;
          m.emplaceBack(r ? 1 : 0, h ? 1 : 0, g || 0, y || 0, x, E), m.emplaceBack(r ? 1 : 0, h ? 1 : 0, g || 0, y || 0, C, E), m.emplaceBack(r ? 1 : 0, h ? 1 : 0, g || 0, y || 0, C, R), m.emplaceBack(r ? 1 : 0, h ? 1 : 0, g || 0, y || 0, x, R);
        }
        const ho = Math.pow(2, 25), Gr = Math.pow(2, 24), Ms = Math.pow(2, 17), zo = Math.pow(2, 16), Ba = Math.pow(2, 9), Da = Math.pow(2, 8), Oa = Math.pow(2, 1);
        function jn(m) {
          if (m.opacity === 0 && !m.placed) return 0;
          if (m.opacity === 1 && m.placed) return 4294967295;
          const r = m.placed ? 1 : 0, h = Math.floor(127 * m.opacity);
          return h * ho + r * Gr + h * Ms + r * zo + h * Ba + r * Da + h * Oa + r;
        }
        const Fr = 0;
        class Fa {
          constructor(r) {
            this._sortAcrossTiles = r.layout.get("symbol-z-order") !== "viewport-y" && !r.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
          }
          continuePlacement(r, h, p, g, y) {
            const x = this._bucketParts;
            for (; this._currentTileIndex < r.length; ) if (h.getBucketParts(x, g, r[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, y()) return !0;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, x.sort(((E, C) => E.sortKey - C.sortKey))); this._currentPartIndex < x.length; ) if (h.placeLayerBucketPart(x[this._currentPartIndex], this._seenCrossTileIDs, p), this._currentPartIndex++, y()) return !0;
            return !1;
          }
        }
        class Vo {
          constructor(r, h, p, g, y, x, E, C) {
            this.placement = new Is(r, h, x, E, C), this._currentPlacementIndex = p.length - 1, this._forceFullPlacement = g, this._showCollisionBoxes = y, this._done = !1;
          }
          isDone() {
            return this._done;
          }
          continuePlacement(r, h, p) {
            const g = N.now(), y = () => !this._forceFullPlacement && N.now() - g > 2;
            for (; this._currentPlacementIndex >= 0; ) {
              const x = h[r[this._currentPlacementIndex]], E = this.placement.collisionIndex.transform.zoom;
              if (x.type === "symbol" && (!x.minzoom || x.minzoom <= E) && (!x.maxzoom || x.maxzoom > E)) {
                if (this._inProgressLayer || (this._inProgressLayer = new Fa(x)), this._inProgressLayer.continuePlacement(p[x.source], this.placement, this._showCollisionBoxes, x, y)) return;
                delete this._inProgressLayer;
              }
              this._currentPlacementIndex--;
            }
            this._done = !0;
          }
          commit(r) {
            return this.placement.commit(r), this.placement;
          }
        }
        const tn = 512 / a.$ / 2;
        class jo {
          constructor(r, h, p) {
            this.tileID = r, this.bucketInstanceId = p, this._symbolsByKey = {};
            const g = /* @__PURE__ */ new Map();
            for (let y = 0; y < h.length; y++) {
              const x = h.get(y), E = x.key, C = g.get(E);
              C ? C.push(x) : g.set(E, [x]);
            }
            for (const [y, x] of g) {
              const E = { positions: x.map(((C) => ({ x: Math.floor(C.anchorX * tn), y: Math.floor(C.anchorY * tn) }))), crossTileIDs: x.map(((C) => C.crossTileID)) };
              if (E.positions.length > 128) {
                const C = new a.aI(E.positions.length, 16, Uint16Array);
                for (const { x: R, y: B } of E.positions) C.add(R, B);
                C.finish(), delete E.positions, E.index = C;
              }
              this._symbolsByKey[y] = E;
            }
          }
          getScaledCoordinates(r, h) {
            const { x: p, y: g, z: y } = this.tileID.canonical, { x, y: E, z: C } = h.canonical, R = tn / Math.pow(2, C - y), B = (E * a.$ + r.anchorY) * R, k = g * a.$ * tn;
            return { x: Math.floor((x * a.$ + r.anchorX) * R - p * a.$ * tn), y: Math.floor(B - k) };
          }
          findMatches(r, h, p) {
            const g = this.tileID.canonical.z < h.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - h.canonical.z);
            for (let y = 0; y < r.length; y++) {
              const x = r.get(y);
              if (x.crossTileID) continue;
              const E = this._symbolsByKey[x.key];
              if (!E) continue;
              const C = this.getScaledCoordinates(x, h);
              if (E.index) {
                const R = E.index.range(C.x - g, C.y - g, C.x + g, C.y + g).sort();
                for (const B of R) {
                  const k = E.crossTileIDs[B];
                  if (!p[k]) {
                    p[k] = !0, x.crossTileID = k;
                    break;
                  }
                }
              } else if (E.positions) for (let R = 0; R < E.positions.length; R++) {
                const B = E.positions[R], k = E.crossTileIDs[R];
                if (Math.abs(B.x - C.x) <= g && Math.abs(B.y - C.y) <= g && !p[k]) {
                  p[k] = !0, x.crossTileID = k;
                  break;
                }
              }
            }
          }
          getCrossTileIDsLists() {
            return Object.values(this._symbolsByKey).map((({ crossTileIDs: r }) => r));
          }
        }
        class ka {
          constructor() {
            this.maxCrossTileID = 0;
          }
          generate() {
            return ++this.maxCrossTileID;
          }
        }
        class yh {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
          }
          handleWrapJump(r) {
            const h = Math.round((r - this.lng) / 360);
            if (h !== 0) for (const p in this.indexes) {
              const g = this.indexes[p], y = {};
              for (const x in g) {
                const E = g[x];
                E.tileID = E.tileID.unwrapTo(E.tileID.wrap + h), y[E.tileID.key] = E;
              }
              this.indexes[p] = y;
            }
            this.lng = r;
          }
          addBucket(r, h, p) {
            if (this.indexes[r.overscaledZ] && this.indexes[r.overscaledZ][r.key]) {
              if (this.indexes[r.overscaledZ][r.key].bucketInstanceId === h.bucketInstanceId) return !1;
              this.removeBucketCrossTileIDs(r.overscaledZ, this.indexes[r.overscaledZ][r.key]);
            }
            for (let y = 0; y < h.symbolInstances.length; y++) h.symbolInstances.get(y).crossTileID = 0;
            this.usedCrossTileIDs[r.overscaledZ] || (this.usedCrossTileIDs[r.overscaledZ] = {});
            const g = this.usedCrossTileIDs[r.overscaledZ];
            for (const y in this.indexes) {
              const x = this.indexes[y];
              if (Number(y) > r.overscaledZ) for (const E in x) {
                const C = x[E];
                C.tileID.isChildOf(r) && C.findMatches(h.symbolInstances, r, g);
              }
              else {
                const E = x[r.scaledTo(Number(y)).key];
                E && E.findMatches(h.symbolInstances, r, g);
              }
            }
            for (let y = 0; y < h.symbolInstances.length; y++) {
              const x = h.symbolInstances.get(y);
              x.crossTileID || (x.crossTileID = p.generate(), g[x.crossTileID] = !0);
            }
            return this.indexes[r.overscaledZ] === void 0 && (this.indexes[r.overscaledZ] = {}), this.indexes[r.overscaledZ][r.key] = new jo(r, h.symbolInstances, h.bucketInstanceId), !0;
          }
          removeBucketCrossTileIDs(r, h) {
            for (const p of h.getCrossTileIDsLists()) for (const g of p) delete this.usedCrossTileIDs[r][g];
          }
          removeStaleBuckets(r) {
            let h = !1;
            for (const p in this.indexes) {
              const g = this.indexes[p];
              for (const y in g) r[g[y].bucketInstanceId] || (this.removeBucketCrossTileIDs(p, g[y]), delete g[y], h = !0);
            }
            return h;
          }
        }
        class X {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new ka(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
          }
          addLayer(r, h, p) {
            let g = this.layerIndexes[r.id];
            g === void 0 && (g = this.layerIndexes[r.id] = new yh());
            let y = !1;
            const x = {};
            g.handleWrapJump(p);
            for (const E of h) {
              const C = E.getBucket(r);
              C && r.id === C.layerIds[0] && (C.bucketInstanceId || (C.bucketInstanceId = ++this.maxBucketInstanceId), g.addBucket(E.tileID, C, this.crossTileIDs) && (y = !0), x[C.bucketInstanceId] = !0);
            }
            return g.removeStaleBuckets(x) && (y = !0), y;
          }
          pruneUnusedLayers(r) {
            const h = {};
            r.forEach(((p) => {
              h[p] = !0;
            }));
            for (const p in this.layerIndexes) h[p] || delete this.layerIndexes[p];
          }
        }
        var Q = "void main() {fragColor=vec4(1.0);}";
        const ue = { prelude: xe(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
out highp vec4 fragColor;`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c
);}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
#ifdef GLOBE
if ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}
#endif
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;`), projectionMercator: xe("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"), projectionGlobe: xe("", `#define GLOBE_RADIUS 6371008.8
uniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos
);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); 
if (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len
);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}`), background: xe(`uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), backgroundPattern: xe(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: xe(`in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {
#ifdef GLOBE
vec3 center_vector=projectToSphere(circle_center);
#endif
float angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {
#ifdef GLOBE
vec4 projected_center=interpolateProjection(circle_center,center_vector,ele);
#else
vec4 projected_center=projectTileWithElevation(circle_center,ele);
#endif
corner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}
#ifdef GLOBE
vec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);
#else
gl_Position=projectTileWithElevation(corner_position,ele);
#endif
} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`), clippingMask: xe(Q, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), heatmap: xe(`uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);
#ifdef GLOBE
vec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);
#else
gl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));
#endif
}`), heatmapTexture: xe(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: xe("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: xe("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), colorRelief: xe(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;uniform vec4 u_unpack;uniform sampler2D u_elevation_stops;uniform sampler2D u_color_stops;uniform int u_color_ramp_size;uniform float u_opacity;in vec2 v_pos;float getElevation(vec2 coord) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}float getElevationStop(int stop) {float x=(float(stop)+0.5)/float(u_color_ramp_size);vec4 data=texture(u_elevation_stops,vec2(x,0))*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {float el=getElevation(v_pos);int r=(u_color_ramp_size-1);int l=0;float el_l=getElevationStop(l);float el_r=getElevationStop(r);while(r-l > 1){int m=(r+l)/2;float el_m=getElevationStop(m);if(el < el_m){r=m;el_r=el_m;}else
{l=m;el_l=el_m;}}float x=(float(l)+(el-el_l)/(el_r-el_l)+0.5)/float(u_color_ramp_size);fragColor=u_opacity*texture(u_color_stops,vec2(x,0));
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_dimension;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_pos/8192.0)*scale+epsilon;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"), debug: xe("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"), depth: xe(Q, `in vec2 a_pos;void main() {
#ifdef GLOBE
gl_Position=projectTileFor3D(a_pos,0.0);
#else
gl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);
#endif
}`), fill: xe(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
fragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_fill_translate;in vec2 a_pos;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);}`), fillOutline: xe(`in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`), fillOutlinePattern: xe(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`), fillPattern: xe(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`), fillExtrusion: xe(`in vec4 v_color;void main() {fragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
out vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);
#ifdef GLOBE
mat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);
#endif
directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`), fillExtrusionPattern: xe(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
#ifdef GLOBE
out vec3 v_sphere_pos;
#endif
out vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`), hillshadePrepare: xe(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {vec2 epsilon=1.0/u_dimension;float tileSize=u_dimension.x-2.0;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))*tileSize/pow(2.0,exaggeration+(28.2562-u_zoom));fragColor=clamp(vec4(deriv.x/8.0+0.5,deriv.y/8.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: xe(`uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform float u_exaggeration;uniform vec4 u_accent;uniform int u_method;uniform float u_altitudes[NUM_ILLUMINATION_SOURCES];uniform float u_azimuths[NUM_ILLUMINATION_SOURCES];uniform vec4 u_shadows[NUM_ILLUMINATION_SOURCES];uniform vec4 u_highlights[NUM_ILLUMINATION_SOURCES];
#define PI 3.141592653589793
#define STANDARD 0
#define COMBINED 1
#define IGOR 2
#define MULTIDIRECTIONAL 3
#define BASIC 4
float get_aspect(vec2 deriv){return deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);}void igor_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float aspect=get_aspect(deriv);float azimuth=u_azimuths[0]+PI;float slope_stength=atan(length(deriv))*2.0/PI;float aspect_strength=1.0-abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);float shadow_strength=slope_stength*aspect_strength;float highlight_strength=slope_stength*(1.0-aspect_strength);fragColor=u_shadows[0]*shadow_strength+u_highlights[0]*highlight_strength;}void standard_hillshade(vec2 deriv){float azimuth=u_azimuths[0]+PI;float slope=atan(0.625*length(deriv));float aspect=get_aspect(deriv);float intensity=u_exaggeration;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadows[0],u_highlights[0],shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;}void basic_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor=u_highlights[0]*(2.0*shade-1.0);}else
{fragColor=u_shadows[0]*(1.0-2.0*shade);}}void multidirectional_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;fragColor=vec4(0,0,0,0);for(int i=0; i < NUM_ILLUMINATION_SOURCES; i++){float cos_alt=cos(u_altitudes[i]);float sin_alt=sin(u_altitudes[i]);float cos_az=-cos(u_azimuths[i]);float sin_az=-sin(u_azimuths[i]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor+=u_highlights[i]*(2.0*shade-1.0)/float(NUM_ILLUMINATION_SOURCES);}else
{fragColor+=u_shadows[i]*(1.0-2.0*shade)/float(NUM_ILLUMINATION_SOURCES);}}}void combined_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=acos((sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv)));cang=clamp(cang,0.0,PI/2.0);float shade=cang*atan(length(deriv))*4.0/PI/PI;float highlight=(PI/2.0-cang)*atan(length(deriv))*4.0/PI/PI;fragColor=u_shadows[0]*shade+u_highlights[0]*highlight;}void main() {vec4 pixel=texture(u_image,v_pos);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));vec2 deriv=((pixel.rg*8.0)-4.0)/scaleFactor;if (u_method==BASIC) {basic_hillshade(deriv);} else if (u_method==COMBINED) {combined_hillshade(deriv);} else if (u_method==IGOR) {igor_hillshade(deriv);} else if (u_method==MULTIDIRECTIONAL) {multidirectional_hillshade(deriv);} else if (u_method==STANDARD) {standard_hillshade(deriv);} else {standard_hillshade(deriv);}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"), line: xe(`uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), lineGradient: xe(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), linePattern: xe(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`), lineSDF: xe(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}`), raster: xe(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;
#ifdef GLOBE
if (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}
#endif
v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`), symbolIcon: xe(`uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`), symbolSDF: xe(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`), symbolTextAndIcon: xe(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`), terrain: xe("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"), terrainDepth: xe("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"), terrainCoords: xe("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"), projectionErrorMeasurement: xe("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"), atmosphere: xe(`in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758
);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}`, "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"), sky: xe("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}") };
        function xe(m, r) {
          const h = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, p = r.match(/in ([\w]+) ([\w]+)/g), g = m.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), y = r.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), x = y ? y.concat(g) : g, E = {};
          return { fragmentSource: m = m.replace(h, ((C, R, B, k, O) => (E[O] = !0, R === "define" ? `
#ifndef HAS_UNIFORM_u_${O}
in ${B} ${k} ${O};
#else
uniform ${B} ${k} u_${O};
#endif
` : `
#ifdef HAS_UNIFORM_u_${O}
    ${B} ${k} ${O} = u_${O};
#endif
`))), vertexSource: r = r.replace(h, ((C, R, B, k, O) => {
            const z = k === "float" ? "vec2" : "vec4", H = O.match(/color/) ? "color" : z;
            return E[O] ? R === "define" ? `
#ifndef HAS_UNIFORM_u_${O}
uniform lowp float u_${O}_t;
in ${B} ${z} a_${O};
out ${B} ${k} ${O};
#else
uniform ${B} ${k} u_${O};
#endif
` : H === "vec4" ? `
#ifndef HAS_UNIFORM_u_${O}
    ${O} = a_${O};
#else
    ${B} ${k} ${O} = u_${O};
#endif
` : `
#ifndef HAS_UNIFORM_u_${O}
    ${O} = unpack_mix_${H}(a_${O}, u_${O}_t);
#else
    ${B} ${k} ${O} = u_${O};
#endif
` : R === "define" ? `
#ifndef HAS_UNIFORM_u_${O}
uniform lowp float u_${O}_t;
in ${B} ${z} a_${O};
#else
uniform ${B} ${k} u_${O};
#endif
` : H === "vec4" ? `
#ifndef HAS_UNIFORM_u_${O}
    ${B} ${k} ${O} = a_${O};
#else
    ${B} ${k} ${O} = u_${O};
#endif
` : `
#ifndef HAS_UNIFORM_u_${O}
    ${B} ${k} ${O} = unpack_mix_${H}(a_${O}, u_${O}_t);
#else
    ${B} ${k} ${O} = u_${O};
#endif
`;
          })), staticAttributes: p, staticUniforms: x };
        }
        class $e {
          constructor(r, h, p) {
            this.vertexBuffer = r, this.indexBuffer = h, this.segments = p;
          }
          destroy() {
            this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null;
          }
        }
        var at = a.aJ([{ name: "a_pos", type: "Int16", components: 2 }]);
        const It = "#define PROJECTION_MERCATOR", hi = "mercator";
        class mt {
          constructor() {
            this._cachedMesh = null;
          }
          get name() {
            return "mercator";
          }
          get useSubdivision() {
            return !1;
          }
          get shaderVariantName() {
            return hi;
          }
          get shaderDefine() {
            return It;
          }
          get shaderPreludeCode() {
            return ue.projectionMercator;
          }
          get vertexShaderPreludeCode() {
            return ue.projectionMercator.vertexSource;
          }
          get subdivisionGranularity() {
            return a.aK.noSubdivision;
          }
          get useGlobeControls() {
            return !1;
          }
          get transitionState() {
            return 0;
          }
          get latitudeErrorCorrectionRadians() {
            return 0;
          }
          destroy() {
          }
          updateGPUdependent(r) {
          }
          getMeshFromTileID(r, h, p, g, y) {
            if (this._cachedMesh) return this._cachedMesh;
            const x = new a.aL();
            x.emplaceBack(0, 0), x.emplaceBack(a.$, 0), x.emplaceBack(0, a.$), x.emplaceBack(a.$, a.$);
            const E = r.createVertexBuffer(x, at.members), C = a.aM.simpleSegment(0, 0, 4, 2), R = new a.aN();
            R.emplaceBack(1, 0, 2), R.emplaceBack(1, 2, 3);
            const B = r.createIndexBuffer(R);
            return this._cachedMesh = new $e(E, B, C), this._cachedMesh;
          }
          recalculate() {
          }
          hasTransition() {
            return !1;
          }
          setErrorQueryLatitudeDegrees(r) {
          }
        }
        class Ai {
          constructor(r = 0, h = 0, p = 0, g = 0) {
            if (isNaN(r) || r < 0 || isNaN(h) || h < 0 || isNaN(p) || p < 0 || isNaN(g) || g < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = r, this.bottom = h, this.left = p, this.right = g;
          }
          interpolate(r, h, p) {
            return h.top != null && r.top != null && (this.top = a.C.number(r.top, h.top, p)), h.bottom != null && r.bottom != null && (this.bottom = a.C.number(r.bottom, h.bottom, p)), h.left != null && r.left != null && (this.left = a.C.number(r.left, h.left, p)), h.right != null && r.right != null && (this.right = a.C.number(r.right, h.right, p)), this;
          }
          getCenter(r, h) {
            const p = a.ah((this.left + r - this.right) / 2, 0, r), g = a.ah((this.top + h - this.bottom) / 2, 0, h);
            return new a.P(p, g);
          }
          equals(r) {
            return this.top === r.top && this.bottom === r.bottom && this.left === r.left && this.right === r.right;
          }
          clone() {
            return new Ai(this.top, this.bottom, this.left, this.right);
          }
          toJSON() {
            return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
          }
        }
        function kr(m, r) {
          if (!m.renderWorldCopies || m.lngRange) return;
          const h = r.lng - m.center.lng;
          r.lng += h > 180 ? -360 : h < -180 ? 360 : 0;
        }
        function Fl(m) {
          return Math.max(0, Math.floor(m));
        }
        class Nr {
          constructor(r, h, p, g, y, x) {
            this._callbacks = r, this._tileSize = 512, this._renderWorldCopies = x === void 0 || !!x, this._minZoom = h || 0, this._maxZoom = p || 22, this._minPitch = g ?? 0, this._maxPitch = y ?? 60, this.setMaxBounds(), this._width = 0, this._height = 0, this._center = new a.S(0, 0), this._elevation = 0, this._zoom = 0, this._tileZoom = Fl(this._zoom), this._scale = a.af(this._zoom), this._bearingInRadians = 0, this._fovInRadians = 0.6435011087932844, this._pitchInRadians = 0, this._rollInRadians = 0, this._unmodified = !0, this._edgeInsets = new Ai(), this._minElevationForCurrentTile = 0, this._autoCalculateNearFarZ = !0;
          }
          apply(r, h, p) {
            this._latRange = r.latRange, this._lngRange = r.lngRange, this._width = r.width, this._height = r.height, this._center = r.center, this._elevation = r.elevation, this._minElevationForCurrentTile = r.minElevationForCurrentTile, this._zoom = r.zoom, this._tileZoom = Fl(this._zoom), this._scale = a.af(this._zoom), this._bearingInRadians = r.bearingInRadians, this._fovInRadians = r.fovInRadians, this._pitchInRadians = r.pitchInRadians, this._rollInRadians = r.rollInRadians, this._unmodified = r.unmodified, this._edgeInsets = new Ai(r.padding.top, r.padding.bottom, r.padding.left, r.padding.right), this._minZoom = r.minZoom, this._maxZoom = r.maxZoom, this._minPitch = r.minPitch, this._maxPitch = r.maxPitch, this._renderWorldCopies = r.renderWorldCopies, this._cameraToCenterDistance = r.cameraToCenterDistance, this._nearZ = r.nearZ, this._farZ = r.farZ, this._autoCalculateNearFarZ = !p && r.autoCalculateNearFarZ, h && this._constrain(), this._calcMatrices();
          }
          get pixelsToClipSpaceMatrix() {
            return this._pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._clipSpaceToPixelsMatrix;
          }
          get minElevationForCurrentTile() {
            return this._minElevationForCurrentTile;
          }
          setMinElevationForCurrentTile(r) {
            this._minElevationForCurrentTile = r;
          }
          get tileSize() {
            return this._tileSize;
          }
          get tileZoom() {
            return this._tileZoom;
          }
          get scale() {
            return this._scale;
          }
          get width() {
            return this._width;
          }
          get height() {
            return this._height;
          }
          get bearingInRadians() {
            return this._bearingInRadians;
          }
          get lngRange() {
            return this._lngRange;
          }
          get latRange() {
            return this._latRange;
          }
          get pixelsToGLUnits() {
            return this._pixelsToGLUnits;
          }
          get minZoom() {
            return this._minZoom;
          }
          setMinZoom(r) {
            this._minZoom !== r && (this._minZoom = r, this.setZoom(this.getConstrained(this._center, this.zoom).zoom));
          }
          get maxZoom() {
            return this._maxZoom;
          }
          setMaxZoom(r) {
            this._maxZoom !== r && (this._maxZoom = r, this.setZoom(this.getConstrained(this._center, this.zoom).zoom));
          }
          get minPitch() {
            return this._minPitch;
          }
          setMinPitch(r) {
            this._minPitch !== r && (this._minPitch = r, this.setPitch(Math.max(this.pitch, r)));
          }
          get maxPitch() {
            return this._maxPitch;
          }
          setMaxPitch(r) {
            this._maxPitch !== r && (this._maxPitch = r, this.setPitch(Math.min(this.pitch, r)));
          }
          get renderWorldCopies() {
            return this._renderWorldCopies;
          }
          setRenderWorldCopies(r) {
            r === void 0 ? r = !0 : r === null && (r = !1), this._renderWorldCopies = r;
          }
          get worldSize() {
            return this._tileSize * this._scale;
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2));
          }
          get size() {
            return new a.P(this._width, this._height);
          }
          get bearing() {
            return this._bearingInRadians / Math.PI * 180;
          }
          setBearing(r) {
            const h = a.aO(r, -180, 180) * Math.PI / 180;
            var p, g, y, x, E, C, R, B, k;
            this._bearingInRadians !== h && (this._unmodified = !1, this._bearingInRadians = h, this._calcMatrices(), this._rotationMatrix = S(), p = this._rotationMatrix, y = -this._bearingInRadians, x = (g = this._rotationMatrix)[0], E = g[1], C = g[2], R = g[3], B = Math.sin(y), k = Math.cos(y), p[0] = x * k + C * B, p[1] = E * k + R * B, p[2] = x * -B + C * k, p[3] = E * -B + R * k);
          }
          get rotationMatrix() {
            return this._rotationMatrix;
          }
          get pitchInRadians() {
            return this._pitchInRadians;
          }
          get pitch() {
            return this._pitchInRadians / Math.PI * 180;
          }
          setPitch(r) {
            const h = a.ah(r, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitchInRadians !== h && (this._unmodified = !1, this._pitchInRadians = h, this._calcMatrices());
          }
          get rollInRadians() {
            return this._rollInRadians;
          }
          get roll() {
            return this._rollInRadians / Math.PI * 180;
          }
          setRoll(r) {
            const h = r / 180 * Math.PI;
            this._rollInRadians !== h && (this._unmodified = !1, this._rollInRadians = h, this._calcMatrices());
          }
          get fovInRadians() {
            return this._fovInRadians;
          }
          get fov() {
            return a.aP(this._fovInRadians);
          }
          setFov(r) {
            r = a.ah(r, 0.1, 150), this.fov !== r && (this._unmodified = !1, this._fovInRadians = a.ae(r), this._calcMatrices());
          }
          get zoom() {
            return this._zoom;
          }
          setZoom(r) {
            const h = this.getConstrained(this._center, r).zoom;
            this._zoom !== h && (this._unmodified = !1, this._zoom = h, this._tileZoom = Math.max(0, Math.floor(h)), this._scale = a.af(h), this._constrain(), this._calcMatrices());
          }
          get center() {
            return this._center;
          }
          setCenter(r) {
            r.lat === this._center.lat && r.lng === this._center.lng || (this._unmodified = !1, this._center = r, this._constrain(), this._calcMatrices());
          }
          get elevation() {
            return this._elevation;
          }
          setElevation(r) {
            r !== this._elevation && (this._elevation = r, this._constrain(), this._calcMatrices());
          }
          get padding() {
            return this._edgeInsets.toJSON();
          }
          setPadding(r) {
            this._edgeInsets.equals(r) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, r, 1), this._calcMatrices());
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this._width, this._height);
          }
          get pixelsPerMeter() {
            return this._pixelPerMeter;
          }
          get unmodified() {
            return this._unmodified;
          }
          get cameraToCenterDistance() {
            return this._cameraToCenterDistance;
          }
          get nearZ() {
            return this._nearZ;
          }
          get farZ() {
            return this._farZ;
          }
          get autoCalculateNearFarZ() {
            return this._autoCalculateNearFarZ;
          }
          overrideNearFarZ(r, h) {
            this._autoCalculateNearFarZ = !1, this._nearZ = r, this._farZ = h, this._calcMatrices();
          }
          clearNearFarZOverride() {
            this._autoCalculateNearFarZ = !0, this._calcMatrices();
          }
          isPaddingEqual(r) {
            return this._edgeInsets.equals(r);
          }
          interpolatePadding(r, h, p) {
            this._unmodified = !1, this._edgeInsets.interpolate(r, h, p), this._constrain(), this._calcMatrices();
          }
          resize(r, h, p = !0) {
            this._width = r, this._height = h, p && this._constrain(), this._calcMatrices();
          }
          getMaxBounds() {
            return this._latRange && this._latRange.length === 2 && this._lngRange && this._lngRange.length === 2 ? new ni([this._lngRange[0], this._latRange[0]], [this._lngRange[1], this._latRange[1]]) : null;
          }
          setMaxBounds(r) {
            r ? (this._lngRange = [r.getWest(), r.getEast()], this._latRange = [r.getSouth(), r.getNorth()], this._constrain()) : (this._lngRange = null, this._latRange = [-a.ai, a.ai]);
          }
          getConstrained(r, h) {
            return this._callbacks.getConstrained(r, h);
          }
          getCameraQueryGeometry(r, h) {
            if (h.length === 1) return [h[0], r];
            {
              const { minX: p, minY: g, maxX: y, maxY: x } = a.a2.fromPoints(h).extend(r);
              return [new a.P(p, g), new a.P(y, g), new a.P(y, x), new a.P(p, x), new a.P(p, g)];
            }
          }
          _constrain() {
            if (!this.center || !this._width || !this._height || this._constraining) return;
            this._constraining = !0;
            const r = this._unmodified, { center: h, zoom: p } = this.getConstrained(this.center, this.zoom);
            this.setCenter(h), this.setZoom(p), this._unmodified = r, this._constraining = !1;
          }
          _calcMatrices() {
            if (this._width && this._height) {
              this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
              let r = a.ag(new Float64Array(16));
              a.N(r, r, [this._width / 2, -this._height / 2, 1]), a.M(r, r, [1, -1, 0]), this._clipSpaceToPixelsMatrix = r, r = a.ag(new Float64Array(16)), a.N(r, r, [1, -1, 1]), a.M(r, r, [-1, -1, 0]), a.N(r, r, [2 / this._width, 2 / this._height, 1]), this._pixelsToClipSpaceMatrix = r, this._cameraToCenterDistance = 0.5 / Math.tan(this.fovInRadians / 2) * this._height;
            }
            this._callbacks.calcMatrices();
          }
          calculateCenterFromCameraLngLatAlt(r, h, p, g) {
            const y = p !== void 0 ? p : this.bearing, x = g = g !== void 0 ? g : this.pitch, E = a.a1.fromLngLat(r, h), C = -Math.cos(a.ae(x)), R = Math.sin(a.ae(x)), B = R * Math.sin(a.ae(y)), k = -R * Math.cos(a.ae(y));
            let O = this.elevation;
            const z = h - O;
            let H;
            C * z >= 0 || Math.abs(C) < 0.1 ? (H = 1e4, O = h + H * C) : H = -z / C;
            let Y, K, J = a.aQ(1, E.y), ie = 0;
            do {
              if (ie += 1, ie > 10) break;
              K = H / J, Y = new a.a1(E.x + B * K, E.y + k * K), J = 1 / Y.meterInMercatorCoordinateUnits();
            } while (Math.abs(H - K * J) > 1e-12);
            return { center: Y.toLngLat(), elevation: O, zoom: a.ak(this.height / 2 / Math.tan(this.fovInRadians / 2) / K / this.tileSize) };
          }
          recalculateZoomAndCenter(r) {
            if (this.elevation - r == 0) return;
            const h = a.aj(1, this.center.lat) * this.worldSize, p = this.cameraToCenterDistance / h, g = a.a1.fromLngLat(this.center, this.elevation), y = Pe(this.center, this.elevation, this.pitch, this.bearing, p);
            this._elevation = r;
            const x = this.calculateCenterFromCameraLngLatAlt(y.toLngLat(), a.aQ(y.z, g.y), this.bearing, this.pitch);
            this._elevation = x.elevation, this._center = x.center, this.setZoom(x.zoom);
          }
          getCameraPoint() {
            const r = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new a.P(r * Math.sin(this.rollInRadians), r * Math.cos(this.rollInRadians)));
          }
          getCameraAltitude() {
            return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation;
          }
          getCameraLngLat() {
            const r = a.aj(1, this.center.lat) * this.worldSize;
            return Pe(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / r).toLngLat();
          }
          getMercatorTileCoordinates(r) {
            if (!r) return [0, 0, 1, 1];
            const h = r.canonical.z >= 0 ? 1 << r.canonical.z : Math.pow(2, r.canonical.z);
            return [r.canonical.x / h, r.canonical.y / h, 1 / h / a.$, 1 / h / a.$];
          }
        }
        class or {
          constructor(r, h) {
            this.min = r, this.max = h, this.center = a.aR([], a.aS([], this.min, this.max), 0.5);
          }
          quadrant(r) {
            const h = [r % 2 == 0, r < 2], p = a.aT(this.min), g = a.aT(this.max);
            for (let y = 0; y < h.length; y++) p[y] = h[y] ? this.min[y] : this.center[y], g[y] = h[y] ? this.center[y] : this.max[y];
            return g[2] = this.max[2], new or(p, g);
          }
          distanceX(r) {
            return Math.max(Math.min(this.max[0], r[0]), this.min[0]) - r[0];
          }
          distanceY(r) {
            return Math.max(Math.min(this.max[1], r[1]), this.min[1]) - r[1];
          }
          intersectsFrustum(r) {
            let h = !0;
            for (let p = 0; p < r.planes.length; p++) {
              const g = this.intersectsPlane(r.planes[p]);
              if (g === 0) return 0;
              g === 1 && (h = !1);
            }
            return h ? 2 : r.aabb.min[0] > this.max[0] || r.aabb.min[1] > this.max[1] || r.aabb.min[2] > this.max[2] || r.aabb.max[0] < this.min[0] || r.aabb.max[1] < this.min[1] || r.aabb.max[2] < this.min[2] ? 0 : 1;
          }
          intersectsPlane(r) {
            let h = r[3], p = r[3];
            for (let g = 0; g < 3; g++) r[g] > 0 ? (h += r[g] * this.min[g], p += r[g] * this.max[g]) : (p += r[g] * this.min[g], h += r[g] * this.max[g]);
            return h >= 0 ? 2 : p < 0 ? 0 : 1;
          }
        }
        class Lr {
          distanceToTile2d(r, h, p, g) {
            const y = g.distanceX([r, h]), x = g.distanceY([r, h]);
            return Math.hypot(y, x);
          }
          getWrap(r, h, p) {
            return p;
          }
          getTileBoundingVolume(r, h, p, g) {
            var y, x;
            let E = 0, C = 0;
            if (g?.terrain) {
              const B = new a.Z(r.z, h, r.z, r.x, r.y), k = g.terrain.getMinMaxElevation(B);
              E = (y = k.minElevation) !== null && y !== void 0 ? y : Math.min(0, p), C = (x = k.maxElevation) !== null && x !== void 0 ? x : Math.max(0, p);
            }
            const R = 1 << r.z;
            return new or([h + r.x / R, r.y / R, E], [h + (r.x + 1) / R, (r.y + 1) / R, C]);
          }
          allowVariableZoom(r, h) {
            const p = r.fov * (Math.abs(Math.cos(r.rollInRadians)) * r.height + Math.abs(Math.sin(r.rollInRadians)) * r.width) / r.height, g = a.ah(78.5 - p / 2, 0, 60);
            return !!h.terrain || r.pitch > g;
          }
          allowWorldCopies() {
            return !0;
          }
          prepareNextFrame() {
          }
        }
        class Gi {
          constructor(r, h, p) {
            this.points = r, this.planes = h, this.aabb = p;
          }
          static fromInvProjectionMatrix(r, h = 1, p = 0, g, y) {
            const x = y ? [[6, 5, 4], [0, 1, 2], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]] : [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]], E = Math.pow(2, p), C = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map(((O) => (function(z, H, Y, K) {
              const J = a.aw([], z, H), ie = 1 / J[3] / Y * K;
              return a.aY(J, J, [ie, ie, 1 / J[3], ie]);
            })(O, r, h, E)));
            g && (function(O, z, H, Y) {
              const K = Y ? 4 : 0, J = Y ? 0 : 4;
              let ie = 0;
              const le = [], se = [];
              for (let oe = 0; oe < 4; oe++) {
                const be = a.aU([], O[oe + J], O[oe + K]), Fe = a.aZ(be);
                a.aR(be, be, 1 / Fe), le.push(Fe), se.push(be);
              }
              for (let oe = 0; oe < 4; oe++) {
                const be = a.a_(O[oe + K], se[oe], H);
                ie = be !== null && be >= 0 ? Math.max(ie, be) : Math.max(ie, le[oe]);
              }
              const he = (function(oe, be) {
                const Fe = a.aU([], oe[be[0]], oe[be[1]]), Ie = a.aU([], oe[be[2]], oe[be[1]]), Me = [0, 0, 0, 0];
                return a.aV(Me, a.aW([], Fe, Ie)), Me[3] = -a.aX(Me, oe[be[0]]), Me;
              })(O, z), fe = (function(oe, be) {
                const Fe = a.a$(oe), Ie = a.b0([], oe, 1 / Fe), Me = a.aU([], be, a.aR([], Ie, a.aX(be, Ie))), Oe = a.a$(Me);
                if (Oe > 0) {
                  const We = Math.sqrt(1 - Ie[3] * Ie[3]), qe = a.aR([], Ie, -Ie[3]), Ve = a.aS([], qe, a.aR([], Me, We / Oe));
                  return a.b1(be, Ve);
                }
                return null;
              })(H, he);
              if (fe !== null) {
                const oe = fe / a.aX(se[0], he);
                ie = Math.min(ie, oe);
              }
              for (let oe = 0; oe < 4; oe++) {
                const be = Math.min(ie, le[oe]);
                O[oe + J] = [O[oe + K][0] + se[oe][0] * be, O[oe + K][1] + se[oe][1] * be, O[oe + K][2] + se[oe][2] * be, 1];
              }
            })(C, x[0], g, y);
            const R = x.map(((O) => {
              const z = a.aU([], C[O[0]], C[O[1]]), H = a.aU([], C[O[2]], C[O[1]]), Y = a.aV([], a.aW([], z, H)), K = -a.aX(Y, C[O[1]]);
              return Y.concat(K);
            })), B = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY], k = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
            for (const O of C) for (let z = 0; z < 3; z++) B[z] = Math.min(B[z], O[z]), k[z] = Math.max(k[z], O[z]);
            return new Gi(C, R, new or(B, k));
          }
        }
        class oi {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(r) {
            this._helper.setMinZoom(r);
          }
          setMaxZoom(r) {
            this._helper.setMaxZoom(r);
          }
          setMinPitch(r) {
            this._helper.setMinPitch(r);
          }
          setMaxPitch(r) {
            this._helper.setMaxPitch(r);
          }
          setRenderWorldCopies(r) {
            this._helper.setRenderWorldCopies(r);
          }
          setBearing(r) {
            this._helper.setBearing(r);
          }
          setPitch(r) {
            this._helper.setPitch(r);
          }
          setRoll(r) {
            this._helper.setRoll(r);
          }
          setFov(r) {
            this._helper.setFov(r);
          }
          setZoom(r) {
            this._helper.setZoom(r);
          }
          setCenter(r) {
            this._helper.setCenter(r);
          }
          setElevation(r) {
            this._helper.setElevation(r);
          }
          setMinElevationForCurrentTile(r) {
            this._helper.setMinElevationForCurrentTile(r);
          }
          setPadding(r) {
            this._helper.setPadding(r);
          }
          interpolatePadding(r, h, p) {
            return this._helper.interpolatePadding(r, h, p);
          }
          isPaddingEqual(r) {
            return this._helper.isPaddingEqual(r);
          }
          resize(r, h, p = !0) {
            this._helper.resize(r, h, p);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(r) {
            this._helper.setMaxBounds(r);
          }
          overrideNearFarZ(r, h) {
            this._helper.overrideNearFarZ(r, h);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(r) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), r);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          setTransitionState(r, h) {
          }
          constructor(r, h, p, g, y) {
            this._posMatrixCache = /* @__PURE__ */ new Map(), this._alignedPosMatrixCache = /* @__PURE__ */ new Map(), this._fogMatrixCacheF32 = /* @__PURE__ */ new Map(), this._helper = new Nr({ calcMatrices: () => {
              this._calcMatrices();
            }, getConstrained: (x, E) => this.getConstrained(x, E) }, r, h, p, g, y), this._coveringTilesDetailsProvider = new Lr();
          }
          clone() {
            const r = new oi();
            return r.apply(this), r;
          }
          apply(r, h, p) {
            this._helper.apply(r, h, p);
          }
          get cameraPosition() {
            return this._cameraPosition;
          }
          get projectionMatrix() {
            return this._projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this._viewProjMatrix;
          }
          get inverseProjectionMatrix() {
            return this._invProjMatrix;
          }
          get mercatorMatrix() {
            return this._mercatorMatrix;
          }
          getVisibleUnwrappedCoordinates(r) {
            const h = [new a.b2(0, r)];
            if (this._helper._renderWorldCopies) {
              const p = this.screenPointToMercatorCoordinate(new a.P(0, 0)), g = this.screenPointToMercatorCoordinate(new a.P(this._helper._width, 0)), y = this.screenPointToMercatorCoordinate(new a.P(this._helper._width, this._helper._height)), x = this.screenPointToMercatorCoordinate(new a.P(0, this._helper._height)), E = Math.floor(Math.min(p.x, g.x, y.x, x.x)), C = Math.floor(Math.max(p.x, g.x, y.x, x.x)), R = 1;
              for (let B = E - R; B <= C + R; B++) B !== 0 && h.push(new a.b2(B, r));
            }
            return h;
          }
          getCameraFrustum() {
            return Gi.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize);
          }
          getClippingPlane() {
            return null;
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider;
          }
          recalculateZoomAndCenter(r) {
            const h = this.screenPointToLocation(this.centerPoint, r), p = r ? r.getElevationForLngLatZoom(h, this._helper._tileZoom) : 0;
            this._helper.recalculateZoomAndCenter(p);
          }
          setLocationAtPoint(r, h) {
            const p = a.aj(this.elevation, this.center.lat), g = this.screenPointToMercatorCoordinateAtZ(h, p), y = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, p), x = a.a1.fromLngLat(r), E = new a.a1(x.x - (g.x - y.x), x.y - (g.y - y.y));
            this.setCenter(E?.toLngLat()), this._helper._renderWorldCopies && this.setCenter(this.center.wrap());
          }
          locationToScreenPoint(r, h) {
            return h ? this.coordinatePoint(a.a1.fromLngLat(r), h.getElevationForLngLatZoom(r, this._helper._tileZoom), this._pixelMatrix3D) : this.coordinatePoint(a.a1.fromLngLat(r));
          }
          screenPointToLocation(r, h) {
            var p;
            return (p = this.screenPointToMercatorCoordinate(r, h)) === null || p === void 0 ? void 0 : p.toLngLat();
          }
          screenPointToMercatorCoordinate(r, h) {
            if (h) {
              const p = h.pointCoordinate(r);
              if (p != null) return p;
            }
            return this.screenPointToMercatorCoordinateAtZ(r);
          }
          screenPointToMercatorCoordinateAtZ(r, h) {
            const p = h || 0, g = [r.x, r.y, 0, 1], y = [r.x, r.y, 1, 1];
            a.aw(g, g, this._pixelMatrixInverse), a.aw(y, y, this._pixelMatrixInverse);
            const x = g[3], E = y[3], C = g[1] / x, R = y[1] / E, B = g[2] / x, k = y[2] / E, O = B === k ? 0 : (p - B) / (k - B);
            return new a.a1(a.C.number(g[0] / x, y[0] / E, O) / this.worldSize, a.C.number(C, R, O) / this.worldSize, p);
          }
          coordinatePoint(r, h = 0, p = this._pixelMatrix) {
            const g = [r.x * this.worldSize, r.y * this.worldSize, h, 1];
            return a.aw(g, g, p), new a.P(g[0] / g[3], g[1] / g[3]);
          }
          getBounds() {
            const r = Math.max(0, this._helper._height / 2 - pe(this));
            return new ni().extend(this.screenPointToLocation(new a.P(0, r))).extend(this.screenPointToLocation(new a.P(this._helper._width, r))).extend(this.screenPointToLocation(new a.P(this._helper._width, this._helper._height))).extend(this.screenPointToLocation(new a.P(0, this._helper._height)));
          }
          isPointOnMapSurface(r, h) {
            return h ? h.pointCoordinate(r) != null : r.y > this.height / 2 - pe(this);
          }
          calculatePosMatrix(r, h = !1, p) {
            var g;
            const y = (g = r.key) !== null && g !== void 0 ? g : a.b3(r.wrap, r.canonical.z, r.canonical.z, r.canonical.x, r.canonical.y), x = h ? this._alignedPosMatrixCache : this._posMatrixCache;
            if (x.has(y)) {
              const R = x.get(y);
              return p ? R.f32 : R.f64;
            }
            const E = ge(r, this.worldSize);
            a.O(E, h ? this._alignedProjMatrix : this._viewProjMatrix, E);
            const C = { f64: E, f32: new Float32Array(E) };
            return x.set(y, C), p ? C.f32 : C.f64;
          }
          calculateFogMatrix(r) {
            const h = r.key, p = this._fogMatrixCacheF32;
            if (p.has(h)) return p.get(h);
            const g = ge(r, this.worldSize);
            return a.O(g, this._fogMatrix, g), p.set(h, new Float32Array(g)), p.get(h);
          }
          getConstrained(r, h) {
            h = a.ah(+h, this.minZoom, this.maxZoom);
            const p = { center: new a.S(r.lng, r.lat), zoom: h };
            let g = this._helper._lngRange;
            if (!this._helper._renderWorldCopies && g === null) {
              const le = 179.9999999999;
              g = [-le, le];
            }
            const y = this.tileSize * a.af(p.zoom);
            let x = 0, E = y, C = 0, R = y, B = 0, k = 0;
            const { x: O, y: z } = this.size;
            if (this._helper._latRange) {
              const le = this._helper._latRange;
              x = a.U(le[1]) * y, E = a.U(le[0]) * y, E - x < z && (B = z / (E - x));
            }
            g && (C = a.aO(a.V(g[0]) * y, 0, y), R = a.aO(a.V(g[1]) * y, 0, y), R < C && (R += y), R - C < O && (k = O / (R - C)));
            const { x: H, y: Y } = q(y, r);
            let K, J;
            const ie = Math.max(k || 0, B || 0);
            if (ie) {
              const le = new a.P(k ? (R + C) / 2 : H, B ? (E + x) / 2 : Y);
              return p.center = ae(y, le).wrap(), p.zoom += a.ak(ie), p;
            }
            if (this._helper._latRange) {
              const le = z / 2;
              Y - le < x && (J = x + le), Y + le > E && (J = E - le);
            }
            if (g) {
              const le = (C + R) / 2;
              let se = H;
              this._helper._renderWorldCopies && (se = a.aO(H, le - y / 2, le + y / 2));
              const he = O / 2;
              se - he < C && (K = C + he), se + he > R && (K = R - he);
            }
            if (K !== void 0 || J !== void 0) {
              const le = new a.P(K ?? H, J ?? Y);
              p.center = ae(y, le).wrap();
            }
            return p;
          }
          calculateCenterFromCameraLngLatAlt(r, h, p, g) {
            return this._helper.calculateCenterFromCameraLngLatAlt(r, h, p, g);
          }
          _calculateNearFarZIfNeeded(r, h, p) {
            if (!this._helper.autoCalculateNearFarZ) return;
            const g = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100), y = r - g * this._helper._pixelPerMeter / Math.cos(h), x = g < 0 ? y : r, E = Math.PI / 2 + this.pitchInRadians, C = a.ae(this.fov) * (Math.abs(Math.cos(a.ae(this.roll))) * this.height + Math.abs(Math.sin(a.ae(this.roll))) * this.width) / this.height * (0.5 + p.y / this.height), R = Math.sin(C) * x / Math.sin(a.ah(Math.PI - E - C, 0.01, Math.PI - 0.01)), B = pe(this), k = Math.atan(B / this._helper.cameraToCenterDistance), O = a.ae(0.75), z = k > O ? 2 * k * (0.5 + p.y / (2 * B)) : O, H = Math.sin(z) * x / Math.sin(a.ah(Math.PI - E - z, 0.01, Math.PI - 0.01)), Y = Math.min(R, H);
            this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - h) * Y + x), this._helper._nearZ = this._helper._height / 50;
          }
          _calcMatrices() {
            if (!this._helper._height) return;
            const r = this.centerOffset, h = q(this.worldSize, this.center), p = h.x, g = h.y;
            this._helper._pixelPerMeter = a.aj(1, this.center.lat) * this.worldSize;
            const y = a.ae(Math.min(this.pitch, W)), x = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(y));
            let E;
            this._calculateNearFarZIfNeeded(x, y, r), E = new Float64Array(16), a.b4(E, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ), this._invProjMatrix = new Float64Array(16), a.aq(this._invProjMatrix, E), E[8] = 2 * -r.x / this._helper._width, E[9] = 2 * r.y / this._helper._height, this._projectionMatrix = a.b5(E), a.N(E, E, [1, -1, 1]), a.M(E, E, [0, 0, -this._helper.cameraToCenterDistance]), a.b6(E, E, -this.rollInRadians), a.b7(E, E, this.pitchInRadians), a.b6(E, E, -this.bearingInRadians), a.M(E, E, [-p, -g, 0]), this._mercatorMatrix = a.N([], E, [this.worldSize, this.worldSize, this.worldSize]), a.N(E, E, [1, 1, this._helper._pixelPerMeter]), this._pixelMatrix = a.O(new Float64Array(16), this.clipSpaceToPixelsMatrix, E), a.M(E, E, [0, 0, -this.elevation]), this._viewProjMatrix = E, this._invViewProjMatrix = a.aq([], E);
            const C = [0, 0, -1, 1];
            a.aw(C, C, this._invViewProjMatrix), this._cameraPosition = [C[0] / C[3], C[1] / C[3], C[2] / C[3]], this._fogMatrix = new Float64Array(16), a.b4(this._fogMatrix, this.fovInRadians, this.width / this.height, x, this._helper._farZ), this._fogMatrix[8] = 2 * -r.x / this.width, this._fogMatrix[9] = 2 * r.y / this.height, a.N(this._fogMatrix, this._fogMatrix, [1, -1, 1]), a.M(this._fogMatrix, this._fogMatrix, [0, 0, -this.cameraToCenterDistance]), a.b6(this._fogMatrix, this._fogMatrix, -this.rollInRadians), a.b7(this._fogMatrix, this._fogMatrix, this.pitchInRadians), a.b6(this._fogMatrix, this._fogMatrix, -this.bearingInRadians), a.M(this._fogMatrix, this._fogMatrix, [-p, -g, 0]), a.N(this._fogMatrix, this._fogMatrix, [1, 1, this._helper._pixelPerMeter]), a.M(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]), this._pixelMatrix3D = a.O(new Float64Array(16), this.clipSpaceToPixelsMatrix, E);
            const R = this._helper._width % 2 / 2, B = this._helper._height % 2 / 2, k = Math.cos(this.bearingInRadians), O = Math.sin(-this.bearingInRadians), z = p - Math.round(p) + k * R + O * B, H = g - Math.round(g) + k * B + O * R, Y = new Float64Array(E);
            if (a.M(Y, Y, [z > 0.5 ? z - 1 : z, H > 0.5 ? H - 1 : H, 0]), this._alignedProjMatrix = Y, E = a.aq(new Float64Array(16), this._pixelMatrix), !E) throw new Error("failed to invert matrix");
            this._pixelMatrixInverse = E, this._clearMatrixCaches();
          }
          _clearMatrixCaches() {
            this._posMatrixCache.clear(), this._alignedPosMatrixCache.clear(), this._fogMatrixCacheF32.clear();
          }
          maxPitchScaleFactor() {
            if (!this._pixelMatrixInverse) return 1;
            const r = this.screenPointToMercatorCoordinate(new a.P(0, 0)), h = [r.x * this.worldSize, r.y * this.worldSize, 0, 1];
            return a.aw(h, h, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance;
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            const r = a.aj(1, this.center.lat) * this.worldSize;
            return Pe(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / r).toLngLat();
          }
          lngLatToCameraDepth(r, h) {
            const p = a.a1.fromLngLat(r), g = [p.x * this.worldSize, p.y * this.worldSize, h, 1];
            return a.aw(g, g, this._viewProjMatrix), g[2] / g[3];
          }
          getProjectionData(r) {
            const { overscaledTileID: h, aligned: p, applyTerrainMatrix: g } = r, y = this._helper.getMercatorTileCoordinates(h), x = h ? this.calculatePosMatrix(h, p, !0) : null;
            let E;
            return E = h && h.terrainRttPosMatrix32f && g ? h.terrainRttPosMatrix32f : x || a.b8(), { mainMatrix: E, tileMercatorCoords: y, clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: E };
          }
          isLocationOccluded(r) {
            return !1;
          }
          getPixelScale() {
            return 1;
          }
          getCircleRadiusCorrection() {
            return 1;
          }
          getPitchedTextCorrection(r, h, p) {
            return 1;
          }
          transformLightDirection(r) {
            return a.aT(r);
          }
          getRayDirectionFromPixel(r) {
            throw new Error("Not implemented.");
          }
          projectTileCoordinates(r, h, p, g) {
            const y = this.calculatePosMatrix(p);
            let x;
            g ? (x = [r, h, g(r, h), 1], a.aw(x, x, y)) : (x = [r, h, 0, 1], Vn(x, x, y));
            const E = x[3];
            return { point: new a.P(x[0] / E, x[1] / E), signedDistanceFromCamera: E, isOccluded: !1 };
          }
          populateCache(r) {
            for (const h of r) this.calculatePosMatrix(h);
          }
          getMatrixForModel(r, h) {
            const p = a.a1.fromLngLat(r, h), g = p.meterInMercatorCoordinateUnits(), y = a.b9();
            return a.M(y, y, [p.x, p.y, p.z]), a.b6(y, y, Math.PI), a.b7(y, y, Math.PI / 2), a.N(y, y, [-g, g, g]), y;
          }
          getProjectionDataForCustomLayer(r = !0) {
            const h = new a.Z(0, 0, 0, 0, 0), p = this.getProjectionData({ overscaledTileID: h, applyGlobeMatrix: r }), g = ge(h, this.worldSize);
            a.O(g, this._viewProjMatrix, g), p.tileMercatorCoords = [0, 0, 1, 1];
            const y = [a.$, a.$, this.worldSize / this._helper.pixelsPerMeter], x = a.ba();
            return a.N(x, g, y), p.fallbackMatrix = x, p.mainMatrix = x, p;
          }
          getFastPathSimpleProjectionMatrix(r) {
            return this.calculatePosMatrix(r);
          }
        }
        function fd() {
          a.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
        }
        function Ur(m) {
          if (m.useSlerp) if (m.k < 1) {
            const r = a.bb(m.startEulerAngles.roll, m.startEulerAngles.pitch, m.startEulerAngles.bearing), h = a.bb(m.endEulerAngles.roll, m.endEulerAngles.pitch, m.endEulerAngles.bearing), p = new Float64Array(4);
            a.bc(p, r, h, m.k);
            const g = a.bd(p);
            m.tr.setRoll(g.roll), m.tr.setPitch(g.pitch), m.tr.setBearing(g.bearing);
          } else m.tr.setRoll(m.endEulerAngles.roll), m.tr.setPitch(m.endEulerAngles.pitch), m.tr.setBearing(m.endEulerAngles.bearing);
          else m.tr.setRoll(a.C.number(m.startEulerAngles.roll, m.endEulerAngles.roll, m.k)), m.tr.setPitch(a.C.number(m.startEulerAngles.pitch, m.endEulerAngles.pitch, m.k)), m.tr.setBearing(a.C.number(m.startEulerAngles.bearing, m.endEulerAngles.bearing, m.k));
        }
        function rs(m, r, h, p, g) {
          const y = g.padding, x = q(g.worldSize, h.getNorthWest()), E = q(g.worldSize, h.getNorthEast()), C = q(g.worldSize, h.getSouthEast()), R = q(g.worldSize, h.getSouthWest()), B = a.ae(-p), k = x.rotate(B), O = E.rotate(B), z = C.rotate(B), H = R.rotate(B), Y = new a.P(Math.max(k.x, O.x, H.x, z.x), Math.max(k.y, O.y, H.y, z.y)), K = new a.P(Math.min(k.x, O.x, H.x, z.x), Math.min(k.y, O.y, H.y, z.y)), J = Y.sub(K), ie = (g.width - (y.left + y.right + r.left + r.right)) / J.x, le = (g.height - (y.top + y.bottom + r.top + r.bottom)) / J.y;
          if (le < 0 || ie < 0) return void fd();
          const se = Math.min(a.ak(g.scale * Math.min(ie, le)), m.maxZoom), he = a.P.convert(m.offset), fe = new a.P((r.left - r.right) / 2, (r.top - r.bottom) / 2).rotate(a.ae(p)), oe = he.add(fe).mult(g.scale / a.af(se));
          return { center: ae(g.worldSize, x.add(C).div(2).sub(oe)), zoom: se, bearing: p };
        }
        class Cr {
          get useGlobeControls() {
            return !1;
          }
          handlePanInertia(r, h) {
            return { easingOffset: r, easingCenter: h.center };
          }
          handleMapControlsRollPitchBearingZoom(r, h) {
            r.bearingDelta && h.setBearing(h.bearing + r.bearingDelta), r.pitchDelta && h.setPitch(h.pitch + r.pitchDelta), r.rollDelta && h.setRoll(h.roll + r.rollDelta), r.zoomDelta && h.setZoom(h.zoom + r.zoomDelta);
          }
          handleMapControlsPan(r, h, p) {
            r.around.distSqr(h.centerPoint) < 0.01 || h.setLocationAtPoint(p, r.around);
          }
          cameraForBoxAndBearing(r, h, p, g, y) {
            return rs(r, h, p, g, y);
          }
          handleJumpToCenterZoom(r, h) {
            r.zoom !== (h.zoom !== void 0 ? +h.zoom : r.zoom) && r.setZoom(+h.zoom), h.center !== void 0 && r.setCenter(a.S.convert(h.center));
          }
          handleEaseTo(r, h) {
            const p = r.zoom, g = r.padding, y = { roll: r.roll, pitch: r.pitch, bearing: r.bearing }, x = { roll: h.roll === void 0 ? r.roll : h.roll, pitch: h.pitch === void 0 ? r.pitch : h.pitch, bearing: h.bearing === void 0 ? r.bearing : h.bearing }, E = h.zoom !== void 0, C = !r.isPaddingEqual(h.padding);
            let R = !1;
            const B = E ? +h.zoom : r.zoom;
            let k = r.centerPoint.add(h.offsetAsPoint);
            const O = r.screenPointToLocation(k), { center: z, zoom: H } = r.getConstrained(a.S.convert(h.center || O), B ?? p);
            kr(r, z);
            const Y = q(r.worldSize, O), K = q(r.worldSize, z).sub(Y), J = a.af(H - p);
            return R = H !== p, { easeFunc: (ie) => {
              if (R && r.setZoom(a.C.number(p, H, ie)), a.be(y, x) || Ur({ startEulerAngles: y, endEulerAngles: x, tr: r, k: ie, useSlerp: y.roll != x.roll }), C && (r.interpolatePadding(g, h.padding, ie), k = r.centerPoint.add(h.offsetAsPoint)), h.around) r.setLocationAtPoint(h.around, h.aroundPoint);
              else {
                const le = a.af(r.zoom - p), se = H > p ? Math.min(2, J) : Math.max(0.5, J), he = Math.pow(se, 1 - ie), fe = ae(r.worldSize, Y.add(K.mult(ie * he)).mult(le));
                r.setLocationAtPoint(r.renderWorldCopies ? fe.wrap() : fe, k);
              }
            }, isZooming: R, elevationCenter: z };
          }
          handleFlyTo(r, h) {
            const p = h.zoom !== void 0, g = r.zoom, y = r.getConstrained(a.S.convert(h.center || h.locationAtOffset), p ? +h.zoom : g), x = y.center, E = y.zoom;
            kr(r, x);
            const C = q(r.worldSize, h.locationAtOffset), R = q(r.worldSize, x).sub(C), B = R.mag(), k = a.af(E - g);
            let O;
            if (h.minZoom !== void 0) {
              const z = Math.min(+h.minZoom, g, E), H = r.getConstrained(x, z).zoom;
              O = a.af(H - g);
            }
            return { easeFunc: (z, H, Y, K) => {
              r.setZoom(z === 1 ? E : g + a.ak(H));
              const J = z === 1 ? x : ae(r.worldSize, C.add(R.mult(Y)).mult(H));
              r.setLocationAtPoint(r.renderWorldCopies ? J.wrap() : J, K);
            }, scaleOfZoom: k, targetCenter: x, scaleOfMinZoom: O, pixelPathLength: B };
          }
        }
        class ui {
          constructor(r, h, p) {
            this.blendFunction = r, this.blendColor = h, this.mask = p;
          }
        }
        ui.Replace = [1, 0], ui.disabled = new ui(ui.Replace, a.bf.transparent, [!1, !1, !1, !1]), ui.unblended = new ui(ui.Replace, a.bf.transparent, [!0, !0, !0, !0]), ui.alphaBlended = new ui([1, 771], a.bf.transparent, [!0, !0, !0, !0]);
        const uo = 2305;
        class vt {
          constructor(r, h, p) {
            this.enable = r, this.mode = h, this.frontFace = p;
          }
        }
        vt.disabled = new vt(!1, 1029, uo), vt.backCCW = new vt(!0, 1029, uo), vt.frontCCW = new vt(!0, 1028, uo);
        class Mt {
          constructor(r, h, p) {
            this.func = r, this.mask = h, this.range = p;
          }
        }
        Mt.ReadOnly = !1, Mt.ReadWrite = !0, Mt.disabled = new Mt(519, Mt.ReadOnly, [0, 1]);
        const mn = 7680;
        class Vt {
          constructor(r, h, p, g, y, x) {
            this.test = r, this.ref = h, this.mask = p, this.fail = g, this.depthFail = y, this.pass = x;
          }
        }
        Vt.disabled = new Vt({ func: 519, mask: 0 }, 0, 0, mn, mn, mn);
        const ss = /* @__PURE__ */ new WeakMap();
        function rn(m) {
          var r;
          if (ss.has(m)) return ss.get(m);
          {
            const h = (r = m.getParameter(m.VERSION)) === null || r === void 0 ? void 0 : r.startsWith("WebGL 2.0");
            return ss.set(m, h), h;
          }
        }
        class sn {
          get awaitingQuery() {
            return !!this._readbackQueue;
          }
          constructor(r) {
            this._readbackWaitFrames = 4, this._measureWaitFrames = 6, this._texWidth = 1, this._texHeight = 1, this._measuredError = 0, this._updateCount = 0, this._lastReadbackFrame = -1e3, this._readbackQueue = null, this._cachedRenderContext = r;
            const h = r.context, p = h.gl;
            this._texFormat = p.RGBA, this._texType = p.UNSIGNED_BYTE;
            const g = new a.aL();
            g.emplaceBack(-1, -1), g.emplaceBack(2, -1), g.emplaceBack(-1, 2);
            const y = new a.aN();
            y.emplaceBack(0, 1, 2), this._fullscreenTriangle = new $e(h.createVertexBuffer(g, at.members), h.createIndexBuffer(y), a.aM.simpleSegment(0, 0, g.length, y.length)), this._resultBuffer = new Uint8Array(4), h.activeTexture.set(p.TEXTURE1);
            const x = p.createTexture();
            p.bindTexture(p.TEXTURE_2D, x), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_S, p.CLAMP_TO_EDGE), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_T, p.CLAMP_TO_EDGE), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MIN_FILTER, p.NEAREST), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MAG_FILTER, p.NEAREST), p.texImage2D(p.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null), this._fbo = h.createFramebuffer(this._texWidth, this._texHeight, !1, !1), this._fbo.colorAttachment.set(x), rn(p) && (this._pbo = p.createBuffer(), p.bindBuffer(p.PIXEL_PACK_BUFFER, this._pbo), p.bufferData(p.PIXEL_PACK_BUFFER, 4, p.STREAM_READ), p.bindBuffer(p.PIXEL_PACK_BUFFER, null));
          }
          destroy() {
            const r = this._cachedRenderContext.context.gl;
            this._fullscreenTriangle.destroy(), this._fbo.destroy(), r.deleteBuffer(this._pbo), this._fullscreenTriangle = null, this._fbo = null, this._pbo = null, this._resultBuffer = null;
          }
          updateErrorLoop(r, h) {
            const p = this._updateCount;
            return this._readbackQueue ? p >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : p >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(r, h), this._updateCount++, this._measuredError;
          }
          _bindFramebuffer() {
            const r = this._cachedRenderContext.context, h = r.gl;
            r.activeTexture.set(h.TEXTURE1), h.bindTexture(h.TEXTURE_2D, this._fbo.colorAttachment.get()), r.bindFramebuffer.set(this._fbo.framebuffer);
          }
          _renderErrorTexture(r, h) {
            const p = this._cachedRenderContext.context, g = p.gl;
            if (this._bindFramebuffer(), p.viewport.set([0, 0, this._texWidth, this._texHeight]), p.clear({ color: a.bf.transparent }), this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(p, g.TRIANGLES, Mt.disabled, Vt.disabled, ui.unblended, vt.disabled, /* @__PURE__ */ ((y, x) => ({ u_input: y, u_output_expected: x }))(r, h), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments), this._pbo && rn(g)) {
              g.bindBuffer(g.PIXEL_PACK_BUFFER, this._pbo), g.readBuffer(g.COLOR_ATTACHMENT0), g.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0), g.bindBuffer(g.PIXEL_PACK_BUFFER, null);
              const y = g.fenceSync(g.SYNC_GPU_COMMANDS_COMPLETE, 0);
              g.flush(), this._readbackQueue = { frameNumberIssued: this._updateCount, sync: y };
            } else this._readbackQueue = { frameNumberIssued: this._updateCount, sync: null };
          }
          _tryReadback() {
            const r = this._cachedRenderContext.context.gl;
            if (this._pbo && this._readbackQueue && rn(r)) {
              const h = r.clientWaitSync(this._readbackQueue.sync, 0, 0);
              if (h === r.WAIT_FAILED) return a.w("WebGL2 clientWaitSync failed."), this._readbackQueue = null, void (this._lastReadbackFrame = this._updateCount);
              if (h === r.TIMEOUT_EXPIRED) return;
              r.bindBuffer(r.PIXEL_PACK_BUFFER, this._pbo), r.getBufferSubData(r.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4), r.bindBuffer(r.PIXEL_PACK_BUFFER, null);
            } else this._bindFramebuffer(), r.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
            this._readbackQueue = null, this._measuredError = sn._parseRGBA8float(this._resultBuffer), this._lastReadbackFrame = this._updateCount;
          }
          static _parseRGBA8float(r) {
            let h = 0;
            return h += r[0] / 256, h += r[1] / 65536, h += r[2] / 16777216, r[3] < 127 && (h = -h), h / 128;
          }
        }
        const kl = a.$ / 128;
        function bh(m, r) {
          const h = m.granularity !== void 0 ? Math.max(m.granularity, 1) : 1, p = h + (m.generateBorders ? 2 : 0), g = h + (m.extendToNorthPole || m.generateBorders ? 1 : 0) + (m.extendToSouthPole || m.generateBorders ? 1 : 0), y = p + 1, x = g + 1, E = m.generateBorders ? -1 : 0, C = m.generateBorders || m.extendToNorthPole ? -1 : 0, R = h + (m.generateBorders ? 1 : 0), B = h + (m.generateBorders || m.extendToSouthPole ? 1 : 0), k = y * x, O = p * g * 6, z = y * x > 65536;
          if (z && r === "16bit") throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices.");
          const H = z || r === "32bit", Y = new Int16Array(2 * k);
          let K = 0;
          for (let le = C; le <= B; le++) for (let se = E; se <= R; se++) {
            let he = se / h * a.$;
            se === -1 && (he = -kl), se === h + 1 && (he = a.$ + kl);
            let fe = le / h * a.$;
            le === -1 && (fe = m.extendToNorthPole ? a.bh : -kl), le === h + 1 && (fe = m.extendToSouthPole ? a.bi : a.$ + kl), Y[K++] = he, Y[K++] = fe;
          }
          const J = H ? new Uint32Array(O) : new Uint16Array(O);
          let ie = 0;
          for (let le = 0; le < g; le++) for (let se = 0; se < p; se++) {
            const he = se + 1 + le * y, fe = se + (le + 1) * y, oe = se + 1 + (le + 1) * y;
            J[ie++] = se + le * y, J[ie++] = fe, J[ie++] = he, J[ie++] = he, J[ie++] = fe, J[ie++] = oe;
          }
          return { vertices: Y.buffer.slice(0), indices: J.buffer.slice(0), uses32bitIndices: H };
        }
        const Ho = new a.aK({ fill: new a.bj(128, 2), line: new a.bj(512, 0), tile: new a.bj(128, 32), stencil: new a.bj(128, 1), circle: 3 });
        class Na {
          constructor() {
            this._tileMeshCache = {}, this._errorCorrectionUsable = 0, this._errorMeasurementLastValue = 0, this._errorCorrectionPreviousValue = 0, this._errorMeasurementLastChangeTime = -1e3;
          }
          get name() {
            return "vertical-perspective";
          }
          get transitionState() {
            return 1;
          }
          get useSubdivision() {
            return !0;
          }
          get shaderVariantName() {
            return "globe";
          }
          get shaderDefine() {
            return "#define GLOBE";
          }
          get shaderPreludeCode() {
            return ue.projectionGlobe;
          }
          get vertexShaderPreludeCode() {
            return ue.projectionMercator.vertexSource;
          }
          get subdivisionGranularity() {
            return Ho;
          }
          get useGlobeControls() {
            return !0;
          }
          get latitudeErrorCorrectionRadians() {
            return this._errorCorrectionUsable;
          }
          destroy() {
            this._errorMeasurement && this._errorMeasurement.destroy();
          }
          updateGPUdependent(r) {
            this._errorMeasurement || (this._errorMeasurement = new sn(r));
            const h = a.U(this._errorQueryLatitudeDegrees), p = 2 * Math.atan(Math.exp(Math.PI - h * Math.PI * 2)) - 0.5 * Math.PI, g = this._errorMeasurement.updateErrorLoop(h, p), y = N.now();
            g !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable, this._errorMeasurementLastValue = g, this._errorMeasurementLastChangeTime = y);
            const x = Math.min(Math.max((y - this._errorMeasurementLastChangeTime) / 1e3 / 0.5, 0), 1);
            this._errorCorrectionUsable = a.bk(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, a.bl(x));
          }
          _getMeshKey(r) {
            return `${r.granularity.toString(36)}_${r.generateBorders ? "b" : ""}${r.extendToNorthPole ? "n" : ""}${r.extendToSouthPole ? "s" : ""}`;
          }
          getMeshFromTileID(r, h, p, g, y) {
            const x = (y === "stencil" ? Ho.stencil : Ho.tile).getGranularityForZoomLevel(h.z);
            return this._getMesh(r, { granularity: x, generateBorders: p, extendToNorthPole: h.y === 0 && g, extendToSouthPole: h.y === (1 << h.z) - 1 && g });
          }
          _getMesh(r, h) {
            const p = this._getMeshKey(h);
            if (p in this._tileMeshCache) return this._tileMeshCache[p];
            const g = (function(y, x) {
              const E = bh(x, "16bit"), C = a.aL.deserialize({ arrayBuffer: E.vertices, length: E.vertices.byteLength / 2 / 2 }), R = a.aN.deserialize({ arrayBuffer: E.indices, length: E.indices.byteLength / 2 / 3 });
              return new $e(y.createVertexBuffer(C, at.members), y.createIndexBuffer(R), a.aM.simpleSegment(0, 0, C.length, R.length));
            })(r, h);
            return this._tileMeshCache[p] = g, g;
          }
          recalculate(r) {
          }
          hasTransition() {
            const r = N.now();
            let h = !1;
            return h = h || (r - this._errorMeasurementLastChangeTime) / 1e3 < 0.7, h = h || this._errorMeasurement && this._errorMeasurement.awaitingQuery, h;
          }
          setErrorQueryLatitudeDegrees(r) {
            this._errorQueryLatitudeDegrees = r;
          }
        }
        const Nl = new a.r({ type: new a.D(a.v.projection.type) });
        class Ll extends a.E {
          constructor(r) {
            super(), this._transitionable = new a.t(Nl), this.setProjection(r), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new a.F(0)), this._mercatorProjection = new mt(), this._verticalPerspectiveProjection = new Na();
          }
          get transitionState() {
            const r = this.properties.get("type");
            if (typeof r == "string" && r === "mercator") return 0;
            if (typeof r == "string" && r === "vertical-perspective") return 1;
            if (r instanceof a.bm) {
              if (r.from === "vertical-perspective" && r.to === "mercator") return 1 - r.transition;
              if (r.from === "mercator" && r.to === "vertical-perspective") return r.transition;
            }
            return 1;
          }
          get useGlobeRendering() {
            return this.transitionState > 0;
          }
          get latitudeErrorCorrectionRadians() {
            return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians;
          }
          get currentProjection() {
            return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection;
          }
          get name() {
            return "globe";
          }
          get useSubdivision() {
            return this.currentProjection.useSubdivision;
          }
          get shaderVariantName() {
            return this.currentProjection.shaderVariantName;
          }
          get shaderDefine() {
            return this.currentProjection.shaderDefine;
          }
          get shaderPreludeCode() {
            return this.currentProjection.shaderPreludeCode;
          }
          get vertexShaderPreludeCode() {
            return this.currentProjection.vertexShaderPreludeCode;
          }
          get subdivisionGranularity() {
            return this.currentProjection.subdivisionGranularity;
          }
          get useGlobeControls() {
            return this.transitionState > 0;
          }
          destroy() {
            this._mercatorProjection.destroy(), this._verticalPerspectiveProjection.destroy();
          }
          updateGPUdependent(r) {
            this._mercatorProjection.updateGPUdependent(r), this._verticalPerspectiveProjection.updateGPUdependent(r);
          }
          getMeshFromTileID(r, h, p, g, y) {
            return this.currentProjection.getMeshFromTileID(r, h, p, g, y);
          }
          setProjection(r) {
            this._transitionable.setValue("type", r?.type || "mercator");
          }
          updateTransitions(r) {
            this._transitioning = this._transitionable.transitioned(r, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition() || this.currentProjection.hasTransition();
          }
          recalculate(r) {
            this.properties = this._transitioning.possiblyEvaluate(r);
          }
          setErrorQueryLatitudeDegrees(r) {
            this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(r), this._mercatorProjection.setErrorQueryLatitudeDegrees(r);
          }
        }
        function Ul(m) {
          const r = $o(m.worldSize, m.center.lat);
          return 2 * Math.PI * r;
        }
        function Rs(m, r, h, p, g) {
          const y = 1 / (1 << g), x = r / a.$ * y + p * y, E = a.bo((m / a.$ * y + h * y) * Math.PI * 2 + Math.PI, 2 * Math.PI), C = 2 * Math.atan(Math.exp(Math.PI - x * Math.PI * 2)) - 0.5 * Math.PI, R = Math.cos(C), B = new Float64Array(3);
          return B[0] = Math.sin(E) * R, B[1] = Math.sin(C), B[2] = Math.cos(E) * R, B;
        }
        function ar(m) {
          return (function(r, h) {
            const p = Math.cos(h), g = new Float64Array(3);
            return g[0] = Math.sin(r) * p, g[1] = Math.sin(h), g[2] = Math.cos(r) * p, g;
          })(m.lng * Math.PI / 180, m.lat * Math.PI / 180);
        }
        function $o(m, r) {
          return m / (2 * Math.PI) / Math.cos(r * Math.PI / 180);
        }
        function La(m) {
          const r = Math.asin(m[1]) / Math.PI * 180, h = Math.sqrt(m[0] * m[0] + m[2] * m[2]);
          if (h > 1e-6) {
            const p = m[0] / h, g = Math.acos(m[2] / h), y = (p > 0 ? g : -g) / Math.PI * 180;
            return new a.S(a.aO(y, -180, 180), r);
          }
          return new a.S(0, r);
        }
        function fo(m) {
          return Math.cos(m * Math.PI / 180);
        }
        function Bi(m, r) {
          const h = fo(m), p = fo(r);
          return a.ak(p / h);
        }
        function pd(m, r) {
          const h = m.rotate(r.bearingInRadians), p = r.zoom + Bi(r.center.lat, 0), g = a.bk(1 / fo(r.center.lat), 1 / fo(Math.min(Math.abs(r.center.lat), 60)), a.bn(p, 7, 3, 0, 1)), y = 360 / Ul({ worldSize: r.worldSize, center: { lat: r.center.lat } });
          return new a.S(r.center.lng - h.x * y * g, a.ah(r.center.lat + h.y * y, -a.ai, a.ai));
        }
        function Ua(m) {
          const r = 0.5 * m, h = Math.sin(r), p = Math.cos(r);
          return Math.log(h + p) - Math.log(p - h);
        }
        function vh(m, r, h, p) {
          const g = m.lat + h * p;
          if (Math.abs(h) > 1) {
            const y = (Math.sign(m.lat + h) !== Math.sign(m.lat) ? -Math.abs(m.lat) : Math.abs(m.lat)) * Math.PI / 180, x = Math.abs(m.lat + h) * Math.PI / 180, E = Ua(y + p * (x - y)), C = Ua(y), R = Ua(x);
            return new a.S(m.lng + r * ((E - C) / (R - C)), g);
          }
          return new a.S(m.lng + r * p, g);
        }
        class $p {
          constructor(r) {
            this._cachePrevious = /* @__PURE__ */ new Map(), this._cache = /* @__PURE__ */ new Map(), this._hadAnyChanges = !1, this._boundingVolumeFactory = r;
          }
          swapBuffers() {
            if (!this._hadAnyChanges) return;
            const r = this._cachePrevious;
            this._cachePrevious = this._cache, this._cache = r, this._cache.clear(), this._hadAnyChanges = !1;
          }
          getTileBoundingVolume(r, h, p, g) {
            const y = `${r.z}_${r.x}_${r.y}_${g?.terrain ? "t" : ""}`, x = this._cache.get(y);
            if (x) return x;
            const E = this._cachePrevious.get(y);
            if (E) return this._cache.set(y, E), E;
            const C = this._boundingVolumeFactory(r, h, p, g);
            return this._cache.set(y, C), this._hadAnyChanges = !0, C;
          }
        }
        class Go {
          constructor(r, h, p, g) {
            this.min = p, this.max = g, this.points = r, this.planes = h;
          }
          static fromAabb(r, h) {
            const p = [];
            for (let g = 0; g < 8; g++) p.push([1 & ~g ? r[0] : h[0], (g >> 1 & 1) == 1 ? h[1] : r[1], (g >> 2 & 1) == 1 ? h[2] : r[2]]);
            return new Go(p, [[-1, 0, 0, h[0]], [1, 0, 0, -r[0]], [0, -1, 0, h[1]], [0, 1, 0, -r[1]], [0, 0, -1, h[2]], [0, 0, 1, -r[2]]], r, h);
          }
          static fromCenterSizeAngles(r, h, p) {
            const g = a.br([], p[0], p[1], p[2]), y = a.bs([], [h[0], 0, 0], g), x = a.bs([], [0, h[1], 0], g), E = a.bs([], [0, 0, h[2]], g), C = [...r], R = [...r];
            for (let k = 0; k < 8; k++) for (let O = 0; O < 3; O++) {
              const z = r[O] + y[O] * (1 & ~k ? -1 : 1) + x[O] * ((k >> 1 & 1) == 1 ? 1 : -1) + E[O] * ((k >> 2 & 1) == 1 ? 1 : -1);
              C[O] = Math.min(C[O], z), R[O] = Math.max(R[O], z);
            }
            const B = [];
            for (let k = 0; k < 8; k++) {
              const O = [...r];
              a.aS(O, O, a.aR([], y, 1 & ~k ? -1 : 1)), a.aS(O, O, a.aR([], x, (k >> 1 & 1) == 1 ? 1 : -1)), a.aS(O, O, a.aR([], E, (k >> 2 & 1) == 1 ? 1 : -1)), B.push(O);
            }
            return new Go(B, [[...y, -a.aX(y, B[0])], [...x, -a.aX(x, B[0])], [...E, -a.aX(E, B[0])], [-y[0], -y[1], -y[2], -a.aX(y, B[7])], [-x[0], -x[1], -x[2], -a.aX(x, B[7])], [-E[0], -E[1], -E[2], -a.aX(E, B[7])]], C, R);
          }
          intersectsFrustum(r) {
            let h = !0;
            const p = this.points.length, g = this.planes.length, y = r.planes.length, x = r.points.length;
            for (let E = 0; E < y; E++) {
              const C = r.planes[E];
              let R = 0;
              for (let B = 0; B < p; B++) {
                const k = this.points[B];
                C[0] * k[0] + C[1] * k[1] + C[2] * k[2] + C[3] >= 0 && R++;
              }
              if (R === 0) return 0;
              R < p && (h = !1);
            }
            if (h) return 2;
            for (let E = 0; E < g; E++) {
              const C = this.planes[E];
              let R = 0;
              for (let B = 0; B < x; B++) {
                const k = r.points[B];
                C[0] * k[0] + C[1] * k[1] + C[2] * k[2] + C[3] >= 0 && R++;
              }
              if (R === 0) return 0;
            }
            return 1;
          }
          intersectsPlane(r) {
            const h = this.points.length;
            let p = 0;
            for (let g = 0; g < h; g++) {
              const y = this.points[g];
              r[0] * y[0] + r[1] * y[1] + r[2] * y[2] + r[3] >= 0 && p++;
            }
            return p === h ? 2 : p === 0 ? 0 : 1;
          }
        }
        function br(m, r, h) {
          const p = m - r;
          return p < 0 ? -p : Math.max(0, p - h);
        }
        function za(m, r, h, p, g) {
          const y = m - h;
          let x;
          return x = y < 0 ? Math.min(-y, 1 + y - g) : y > 1 ? Math.min(Math.max(y - g, 0), 1 - y) : 0, Math.max(x, br(r, p, g));
        }
        class nn {
          constructor() {
            this._boundingVolumeCache = new $p(this._computeTileBoundingVolume);
          }
          prepareNextFrame() {
            this._boundingVolumeCache.swapBuffers();
          }
          distanceToTile2d(r, h, p, g) {
            const y = 1 << p.z, x = 1 / y, E = p.x / y, C = p.y / y;
            let R = 2;
            return R = Math.min(R, za(r, h, E, C, x)), R = Math.min(R, za(r, h, E + 0.5, -C - x, x)), R = Math.min(R, za(r, h, E + 0.5, 2 - C - x, x)), R;
          }
          getWrap(r, h, p) {
            const g = 1 << h.z, y = 1 / g, x = h.x / g, E = br(r.x, x, y), C = br(r.x, x - 1, y), R = br(r.x, x + 1, y), B = Math.min(E, C, R);
            return B === R ? 1 : B === C ? -1 : 0;
          }
          allowVariableZoom(r, h) {
            return lt(r, h) > 4;
          }
          allowWorldCopies() {
            return !1;
          }
          getTileBoundingVolume(r, h, p, g) {
            return this._boundingVolumeCache.getTileBoundingVolume(r, h, p, g);
          }
          _computeTileBoundingVolume(r, h, p, g) {
            var y, x;
            let E = 0, C = 0;
            if (g?.terrain) {
              const R = new a.Z(r.z, h, r.z, r.x, r.y), B = g.terrain.getMinMaxElevation(R);
              E = (y = B.minElevation) !== null && y !== void 0 ? y : Math.min(0, p), C = (x = B.maxElevation) !== null && x !== void 0 ? x : Math.max(0, p);
            }
            if (E /= a.bu, C /= a.bu, E += 1, C += 1, r.z <= 0) return Go.fromAabb([-C, -C, -C], [C, C, C]);
            if (r.z === 1) return Go.fromAabb([r.x === 0 ? -C : 0, r.y === 0 ? 0 : -C, -C], [r.x === 0 ? 0 : C, r.y === 0 ? C : 0, C]);
            {
              const R = [Rs(0, 0, r.x, r.y, r.z), Rs(a.$, 0, r.x, r.y, r.z), Rs(a.$, a.$, r.x, r.y, r.z), Rs(0, a.$, r.x, r.y, r.z)], B = [];
              for (const Me of R) B.push(a.aR([], Me, C));
              if (C !== E) for (const Me of R) B.push(a.aR([], Me, E));
              r.y === 0 && B.push([0, 1, 0]), r.y === (1 << r.z) - 1 && B.push([0, -1, 0]);
              const k = [1, 1, 1], O = [-1, -1, -1];
              for (const Me of B) for (let Oe = 0; Oe < 3; Oe++) k[Oe] = Math.min(k[Oe], Me[Oe]), O[Oe] = Math.max(O[Oe], Me[Oe]);
              const z = Rs(a.$ / 2, a.$ / 2, r.x, r.y, r.z), H = a.aW([], [0, 1, 0], z);
              a.aV(H, H);
              const Y = a.aW([], z, H);
              a.aV(Y, Y);
              const K = a.aW([], R[2], R[1]);
              a.aV(K, K);
              const J = a.aW([], R[0], R[3]);
              a.aV(J, J), B.push(a.aR([], z, C)), r.y >= (1 << r.z) / 2 && B.push(a.aR([], Rs(a.$ / 2, 0, r.x, r.y, r.z), C)), r.y < (1 << r.z) / 2 && B.push(a.aR([], Rs(a.$ / 2, a.$, r.x, r.y, r.z), C));
              const ie = Va(z, B), le = Va(Y, B), se = [-z[0], -z[1], -z[2], ie.max], he = [z[0], z[1], z[2], -ie.min], fe = [-Y[0], -Y[1], -Y[2], le.max], oe = [Y[0], Y[1], Y[2], -le.min], be = [...K, 0], Fe = [...J, 0], Ie = [];
              return r.y === 0 ? Ie.push(a.bt(Fe, be, se), a.bt(Fe, be, he)) : Ie.push(a.bt(fe, be, se), a.bt(fe, be, he), a.bt(fe, Fe, se), a.bt(fe, Fe, he)), r.y === (1 << r.z) - 1 ? Ie.push(a.bt(Fe, be, se), a.bt(Fe, be, he)) : Ie.push(a.bt(oe, be, se), a.bt(oe, be, he), a.bt(oe, Fe, se), a.bt(oe, Fe, he)), new Go(Ie, [se, he, fe, oe, be, Fe], k, O);
            }
          }
        }
        function Va(m, r) {
          let h = 1 / 0, p = -1 / 0;
          for (const g of r) {
            const y = a.aX(m, g);
            h = Math.min(h, y), p = Math.max(p, y);
          }
          return { min: h, max: p };
        }
        class ja {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(r) {
            this._helper.setMinZoom(r);
          }
          setMaxZoom(r) {
            this._helper.setMaxZoom(r);
          }
          setMinPitch(r) {
            this._helper.setMinPitch(r);
          }
          setMaxPitch(r) {
            this._helper.setMaxPitch(r);
          }
          setRenderWorldCopies(r) {
            this._helper.setRenderWorldCopies(r);
          }
          setBearing(r) {
            this._helper.setBearing(r);
          }
          setPitch(r) {
            this._helper.setPitch(r);
          }
          setRoll(r) {
            this._helper.setRoll(r);
          }
          setFov(r) {
            this._helper.setFov(r);
          }
          setZoom(r) {
            this._helper.setZoom(r);
          }
          setCenter(r) {
            this._helper.setCenter(r);
          }
          setElevation(r) {
            this._helper.setElevation(r);
          }
          setMinElevationForCurrentTile(r) {
            this._helper.setMinElevationForCurrentTile(r);
          }
          setPadding(r) {
            this._helper.setPadding(r);
          }
          interpolatePadding(r, h, p) {
            return this._helper.interpolatePadding(r, h, p);
          }
          isPaddingEqual(r) {
            return this._helper.isPaddingEqual(r);
          }
          resize(r, h) {
            this._helper.resize(r, h);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(r) {
            this._helper.setMaxBounds(r);
          }
          overrideNearFarZ(r, h) {
            this._helper.overrideNearFarZ(r, h);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(r) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), r);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          setTransitionState(r) {
          }
          constructor() {
            this._cachedClippingPlane = a.bv(), this._projectionMatrix = a.b9(), this._globeViewProjMatrix32f = a.b8(), this._globeViewProjMatrixNoCorrection = a.b9(), this._globeViewProjMatrixNoCorrectionInverted = a.b9(), this._globeProjMatrixInverted = a.b9(), this._cameraPosition = a.bp(), this._globeLatitudeErrorCorrectionRadians = 0, this._helper = new Nr({ calcMatrices: () => {
              this._calcMatrices();
            }, getConstrained: (r, h) => this.getConstrained(r, h) }), this._coveringTilesDetailsProvider = new nn();
          }
          clone() {
            const r = new ja();
            return r.apply(this), r;
          }
          apply(r, h) {
            this._globeLatitudeErrorCorrectionRadians = h || 0, this._helper.apply(r);
          }
          get projectionMatrix() {
            return this._projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this._globeViewProjMatrixNoCorrection;
          }
          get inverseProjectionMatrix() {
            return this._globeProjMatrixInverted;
          }
          get cameraPosition() {
            const r = a.bp();
            return r[0] = this._cameraPosition[0], r[1] = this._cameraPosition[1], r[2] = this._cameraPosition[2], r;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          getProjectionData(r) {
            const { overscaledTileID: h, applyGlobeMatrix: p } = r, g = this._helper.getMercatorTileCoordinates(h);
            return { mainMatrix: this._globeViewProjMatrix32f, tileMercatorCoords: g, clippingPlane: this._cachedClippingPlane, projectionTransition: p ? 1 : 0, fallbackMatrix: this._globeViewProjMatrix32f };
          }
          _computeClippingPlane(r) {
            const h = this.pitchInRadians, p = this.cameraToCenterDistance / r, g = Math.sin(h) * p, y = Math.cos(h) * p + 1, x = 1 / Math.sqrt(g * g + y * y) * 1;
            let E = -g, C = y;
            const R = Math.sqrt(E * E + C * C);
            E /= R, C /= R;
            const B = [0, E, C];
            a.bw(B, B, [0, 0, 0], -this.bearingInRadians), a.bx(B, B, [0, 0, 0], -1 * this.center.lat * Math.PI / 180), a.by(B, B, [0, 0, 0], this.center.lng * Math.PI / 180);
            const k = 1 / a.aZ(B);
            return a.aR(B, B, k), [...B, -x * k];
          }
          isLocationOccluded(r) {
            return !this.isSurfacePointVisible(ar(r));
          }
          transformLightDirection(r) {
            const h = this._helper._center.lng * Math.PI / 180, p = this._helper._center.lat * Math.PI / 180, g = Math.cos(p), y = [Math.sin(h) * g, Math.sin(p), Math.cos(h) * g], x = [y[2], 0, -y[0]], E = [0, 0, 0];
            a.aW(E, x, y), a.aV(x, x), a.aV(E, E);
            const C = [0, 0, 0];
            return a.aV(C, [x[0] * r[0] + E[0] * r[1] + y[0] * r[2], x[1] * r[0] + E[1] * r[1] + y[1] * r[2], x[2] * r[0] + E[2] * r[1] + y[2] * r[2]]), C;
          }
          getPixelScale() {
            return 1 / Math.cos(this._helper._center.lat * Math.PI / 180);
          }
          getCircleRadiusCorrection() {
            return Math.cos(this._helper._center.lat * Math.PI / 180);
          }
          getPitchedTextCorrection(r, h, p) {
            const g = (function(E, C, R) {
              const B = 1 / (1 << R.z);
              return new a.a1(E / a.$ * B + R.x * B, C / a.$ * B + R.y * B);
            })(r, h, p.canonical), y = (x = g.y, [a.bo(g.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - x * Math.PI * 2)) - 0.5 * Math.PI]);
            var x;
            return this.getCircleRadiusCorrection() / Math.cos(y[1]);
          }
          projectTileCoordinates(r, h, p, g) {
            const y = p.canonical, x = Rs(r, h, y.x, y.y, y.z), E = 1 + (g ? g(r, h) : 0) / a.bu, C = [x[0] * E, x[1] * E, x[2] * E, 1];
            a.aw(C, C, this._globeViewProjMatrixNoCorrection);
            const R = this._cachedClippingPlane, B = R[0] * x[0] + R[1] * x[1] + R[2] * x[2] + R[3] < 0;
            return { point: new a.P(C[0] / C[3], C[1] / C[3]), signedDistanceFromCamera: C[3], isOccluded: B };
          }
          _calcMatrices() {
            if (!this._helper._width || !this._helper._height) return;
            const r = $o(this.worldSize, this.center.lat), h = a.ba(), p = a.ba();
            this._helper.autoCalculateNearFarZ && (this._helper._nearZ = 0.5, this._helper._farZ = this.cameraToCenterDistance + 2 * r), a.b4(h, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
            const g = this.centerOffset;
            h[8] = 2 * -g.x / this._helper._width, h[9] = 2 * g.y / this._helper._height, this._projectionMatrix = a.b5(h), this._globeProjMatrixInverted = a.ba(), a.aq(this._globeProjMatrixInverted, h), a.M(h, h, [0, 0, -this.cameraToCenterDistance]), a.b6(h, h, this.rollInRadians), a.b7(h, h, -this.pitchInRadians), a.b6(h, h, this.bearingInRadians), a.M(h, h, [0, 0, -r]);
            const y = a.bp();
            y[0] = r, y[1] = r, y[2] = r, a.b7(p, h, this.center.lat * Math.PI / 180), a.bz(p, p, -this.center.lng * Math.PI / 180), a.N(p, p, y), this._globeViewProjMatrixNoCorrection = p, a.b7(h, h, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians), a.bz(h, h, -this.center.lng * Math.PI / 180), a.N(h, h, y), this._globeViewProjMatrix32f = new Float32Array(h), this._globeViewProjMatrixNoCorrectionInverted = a.ba(), a.aq(this._globeViewProjMatrixNoCorrectionInverted, p);
            const x = a.bp();
            this._cameraPosition = a.bp(), this._cameraPosition[2] = this.cameraToCenterDistance / r, a.bw(this._cameraPosition, this._cameraPosition, x, -this.rollInRadians), a.bx(this._cameraPosition, this._cameraPosition, x, this.pitchInRadians), a.bw(this._cameraPosition, this._cameraPosition, x, -this.bearingInRadians), a.aS(this._cameraPosition, this._cameraPosition, [0, 0, 1]), a.bx(this._cameraPosition, this._cameraPosition, x, -this.center.lat * Math.PI / 180), a.by(this._cameraPosition, this._cameraPosition, x, this.center.lng * Math.PI / 180), this._cachedClippingPlane = this._computeClippingPlane(r);
            const E = a.b5(this._globeViewProjMatrixNoCorrectionInverted);
            a.N(E, E, [1, 1, -1]), this._cachedFrustum = Gi.fromInvProjectionMatrix(E, 1, 0, this._cachedClippingPlane, !0);
          }
          calculateFogMatrix(r) {
            a.w("calculateFogMatrix is not supported on globe projection.");
            const h = a.ba();
            return a.ag(h), h;
          }
          getVisibleUnwrappedCoordinates(r) {
            return [new a.b2(0, r)];
          }
          getCameraFrustum() {
            return this._cachedFrustum;
          }
          getClippingPlane() {
            return this._cachedClippingPlane;
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider;
          }
          recalculateZoomAndCenter(r) {
            r && a.w("terrain is not fully supported on vertical perspective projection."), this._helper.recalculateZoomAndCenter(0);
          }
          maxPitchScaleFactor() {
            return 1;
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat();
          }
          lngLatToCameraDepth(r, h) {
            if (!this._globeViewProjMatrixNoCorrection) return 1;
            const p = ar(r);
            a.aR(p, p, 1 + h / a.bu);
            const g = a.bv();
            return a.aw(g, [p[0], p[1], p[2], 1], this._globeViewProjMatrixNoCorrection), g[2] / g[3];
          }
          populateCache(r) {
          }
          getBounds() {
            const r = 0.5 * this.width, h = 0.5 * this.height, p = [new a.P(0, 0), new a.P(r, 0), new a.P(this.width, 0), new a.P(this.width, h), new a.P(this.width, this.height), new a.P(r, this.height), new a.P(0, this.height), new a.P(0, h)], g = [];
            for (const k of p) g.push(this.unprojectScreenPoint(k));
            let y = 0, x = 0, E = 0, C = 0;
            const R = this.center;
            for (const k of g) {
              const O = a.bA(R.lng, k.lng), z = a.bA(R.lat, k.lat);
              O < x && (x = O), O > y && (y = O), z < C && (C = z), z > E && (E = z);
            }
            const B = [R.lng + x, R.lat + C, R.lng + y, R.lat + E];
            return this.isSurfacePointOnScreen([0, 1, 0]) && (B[3] = 90, B[0] = -180, B[2] = 180), this.isSurfacePointOnScreen([0, -1, 0]) && (B[1] = -90, B[0] = -180, B[2] = 180), new ni(B);
          }
          getConstrained(r, h) {
            const p = a.ah(r.lat, -a.ai, a.ai), g = a.ah(+h, this.minZoom + Bi(0, p), this.maxZoom);
            return { center: new a.S(r.lng, p), zoom: g };
          }
          calculateCenterFromCameraLngLatAlt(r, h, p, g) {
            return this._helper.calculateCenterFromCameraLngLatAlt(r, h, p, g);
          }
          setLocationAtPoint(r, h) {
            const p = ar(this.unprojectScreenPoint(h)), g = ar(r), y = a.bp();
            a.bB(y);
            const x = a.bp();
            a.by(x, p, y, -this.center.lng * Math.PI / 180), a.bx(x, x, y, this.center.lat * Math.PI / 180);
            const E = g[0] * g[0] + g[2] * g[2], C = x[0] * x[0];
            if (E < C) return;
            const R = Math.sqrt(E - C), B = -R, k = a.bC(g[0], g[2], x[0], R), O = a.bC(g[0], g[2], x[0], B), z = a.bp();
            a.by(z, g, y, -k);
            const H = a.bC(z[1], z[2], x[1], x[2]), Y = a.bp();
            a.by(Y, g, y, -O);
            const K = a.bC(Y[1], Y[2], x[1], x[2]), J = 0.5 * Math.PI, ie = H >= -J && H <= J, le = K >= -J && K <= J;
            let se, he;
            if (ie && le) {
              const Fe = this.center.lng * Math.PI / 180, Ie = this.center.lat * Math.PI / 180;
              a.bD(k, Fe) + a.bD(H, Ie) < a.bD(O, Fe) + a.bD(K, Ie) ? (se = k, he = H) : (se = O, he = K);
            } else if (ie) se = k, he = H;
            else {
              if (!le) return;
              se = O, he = K;
            }
            const fe = se / Math.PI * 180, oe = he / Math.PI * 180, be = this.center.lat;
            this.setCenter(new a.S(fe, a.ah(oe, -90, 90))), this.setZoom(this.zoom + Bi(be, this.center.lat));
          }
          locationToScreenPoint(r, h) {
            const p = ar(r);
            if (h) {
              const g = h.getElevationForLngLatZoom(r, this._helper._tileZoom);
              a.aR(p, p, 1 + g / a.bu);
            }
            return this._projectSurfacePointToScreen(p);
          }
          _projectSurfacePointToScreen(r) {
            const h = a.bv();
            return a.aw(h, [...r, 1], this._globeViewProjMatrixNoCorrection), h[0] /= h[3], h[1] /= h[3], new a.P((0.5 * h[0] + 0.5) * this.width, (0.5 * -h[1] + 0.5) * this.height);
          }
          screenPointToMercatorCoordinate(r, h) {
            if (h) {
              const p = h.pointCoordinate(r);
              if (p) return p;
            }
            return a.a1.fromLngLat(this.unprojectScreenPoint(r));
          }
          screenPointToLocation(r, h) {
            var p;
            return (p = this.screenPointToMercatorCoordinate(r, h)) === null || p === void 0 ? void 0 : p.toLngLat();
          }
          isPointOnMapSurface(r, h) {
            const p = this._cameraPosition, g = this.getRayDirectionFromPixel(r);
            return !!this.rayPlanetIntersection(p, g);
          }
          getRayDirectionFromPixel(r) {
            const h = a.bv();
            h[0] = r.x / this.width * 2 - 1, h[1] = -1 * (r.y / this.height * 2 - 1), h[2] = 1, h[3] = 1, a.aw(h, h, this._globeViewProjMatrixNoCorrectionInverted), h[0] /= h[3], h[1] /= h[3], h[2] /= h[3];
            const p = a.bp();
            p[0] = h[0] - this._cameraPosition[0], p[1] = h[1] - this._cameraPosition[1], p[2] = h[2] - this._cameraPosition[2];
            const g = a.bp();
            return a.aV(g, p), g;
          }
          isSurfacePointVisible(r) {
            const h = this._cachedClippingPlane;
            return h[0] * r[0] + h[1] * r[1] + h[2] * r[2] + h[3] >= 0;
          }
          isSurfacePointOnScreen(r) {
            if (!this.isSurfacePointVisible(r)) return !1;
            const h = a.bv();
            return a.aw(h, [...r, 1], this._globeViewProjMatrixNoCorrection), h[0] /= h[3], h[1] /= h[3], h[2] /= h[3], h[0] > -1 && h[0] < 1 && h[1] > -1 && h[1] < 1 && h[2] > -1 && h[2] < 1;
          }
          rayPlanetIntersection(r, h) {
            const p = a.aX(r, h), g = a.bp(), y = a.bp();
            a.aR(y, h, p), a.aU(g, r, y);
            const x = 1 - a.aX(g, g);
            if (x < 0) return null;
            const E = a.aX(r, r) - 1, C = -p + (p < 0 ? 1 : -1) * Math.sqrt(x), R = E / C, B = C;
            return { tMin: Math.min(R, B), tMax: Math.max(R, B) };
          }
          unprojectScreenPoint(r) {
            const h = this._cameraPosition, p = this.getRayDirectionFromPixel(r), g = this.rayPlanetIntersection(h, p);
            if (g) {
              const B = a.bp();
              a.aS(B, h, [p[0] * g.tMin, p[1] * g.tMin, p[2] * g.tMin]);
              const k = a.bp();
              return a.aV(k, B), La(k);
            }
            const y = this._cachedClippingPlane, x = y[0] * p[0] + y[1] * p[1] + y[2] * p[2], E = -a.b1(y, h) / x, C = a.bp();
            if (E > 0) a.aS(C, h, [p[0] * E, p[1] * E, p[2] * E]);
            else {
              const B = a.bp();
              a.aS(B, h, [2 * p[0], 2 * p[1], 2 * p[2]]);
              const k = a.b1(this._cachedClippingPlane, B);
              a.aU(C, B, [this._cachedClippingPlane[0] * k, this._cachedClippingPlane[1] * k, this._cachedClippingPlane[2] * k]);
            }
            const R = (function(B) {
              const k = a.bp();
              return k[0] = B[0] * -B[3], k[1] = B[1] * -B[3], k[2] = B[2] * -B[3], { center: k, radius: Math.sqrt(1 - B[3] * B[3]) };
            })(y);
            return La((function(B, k, O) {
              const z = a.bp();
              a.aU(z, O, B);
              const H = a.bp();
              return a.bq(H, B, z, k / a.a$(z)), H;
            })(R.center, R.radius, C));
          }
          getMatrixForModel(r, h) {
            const p = a.S.convert(r), g = 1 / a.bu, y = a.b9();
            return a.bz(y, y, p.lng / 180 * Math.PI), a.b7(y, y, -p.lat / 180 * Math.PI), a.M(y, y, [0, 0, 1 + h / a.bu]), a.b7(y, y, 0.5 * Math.PI), a.N(y, y, [g, g, g]), y;
          }
          getProjectionDataForCustomLayer(r = !0) {
            const h = this.getProjectionData({ overscaledTileID: new a.Z(0, 0, 0, 0, 0), applyGlobeMatrix: r });
            return h.tileMercatorCoords = [0, 0, 1, 1], h;
          }
          getFastPathSimpleProjectionMatrix(r) {
          }
        }
        class Ha {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(r) {
            this._helper.setMinZoom(r);
          }
          setMaxZoom(r) {
            this._helper.setMaxZoom(r);
          }
          setMinPitch(r) {
            this._helper.setMinPitch(r);
          }
          setMaxPitch(r) {
            this._helper.setMaxPitch(r);
          }
          setRenderWorldCopies(r) {
            this._helper.setRenderWorldCopies(r);
          }
          setBearing(r) {
            this._helper.setBearing(r);
          }
          setPitch(r) {
            this._helper.setPitch(r);
          }
          setRoll(r) {
            this._helper.setRoll(r);
          }
          setFov(r) {
            this._helper.setFov(r);
          }
          setZoom(r) {
            this._helper.setZoom(r);
          }
          setCenter(r) {
            this._helper.setCenter(r);
          }
          setElevation(r) {
            this._helper.setElevation(r);
          }
          setMinElevationForCurrentTile(r) {
            this._helper.setMinElevationForCurrentTile(r);
          }
          setPadding(r) {
            this._helper.setPadding(r);
          }
          interpolatePadding(r, h, p) {
            return this._helper.interpolatePadding(r, h, p);
          }
          isPaddingEqual(r) {
            return this._helper.isPaddingEqual(r);
          }
          resize(r, h, p = !0) {
            this._helper.resize(r, h, p);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(r) {
            this._helper.setMaxBounds(r);
          }
          overrideNearFarZ(r, h) {
            this._helper.overrideNearFarZ(r, h);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(r) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), r);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          get isGlobeRendering() {
            return this._globeness > 0;
          }
          setTransitionState(r, h) {
            this._globeness = r, this._globeLatitudeErrorCorrectionRadians = h, this._calcMatrices(), this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().prepareNextFrame(), this._mercatorTransform.getCoveringTilesDetailsProvider().prepareNextFrame();
          }
          get currentTransform() {
            return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform;
          }
          constructor() {
            this._globeLatitudeErrorCorrectionRadians = 0, this._globeness = 1, this._helper = new Nr({ calcMatrices: () => {
              this._calcMatrices();
            }, getConstrained: (r, h) => this.getConstrained(r, h) }), this._globeness = 1, this._mercatorTransform = new oi(), this._verticalPerspectiveTransform = new ja();
          }
          clone() {
            const r = new Ha();
            return r._globeness = this._globeness, r._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians, r.apply(this), r;
          }
          apply(r) {
            this._helper.apply(r), this._mercatorTransform.apply(this), this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians);
          }
          get projectionMatrix() {
            return this.currentTransform.projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this.currentTransform.modelViewProjectionMatrix;
          }
          get inverseProjectionMatrix() {
            return this.currentTransform.inverseProjectionMatrix;
          }
          get cameraPosition() {
            return this.currentTransform.cameraPosition;
          }
          getProjectionData(r) {
            const h = this._mercatorTransform.getProjectionData(r), p = this._verticalPerspectiveTransform.getProjectionData(r);
            return { mainMatrix: this.isGlobeRendering ? p.mainMatrix : h.mainMatrix, clippingPlane: p.clippingPlane, tileMercatorCoords: p.tileMercatorCoords, projectionTransition: r.applyGlobeMatrix ? this._globeness : 0, fallbackMatrix: h.fallbackMatrix };
          }
          isLocationOccluded(r) {
            return this.currentTransform.isLocationOccluded(r);
          }
          transformLightDirection(r) {
            return this.currentTransform.transformLightDirection(r);
          }
          getPixelScale() {
            return a.bk(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness);
          }
          getCircleRadiusCorrection() {
            return a.bk(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness);
          }
          getPitchedTextCorrection(r, h, p) {
            const g = this._mercatorTransform.getPitchedTextCorrection(r, h, p), y = this._verticalPerspectiveTransform.getPitchedTextCorrection(r, h, p);
            return a.bk(g, y, this._globeness);
          }
          projectTileCoordinates(r, h, p, g) {
            return this.currentTransform.projectTileCoordinates(r, h, p, g);
          }
          _calcMatrices() {
            this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians), this._helper._nearZ = this._verticalPerspectiveTransform.nearZ, this._helper._farZ = this._verticalPerspectiveTransform.farZ, this._mercatorTransform.apply(this, !0, this.isGlobeRendering), this._helper._nearZ = this._mercatorTransform.nearZ, this._helper._farZ = this._mercatorTransform.farZ);
          }
          calculateFogMatrix(r) {
            return this.currentTransform.calculateFogMatrix(r);
          }
          getVisibleUnwrappedCoordinates(r) {
            return this.currentTransform.getVisibleUnwrappedCoordinates(r);
          }
          getCameraFrustum() {
            return this.currentTransform.getCameraFrustum();
          }
          getClippingPlane() {
            return this.currentTransform.getClippingPlane();
          }
          getCoveringTilesDetailsProvider() {
            return this.currentTransform.getCoveringTilesDetailsProvider();
          }
          recalculateZoomAndCenter(r) {
            this._mercatorTransform.recalculateZoomAndCenter(r), this._verticalPerspectiveTransform.recalculateZoomAndCenter(r);
          }
          maxPitchScaleFactor() {
            return this._mercatorTransform.maxPitchScaleFactor();
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat();
          }
          lngLatToCameraDepth(r, h) {
            return this.currentTransform.lngLatToCameraDepth(r, h);
          }
          populateCache(r) {
            this._mercatorTransform.populateCache(r), this._verticalPerspectiveTransform.populateCache(r);
          }
          getBounds() {
            return this.currentTransform.getBounds();
          }
          getConstrained(r, h) {
            return this.currentTransform.getConstrained(r, h);
          }
          calculateCenterFromCameraLngLatAlt(r, h, p, g) {
            return this._helper.calculateCenterFromCameraLngLatAlt(r, h, p, g);
          }
          setLocationAtPoint(r, h) {
            if (!this.isGlobeRendering) return this._mercatorTransform.setLocationAtPoint(r, h), void this.apply(this._mercatorTransform);
            this._verticalPerspectiveTransform.setLocationAtPoint(r, h), this.apply(this._verticalPerspectiveTransform);
          }
          locationToScreenPoint(r, h) {
            return this.currentTransform.locationToScreenPoint(r, h);
          }
          screenPointToMercatorCoordinate(r, h) {
            return this.currentTransform.screenPointToMercatorCoordinate(r, h);
          }
          screenPointToLocation(r, h) {
            return this.currentTransform.screenPointToLocation(r, h);
          }
          isPointOnMapSurface(r, h) {
            return this.currentTransform.isPointOnMapSurface(r, h);
          }
          getRayDirectionFromPixel(r) {
            return this._verticalPerspectiveTransform.getRayDirectionFromPixel(r);
          }
          getMatrixForModel(r, h) {
            return this.currentTransform.getMatrixForModel(r, h);
          }
          getProjectionDataForCustomLayer(r = !0) {
            const h = this._mercatorTransform.getProjectionDataForCustomLayer(r);
            if (!this.isGlobeRendering) return h;
            const p = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(r);
            return p.fallbackMatrix = h.mainMatrix, p;
          }
          getFastPathSimpleProjectionMatrix(r) {
            return this.currentTransform.getFastPathSimpleProjectionMatrix(r);
          }
        }
        class Ir {
          get useGlobeControls() {
            return !0;
          }
          handlePanInertia(r, h) {
            const p = pd(r, h);
            return Math.abs(p.lng - h.center.lng) > 180 && (p.lng = h.center.lng + 179.5 * Math.sign(p.lng - h.center.lng)), { easingCenter: p, easingOffset: new a.P(0, 0) };
          }
          handleMapControlsRollPitchBearingZoom(r, h) {
            const p = r.around, g = h.screenPointToLocation(p);
            r.bearingDelta && h.setBearing(h.bearing + r.bearingDelta), r.pitchDelta && h.setPitch(h.pitch + r.pitchDelta), r.rollDelta && h.setRoll(h.roll + r.rollDelta);
            const y = h.zoom;
            r.zoomDelta && h.setZoom(h.zoom + r.zoomDelta);
            const x = h.zoom - y;
            if (x === 0) return;
            const E = a.bA(h.center.lng, g.lng), C = E / (Math.abs(E / 180) + 1), R = a.bA(h.center.lat, g.lat), B = h.getRayDirectionFromPixel(p), k = h.cameraPosition, O = -1 * a.aX(k, B), z = a.bp();
            a.aS(z, k, [B[0] * O, B[1] * O, B[2] * O]);
            const H = a.aZ(z) - 1, Y = Math.exp(0.5 * -Math.max(H - 0.3, 0)), K = $o(h.worldSize, h.center.lat) / Math.min(h.width, h.height), J = a.bn(K, 0.9, 0.5, 1, 0.25), ie = (1 - a.af(-x)) * Math.min(Y, J), le = h.center.lat, se = h.zoom, he = new a.S(h.center.lng + C * ie, a.ah(h.center.lat + R * ie, -a.ai, a.ai));
            h.setLocationAtPoint(g, p);
            const fe = h.center, oe = a.bn(Math.abs(E), 45, 85, 0, 1), be = a.bn(K, 0.75, 0.35, 0, 1), Fe = Math.pow(Math.max(oe, be), 0.25), Ie = a.bA(fe.lng, he.lng), Me = a.bA(fe.lat, he.lat);
            h.setCenter(new a.S(fe.lng + Ie * Fe, fe.lat + Me * Fe).wrap()), h.setZoom(se + Bi(le, h.center.lat));
          }
          handleMapControlsPan(r, h, p) {
            if (!r.panDelta) return;
            const g = h.center.lat, y = h.zoom;
            h.setCenter(pd(r.panDelta, h).wrap()), h.setZoom(y + Bi(g, h.center.lat));
          }
          cameraForBoxAndBearing(r, h, p, g, y) {
            const x = rs(r, h, p, g, y), E = h.left / y.width * 2 - 1, C = (y.width - h.right) / y.width * 2 - 1, R = h.top / y.height * -2 + 1, B = (y.height - h.bottom) / y.height * -2 + 1, k = a.bA(p.getWest(), p.getEast()) < 0, O = k ? p.getEast() : p.getWest(), z = k ? p.getWest() : p.getEast(), H = Math.max(p.getNorth(), p.getSouth()), Y = Math.min(p.getNorth(), p.getSouth()), K = O + 0.5 * a.bA(O, z), J = H + 0.5 * a.bA(H, Y), ie = y.clone();
            ie.setCenter(x.center), ie.setBearing(x.bearing), ie.setPitch(0), ie.setRoll(0), ie.setZoom(x.zoom);
            const le = ie.modelViewProjectionMatrix, se = [ar(p.getNorthWest()), ar(p.getNorthEast()), ar(p.getSouthWest()), ar(p.getSouthEast()), ar(new a.S(z, J)), ar(new a.S(O, J)), ar(new a.S(K, H)), ar(new a.S(K, Y))], he = ar(x.center);
            let fe = Number.POSITIVE_INFINITY;
            for (const oe of se) E < 0 && (fe = Ir.getLesserNonNegativeNonNull(fe, Ir.solveVectorScale(oe, he, le, "x", E))), C > 0 && (fe = Ir.getLesserNonNegativeNonNull(fe, Ir.solveVectorScale(oe, he, le, "x", C))), R > 0 && (fe = Ir.getLesserNonNegativeNonNull(fe, Ir.solveVectorScale(oe, he, le, "y", R))), B < 0 && (fe = Ir.getLesserNonNegativeNonNull(fe, Ir.solveVectorScale(oe, he, le, "y", B)));
            if (Number.isFinite(fe) && fe !== 0) return x.zoom = ie.zoom + a.ak(fe), x;
            fd();
          }
          handleJumpToCenterZoom(r, h) {
            const p = r.center.lat, g = r.getConstrained(h.center ? a.S.convert(h.center) : r.center, r.zoom).center;
            r.setCenter(g.wrap());
            const y = h.zoom !== void 0 ? +h.zoom : r.zoom + Bi(p, g.lat);
            r.zoom !== y && r.setZoom(y);
          }
          handleEaseTo(r, h) {
            const p = r.zoom, g = r.center, y = r.padding, x = { roll: r.roll, pitch: r.pitch, bearing: r.bearing }, E = { roll: h.roll === void 0 ? r.roll : h.roll, pitch: h.pitch === void 0 ? r.pitch : h.pitch, bearing: h.bearing === void 0 ? r.bearing : h.bearing }, C = h.zoom !== void 0, R = !r.isPaddingEqual(h.padding);
            let B = !1;
            const k = h.center ? a.S.convert(h.center) : g, O = r.getConstrained(k, p).center;
            kr(r, O);
            const z = r.clone();
            z.setCenter(O), z.setZoom(C ? +h.zoom : p + Bi(g.lat, k.lat)), z.setBearing(h.bearing);
            const H = new a.P(a.ah(r.centerPoint.x + h.offsetAsPoint.x, 0, r.width), a.ah(r.centerPoint.y + h.offsetAsPoint.y, 0, r.height));
            z.setLocationAtPoint(O, H);
            const Y = (h.offset && h.offsetAsPoint.mag()) > 0 ? z.center : O, K = C ? +h.zoom : p + Bi(g.lat, Y.lat), J = p + Bi(g.lat, 0), ie = K + Bi(Y.lat, 0), le = a.bA(g.lng, Y.lng), se = a.bA(g.lat, Y.lat), he = a.af(ie - J);
            return B = K !== p, { easeFunc: (fe) => {
              if (a.be(x, E) || Ur({ startEulerAngles: x, endEulerAngles: E, tr: r, k: fe, useSlerp: x.roll != E.roll }), R && r.interpolatePadding(y, h.padding, fe), h.around) a.w("Easing around a point is not supported under globe projection."), r.setLocationAtPoint(h.around, h.aroundPoint);
              else {
                const oe = ie > J ? Math.min(2, he) : Math.max(0.5, he), be = Math.pow(oe, 1 - fe), Fe = vh(g, le, se, fe * be);
                r.setCenter(Fe.wrap());
              }
              if (B) {
                const oe = a.C.number(J, ie, fe) + Bi(0, r.center.lat);
                r.setZoom(oe);
              }
            }, isZooming: B, elevationCenter: Y };
          }
          handleFlyTo(r, h) {
            const p = h.zoom !== void 0, g = r.center, y = r.zoom, x = r.padding, E = !r.isPaddingEqual(h.padding), C = r.getConstrained(a.S.convert(h.center || h.locationAtOffset), y).center, R = p ? +h.zoom : r.zoom + Bi(r.center.lat, C.lat), B = r.clone();
            B.setCenter(C), B.setZoom(R), B.setBearing(h.bearing);
            const k = new a.P(a.ah(r.centerPoint.x + h.offsetAsPoint.x, 0, r.width), a.ah(r.centerPoint.y + h.offsetAsPoint.y, 0, r.height));
            B.setLocationAtPoint(C, k);
            const O = B.center;
            kr(r, O);
            const z = (function(se, he, fe) {
              const oe = ar(he), be = ar(fe), Fe = a.aX(oe, be), Ie = Math.acos(Fe), Me = Ul(se);
              return Ie / (2 * Math.PI) * Me;
            })(r, g, O), H = y + Bi(g.lat, 0), Y = R + Bi(O.lat, 0), K = a.af(Y - H);
            let J;
            if (typeof h.minZoom == "number") {
              const se = +h.minZoom + Bi(O.lat, 0), he = Math.min(se, H, Y) + Bi(0, O.lat), fe = r.getConstrained(O, he).zoom + Bi(O.lat, 0);
              J = a.af(fe - H);
            }
            const ie = a.bA(g.lng, O.lng), le = a.bA(g.lat, O.lat);
            return { easeFunc: (se, he, fe, oe) => {
              const be = vh(g, ie, le, fe);
              E && r.interpolatePadding(x, h.padding, se);
              const Fe = se === 1 ? O : be;
              r.setCenter(Fe.wrap());
              const Ie = H + a.ak(he);
              r.setZoom(se === 1 ? R : Ie + Bi(0, Fe.lat));
            }, scaleOfZoom: K, targetCenter: O, scaleOfMinZoom: J, pixelPathLength: z };
          }
          static solveVectorScale(r, h, p, g, y) {
            const x = g === "x" ? [p[0], p[4], p[8], p[12]] : [p[1], p[5], p[9], p[13]], E = [p[3], p[7], p[11], p[15]], C = r[0] * x[0] + r[1] * x[1] + r[2] * x[2], R = r[0] * E[0] + r[1] * E[1] + r[2] * E[2], B = h[0] * x[0] + h[1] * x[1] + h[2] * x[2], k = h[0] * E[0] + h[1] * E[1] + h[2] * E[2];
            return B + y * R === C + y * k || E[3] * (C - B) + x[3] * (k - R) + C * k == B * R ? null : (B + x[3] - y * k - y * E[3]) / (B - C - y * k + y * R);
          }
          static getLesserNonNegativeNonNull(r, h) {
            return h !== null && h >= 0 && h < r ? h : r;
          }
        }
        class _d {
          constructor(r) {
            this._globe = r, this._mercatorCameraHelper = new Cr(), this._verticalPerspectiveCameraHelper = new Ir();
          }
          get useGlobeControls() {
            return this._globe.useGlobeRendering;
          }
          get currentHelper() {
            return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper;
          }
          handlePanInertia(r, h) {
            return this.currentHelper.handlePanInertia(r, h);
          }
          handleMapControlsRollPitchBearingZoom(r, h) {
            return this.currentHelper.handleMapControlsRollPitchBearingZoom(r, h);
          }
          handleMapControlsPan(r, h, p) {
            this.currentHelper.handleMapControlsPan(r, h, p);
          }
          cameraForBoxAndBearing(r, h, p, g, y) {
            return this.currentHelper.cameraForBoxAndBearing(r, h, p, g, y);
          }
          handleJumpToCenterZoom(r, h) {
            this.currentHelper.handleJumpToCenterZoom(r, h);
          }
          handleEaseTo(r, h) {
            return this.currentHelper.handleEaseTo(r, h);
          }
          handleFlyTo(r, h) {
            return this.currentHelper.handleFlyTo(r, h);
          }
        }
        const zl = (m, r) => a.y(m, r && r.filter(((h) => h.identifier !== "source.canvas"))), Gp = a.bE();
        class xh extends a.E {
          constructor(r, h = {}) {
            super(), this._rtlPluginLoaded = () => {
              for (const p in this.sourceCaches) {
                const g = this.sourceCaches[p].getSource().type;
                g !== "vector" && g !== "geojson" || this.sourceCaches[p].reload();
              }
            }, this.map = r, this.dispatcher = new Er(pn(), r._getMapId()), this.dispatcher.registerMessageHandler("GG", ((p, g) => this.getGlyphs(p, g))), this.dispatcher.registerMessageHandler("GI", ((p, g) => this.getImages(p, g))), this.imageManager = new st(), this.imageManager.setEventedParent(this), this.glyphManager = new jt(r._requestManager, h.localIdeographFontFamily), this.lineAtlas = new Ht(256, 512), this.crossTileSymbolIndex = new X(), this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new a.bF(), this._loaded = !1, this._availableImages = [], this._globalState = {}, this._resetUpdates(), this.dispatcher.broadcast("SR", a.bG()), As().on(_n, this._rtlPluginLoaded), this.on("data", ((p) => {
              if (p.dataType !== "source" || p.sourceDataType !== "metadata") return;
              const g = this.sourceCaches[p.sourceId];
              if (!g) return;
              const y = g.getSource();
              if (y && y.vectorLayerIds) for (const x in this._layers) {
                const E = this._layers[x];
                E.source === y.id && this._validateLayer(E);
              }
            }));
          }
          setGlobalStateProperty(r, h) {
            var p, g, y;
            this._checkLoaded();
            const x = h === null ? (y = (g = (p = this.stylesheet.state) === null || p === void 0 ? void 0 : p[r]) === null || g === void 0 ? void 0 : g.default) !== null && y !== void 0 ? y : null : h;
            if (a.bH(x, this._globalState[r])) return this;
            this._globalState[r] = x;
            const E = this._findGlobalStateAffectedSources([r]);
            for (const C in this.sourceCaches) E.has(C) && (this._reloadSource(C), this._changed = !0);
          }
          getGlobalState() {
            return this._globalState;
          }
          setGlobalState(r) {
            this._checkLoaded();
            const h = [];
            for (const g in r) !a.bH(this._globalState[g], r[g].default) && (h.push(g), this._globalState[g] = r[g].default);
            const p = this._findGlobalStateAffectedSources(h);
            for (const g in this.sourceCaches) p.has(g) && (this._reloadSource(g), this._changed = !0);
          }
          _findGlobalStateAffectedSources(r) {
            if (r.length === 0) return /* @__PURE__ */ new Set();
            const h = /* @__PURE__ */ new Set();
            for (const p in this._layers) {
              const g = this._layers[p], y = g.getLayoutAffectingGlobalStateRefs();
              for (const x of r) y.has(x) && h.add(g.source);
            }
            return h;
          }
          loadURL(r, h = {}, p) {
            this.fire(new a.l("dataloading", { dataType: "style" })), h.validate = typeof h.validate != "boolean" || h.validate;
            const g = this.map._requestManager.transformRequest(r, "Style");
            this._loadStyleRequest = new AbortController();
            const y = this._loadStyleRequest;
            a.j(g, this._loadStyleRequest).then(((x) => {
              this._loadStyleRequest = null, this._load(x.data, h, p);
            })).catch(((x) => {
              this._loadStyleRequest = null, x && !y.signal.aborted && this.fire(new a.k(x));
            }));
          }
          loadJSON(r, h = {}, p) {
            this.fire(new a.l("dataloading", { dataType: "style" })), this._frameRequest = new AbortController(), N.frameAsync(this._frameRequest).then((() => {
              this._frameRequest = null, h.validate = h.validate !== !1, this._load(r, h, p);
            })).catch((() => {
            }));
          }
          loadEmpty() {
            this.fire(new a.l("dataloading", { dataType: "style" })), this._load(Gp, { validate: !1 });
          }
          _load(r, h, p) {
            var g, y, x;
            const E = h.transformStyle ? h.transformStyle(p, r) : r;
            if (!h.validate || !zl(this, a.z(E))) {
              this._loaded = !0, this.stylesheet = E;
              for (const C in E.sources) this.addSource(C, E.sources[C], { validate: !1 });
              E.sprite ? this._loadSprite(E.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(E.glyphs), this._createLayers(), this.light = new Dr(this.stylesheet.light), this._setProjectionInternal(((g = this.stylesheet.projection) === null || g === void 0 ? void 0 : g.type) || "mercator"), this.sky = new Ln(this.stylesheet.sky), this.map.setTerrain((y = this.stylesheet.terrain) !== null && y !== void 0 ? y : null), this.setGlobalState((x = this.stylesheet.state) !== null && x !== void 0 ? x : null), this.fire(new a.l("data", { dataType: "style" })), this.fire(new a.l("style.load"));
            }
          }
          _createLayers() {
            const r = a.bI(this.stylesheet.layers);
            this.dispatcher.broadcast("SL", r), this._order = r.map(((h) => h.id)), this._layers = {}, this._serializedLayers = null;
            for (const h of r) {
              const p = a.bJ(h);
              p.setEventedParent(this, { layer: { id: h.id } }), this._layers[h.id] = p;
            }
          }
          _loadSprite(r, h = !1, p = void 0) {
            let g;
            this.imageManager.setLoaded(!1), this._spriteRequest = new AbortController(), (function(y, x, E, C) {
              return a._(this, void 0, void 0, (function* () {
                const R = Ke(y), B = E > 1 ? "@2x" : "", k = {}, O = {};
                for (const { id: z, url: H } of R) {
                  const Y = x.transformRequest(ct(H, B, ".json"), "SpriteJSON");
                  k[z] = a.j(Y, C);
                  const K = x.transformRequest(ct(H, B, ".png"), "SpriteImage");
                  O[z] = Le.getImage(K, C);
                }
                return yield Promise.all([...Object.values(k), ...Object.values(O)]), (function(z, H) {
                  return a._(this, void 0, void 0, (function* () {
                    const Y = {};
                    for (const K in z) {
                      Y[K] = {};
                      const J = N.getImageCanvasContext((yield H[K]).data), ie = (yield z[K]).data;
                      for (const le in ie) {
                        const { width: se, height: he, x: fe, y: oe, sdf: be, pixelRatio: Fe, stretchX: Ie, stretchY: Me, content: Oe, textFitWidth: We, textFitHeight: qe } = ie[le];
                        Y[K][le] = { data: null, pixelRatio: Fe, sdf: be, stretchX: Ie, stretchY: Me, content: Oe, textFitWidth: We, textFitHeight: qe, spriteData: { width: se, height: he, x: fe, y: oe, context: J } };
                      }
                    }
                    return Y;
                  }));
                })(k, O);
              }));
            })(r, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then(((y) => {
              if (this._spriteRequest = null, y) for (const x in y) {
                this._spritesImagesIds[x] = [];
                const E = this._spritesImagesIds[x] ? this._spritesImagesIds[x].filter(((C) => !(C in y))) : [];
                for (const C of E) this.imageManager.removeImage(C), this._changedImages[C] = !0;
                for (const C in y[x]) {
                  const R = x === "default" ? C : `${x}:${C}`;
                  this._spritesImagesIds[x].push(R), R in this.imageManager.images ? this.imageManager.updateImage(R, y[x][C], !1) : this.imageManager.addImage(R, y[x][C]), h && (this._changedImages[R] = !0);
                }
              }
            })).catch(((y) => {
              this._spriteRequest = null, g = y, this.fire(new a.k(g));
            })).finally((() => {
              this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), h && (this._changed = !0), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new a.l("data", { dataType: "style" })), p && p(g);
            }));
          }
          _unloadSprite() {
            for (const r of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(r), this._changedImages[r] = !0;
            this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new a.l("data", { dataType: "style" }));
          }
          _validateLayer(r) {
            const h = this.sourceCaches[r.source];
            if (!h) return;
            const p = r.sourceLayer;
            if (!p) return;
            const g = h.getSource();
            (g.type === "geojson" || g.vectorLayerIds && g.vectorLayerIds.indexOf(p) === -1) && this.fire(new a.k(new Error(`Source layer "${p}" does not exist on source "${g.id}" as specified by style layer "${r.id}".`)));
          }
          loaded() {
            if (!this._loaded || Object.keys(this._updatedSources).length) return !1;
            for (const r in this.sourceCaches) if (!this.sourceCaches[r].loaded()) return !1;
            return !!this.imageManager.isLoaded();
          }
          _serializeByIds(r, h = !1) {
            const p = this._serializedAllLayers();
            if (!r || r.length === 0) return Object.values(h ? a.bK(p) : p);
            const g = [];
            for (const y of r) if (p[y]) {
              const x = h ? a.bK(p[y]) : p[y];
              g.push(x);
            }
            return g;
          }
          _serializedAllLayers() {
            let r = this._serializedLayers;
            if (r) return r;
            r = this._serializedLayers = {};
            const h = Object.keys(this._layers);
            for (const p of h) {
              const g = this._layers[p];
              g.type !== "custom" && (r[p] = g.serialize());
            }
            return r;
          }
          hasTransitions() {
            var r, h, p;
            if (!((r = this.light) === null || r === void 0) && r.hasTransition() || !((h = this.sky) === null || h === void 0) && h.hasTransition() || !((p = this.projection) === null || p === void 0) && p.hasTransition()) return !0;
            for (const g in this.sourceCaches) if (this.sourceCaches[g].hasTransition()) return !0;
            for (const g in this._layers) if (this._layers[g].hasTransition()) return !0;
            return !1;
          }
          _checkLoaded() {
            if (!this._loaded) throw new Error("Style is not done loading.");
          }
          update(r) {
            if (!this._loaded) return;
            const h = this._changed;
            if (h) {
              const g = Object.keys(this._updatedLayers), y = Object.keys(this._removedLayers);
              (g.length || y.length) && this._updateWorkerLayers(g, y);
              for (const x in this._updatedSources) {
                const E = this._updatedSources[x];
                if (E === "reload") this._reloadSource(x);
                else {
                  if (E !== "clear") throw new Error(`Invalid action ${E}`);
                  this._clearSource(x);
                }
              }
              this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
              for (const x in this._updatedPaintProps) this._layers[x].updateTransitions(r);
              this.light.updateTransitions(r), this.sky.updateTransitions(r), this._resetUpdates();
            }
            const p = {};
            for (const g in this.sourceCaches) {
              const y = this.sourceCaches[g];
              p[g] = y.used, y.used = !1;
            }
            for (const g of this._order) {
              const y = this._layers[g];
              y.recalculate(r, this._availableImages), !y.isHidden(r.zoom) && y.source && (this.sourceCaches[y.source].used = !0);
            }
            for (const g in p) {
              const y = this.sourceCaches[g];
              !!p[g] != !!y.used && y.fire(new a.l("data", { sourceDataType: "visibility", dataType: "source", sourceId: g }));
            }
            this.light.recalculate(r), this.sky.recalculate(r), this.projection.recalculate(r), this.z = r.zoom, h && this.fire(new a.l("data", { dataType: "style" }));
          }
          _updateTilesForChangedImages() {
            const r = Object.keys(this._changedImages);
            if (r.length) {
              for (const h in this.sourceCaches) this.sourceCaches[h].reloadTilesForDependencies(["icons", "patterns"], r);
              this._changedImages = {};
            }
          }
          _updateTilesForChangedGlyphs() {
            if (this._glyphsDidChange) {
              for (const r in this.sourceCaches) this.sourceCaches[r].reloadTilesForDependencies(["glyphs"], [""]);
              this._glyphsDidChange = !1;
            }
          }
          _updateWorkerLayers(r, h) {
            this.dispatcher.broadcast("UL", { layers: this._serializeByIds(r, !1), removedIds: h });
          }
          _resetUpdates() {
            this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = !1;
          }
          setState(r, h = {}) {
            var p;
            this._checkLoaded();
            const g = this.serialize();
            if (r = h.transformStyle ? h.transformStyle(g, r) : r, ((p = h.validate) === null || p === void 0 || p) && zl(this, a.z(r))) return !1;
            (r = a.bK(r)).layers = a.bI(r.layers);
            const y = a.bL(g, r), x = this._getOperationsToPerform(y);
            if (x.unimplemented.length > 0) throw new Error(`Unimplemented: ${x.unimplemented.join(", ")}.`);
            if (x.operations.length === 0) return !1;
            for (const E of x.operations) E();
            return this.stylesheet = r, this._serializedLayers = null, !0;
          }
          _getOperationsToPerform(r) {
            const h = [], p = [];
            for (const g of r) switch (g.command) {
              case "setCenter":
              case "setZoom":
              case "setBearing":
              case "setPitch":
              case "setRoll":
                continue;
              case "addLayer":
                h.push((() => this.addLayer.apply(this, g.args)));
                break;
              case "removeLayer":
                h.push((() => this.removeLayer.apply(this, g.args)));
                break;
              case "setPaintProperty":
                h.push((() => this.setPaintProperty.apply(this, g.args)));
                break;
              case "setLayoutProperty":
                h.push((() => this.setLayoutProperty.apply(this, g.args)));
                break;
              case "setFilter":
                h.push((() => this.setFilter.apply(this, g.args)));
                break;
              case "addSource":
                h.push((() => this.addSource.apply(this, g.args)));
                break;
              case "removeSource":
                h.push((() => this.removeSource.apply(this, g.args)));
                break;
              case "setLayerZoomRange":
                h.push((() => this.setLayerZoomRange.apply(this, g.args)));
                break;
              case "setLight":
                h.push((() => this.setLight.apply(this, g.args)));
                break;
              case "setGeoJSONSourceData":
                h.push((() => this.setGeoJSONSourceData.apply(this, g.args)));
                break;
              case "setGlyphs":
                h.push((() => this.setGlyphs.apply(this, g.args)));
                break;
              case "setSprite":
                h.push((() => this.setSprite.apply(this, g.args)));
                break;
              case "setTerrain":
                h.push((() => this.map.setTerrain.apply(this, g.args)));
                break;
              case "setSky":
                h.push((() => this.setSky.apply(this, g.args)));
                break;
              case "setProjection":
                this.setProjection.apply(this, g.args);
                break;
              case "setGlobalState":
                h.push((() => this.setGlobalState.apply(this, g.args)));
                break;
              case "setTransition":
                h.push((() => {
                }));
                break;
              default:
                p.push(g.command);
            }
            return { operations: h, unimplemented: p };
          }
          addImage(r, h) {
            if (this.getImage(r)) return this.fire(new a.k(new Error(`An image named "${r}" already exists.`)));
            this.imageManager.addImage(r, h), this._afterImageUpdated(r);
          }
          updateImage(r, h) {
            this.imageManager.updateImage(r, h);
          }
          getImage(r) {
            return this.imageManager.getImage(r);
          }
          removeImage(r) {
            if (!this.getImage(r)) return this.fire(new a.k(new Error(`An image named "${r}" does not exist.`)));
            this.imageManager.removeImage(r), this._afterImageUpdated(r);
          }
          _afterImageUpdated(r) {
            this._availableImages = this.imageManager.listImages(), this._changedImages[r] = !0, this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new a.l("data", { dataType: "style" }));
          }
          listImages() {
            return this._checkLoaded(), this.imageManager.listImages();
          }
          addSource(r, h, p = {}) {
            if (this._checkLoaded(), this.sourceCaches[r] !== void 0) throw new Error(`Source "${r}" already exists.`);
            if (!h.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(h).join(", ")}.`);
            if (["vector", "raster", "geojson", "video", "image"].indexOf(h.type) >= 0 && this._validate(a.z.source, `sources.${r}`, h, null, p)) return;
            this.map && this.map._collectResourceTiming && (h.collectResourceTiming = !0);
            const g = this.sourceCaches[r] = new Ot(r, h, this.dispatcher);
            g.style = this, g.setEventedParent(this, (() => ({ isSourceLoaded: g.loaded(), source: g.serialize(), sourceId: r }))), g.onAdd(this.map), this._changed = !0;
          }
          removeSource(r) {
            if (this._checkLoaded(), this.sourceCaches[r] === void 0) throw new Error("There is no source with this ID");
            for (const p in this._layers) if (this._layers[p].source === r) return this.fire(new a.k(new Error(`Source "${r}" cannot be removed while layer "${p}" is using it.`)));
            const h = this.sourceCaches[r];
            delete this.sourceCaches[r], delete this._updatedSources[r], h.fire(new a.l("data", { sourceDataType: "metadata", dataType: "source", sourceId: r })), h.setEventedParent(null), h.onRemove(this.map), this._changed = !0;
          }
          setGeoJSONSourceData(r, h) {
            if (this._checkLoaded(), this.sourceCaches[r] === void 0) throw new Error(`There is no source with this ID=${r}`);
            const p = this.sourceCaches[r].getSource();
            if (p.type !== "geojson") throw new Error(`geojsonSource.type is ${p.type}, which is !== 'geojson`);
            p.setData(h), this._changed = !0;
          }
          getSource(r) {
            return this.sourceCaches[r] && this.sourceCaches[r].getSource();
          }
          addLayer(r, h, p = {}) {
            this._checkLoaded();
            const g = r.id;
            if (this.getLayer(g)) return void this.fire(new a.k(new Error(`Layer "${g}" already exists on this map.`)));
            let y;
            if (r.type === "custom") {
              if (zl(this, a.bM(r))) return;
              y = a.bJ(r);
            } else {
              if ("source" in r && typeof r.source == "object" && (this.addSource(g, r.source), r = a.bK(r), r = a.e(r, { source: g })), this._validate(a.z.layer, `layers.${g}`, r, { arrayIndex: -1 }, p)) return;
              y = a.bJ(r), this._validateLayer(y), y.setEventedParent(this, { layer: { id: g } });
            }
            const x = h ? this._order.indexOf(h) : this._order.length;
            if (h && x === -1) this.fire(new a.k(new Error(`Cannot add layer "${g}" before non-existing layer "${h}".`)));
            else {
              if (this._order.splice(x, 0, g), this._layerOrderChanged = !0, this._layers[g] = y, this._removedLayers[g] && y.source && y.type !== "custom") {
                const E = this._removedLayers[g];
                delete this._removedLayers[g], E.type !== y.type ? this._updatedSources[y.source] = "clear" : (this._updatedSources[y.source] = "reload", this.sourceCaches[y.source].pause());
              }
              this._updateLayer(y), y.onAdd && y.onAdd(this.map);
            }
          }
          moveLayer(r, h) {
            if (this._checkLoaded(), this._changed = !0, !this._layers[r]) return void this.fire(new a.k(new Error(`The layer '${r}' does not exist in the map's style and cannot be moved.`)));
            if (r === h) return;
            const p = this._order.indexOf(r);
            this._order.splice(p, 1);
            const g = h ? this._order.indexOf(h) : this._order.length;
            h && g === -1 ? this.fire(new a.k(new Error(`Cannot move layer "${r}" before non-existing layer "${h}".`))) : (this._order.splice(g, 0, r), this._layerOrderChanged = !0);
          }
          removeLayer(r) {
            this._checkLoaded();
            const h = this._layers[r];
            if (!h) return void this.fire(new a.k(new Error(`Cannot remove non-existing layer "${r}".`)));
            h.setEventedParent(null);
            const p = this._order.indexOf(r);
            this._order.splice(p, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[r] = h, delete this._layers[r], this._serializedLayers && delete this._serializedLayers[r], delete this._updatedLayers[r], delete this._updatedPaintProps[r], h.onRemove && h.onRemove(this.map);
          }
          getLayer(r) {
            return this._layers[r];
          }
          getLayersOrder() {
            return [...this._order];
          }
          hasLayer(r) {
            return r in this._layers;
          }
          setLayerZoomRange(r, h, p) {
            this._checkLoaded();
            const g = this.getLayer(r);
            g ? g.minzoom === h && g.maxzoom === p || (h != null && (g.minzoom = h), p != null && (g.maxzoom = p), this._updateLayer(g)) : this.fire(new a.k(new Error(`Cannot set the zoom range of non-existing layer "${r}".`)));
          }
          setFilter(r, h, p = {}) {
            this._checkLoaded();
            const g = this.getLayer(r);
            if (g) {
              if (!a.bH(g.filter, h)) return h == null ? (g.setFilter(void 0), void this._updateLayer(g)) : void (this._validate(a.z.filter, `layers.${g.id}.filter`, h, null, p) || (g.setFilter(a.bK(h)), this._updateLayer(g)));
            } else this.fire(new a.k(new Error(`Cannot filter non-existing layer "${r}".`)));
          }
          getFilter(r) {
            return a.bK(this.getLayer(r).filter);
          }
          setLayoutProperty(r, h, p, g = {}) {
            this._checkLoaded();
            const y = this.getLayer(r);
            y ? a.bH(y.getLayoutProperty(h), p) || (y.setLayoutProperty(h, p, g), this._updateLayer(y)) : this.fire(new a.k(new Error(`Cannot style non-existing layer "${r}".`)));
          }
          getLayoutProperty(r, h) {
            const p = this.getLayer(r);
            if (p) return p.getLayoutProperty(h);
            this.fire(new a.k(new Error(`Cannot get style of non-existing layer "${r}".`)));
          }
          setPaintProperty(r, h, p, g = {}) {
            this._checkLoaded();
            const y = this.getLayer(r);
            y ? a.bH(y.getPaintProperty(h), p) || (y.setPaintProperty(h, p, g) && this._updateLayer(y), this._changed = !0, this._updatedPaintProps[r] = !0, this._serializedLayers = null) : this.fire(new a.k(new Error(`Cannot style non-existing layer "${r}".`)));
          }
          getPaintProperty(r, h) {
            return this.getLayer(r).getPaintProperty(h);
          }
          setFeatureState(r, h) {
            this._checkLoaded();
            const p = r.source, g = r.sourceLayer, y = this.sourceCaches[p];
            if (y === void 0) return void this.fire(new a.k(new Error(`The source '${p}' does not exist in the map's style.`)));
            const x = y.getSource().type;
            x === "geojson" && g ? this.fire(new a.k(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : x !== "vector" || g ? (r.id === void 0 && this.fire(new a.k(new Error("The feature id parameter must be provided."))), y.setFeatureState(g, r.id, h)) : this.fire(new a.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          removeFeatureState(r, h) {
            this._checkLoaded();
            const p = r.source, g = this.sourceCaches[p];
            if (g === void 0) return void this.fire(new a.k(new Error(`The source '${p}' does not exist in the map's style.`)));
            const y = g.getSource().type, x = y === "vector" ? r.sourceLayer : void 0;
            y !== "vector" || x ? h && typeof r.id != "string" && typeof r.id != "number" ? this.fire(new a.k(new Error("A feature id is required to remove its specific state property."))) : g.removeFeatureState(x, r.id, h) : this.fire(new a.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          getFeatureState(r) {
            this._checkLoaded();
            const h = r.source, p = r.sourceLayer, g = this.sourceCaches[h];
            if (g !== void 0) return g.getSource().type !== "vector" || p ? (r.id === void 0 && this.fire(new a.k(new Error("The feature id parameter must be provided."))), g.getFeatureState(p, r.id)) : void this.fire(new a.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
            this.fire(new a.k(new Error(`The source '${h}' does not exist in the map's style.`)));
          }
          getTransition() {
            return a.e({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
          }
          serialize() {
            if (!this._loaded) return;
            const r = a.bN(this.sourceCaches, ((y) => y.serialize())), h = this._serializeByIds(this._order, !0), p = this.map.getTerrain() || void 0, g = this.stylesheet;
            return a.bO({ version: g.version, name: g.name, metadata: g.metadata, light: g.light, sky: g.sky, center: g.center, zoom: g.zoom, bearing: g.bearing, pitch: g.pitch, sprite: g.sprite, glyphs: g.glyphs, transition: g.transition, projection: g.projection, sources: r, layers: h, terrain: p }, ((y) => y !== void 0));
          }
          _updateLayer(r) {
            this._updatedLayers[r.id] = !0, r.source && !this._updatedSources[r.source] && this.sourceCaches[r.source].getSource().type !== "raster" && (this._updatedSources[r.source] = "reload", this.sourceCaches[r.source].pause()), this._serializedLayers = null, this._changed = !0;
          }
          _flattenAndSortRenderedFeatures(r) {
            const h = (x) => this._layers[x].type === "fill-extrusion", p = {}, g = [];
            for (let x = this._order.length - 1; x >= 0; x--) {
              const E = this._order[x];
              if (h(E)) {
                p[E] = x;
                for (const C of r) {
                  const R = C[E];
                  if (R) for (const B of R) g.push(B);
                }
              }
            }
            g.sort(((x, E) => E.intersectionZ - x.intersectionZ));
            const y = [];
            for (let x = this._order.length - 1; x >= 0; x--) {
              const E = this._order[x];
              if (h(E)) for (let C = g.length - 1; C >= 0; C--) {
                const R = g[C].feature;
                if (p[R.layer.id] < x) break;
                y.push(R), g.pop();
              }
              else for (const C of r) {
                const R = C[E];
                if (R) for (const B of R) y.push(B.feature);
              }
            }
            return y;
          }
          queryRenderedFeatures(r, h, p) {
            h && h.filter && this._validate(a.z.filter, "queryRenderedFeatures.filter", h.filter, null, h);
            const g = {};
            if (h && h.layers) {
              if (!(Array.isArray(h.layers) || h.layers instanceof Set)) return this.fire(new a.k(new Error("parameters.layers must be an Array or a Set of strings"))), [];
              for (const R of h.layers) {
                const B = this._layers[R];
                if (!B) return this.fire(new a.k(new Error(`The layer '${R}' does not exist in the map's style and cannot be queried for features.`))), [];
                g[B.source] = !0;
              }
            }
            const y = [];
            h.availableImages = this._availableImages;
            const x = this._serializedAllLayers(), E = h.layers instanceof Set ? h.layers : Array.isArray(h.layers) ? new Set(h.layers) : null, C = Object.assign(Object.assign({}, h), { layers: E });
            for (const R in this.sourceCaches) h.layers && !g[R] || y.push(qt(this.sourceCaches[R], this._layers, x, r, C, p, this.map.terrain ? (B, k, O) => this.map.terrain.getElevation(B, k, O) : void 0));
            return this.placement && y.push((function(R, B, k, O, z, H, Y) {
              const K = {}, J = H.queryRenderedSymbols(O), ie = [];
              for (const le of Object.keys(J).map(Number)) ie.push(Y[le]);
              ie.sort(Fi);
              for (const le of ie) {
                const se = le.featureIndex.lookupSymbolFeatures(J[le.bucketInstanceId], B, le.bucketIndex, le.sourceLayerIndex, z.filter, z.layers, z.availableImages, R);
                for (const he in se) {
                  const fe = K[he] = K[he] || [], oe = se[he];
                  oe.sort(((be, Fe) => {
                    const Ie = le.featureSortOrder;
                    if (Ie) {
                      const Me = Ie.indexOf(be.featureIndex);
                      return Ie.indexOf(Fe.featureIndex) - Me;
                    }
                    return Fe.featureIndex - be.featureIndex;
                  }));
                  for (const be of oe) fe.push(be);
                }
              }
              return (function(le, se, he) {
                for (const fe in le) for (const oe of le[fe]) ws(oe, he[se[fe].source]);
                return le;
              })(K, R, k);
            })(this._layers, x, this.sourceCaches, r, C, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(y);
          }
          querySourceFeatures(r, h) {
            h && h.filter && this._validate(a.z.filter, "querySourceFeatures.filter", h.filter, null, h);
            const p = this.sourceCaches[r];
            return p ? (function(g, y) {
              const x = g.getRenderableIds().map(((R) => g.getTileByID(R))), E = [], C = {};
              for (let R = 0; R < x.length; R++) {
                const B = x[R], k = B.tileID.canonical.key;
                C[k] || (C[k] = !0, B.querySourceFeatures(E, y));
              }
              return E;
            })(p, h) : [];
          }
          getLight() {
            return this.light.getLight();
          }
          setLight(r, h = {}) {
            this._checkLoaded();
            const p = this.light.getLight();
            let g = !1;
            for (const x in r) if (!a.bH(r[x], p[x])) {
              g = !0;
              break;
            }
            if (!g) return;
            const y = { now: N.now(), transition: a.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.light.setLight(r, h), this.light.updateTransitions(y);
          }
          getProjection() {
            var r;
            return (r = this.stylesheet) === null || r === void 0 ? void 0 : r.projection;
          }
          setProjection(r) {
            if (this._checkLoaded(), this.projection) {
              if (this.projection.name === r.type) return;
              this.projection.destroy(), delete this.projection;
            }
            this.stylesheet.projection = r, this._setProjectionInternal(r.type);
          }
          getSky() {
            var r;
            return (r = this.stylesheet) === null || r === void 0 ? void 0 : r.sky;
          }
          setSky(r, h = {}) {
            this._checkLoaded();
            const p = this.getSky();
            let g = !1;
            if (!r && !p) return;
            if (r && !p) g = !0;
            else if (!r && p) g = !0;
            else for (const x in r) if (!a.bH(r[x], p[x])) {
              g = !0;
              break;
            }
            if (!g) return;
            const y = { now: N.now(), transition: a.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.stylesheet.sky = r, this.sky.setSky(r, h), this.sky.updateTransitions(y);
          }
          _setProjectionInternal(r) {
            const h = (function(p) {
              if (Array.isArray(p)) {
                const g = new Ll({ type: p });
                return { projection: g, transform: new Ha(), cameraHelper: new _d(g) };
              }
              switch (p) {
                case "mercator":
                  return { projection: new mt(), transform: new oi(), cameraHelper: new Cr() };
                case "globe": {
                  const g = new Ll({ type: ["interpolate", ["linear"], ["zoom"], 11, "vertical-perspective", 12, "mercator"] });
                  return { projection: g, transform: new Ha(), cameraHelper: new _d(g) };
                }
                case "vertical-perspective":
                  return { projection: new Na(), transform: new ja(), cameraHelper: new Ir() };
                default:
                  return a.w(`Unknown projection name: ${p}. Falling back to mercator projection.`), { projection: new mt(), transform: new oi(), cameraHelper: new Cr() };
              }
            })(r);
            this.projection = h.projection, this.map.migrateProjection(h.transform, h.cameraHelper);
            for (const p in this.sourceCaches) this.sourceCaches[p].reload();
          }
          _validate(r, h, p, g, y = {}) {
            return (!y || y.validate !== !1) && zl(this, r.call(a.z, a.e({ key: h, style: this.serialize(), value: p, styleSpec: a.v }, g)));
          }
          _remove(r = !0) {
            this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), As().off(_n, this._rtlPluginLoaded);
            for (const h in this._layers) this._layers[h].setEventedParent(null);
            for (const h in this.sourceCaches) {
              const p = this.sourceCaches[h];
              p.setEventedParent(null), p.onRemove(this.map);
            }
            this.imageManager.setEventedParent(null), this.setEventedParent(null), r && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(r);
          }
          _clearSource(r) {
            this.sourceCaches[r].clearTiles();
          }
          _reloadSource(r) {
            this.sourceCaches[r].resume(), this.sourceCaches[r].reload();
          }
          _updateSources(r) {
            for (const h in this.sourceCaches) this.sourceCaches[h].update(r, this.map.terrain);
          }
          _generateCollisionBoxes() {
            for (const r in this.sourceCaches) this._reloadSource(r);
          }
          _updatePlacement(r, h, p, g, y = !1) {
            let x = !1, E = !1;
            const C = {};
            for (const R of this._order) {
              const B = this._layers[R];
              if (B.type !== "symbol") continue;
              if (!C[B.source]) {
                const O = this.sourceCaches[B.source];
                C[B.source] = O.getRenderableIds(!0).map(((z) => O.getTileByID(z))).sort(((z, H) => H.tileID.overscaledZ - z.tileID.overscaledZ || (z.tileID.isLessThan(H.tileID) ? -1 : 1)));
              }
              const k = this.crossTileSymbolIndex.addLayer(B, C[B.source], r.center.lng);
              x = x || k;
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((y = y || this._layerOrderChanged || p === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(N.now(), r.zoom)) && (this.pauseablePlacement = new Vo(r, this.map.terrain, this._order, y, h, p, g, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, C), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(N.now()), E = !0), x && this.pauseablePlacement.placement.setStale()), E || x) for (const R of this._order) {
              const B = this._layers[R];
              B.type === "symbol" && this.placement.updateLayerOpacities(B, C[B.source]);
            }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(N.now());
          }
          _releaseSymbolFadeTiles() {
            for (const r in this.sourceCaches) this.sourceCaches[r].releaseSymbolFadeTiles();
          }
          getImages(r, h) {
            return a._(this, void 0, void 0, (function* () {
              const p = yield this.imageManager.getImages(h.icons);
              this._updateTilesForChangedImages();
              const g = this.sourceCaches[h.source];
              return g && g.setDependencies(h.tileID.key, h.type, h.icons), p;
            }));
          }
          getGlyphs(r, h) {
            return a._(this, void 0, void 0, (function* () {
              const p = yield this.glyphManager.getGlyphs(h.stacks), g = this.sourceCaches[h.source];
              return g && g.setDependencies(h.tileID.key, h.type, [""]), p;
            }));
          }
          getGlyphsUrl() {
            return this.stylesheet.glyphs || null;
          }
          setGlyphs(r, h = {}) {
            this._checkLoaded(), r && this._validate(a.z.glyphs, "glyphs", r, null, h) || (this._glyphsDidChange = !0, this.stylesheet.glyphs = r, this.glyphManager.entries = {}, this.glyphManager.setURL(r));
          }
          addSprite(r, h, p = {}, g) {
            this._checkLoaded();
            const y = [{ id: r, url: h }], x = [...Ke(this.stylesheet.sprite), ...y];
            this._validate(a.z.sprite, "sprite", x, null, p) || (this.stylesheet.sprite = x, this._loadSprite(y, !0, g));
          }
          removeSprite(r) {
            this._checkLoaded();
            const h = Ke(this.stylesheet.sprite);
            if (h.find(((p) => p.id === r))) {
              if (this._spritesImagesIds[r]) for (const p of this._spritesImagesIds[r]) this.imageManager.removeImage(p), this._changedImages[p] = !0;
              h.splice(h.findIndex(((p) => p.id === r)), 1), this.stylesheet.sprite = h.length > 0 ? h : void 0, delete this._spritesImagesIds[r], this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new a.l("data", { dataType: "style" }));
            } else this.fire(new a.k(new Error(`Sprite "${r}" doesn't exists on this map.`)));
          }
          getSprite() {
            return Ke(this.stylesheet.sprite);
          }
          setSprite(r, h = {}, p) {
            this._checkLoaded(), r && this._validate(a.z.sprite, "sprite", r, null, h) || (this.stylesheet.sprite = r, r ? this._loadSprite(r, !0, p) : (this._unloadSprite(), p && p(null)));
          }
        }
        var Wp = a.aJ([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
        class Xp {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
          }
          bind(r, h, p, g, y, x, E, C, R) {
            this.context = r;
            let B = this.boundPaintVertexBuffers.length !== g.length;
            for (let k = 0; !B && k < g.length; k++) this.boundPaintVertexBuffers[k] !== g[k] && (B = !0);
            !this.vao || this.boundProgram !== h || this.boundLayoutVertexBuffer !== p || B || this.boundIndexBuffer !== y || this.boundVertexOffset !== x || this.boundDynamicVertexBuffer !== E || this.boundDynamicVertexBuffer2 !== C || this.boundDynamicVertexBuffer3 !== R ? this.freshBind(h, p, g, y, x, E, C, R) : (r.bindVertexArray.set(this.vao), E && E.bind(), y && y.dynamicDraw && y.bind(), C && C.bind(), R && R.bind());
          }
          freshBind(r, h, p, g, y, x, E, C) {
            const R = r.numAttributes, B = this.context, k = B.gl;
            this.vao && this.destroy(), this.vao = B.createVertexArray(), B.bindVertexArray.set(this.vao), this.boundProgram = r, this.boundLayoutVertexBuffer = h, this.boundPaintVertexBuffers = p, this.boundIndexBuffer = g, this.boundVertexOffset = y, this.boundDynamicVertexBuffer = x, this.boundDynamicVertexBuffer2 = E, this.boundDynamicVertexBuffer3 = C, h.enableAttributes(k, r);
            for (const O of p) O.enableAttributes(k, r);
            x && x.enableAttributes(k, r), E && E.enableAttributes(k, r), C && C.enableAttributes(k, r), h.bind(), h.setVertexAttribPointers(k, r, y);
            for (const O of p) O.bind(), O.setVertexAttribPointers(k, r, y);
            x && (x.bind(), x.setVertexAttribPointers(k, r, y)), g && g.bind(), E && (E.bind(), E.setVertexAttribPointers(k, r, y)), C && (C.bind(), C.setVertexAttribPointers(k, r, y)), B.currentNumAttributes = R;
          }
          destroy() {
            this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
          }
        }
        const Vl = (m, r, h, p, g) => ({ u_texture: 0, u_ele_delta: m, u_fog_matrix: r, u_fog_color: h ? h.properties.get("fog-color") : a.bf.white, u_fog_ground_blend: h ? h.properties.get("fog-ground-blend") : 1, u_fog_ground_blend_opacity: g ? 0 : h ? h.calculateFogBlendOpacity(p) : 0, u_horizon_color: h ? h.properties.get("horizon-color") : a.bf.white, u_horizon_fog_blend: h ? h.properties.get("horizon-fog-blend") : 1, u_is_globe_mode: g ? 1 : 0 }), wh = { mainMatrix: "u_projection_matrix", tileMercatorCoords: "u_projection_tile_mercator_coords", clippingPlane: "u_projection_clipping_plane", projectionTransition: "u_projection_transition", fallbackMatrix: "u_projection_fallback_matrix" };
        function po(m) {
          const r = [];
          for (let h = 0; h < m.length; h++) {
            if (m[h] === null) continue;
            const p = m[h].split(" ");
            r.push(p.pop());
          }
          return r;
        }
        class Th {
          constructor(r, h, p, g, y, x, E, C, R = []) {
            const B = r.gl;
            this.program = B.createProgram();
            const k = po(h.staticAttributes), O = p ? p.getBinderAttributes() : [], z = k.concat(O), H = ue.prelude.staticUniforms ? po(ue.prelude.staticUniforms) : [], Y = E.staticUniforms ? po(E.staticUniforms) : [], K = h.staticUniforms ? po(h.staticUniforms) : [], J = p ? p.getBinderUniforms() : [], ie = H.concat(Y).concat(K).concat(J), le = [];
            for (const Ie of ie) le.indexOf(Ie) < 0 && le.push(Ie);
            const se = p ? p.defines() : [];
            rn(B) && se.unshift("#version 300 es"), y && se.push("#define OVERDRAW_INSPECTOR;"), x && se.push("#define TERRAIN3D;"), C && se.push(C), R && se.push(...R);
            let he = se.concat(ue.prelude.fragmentSource, E.fragmentSource, h.fragmentSource).join(`
`), fe = se.concat(ue.prelude.vertexSource, E.vertexSource, h.vertexSource).join(`
`);
            rn(B) || (he = (function(Ie) {
              return Ie.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(");
            })(he), fe = (function(Ie) {
              return Ie.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(");
            })(fe));
            const oe = B.createShader(B.FRAGMENT_SHADER);
            if (B.isContextLost()) return void (this.failedToCreate = !0);
            if (B.shaderSource(oe, he), B.compileShader(oe), !B.getShaderParameter(oe, B.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${B.getShaderInfoLog(oe)}`);
            B.attachShader(this.program, oe);
            const be = B.createShader(B.VERTEX_SHADER);
            if (B.isContextLost()) return void (this.failedToCreate = !0);
            if (B.shaderSource(be, fe), B.compileShader(be), !B.getShaderParameter(be, B.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${B.getShaderInfoLog(be)}`);
            B.attachShader(this.program, be), this.attributes = {};
            const Fe = {};
            this.numAttributes = z.length;
            for (let Ie = 0; Ie < this.numAttributes; Ie++) z[Ie] && (B.bindAttribLocation(this.program, Ie, z[Ie]), this.attributes[z[Ie]] = Ie);
            if (B.linkProgram(this.program), !B.getProgramParameter(this.program, B.LINK_STATUS)) throw new Error(`Program failed to link: ${B.getProgramInfoLog(this.program)}`);
            B.deleteShader(be), B.deleteShader(oe);
            for (let Ie = 0; Ie < le.length; Ie++) {
              const Me = le[Ie];
              if (Me && !Fe[Me]) {
                const Oe = B.getUniformLocation(this.program, Me);
                Oe && (Fe[Me] = Oe);
              }
            }
            this.fixedUniforms = g(r, Fe), this.terrainUniforms = ((Ie, Me) => ({ u_depth: new a.bP(Ie, Me.u_depth), u_terrain: new a.bP(Ie, Me.u_terrain), u_terrain_dim: new a.bg(Ie, Me.u_terrain_dim), u_terrain_matrix: new a.bR(Ie, Me.u_terrain_matrix), u_terrain_unpack: new a.bS(Ie, Me.u_terrain_unpack), u_terrain_exaggeration: new a.bg(Ie, Me.u_terrain_exaggeration) }))(r, Fe), this.projectionUniforms = ((Ie, Me) => ({ u_projection_matrix: new a.bR(Ie, Me.u_projection_matrix), u_projection_tile_mercator_coords: new a.bS(Ie, Me.u_projection_tile_mercator_coords), u_projection_clipping_plane: new a.bS(Ie, Me.u_projection_clipping_plane), u_projection_transition: new a.bg(Ie, Me.u_projection_transition), u_projection_fallback_matrix: new a.bR(Ie, Me.u_projection_fallback_matrix) }))(r, Fe), this.binderUniforms = p ? p.getUniforms(r, Fe) : [];
          }
          draw(r, h, p, g, y, x, E, C, R, B, k, O, z, H, Y, K, J, ie, le) {
            const se = r.gl;
            if (this.failedToCreate) return;
            if (r.program.set(this.program), r.setDepthMode(p), r.setStencilMode(g), r.setColorMode(y), r.setCullFace(x), C) {
              r.activeTexture.set(se.TEXTURE2), se.bindTexture(se.TEXTURE_2D, C.depthTexture), r.activeTexture.set(se.TEXTURE3), se.bindTexture(se.TEXTURE_2D, C.texture);
              for (const fe in this.terrainUniforms) this.terrainUniforms[fe].set(C[fe]);
            }
            if (R) for (const fe in R) this.projectionUniforms[wh[fe]].set(R[fe]);
            if (E) for (const fe in this.fixedUniforms) this.fixedUniforms[fe].set(E[fe]);
            K && K.setUniforms(r, this.binderUniforms, H, { zoom: Y });
            let he = 0;
            switch (h) {
              case se.LINES:
                he = 2;
                break;
              case se.TRIANGLES:
                he = 3;
                break;
              case se.LINE_STRIP:
                he = 1;
            }
            for (const fe of z.get()) {
              const oe = fe.vaos || (fe.vaos = {});
              (oe[B] || (oe[B] = new Xp())).bind(r, this, k, K ? K.getPaintVertexBuffers() : [], O, fe.vertexOffset, J, ie, le), se.drawElements(h, fe.primitiveLength * he, se.UNSIGNED_SHORT, fe.primitiveOffset * he * 2);
            }
          }
        }
        function jl(m, r, h) {
          const p = 1 / a.aC(h, 1, r.transform.tileZoom), g = Math.pow(2, h.tileID.overscaledZ), y = h.tileSize * Math.pow(2, r.transform.tileZoom) / g, x = y * (h.tileID.canonical.x + h.tileID.wrap * g), E = y * h.tileID.canonical.y;
          return { u_image: 0, u_texsize: h.imageAtlasTexture.size, u_scale: [p, m.fromScale, m.toScale], u_fade: m.t, u_pixel_coord_upper: [x >> 16, E >> 16], u_pixel_coord_lower: [65535 & x, 65535 & E] };
        }
        const Ps = (m, r, h, p) => {
          const g = m.style.light, y = g.properties.get("position"), x = [y.x, y.y, y.z], E = a.bV();
          g.properties.get("anchor") === "viewport" && a.bW(E, m.transform.bearingInRadians), a.bX(x, x, E);
          const C = m.transform.transformLightDirection(x), R = g.properties.get("color");
          return { u_lightpos: x, u_lightpos_globe: C, u_lightintensity: g.properties.get("intensity"), u_lightcolor: [R.r, R.g, R.b], u_vertical_gradient: +r, u_opacity: h, u_fill_translate: p };
        }, qp = (m, r, h, p, g, y, x) => a.e(Ps(m, r, h, p), jl(y, m, x), { u_height_factor: -Math.pow(2, g.overscaledZ) / x.tileSize / 8 }), Hl = (m, r, h, p) => a.e(jl(r, m, h), { u_fill_translate: p }), $a = (m, r) => ({ u_world: m, u_fill_translate: r }), Ga = (m, r, h, p, g) => a.e(Hl(m, r, h, g), { u_world: p }), Zp = (m, r, h, p, g) => {
          const y = m.transform;
          let x, E, C = 0;
          if (h.paint.get("circle-pitch-alignment") === "map") {
            const R = a.aC(r, 1, y.zoom);
            x = !0, E = [R, R], C = R / (a.$ * Math.pow(2, r.tileID.overscaledZ)) * 2 * Math.PI * g;
          } else x = !1, E = y.pixelsToGLUnits;
          return { u_camera_to_center_distance: y.cameraToCenterDistance, u_scale_with_map: +(h.paint.get("circle-pitch-scale") === "map"), u_pitch_with_map: +x, u_device_pixel_ratio: m.pixelRatio, u_extrude_scale: E, u_globe_extrude_scale: C, u_translate: p };
        }, $l = (m) => ({ u_pixel_extrude_scale: [1 / m.width, 1 / m.height] }), Kp = (m) => ({ u_viewport_size: [m.width, m.height] }), _o = (m, r = 1) => ({ u_color: m, u_overlay: 0, u_overlay_scale: r }), gd = (m, r, h, p) => {
          const g = a.aC(m, 1, r) / (a.$ * Math.pow(2, m.tileID.overscaledZ)) * 2 * Math.PI * p;
          return { u_extrude_scale: a.aC(m, 1, r), u_intensity: h, u_globe_extrude_scale: g };
        }, Ah = (m, r, h, p) => {
          const g = a.L();
          a.bY(g, 0, m.width, m.height, 0, 0, 1);
          const y = m.context.gl;
          return { u_matrix: g, u_world: [y.drawingBufferWidth, y.drawingBufferHeight], u_image: h, u_color_ramp: p, u_opacity: r.paint.get("heatmap-opacity") };
        }, Yp = (m, r, h) => {
          const p = h.paint.get("hillshade-accent-color");
          let g;
          switch (h.paint.get("hillshade-method")) {
            case "basic":
              g = 4;
              break;
            case "combined":
              g = 1;
              break;
            case "igor":
              g = 2;
              break;
            case "multidirectional":
              g = 3;
              break;
            default:
              g = 0;
          }
          const y = h.getIlluminationProperties();
          for (let x = 0; x < y.directionRadians.length; x++) h.paint.get("hillshade-illumination-anchor") === "viewport" && (y.directionRadians[x] += m.transform.bearingInRadians);
          return { u_image: 0, u_latrange: Eh(0, r.tileID), u_exaggeration: h.paint.get("hillshade-exaggeration"), u_altitudes: y.altitudeRadians, u_azimuths: y.directionRadians, u_accent: p, u_method: g, u_highlights: y.highlightColor, u_shadows: y.shadowColor };
        }, md = (m, r) => {
          const h = r.stride, p = a.L();
          return a.bY(p, 0, a.$, -a.$, 0, 0, 1), a.M(p, p, [0, -a.$, 0]), { u_matrix: p, u_image: 1, u_dimension: [h, h], u_zoom: m.overscaledZ, u_unpack: r.getUnpackVector() };
        };
        function Eh(m, r) {
          const h = Math.pow(2, r.canonical.z), p = r.canonical.y;
          return [new a.a1(0, p / h).toLngLat().lat, new a.a1(0, (p + 1) / h).toLngLat().lat];
        }
        const yd = (m, r, h = 0) => ({ u_image: 0, u_unpack: r.getUnpackVector(), u_dimension: [r.stride, r.stride], u_elevation_stops: 1, u_color_stops: 4, u_color_ramp_size: h, u_opacity: m.paint.get("color-relief-opacity") }), Gl = (m, r, h, p) => {
          const g = m.transform;
          return { u_translation: Ch(m, r, h), u_ratio: p / a.aC(r, 1, g.zoom), u_device_pixel_ratio: m.pixelRatio, u_units_to_pixels: [1 / g.pixelsToGLUnits[0], 1 / g.pixelsToGLUnits[1]] };
        }, bd = (m, r, h, p, g) => a.e(Gl(m, r, h, p), { u_image: 0, u_image_height: g }), vd = (m, r, h, p, g) => {
          const y = m.transform, x = Sh(r, y);
          return { u_translation: Ch(m, r, h), u_texsize: r.imageAtlasTexture.size, u_ratio: p / a.aC(r, 1, y.zoom), u_device_pixel_ratio: m.pixelRatio, u_image: 0, u_scale: [x, g.fromScale, g.toScale], u_fade: g.t, u_units_to_pixels: [1 / y.pixelsToGLUnits[0], 1 / y.pixelsToGLUnits[1]] };
        }, go = (m, r, h, p, g, y) => {
          const x = m.lineAtlas, E = Sh(r, m.transform), C = h.layout.get("line-cap") === "round", R = x.getDash(g.from, C), B = x.getDash(g.to, C), k = R.width * y.fromScale, O = B.width * y.toScale;
          return a.e(Gl(m, r, h, p), { u_patternscale_a: [E / k, -R.height / 2], u_patternscale_b: [E / O, -B.height / 2], u_sdfgamma: x.width / (256 * Math.min(k, O) * m.pixelRatio) / 2, u_image: 0, u_tex_y_a: R.y, u_tex_y_b: B.y, u_mix: y.t });
        };
        function Sh(m, r) {
          return 1 / a.aC(m, 1, r.tileZoom);
        }
        function Ch(m, r, h) {
          return a.aD(m.transform, r, h.paint.get("line-translate"), h.paint.get("line-translate-anchor"));
        }
        const Wa = (m, r, h, p, g) => {
          return { u_tl_parent: m, u_scale_parent: r, u_buffer_scale: 1, u_fade_t: h.mix, u_opacity: h.opacity * p.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: p.paint.get("raster-brightness-min"), u_brightness_high: p.paint.get("raster-brightness-max"), u_saturation_factor: (x = p.paint.get("raster-saturation"), x > 0 ? 1 - 1 / (1.001 - x) : -x), u_contrast_factor: (y = p.paint.get("raster-contrast"), y > 0 ? 1 / (1 - y) : 1 + y), u_spin_weights: Jp(p.paint.get("raster-hue-rotate")), u_coords_top: [g[0].x, g[0].y, g[1].x, g[1].y], u_coords_bottom: [g[3].x, g[3].y, g[2].x, g[2].y] };
          var y, x;
        };
        function Jp(m) {
          m *= Math.PI / 180;
          const r = Math.sin(m), h = Math.cos(m);
          return [(2 * h + 1) / 3, (-Math.sqrt(3) * r - h + 1) / 3, (Math.sqrt(3) * r - h + 1) / 3];
        }
        const Xa = (m, r, h, p, g, y, x, E, C, R, B, k, O) => {
          const z = x.transform;
          return { u_is_size_zoom_constant: +(m === "constant" || m === "source"), u_is_size_feature_constant: +(m === "constant" || m === "camera"), u_size_t: r ? r.uSizeT : 0, u_size: r ? r.uSize : 0, u_camera_to_center_distance: z.cameraToCenterDistance, u_pitch: z.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +h, u_aspect_ratio: z.width / z.height, u_fade_change: x.options.fadeDuration ? x.symbolFadeChange : 1, u_label_plane_matrix: E, u_coord_matrix: C, u_is_text: +B, u_pitch_with_map: +p, u_is_along_line: g, u_is_variable_anchor: y, u_texsize: k, u_texture: 0, u_translation: R, u_pitched_scale: O };
        }, xd = (m, r, h, p, g, y, x, E, C, R, B, k, O, z) => {
          const H = x.transform;
          return a.e(Xa(m, r, h, p, g, y, x, E, C, R, B, k, z), { u_gamma_scale: p ? Math.cos(H.pitch * Math.PI / 180) * H.cameraToCenterDistance : 1, u_device_pixel_ratio: x.pixelRatio, u_is_halo: 1 });
        }, Qp = (m, r, h, p, g, y, x, E, C, R, B, k, O) => a.e(xd(m, r, h, p, g, y, x, E, C, R, !0, B, 0, O), { u_texsize_icon: k, u_texture_icon: 1 }), wd = (m, r) => ({ u_opacity: m, u_color: r }), Td = (m, r, h, p, g) => a.e((function(y, x, E, C) {
          const R = E.imageManager.getPattern(y.from.toString()), B = E.imageManager.getPattern(y.to.toString()), { width: k, height: O } = E.imageManager.getPixelSize(), z = Math.pow(2, C.tileID.overscaledZ), H = C.tileSize * Math.pow(2, E.transform.tileZoom) / z, Y = H * (C.tileID.canonical.x + C.tileID.wrap * z), K = H * C.tileID.canonical.y;
          return { u_image: 0, u_pattern_tl_a: R.tl, u_pattern_br_a: R.br, u_pattern_tl_b: B.tl, u_pattern_br_b: B.br, u_texsize: [k, O], u_mix: x.t, u_pattern_size_a: R.displaySize, u_pattern_size_b: B.displaySize, u_scale_a: x.fromScale, u_scale_b: x.toScale, u_tile_units_to_pixels: 1 / a.aC(C, 1, E.transform.tileZoom), u_pixel_coord_upper: [Y >> 16, K >> 16], u_pixel_coord_lower: [65535 & Y, 65535 & K] };
        })(h, g, r, p), { u_opacity: m }), Ih = (m, r) => {
        }, Mh = { fillExtrusion: (m, r) => ({ u_lightpos: new a.bT(m, r.u_lightpos), u_lightpos_globe: new a.bT(m, r.u_lightpos_globe), u_lightintensity: new a.bg(m, r.u_lightintensity), u_lightcolor: new a.bT(m, r.u_lightcolor), u_vertical_gradient: new a.bg(m, r.u_vertical_gradient), u_opacity: new a.bg(m, r.u_opacity), u_fill_translate: new a.bU(m, r.u_fill_translate) }), fillExtrusionPattern: (m, r) => ({ u_lightpos: new a.bT(m, r.u_lightpos), u_lightpos_globe: new a.bT(m, r.u_lightpos_globe), u_lightintensity: new a.bg(m, r.u_lightintensity), u_lightcolor: new a.bT(m, r.u_lightcolor), u_vertical_gradient: new a.bg(m, r.u_vertical_gradient), u_height_factor: new a.bg(m, r.u_height_factor), u_opacity: new a.bg(m, r.u_opacity), u_fill_translate: new a.bU(m, r.u_fill_translate), u_image: new a.bP(m, r.u_image), u_texsize: new a.bU(m, r.u_texsize), u_pixel_coord_upper: new a.bU(m, r.u_pixel_coord_upper), u_pixel_coord_lower: new a.bU(m, r.u_pixel_coord_lower), u_scale: new a.bT(m, r.u_scale), u_fade: new a.bg(m, r.u_fade) }), fill: (m, r) => ({ u_fill_translate: new a.bU(m, r.u_fill_translate) }), fillPattern: (m, r) => ({ u_image: new a.bP(m, r.u_image), u_texsize: new a.bU(m, r.u_texsize), u_pixel_coord_upper: new a.bU(m, r.u_pixel_coord_upper), u_pixel_coord_lower: new a.bU(m, r.u_pixel_coord_lower), u_scale: new a.bT(m, r.u_scale), u_fade: new a.bg(m, r.u_fade), u_fill_translate: new a.bU(m, r.u_fill_translate) }), fillOutline: (m, r) => ({ u_world: new a.bU(m, r.u_world), u_fill_translate: new a.bU(m, r.u_fill_translate) }), fillOutlinePattern: (m, r) => ({ u_world: new a.bU(m, r.u_world), u_image: new a.bP(m, r.u_image), u_texsize: new a.bU(m, r.u_texsize), u_pixel_coord_upper: new a.bU(m, r.u_pixel_coord_upper), u_pixel_coord_lower: new a.bU(m, r.u_pixel_coord_lower), u_scale: new a.bT(m, r.u_scale), u_fade: new a.bg(m, r.u_fade), u_fill_translate: new a.bU(m, r.u_fill_translate) }), circle: (m, r) => ({ u_camera_to_center_distance: new a.bg(m, r.u_camera_to_center_distance), u_scale_with_map: new a.bP(m, r.u_scale_with_map), u_pitch_with_map: new a.bP(m, r.u_pitch_with_map), u_extrude_scale: new a.bU(m, r.u_extrude_scale), u_device_pixel_ratio: new a.bg(m, r.u_device_pixel_ratio), u_globe_extrude_scale: new a.bg(m, r.u_globe_extrude_scale), u_translate: new a.bU(m, r.u_translate) }), collisionBox: (m, r) => ({ u_pixel_extrude_scale: new a.bU(m, r.u_pixel_extrude_scale) }), collisionCircle: (m, r) => ({ u_viewport_size: new a.bU(m, r.u_viewport_size) }), debug: (m, r) => ({ u_color: new a.bQ(m, r.u_color), u_overlay: new a.bP(m, r.u_overlay), u_overlay_scale: new a.bg(m, r.u_overlay_scale) }), depth: Ih, clippingMask: Ih, heatmap: (m, r) => ({ u_extrude_scale: new a.bg(m, r.u_extrude_scale), u_intensity: new a.bg(m, r.u_intensity), u_globe_extrude_scale: new a.bg(m, r.u_globe_extrude_scale) }), heatmapTexture: (m, r) => ({ u_matrix: new a.bR(m, r.u_matrix), u_world: new a.bU(m, r.u_world), u_image: new a.bP(m, r.u_image), u_color_ramp: new a.bP(m, r.u_color_ramp), u_opacity: new a.bg(m, r.u_opacity) }), hillshade: (m, r) => ({ u_image: new a.bP(m, r.u_image), u_latrange: new a.bU(m, r.u_latrange), u_exaggeration: new a.bg(m, r.u_exaggeration), u_altitudes: new a.b_(m, r.u_altitudes), u_azimuths: new a.b_(m, r.u_azimuths), u_accent: new a.bQ(m, r.u_accent), u_method: new a.bP(m, r.u_method), u_shadows: new a.bZ(m, r.u_shadows), u_highlights: new a.bZ(m, r.u_highlights) }), hillshadePrepare: (m, r) => ({ u_matrix: new a.bR(m, r.u_matrix), u_image: new a.bP(m, r.u_image), u_dimension: new a.bU(m, r.u_dimension), u_zoom: new a.bg(m, r.u_zoom), u_unpack: new a.bS(m, r.u_unpack) }), colorRelief: (m, r) => ({ u_image: new a.bP(m, r.u_image), u_unpack: new a.bS(m, r.u_unpack), u_dimension: new a.bU(m, r.u_dimension), u_elevation_stops: new a.bP(m, r.u_elevation_stops), u_color_stops: new a.bP(m, r.u_color_stops), u_color_ramp_size: new a.bP(m, r.u_color_ramp_size), u_opacity: new a.bg(m, r.u_opacity) }), line: (m, r) => ({ u_translation: new a.bU(m, r.u_translation), u_ratio: new a.bg(m, r.u_ratio), u_device_pixel_ratio: new a.bg(m, r.u_device_pixel_ratio), u_units_to_pixels: new a.bU(m, r.u_units_to_pixels) }), lineGradient: (m, r) => ({ u_translation: new a.bU(m, r.u_translation), u_ratio: new a.bg(m, r.u_ratio), u_device_pixel_ratio: new a.bg(m, r.u_device_pixel_ratio), u_units_to_pixels: new a.bU(m, r.u_units_to_pixels), u_image: new a.bP(m, r.u_image), u_image_height: new a.bg(m, r.u_image_height) }), linePattern: (m, r) => ({ u_translation: new a.bU(m, r.u_translation), u_texsize: new a.bU(m, r.u_texsize), u_ratio: new a.bg(m, r.u_ratio), u_device_pixel_ratio: new a.bg(m, r.u_device_pixel_ratio), u_image: new a.bP(m, r.u_image), u_units_to_pixels: new a.bU(m, r.u_units_to_pixels), u_scale: new a.bT(m, r.u_scale), u_fade: new a.bg(m, r.u_fade) }), lineSDF: (m, r) => ({ u_translation: new a.bU(m, r.u_translation), u_ratio: new a.bg(m, r.u_ratio), u_device_pixel_ratio: new a.bg(m, r.u_device_pixel_ratio), u_units_to_pixels: new a.bU(m, r.u_units_to_pixels), u_patternscale_a: new a.bU(m, r.u_patternscale_a), u_patternscale_b: new a.bU(m, r.u_patternscale_b), u_sdfgamma: new a.bg(m, r.u_sdfgamma), u_image: new a.bP(m, r.u_image), u_tex_y_a: new a.bg(m, r.u_tex_y_a), u_tex_y_b: new a.bg(m, r.u_tex_y_b), u_mix: new a.bg(m, r.u_mix) }), raster: (m, r) => ({ u_tl_parent: new a.bU(m, r.u_tl_parent), u_scale_parent: new a.bg(m, r.u_scale_parent), u_buffer_scale: new a.bg(m, r.u_buffer_scale), u_fade_t: new a.bg(m, r.u_fade_t), u_opacity: new a.bg(m, r.u_opacity), u_image0: new a.bP(m, r.u_image0), u_image1: new a.bP(m, r.u_image1), u_brightness_low: new a.bg(m, r.u_brightness_low), u_brightness_high: new a.bg(m, r.u_brightness_high), u_saturation_factor: new a.bg(m, r.u_saturation_factor), u_contrast_factor: new a.bg(m, r.u_contrast_factor), u_spin_weights: new a.bT(m, r.u_spin_weights), u_coords_top: new a.bS(m, r.u_coords_top), u_coords_bottom: new a.bS(m, r.u_coords_bottom) }), symbolIcon: (m, r) => ({ u_is_size_zoom_constant: new a.bP(m, r.u_is_size_zoom_constant), u_is_size_feature_constant: new a.bP(m, r.u_is_size_feature_constant), u_size_t: new a.bg(m, r.u_size_t), u_size: new a.bg(m, r.u_size), u_camera_to_center_distance: new a.bg(m, r.u_camera_to_center_distance), u_pitch: new a.bg(m, r.u_pitch), u_rotate_symbol: new a.bP(m, r.u_rotate_symbol), u_aspect_ratio: new a.bg(m, r.u_aspect_ratio), u_fade_change: new a.bg(m, r.u_fade_change), u_label_plane_matrix: new a.bR(m, r.u_label_plane_matrix), u_coord_matrix: new a.bR(m, r.u_coord_matrix), u_is_text: new a.bP(m, r.u_is_text), u_pitch_with_map: new a.bP(m, r.u_pitch_with_map), u_is_along_line: new a.bP(m, r.u_is_along_line), u_is_variable_anchor: new a.bP(m, r.u_is_variable_anchor), u_texsize: new a.bU(m, r.u_texsize), u_texture: new a.bP(m, r.u_texture), u_translation: new a.bU(m, r.u_translation), u_pitched_scale: new a.bg(m, r.u_pitched_scale) }), symbolSDF: (m, r) => ({ u_is_size_zoom_constant: new a.bP(m, r.u_is_size_zoom_constant), u_is_size_feature_constant: new a.bP(m, r.u_is_size_feature_constant), u_size_t: new a.bg(m, r.u_size_t), u_size: new a.bg(m, r.u_size), u_camera_to_center_distance: new a.bg(m, r.u_camera_to_center_distance), u_pitch: new a.bg(m, r.u_pitch), u_rotate_symbol: new a.bP(m, r.u_rotate_symbol), u_aspect_ratio: new a.bg(m, r.u_aspect_ratio), u_fade_change: new a.bg(m, r.u_fade_change), u_label_plane_matrix: new a.bR(m, r.u_label_plane_matrix), u_coord_matrix: new a.bR(m, r.u_coord_matrix), u_is_text: new a.bP(m, r.u_is_text), u_pitch_with_map: new a.bP(m, r.u_pitch_with_map), u_is_along_line: new a.bP(m, r.u_is_along_line), u_is_variable_anchor: new a.bP(m, r.u_is_variable_anchor), u_texsize: new a.bU(m, r.u_texsize), u_texture: new a.bP(m, r.u_texture), u_gamma_scale: new a.bg(m, r.u_gamma_scale), u_device_pixel_ratio: new a.bg(m, r.u_device_pixel_ratio), u_is_halo: new a.bP(m, r.u_is_halo), u_translation: new a.bU(m, r.u_translation), u_pitched_scale: new a.bg(m, r.u_pitched_scale) }), symbolTextAndIcon: (m, r) => ({ u_is_size_zoom_constant: new a.bP(m, r.u_is_size_zoom_constant), u_is_size_feature_constant: new a.bP(m, r.u_is_size_feature_constant), u_size_t: new a.bg(m, r.u_size_t), u_size: new a.bg(m, r.u_size), u_camera_to_center_distance: new a.bg(m, r.u_camera_to_center_distance), u_pitch: new a.bg(m, r.u_pitch), u_rotate_symbol: new a.bP(m, r.u_rotate_symbol), u_aspect_ratio: new a.bg(m, r.u_aspect_ratio), u_fade_change: new a.bg(m, r.u_fade_change), u_label_plane_matrix: new a.bR(m, r.u_label_plane_matrix), u_coord_matrix: new a.bR(m, r.u_coord_matrix), u_is_text: new a.bP(m, r.u_is_text), u_pitch_with_map: new a.bP(m, r.u_pitch_with_map), u_is_along_line: new a.bP(m, r.u_is_along_line), u_is_variable_anchor: new a.bP(m, r.u_is_variable_anchor), u_texsize: new a.bU(m, r.u_texsize), u_texsize_icon: new a.bU(m, r.u_texsize_icon), u_texture: new a.bP(m, r.u_texture), u_texture_icon: new a.bP(m, r.u_texture_icon), u_gamma_scale: new a.bg(m, r.u_gamma_scale), u_device_pixel_ratio: new a.bg(m, r.u_device_pixel_ratio), u_is_halo: new a.bP(m, r.u_is_halo), u_translation: new a.bU(m, r.u_translation), u_pitched_scale: new a.bg(m, r.u_pitched_scale) }), background: (m, r) => ({ u_opacity: new a.bg(m, r.u_opacity), u_color: new a.bQ(m, r.u_color) }), backgroundPattern: (m, r) => ({ u_opacity: new a.bg(m, r.u_opacity), u_image: new a.bP(m, r.u_image), u_pattern_tl_a: new a.bU(m, r.u_pattern_tl_a), u_pattern_br_a: new a.bU(m, r.u_pattern_br_a), u_pattern_tl_b: new a.bU(m, r.u_pattern_tl_b), u_pattern_br_b: new a.bU(m, r.u_pattern_br_b), u_texsize: new a.bU(m, r.u_texsize), u_mix: new a.bg(m, r.u_mix), u_pattern_size_a: new a.bU(m, r.u_pattern_size_a), u_pattern_size_b: new a.bU(m, r.u_pattern_size_b), u_scale_a: new a.bg(m, r.u_scale_a), u_scale_b: new a.bg(m, r.u_scale_b), u_pixel_coord_upper: new a.bU(m, r.u_pixel_coord_upper), u_pixel_coord_lower: new a.bU(m, r.u_pixel_coord_lower), u_tile_units_to_pixels: new a.bg(m, r.u_tile_units_to_pixels) }), terrain: (m, r) => ({ u_texture: new a.bP(m, r.u_texture), u_ele_delta: new a.bg(m, r.u_ele_delta), u_fog_matrix: new a.bR(m, r.u_fog_matrix), u_fog_color: new a.bQ(m, r.u_fog_color), u_fog_ground_blend: new a.bg(m, r.u_fog_ground_blend), u_fog_ground_blend_opacity: new a.bg(m, r.u_fog_ground_blend_opacity), u_horizon_color: new a.bQ(m, r.u_horizon_color), u_horizon_fog_blend: new a.bg(m, r.u_horizon_fog_blend), u_is_globe_mode: new a.bg(m, r.u_is_globe_mode) }), terrainDepth: (m, r) => ({ u_ele_delta: new a.bg(m, r.u_ele_delta) }), terrainCoords: (m, r) => ({ u_texture: new a.bP(m, r.u_texture), u_terrain_coords_id: new a.bg(m, r.u_terrain_coords_id), u_ele_delta: new a.bg(m, r.u_ele_delta) }), projectionErrorMeasurement: (m, r) => ({ u_input: new a.bg(m, r.u_input), u_output_expected: new a.bg(m, r.u_output_expected) }), atmosphere: (m, r) => ({ u_sun_pos: new a.bT(m, r.u_sun_pos), u_atmosphere_blend: new a.bg(m, r.u_atmosphere_blend), u_globe_position: new a.bT(m, r.u_globe_position), u_globe_radius: new a.bg(m, r.u_globe_radius), u_inv_proj_matrix: new a.bR(m, r.u_inv_proj_matrix) }), sky: (m, r) => ({ u_sky_color: new a.bQ(m, r.u_sky_color), u_horizon_color: new a.bQ(m, r.u_horizon_color), u_horizon: new a.bU(m, r.u_horizon), u_horizon_normal: new a.bU(m, r.u_horizon_normal), u_sky_horizon_blend: new a.bg(m, r.u_sky_horizon_blend), u_sky_blend: new a.bg(m, r.u_sky_blend) }) };
        class Ad {
          constructor(r, h, p) {
            this.context = r;
            const g = r.gl;
            this.buffer = g.createBuffer(), this.dynamicDraw = !!p, this.context.unbindVAO(), r.bindElementBuffer.set(this.buffer), g.bufferData(g.ELEMENT_ARRAY_BUFFER, h.arrayBuffer, this.dynamicDraw ? g.DYNAMIC_DRAW : g.STATIC_DRAW), this.dynamicDraw || delete h.arrayBuffer;
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer);
          }
          updateData(r) {
            const h = this.context.gl;
            if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
            this.context.unbindVAO(), this.bind(), h.bufferSubData(h.ELEMENT_ARRAY_BUFFER, 0, r.arrayBuffer);
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        const Wl = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
        class yn {
          constructor(r, h, p, g) {
            this.length = h.length, this.attributes = p, this.itemSize = h.bytesPerElement, this.dynamicDraw = g, this.context = r;
            const y = r.gl;
            this.buffer = y.createBuffer(), r.bindVertexBuffer.set(this.buffer), y.bufferData(y.ARRAY_BUFFER, h.arrayBuffer, this.dynamicDraw ? y.DYNAMIC_DRAW : y.STATIC_DRAW), this.dynamicDraw || delete h.arrayBuffer;
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer);
          }
          updateData(r) {
            if (r.length !== this.length) throw new Error(`Length of new data is ${r.length}, which doesn't match current length of ${this.length}`);
            const h = this.context.gl;
            this.bind(), h.bufferSubData(h.ARRAY_BUFFER, 0, r.arrayBuffer);
          }
          enableAttributes(r, h) {
            for (let p = 0; p < this.attributes.length; p++) {
              const g = h.attributes[this.attributes[p].name];
              g !== void 0 && r.enableVertexAttribArray(g);
            }
          }
          setVertexAttribPointers(r, h, p) {
            for (let g = 0; g < this.attributes.length; g++) {
              const y = this.attributes[g], x = h.attributes[y.name];
              x !== void 0 && r.vertexAttribPointer(x, y.components, r[Wl[y.type]], !1, this.itemSize, y.offset + this.itemSize * (p || 0));
            }
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        class $t {
          constructor(r) {
            this.gl = r.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
          }
          get() {
            return this.current;
          }
          set(r) {
          }
          getDefault() {
            return this.default;
          }
          setDefault() {
            this.set(this.default);
          }
        }
        class Rh extends $t {
          getDefault() {
            return a.bf.transparent;
          }
          set(r) {
            const h = this.current;
            (r.r !== h.r || r.g !== h.g || r.b !== h.b || r.a !== h.a || this.dirty) && (this.gl.clearColor(r.r, r.g, r.b, r.a), this.current = r, this.dirty = !1);
          }
        }
        class Ph extends $t {
          getDefault() {
            return 1;
          }
          set(r) {
            (r !== this.current || this.dirty) && (this.gl.clearDepth(r), this.current = r, this.dirty = !1);
          }
        }
        class Ed extends $t {
          getDefault() {
            return 0;
          }
          set(r) {
            (r !== this.current || this.dirty) && (this.gl.clearStencil(r), this.current = r, this.dirty = !1);
          }
        }
        class Bh extends $t {
          getDefault() {
            return [!0, !0, !0, !0];
          }
          set(r) {
            const h = this.current;
            (r[0] !== h[0] || r[1] !== h[1] || r[2] !== h[2] || r[3] !== h[3] || this.dirty) && (this.gl.colorMask(r[0], r[1], r[2], r[3]), this.current = r, this.dirty = !1);
          }
        }
        class mo extends $t {
          getDefault() {
            return !0;
          }
          set(r) {
            (r !== this.current || this.dirty) && (this.gl.depthMask(r), this.current = r, this.dirty = !1);
          }
        }
        class Dh extends $t {
          getDefault() {
            return 255;
          }
          set(r) {
            (r !== this.current || this.dirty) && (this.gl.stencilMask(r), this.current = r, this.dirty = !1);
          }
        }
        class e_ extends $t {
          getDefault() {
            return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
          }
          set(r) {
            const h = this.current;
            (r.func !== h.func || r.ref !== h.ref || r.mask !== h.mask || this.dirty) && (this.gl.stencilFunc(r.func, r.ref, r.mask), this.current = r, this.dirty = !1);
          }
        }
        class t_ extends $t {
          getDefault() {
            const r = this.gl;
            return [r.KEEP, r.KEEP, r.KEEP];
          }
          set(r) {
            const h = this.current;
            (r[0] !== h[0] || r[1] !== h[1] || r[2] !== h[2] || this.dirty) && (this.gl.stencilOp(r[0], r[1], r[2]), this.current = r, this.dirty = !1);
          }
        }
        class i_ extends $t {
          getDefault() {
            return !1;
          }
          set(r) {
            if (r === this.current && !this.dirty) return;
            const h = this.gl;
            r ? h.enable(h.STENCIL_TEST) : h.disable(h.STENCIL_TEST), this.current = r, this.dirty = !1;
          }
        }
        class r_ extends $t {
          getDefault() {
            return [0, 1];
          }
          set(r) {
            const h = this.current;
            (r[0] !== h[0] || r[1] !== h[1] || this.dirty) && (this.gl.depthRange(r[0], r[1]), this.current = r, this.dirty = !1);
          }
        }
        class Sd extends $t {
          getDefault() {
            return !1;
          }
          set(r) {
            if (r === this.current && !this.dirty) return;
            const h = this.gl;
            r ? h.enable(h.DEPTH_TEST) : h.disable(h.DEPTH_TEST), this.current = r, this.dirty = !1;
          }
        }
        class s_ extends $t {
          getDefault() {
            return this.gl.LESS;
          }
          set(r) {
            (r !== this.current || this.dirty) && (this.gl.depthFunc(r), this.current = r, this.dirty = !1);
          }
        }
        class Cd extends $t {
          getDefault() {
            return !1;
          }
          set(r) {
            if (r === this.current && !this.dirty) return;
            const h = this.gl;
            r ? h.enable(h.BLEND) : h.disable(h.BLEND), this.current = r, this.dirty = !1;
          }
        }
        class Xl extends $t {
          getDefault() {
            const r = this.gl;
            return [r.ONE, r.ZERO];
          }
          set(r) {
            const h = this.current;
            (r[0] !== h[0] || r[1] !== h[1] || this.dirty) && (this.gl.blendFunc(r[0], r[1]), this.current = r, this.dirty = !1);
          }
        }
        class ql extends $t {
          getDefault() {
            return a.bf.transparent;
          }
          set(r) {
            const h = this.current;
            (r.r !== h.r || r.g !== h.g || r.b !== h.b || r.a !== h.a || this.dirty) && (this.gl.blendColor(r.r, r.g, r.b, r.a), this.current = r, this.dirty = !1);
          }
        }
        class Zl extends $t {
          getDefault() {
            return this.gl.FUNC_ADD;
          }
          set(r) {
            (r !== this.current || this.dirty) && (this.gl.blendEquation(r), this.current = r, this.dirty = !1);
          }
        }
        class Oh extends $t {
          getDefault() {
            return !1;
          }
          set(r) {
            if (r === this.current && !this.dirty) return;
            const h = this.gl;
            r ? h.enable(h.CULL_FACE) : h.disable(h.CULL_FACE), this.current = r, this.dirty = !1;
          }
        }
        class yo extends $t {
          getDefault() {
            return this.gl.BACK;
          }
          set(r) {
            (r !== this.current || this.dirty) && (this.gl.cullFace(r), this.current = r, this.dirty = !1);
          }
        }
        class qa extends $t {
          getDefault() {
            return this.gl.CCW;
          }
          set(r) {
            (r !== this.current || this.dirty) && (this.gl.frontFace(r), this.current = r, this.dirty = !1);
          }
        }
        class Wo extends $t {
          getDefault() {
            return null;
          }
          set(r) {
            (r !== this.current || this.dirty) && (this.gl.useProgram(r), this.current = r, this.dirty = !1);
          }
        }
        class fs extends $t {
          getDefault() {
            return this.gl.TEXTURE0;
          }
          set(r) {
            (r !== this.current || this.dirty) && (this.gl.activeTexture(r), this.current = r, this.dirty = !1);
          }
        }
        class Id extends $t {
          getDefault() {
            const r = this.gl;
            return [0, 0, r.drawingBufferWidth, r.drawingBufferHeight];
          }
          set(r) {
            const h = this.current;
            (r[0] !== h[0] || r[1] !== h[1] || r[2] !== h[2] || r[3] !== h[3] || this.dirty) && (this.gl.viewport(r[0], r[1], r[2], r[3]), this.current = r, this.dirty = !1);
          }
        }
        class Md extends $t {
          getDefault() {
            return null;
          }
          set(r) {
            if (r === this.current && !this.dirty) return;
            const h = this.gl;
            h.bindFramebuffer(h.FRAMEBUFFER, r), this.current = r, this.dirty = !1;
          }
        }
        class Fh extends $t {
          getDefault() {
            return null;
          }
          set(r) {
            if (r === this.current && !this.dirty) return;
            const h = this.gl;
            h.bindRenderbuffer(h.RENDERBUFFER, r), this.current = r, this.dirty = !1;
          }
        }
        class bo extends $t {
          getDefault() {
            return null;
          }
          set(r) {
            if (r === this.current && !this.dirty) return;
            const h = this.gl;
            h.bindTexture(h.TEXTURE_2D, r), this.current = r, this.dirty = !1;
          }
        }
        class Kl extends $t {
          getDefault() {
            return null;
          }
          set(r) {
            if (r === this.current && !this.dirty) return;
            const h = this.gl;
            h.bindBuffer(h.ARRAY_BUFFER, r), this.current = r, this.dirty = !1;
          }
        }
        class Yl extends $t {
          getDefault() {
            return null;
          }
          set(r) {
            const h = this.gl;
            h.bindBuffer(h.ELEMENT_ARRAY_BUFFER, r), this.current = r, this.dirty = !1;
          }
        }
        class Za extends $t {
          getDefault() {
            return null;
          }
          set(r) {
            var h;
            if (r === this.current && !this.dirty) return;
            const p = this.gl;
            rn(p) ? p.bindVertexArray(r) : (h = p.getExtension("OES_vertex_array_object")) === null || h === void 0 || h.bindVertexArrayOES(r), this.current = r, this.dirty = !1;
          }
        }
        class Jl extends $t {
          getDefault() {
            return 4;
          }
          set(r) {
            if (r === this.current && !this.dirty) return;
            const h = this.gl;
            h.pixelStorei(h.UNPACK_ALIGNMENT, r), this.current = r, this.dirty = !1;
          }
        }
        class Rd extends $t {
          getDefault() {
            return !1;
          }
          set(r) {
            if (r === this.current && !this.dirty) return;
            const h = this.gl;
            h.pixelStorei(h.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r), this.current = r, this.dirty = !1;
          }
        }
        class Xo extends $t {
          getDefault() {
            return !1;
          }
          set(r) {
            if (r === this.current && !this.dirty) return;
            const h = this.gl;
            h.pixelStorei(h.UNPACK_FLIP_Y_WEBGL, r), this.current = r, this.dirty = !1;
          }
        }
        class Hn extends $t {
          constructor(r, h) {
            super(r), this.context = r, this.parent = h;
          }
          getDefault() {
            return null;
          }
        }
        class Pd extends Hn {
          setDirty() {
            this.dirty = !0;
          }
          set(r) {
            if (r === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const h = this.gl;
            h.framebufferTexture2D(h.FRAMEBUFFER, h.COLOR_ATTACHMENT0, h.TEXTURE_2D, r, 0), this.current = r, this.dirty = !1;
          }
        }
        class kh extends Hn {
          set(r) {
            if (r === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const h = this.gl;
            h.framebufferRenderbuffer(h.FRAMEBUFFER, h.DEPTH_ATTACHMENT, h.RENDERBUFFER, r), this.current = r, this.dirty = !1;
          }
        }
        class kt extends Hn {
          set(r) {
            if (r === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const h = this.gl;
            h.framebufferRenderbuffer(h.FRAMEBUFFER, h.DEPTH_STENCIL_ATTACHMENT, h.RENDERBUFFER, r), this.current = r, this.dirty = !1;
          }
        }
        const Ka = "Framebuffer is not complete";
        class n_ {
          constructor(r, h, p, g, y) {
            this.context = r, this.width = h, this.height = p;
            const x = r.gl, E = this.framebuffer = x.createFramebuffer();
            if (this.colorAttachment = new Pd(r, E), g) this.depthAttachment = y ? new kt(r, E) : new kh(r, E);
            else if (y) throw new Error("Stencil cannot be set without depth");
            if (x.checkFramebufferStatus(x.FRAMEBUFFER) !== x.FRAMEBUFFER_COMPLETE) throw new Error(Ka);
          }
          destroy() {
            const r = this.context.gl, h = this.colorAttachment.get();
            if (h && r.deleteTexture(h), this.depthAttachment) {
              const p = this.depthAttachment.get();
              p && r.deleteRenderbuffer(p);
            }
            r.deleteFramebuffer(this.framebuffer);
          }
        }
        class Bd {
          constructor(r) {
            var h, p;
            if (this.gl = r, this.clearColor = new Rh(this), this.clearDepth = new Ph(this), this.clearStencil = new Ed(this), this.colorMask = new Bh(this), this.depthMask = new mo(this), this.stencilMask = new Dh(this), this.stencilFunc = new e_(this), this.stencilOp = new t_(this), this.stencilTest = new i_(this), this.depthRange = new r_(this), this.depthTest = new Sd(this), this.depthFunc = new s_(this), this.blend = new Cd(this), this.blendFunc = new Xl(this), this.blendColor = new ql(this), this.blendEquation = new Zl(this), this.cullFace = new Oh(this), this.cullFaceSide = new yo(this), this.frontFace = new qa(this), this.program = new Wo(this), this.activeTexture = new fs(this), this.viewport = new Id(this), this.bindFramebuffer = new Md(this), this.bindRenderbuffer = new Fh(this), this.bindTexture = new bo(this), this.bindVertexBuffer = new Kl(this), this.bindElementBuffer = new Yl(this), this.bindVertexArray = new Za(this), this.pixelStoreUnpack = new Jl(this), this.pixelStoreUnpackPremultiplyAlpha = new Rd(this), this.pixelStoreUnpackFlipY = new Xo(this), this.extTextureFilterAnisotropic = r.getExtension("EXT_texture_filter_anisotropic") || r.getExtension("MOZ_EXT_texture_filter_anisotropic") || r.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = r.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = r.getParameter(r.MAX_TEXTURE_SIZE), rn(r)) {
              this.HALF_FLOAT = r.HALF_FLOAT;
              const g = r.getExtension("EXT_color_buffer_half_float");
              this.RGBA16F = (h = r.RGBA16F) !== null && h !== void 0 ? h : g?.RGBA16F_EXT, this.RGB16F = (p = r.RGB16F) !== null && p !== void 0 ? p : g?.RGB16F_EXT, r.getExtension("EXT_color_buffer_float");
            } else {
              r.getExtension("EXT_color_buffer_half_float"), r.getExtension("OES_texture_half_float_linear");
              const g = r.getExtension("OES_texture_half_float");
              this.HALF_FLOAT = g?.HALF_FLOAT_OES;
            }
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
          }
          setDirty() {
            this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArray.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
          }
          createIndexBuffer(r, h) {
            return new Ad(this, r, h);
          }
          createVertexBuffer(r, h, p) {
            return new yn(this, r, h, p);
          }
          createRenderbuffer(r, h, p) {
            const g = this.gl, y = g.createRenderbuffer();
            return this.bindRenderbuffer.set(y), g.renderbufferStorage(g.RENDERBUFFER, r, h, p), this.bindRenderbuffer.set(null), y;
          }
          createFramebuffer(r, h, p, g) {
            return new n_(this, r, h, p, g);
          }
          clear({ color: r, depth: h, stencil: p }) {
            const g = this.gl;
            let y = 0;
            r && (y |= g.COLOR_BUFFER_BIT, this.clearColor.set(r), this.colorMask.set([!0, !0, !0, !0])), h !== void 0 && (y |= g.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(h), this.depthMask.set(!0)), p !== void 0 && (y |= g.STENCIL_BUFFER_BIT, this.clearStencil.set(p), this.stencilMask.set(255)), g.clear(y);
          }
          setCullFace(r) {
            r.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(r.mode), this.frontFace.set(r.frontFace));
          }
          setDepthMode(r) {
            r.func !== this.gl.ALWAYS || r.mask ? (this.depthTest.set(!0), this.depthFunc.set(r.func), this.depthMask.set(r.mask), this.depthRange.set(r.range)) : this.depthTest.set(!1);
          }
          setStencilMode(r) {
            r.test.func !== this.gl.ALWAYS || r.mask ? (this.stencilTest.set(!0), this.stencilMask.set(r.mask), this.stencilOp.set([r.fail, r.depthFail, r.pass]), this.stencilFunc.set({ func: r.test.func, ref: r.ref, mask: r.test.mask })) : this.stencilTest.set(!1);
          }
          setColorMode(r) {
            a.bH(r.blendFunction, ui.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(r.blendFunction), this.blendColor.set(r.blendColor)), this.colorMask.set(r.mask);
          }
          createVertexArray() {
            var r;
            return rn(this.gl) ? this.gl.createVertexArray() : (r = this.gl.getExtension("OES_vertex_array_object")) === null || r === void 0 ? void 0 : r.createVertexArrayOES();
          }
          deleteVertexArray(r) {
            var h;
            return rn(this.gl) ? this.gl.deleteVertexArray(r) : (h = this.gl.getExtension("OES_vertex_array_object")) === null || h === void 0 ? void 0 : h.deleteVertexArrayOES(r);
          }
          unbindVAO() {
            this.bindVertexArray.set(null);
          }
        }
        let $n;
        function Dd(m, r, h, p, g) {
          const y = m.context, x = m.transform, E = y.gl, C = m.useProgram("collisionBox"), R = [];
          let B = 0, k = 0;
          for (let J = 0; J < p.length; J++) {
            const ie = p[J], le = r.getTile(ie).getBucket(h);
            if (!le) continue;
            const se = g ? le.textCollisionBox : le.iconCollisionBox, he = le.collisionCircleArray;
            he.length > 0 && (R.push({ circleArray: he, circleOffset: k, coord: ie }), B += he.length / 4, k = B), se && C.draw(y, E.LINES, Mt.disabled, Vt.disabled, m.colorModeForRenderPass(), vt.disabled, $l(m.transform), m.style.map.terrain && m.style.map.terrain.getTerrainData(ie), x.getProjectionData({ overscaledTileID: ie, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }), h.id, se.layoutVertexBuffer, se.indexBuffer, se.segments, null, m.transform.zoom, null, null, se.collisionVertexBuffer);
          }
          if (!g || !R.length) return;
          const O = m.useProgram("collisionCircle"), z = new a.b$();
          z.resize(4 * B), z._trim();
          let H = 0;
          for (const J of R) for (let ie = 0; ie < J.circleArray.length / 4; ie++) {
            const le = 4 * ie, se = J.circleArray[le + 0], he = J.circleArray[le + 1], fe = J.circleArray[le + 2], oe = J.circleArray[le + 3];
            z.emplace(H++, se, he, fe, oe, 0), z.emplace(H++, se, he, fe, oe, 1), z.emplace(H++, se, he, fe, oe, 2), z.emplace(H++, se, he, fe, oe, 3);
          }
          (!$n || $n.length < 2 * B) && ($n = (function(J) {
            const ie = 2 * J, le = new a.c1();
            le.resize(ie), le._trim();
            for (let se = 0; se < ie; se++) {
              const he = 6 * se;
              le.uint16[he + 0] = 4 * se + 0, le.uint16[he + 1] = 4 * se + 1, le.uint16[he + 2] = 4 * se + 2, le.uint16[he + 3] = 4 * se + 2, le.uint16[he + 4] = 4 * se + 3, le.uint16[he + 5] = 4 * se + 0;
            }
            return le;
          })(B));
          const Y = y.createIndexBuffer($n, !0), K = y.createVertexBuffer(z, a.c0.members, !0);
          for (const J of R) {
            const ie = Kp(m.transform);
            O.draw(y, E.TRIANGLES, Mt.disabled, Vt.disabled, m.colorModeForRenderPass(), vt.disabled, ie, m.style.map.terrain && m.style.map.terrain.getTerrainData(J.coord), null, h.id, K, Y, a.aM.simpleSegment(0, 2 * J.circleOffset, J.circleArray.length, J.circleArray.length / 2), null, m.transform.zoom, null, null, null);
          }
          K.destroy(), Y.destroy();
        }
        const o_ = a.ag(new Float32Array(16));
        function Od(m, r, h, p, g, y) {
          const { horizontalAlign: x, verticalAlign: E } = a.aH(m);
          return new a.P((-(x - 0.5) * r / g + p[0]) * y, (-(E - 0.5) * h / g + p[1]) * y);
        }
        function a_(m, r, h, p, g, y) {
          const x = r.tileAnchorPoint.add(new a.P(r.translation[0], r.translation[1]));
          if (r.pitchWithMap) {
            let E = p.mult(y);
            h || (E = E.rotate(-g));
            const C = x.add(E);
            return Pi(C.x, C.y, r.pitchedLabelPlaneMatrix, r.getElevation).point;
          }
          if (h) {
            const E = $i(r.tileAnchorPoint.x + 1, r.tileAnchorPoint.y, r).point.sub(m), C = Math.atan(E.y / E.x) + (E.x < 0 ? Math.PI : 0);
            return m.add(p.rotate(C));
          }
          return m.add(p);
        }
        function Nh(m, r, h, p, g, y, x, E, C, R, B, k) {
          const O = m.text.placedSymbolArray, z = m.text.dynamicLayoutVertexArray, H = m.icon.dynamicLayoutVertexArray, Y = {};
          z.clear();
          for (let K = 0; K < O.length; K++) {
            const J = O.get(K), ie = J.hidden || !J.crossTileID || m.allowVerticalPlacement && !J.placedOrientation ? null : p[J.crossTileID];
            if (ie) {
              const le = new a.P(J.anchorX, J.anchorY), se = { getElevation: k, width: g.width, height: g.height, pitchedLabelPlaneMatrix: y, pitchWithMap: h, transform: g, tileAnchorPoint: le, translation: R, unwrappedTileID: B }, he = h ? Sr(le.x, le.y, se) : $i(le.x, le.y, se), fe = Ge(g.cameraToCenterDistance, he.signedDistanceFromCamera);
              let oe = a.ap(m.textSizeData, E, J) * fe / a.aB;
              h && (oe *= m.tilePixelRatio / x);
              const { width: be, height: Fe, anchor: Ie, textOffset: Me, textBoxScale: Oe } = ie, We = Od(Ie, be, Fe, Me, Oe, oe), qe = g.getPitchedTextCorrection(le.x + R[0], le.y + R[1], B), Ve = a_(he.point, se, r, We, -g.bearingInRadians, qe), ht = m.allowVerticalPlacement && J.placedOrientation === a.ao.vertical ? Math.PI / 2 : 0;
              for (let Bt = 0; Bt < J.numGlyphs; Bt++) a.av(z, Ve, ht);
              C && J.associatedIconIndex >= 0 && (Y[J.associatedIconIndex] = { shiftedAnchor: Ve, angle: ht });
            } else us(J.numGlyphs, z);
          }
          if (C) {
            H.clear();
            const K = m.icon.placedSymbolArray;
            for (let J = 0; J < K.length; J++) {
              const ie = K.get(J);
              if (ie.hidden) us(ie.numGlyphs, H);
              else {
                const le = Y[J];
                if (le) for (let se = 0; se < ie.numGlyphs; se++) a.av(H, le.shiftedAnchor, le.angle);
                else us(ie.numGlyphs, H);
              }
            }
            m.icon.dynamicLayoutVertexBuffer.updateData(H);
          }
          m.text.dynamicLayoutVertexBuffer.updateData(z);
        }
        function Ql(m, r, h) {
          return h.iconsInText && r ? "symbolTextAndIcon" : m ? "symbolSDF" : "symbolIcon";
        }
        function Ya(m, r, h, p, g, y, x, E, C, R, B, k, O) {
          const z = m.context, H = z.gl, Y = m.transform, K = E === "map", J = C === "map", ie = E !== "viewport" && h.layout.get("symbol-placement") !== "point", le = K && !J && !ie, se = !h.layout.get("symbol-sort-key").isConstant();
          let he = !1;
          const fe = m.getDepthModeForSublayer(0, Mt.ReadOnly), oe = h._unevaluatedLayout.hasValue("text-variable-anchor") || h._unevaluatedLayout.hasValue("text-variable-anchor-offset"), be = [], Fe = Y.getCircleRadiusCorrection();
          for (const Ie of p) {
            const Me = r.getTile(Ie), Oe = Me.getBucket(h);
            if (!Oe) continue;
            const We = g ? Oe.text : Oe.icon;
            if (!We || !We.segments.get().length || !We.hasVisibleVertices) continue;
            const qe = We.programConfigurations.get(h.id), Ve = g || Oe.sdfIcons, ht = g ? Oe.textSizeData : Oe.iconSizeData, Bt = J || Y.pitch !== 0, Wt = m.useProgram(Ql(Ve, g, Oe), qe), ti = a.an(ht, Y.zoom), Yt = m.style.map.terrain && m.style.map.terrain.getTerrainData(Ie);
            let vi, Si, Rt, ii, Wi = [0, 0], Qi = null;
            if (g) Si = Me.glyphAtlasTexture, Rt = H.LINEAR, vi = Me.glyphAtlasTexture.size, Oe.iconsInText && (Wi = Me.imageAtlasTexture.size, Qi = Me.imageAtlasTexture, ii = Bt || m.options.rotating || m.options.zooming || ht.kind === "composite" || ht.kind === "camera" ? H.LINEAR : H.NEAREST);
            else {
              const Xi = h.layout.get("icon-size").constantOr(0) !== 1 || Oe.iconsNeedLinear;
              Si = Me.imageAtlasTexture, Rt = Ve || m.options.rotating || m.options.zooming || Xi || Bt ? H.LINEAR : H.NEAREST, vi = Me.imageAtlasTexture.size;
            }
            const lr = a.aC(Me, 1, m.transform.zoom), Vr = Ti(K, m.transform, lr), Ns = a.L();
            a.aq(Ns, Vr);
            const Wn = Pt(J, K, m.transform, lr), Xn = a.aD(Y, Me, y, x), na = Y.getProjectionData({ overscaledTileID: Ie, applyGlobeMatrix: !O, applyTerrainMatrix: !0 }), oa = oe && Oe.hasTextData(), So = h.layout.get("icon-text-fit") !== "none" && oa && Oe.hasIconData();
            if (ie) {
              const Xi = m.style.map.terrain ? (gs, qi) => m.style.map.terrain.getElevation(Ie, gs, qi) : null, er = h.layout.get("text-rotation-alignment") === "map";
              _i(Oe, m, g, Vr, Ns, J, R, er, Ie.toUnwrapped(), Y.width, Y.height, Xn, Xi);
            }
            const Co = g && oe || So, qr = ie || Co ? o_ : J ? Vr : m.transform.clipSpaceToPixelsMatrix, Ls = Ve && h.paint.get(g ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
            let jr;
            jr = Ve ? Oe.iconsInText ? Qp(ht.kind, ti, le, J, ie, Co, m, qr, Wn, Xn, vi, Wi, Fe) : xd(ht.kind, ti, le, J, ie, Co, m, qr, Wn, Xn, g, vi, 0, Fe) : Xa(ht.kind, ti, le, J, ie, Co, m, qr, Wn, Xn, g, vi, Fe);
            const qn = { program: Wt, buffers: We, uniformValues: jr, projectionData: na, atlasTexture: Si, atlasTextureIcon: Qi, atlasInterpolation: Rt, atlasInterpolationIcon: ii, isSDF: Ve, hasHalo: Ls };
            if (se && Oe.canOverlap) {
              he = !0;
              const Xi = We.segments.get();
              for (const er of Xi) be.push({ segments: new a.aM([er]), sortKey: er.sortKey, state: qn, terrainData: Yt });
            } else be.push({ segments: We.segments, sortKey: 0, state: qn, terrainData: Yt });
          }
          he && be.sort(((Ie, Me) => Ie.sortKey - Me.sortKey));
          for (const Ie of be) {
            const Me = Ie.state;
            if (z.activeTexture.set(H.TEXTURE0), Me.atlasTexture.bind(Me.atlasInterpolation, H.CLAMP_TO_EDGE), Me.atlasTextureIcon && (z.activeTexture.set(H.TEXTURE1), Me.atlasTextureIcon && Me.atlasTextureIcon.bind(Me.atlasInterpolationIcon, H.CLAMP_TO_EDGE)), Me.isSDF) {
              const Oe = Me.uniformValues;
              Me.hasHalo && (Oe.u_is_halo = 1, Ja(Me.buffers, Ie.segments, h, m, Me.program, fe, B, k, Oe, Me.projectionData, Ie.terrainData)), Oe.u_is_halo = 0;
            }
            Ja(Me.buffers, Ie.segments, h, m, Me.program, fe, B, k, Me.uniformValues, Me.projectionData, Ie.terrainData);
          }
        }
        function Ja(m, r, h, p, g, y, x, E, C, R, B) {
          const k = p.context;
          g.draw(k, k.gl.TRIANGLES, y, x, E, vt.backCCW, C, B, R, h.id, m.layoutVertexBuffer, m.indexBuffer, r, h.paint, p.transform.zoom, m.programConfigurations.get(h.id), m.dynamicLayoutVertexBuffer, m.opacityVertexBuffer);
        }
        function Lh(m, r, h, p, g) {
          const y = m.context, x = y.gl, E = Vt.disabled, C = new ui([x.ONE, x.ONE], a.bf.transparent, [!0, !0, !0, !0]), R = r.getBucket(h);
          if (!R) return;
          const B = p.key;
          let k = h.heatmapFbos.get(B);
          k || (k = Qa(y, r.tileSize, r.tileSize), h.heatmapFbos.set(B, k)), y.bindFramebuffer.set(k.framebuffer), y.viewport.set([0, 0, r.tileSize, r.tileSize]), y.clear({ color: a.bf.transparent });
          const O = R.programConfigurations.get(h.id), z = m.useProgram("heatmap", O, !g), H = m.transform.getProjectionData({ overscaledTileID: r.tileID, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }), Y = m.style.map.terrain.getTerrainData(p);
          z.draw(y, x.TRIANGLES, Mt.disabled, E, C, vt.disabled, gd(r, m.transform.zoom, h.paint.get("heatmap-intensity"), 1), Y, H, h.id, R.layoutVertexBuffer, R.indexBuffer, R.segments, h.paint, m.transform.zoom, O);
        }
        function Fd(m, r, h, p, g) {
          const y = m.context, x = y.gl, E = m.transform;
          y.setColorMode(m.colorModeForRenderPass());
          const C = el(y, r), R = h.key, B = r.heatmapFbos.get(R);
          if (!B) return;
          y.activeTexture.set(x.TEXTURE0), x.bindTexture(x.TEXTURE_2D, B.colorAttachment.get()), y.activeTexture.set(x.TEXTURE1), C.bind(x.LINEAR, x.CLAMP_TO_EDGE);
          const k = E.getProjectionData({ overscaledTileID: h, applyTerrainMatrix: g, applyGlobeMatrix: !p });
          m.useProgram("heatmapTexture").draw(y, x.TRIANGLES, Mt.disabled, Vt.disabled, m.colorModeForRenderPass(), vt.disabled, Ah(m, r, 0, 1), null, k, r.id, m.rasterBoundsBuffer, m.quadTriangleIndexBuffer, m.rasterBoundsSegments, r.paint, E.zoom), B.destroy(), r.heatmapFbos.delete(R);
        }
        function Qa(m, r, h) {
          var p, g;
          const y = m.gl, x = y.createTexture();
          y.bindTexture(y.TEXTURE_2D, x), y.texParameteri(y.TEXTURE_2D, y.TEXTURE_WRAP_S, y.CLAMP_TO_EDGE), y.texParameteri(y.TEXTURE_2D, y.TEXTURE_WRAP_T, y.CLAMP_TO_EDGE), y.texParameteri(y.TEXTURE_2D, y.TEXTURE_MIN_FILTER, y.LINEAR), y.texParameteri(y.TEXTURE_2D, y.TEXTURE_MAG_FILTER, y.LINEAR);
          const E = (p = m.HALF_FLOAT) !== null && p !== void 0 ? p : y.UNSIGNED_BYTE, C = (g = m.RGBA16F) !== null && g !== void 0 ? g : y.RGBA;
          y.texImage2D(y.TEXTURE_2D, 0, C, r, h, 0, y.RGBA, E, null);
          const R = m.createFramebuffer(r, h, !1, !1);
          return R.colorAttachment.set(x), R;
        }
        function el(m, r) {
          return r.colorRampTexture || (r.colorRampTexture = new a.T(m, r.colorRamp, m.gl.RGBA)), r.colorRampTexture;
        }
        function tl(m, r, h, p, g) {
          if (!h || !p || !p.imageAtlas) return;
          const y = p.imageAtlas.patternPositions;
          let x = y[h.to.toString()], E = y[h.from.toString()];
          if (!x && E && (x = E), !E && x && (E = x), !x || !E) {
            const C = g.getPaintProperty(r);
            x = y[C], E = y[C];
          }
          x && E && m.setConstantPatternPositions(x, E);
        }
        function ec(m, r, h, p, g, y, x, E) {
          const C = m.context.gl, R = "fill-pattern", B = h.paint.get(R), k = B && B.constantOr(1), O = h.getCrossfadeParameters();
          let z, H, Y, K, J;
          const ie = m.transform, le = h.paint.get("fill-translate"), se = h.paint.get("fill-translate-anchor");
          x ? (H = k && !h.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", z = C.LINES) : (H = k ? "fillPattern" : "fill", z = C.TRIANGLES);
          const he = B.constantOr(null);
          for (const fe of p) {
            const oe = r.getTile(fe);
            if (k && !oe.patternsLoaded()) continue;
            const be = oe.getBucket(h);
            if (!be) continue;
            const Fe = be.programConfigurations.get(h.id), Ie = m.useProgram(H, Fe), Me = m.style.map.terrain && m.style.map.terrain.getTerrainData(fe);
            k && (m.context.activeTexture.set(C.TEXTURE0), oe.imageAtlasTexture.bind(C.LINEAR, C.CLAMP_TO_EDGE), Fe.updatePaintBuffers(O)), tl(Fe, R, he, oe, h);
            const Oe = ie.getProjectionData({ overscaledTileID: fe, applyGlobeMatrix: !E, applyTerrainMatrix: !0 }), We = a.aD(ie, oe, le, se);
            if (x) {
              K = be.indexBuffer2, J = be.segments2;
              const Ve = [C.drawingBufferWidth, C.drawingBufferHeight];
              Y = H === "fillOutlinePattern" && k ? Ga(m, O, oe, Ve, We) : $a(Ve, We);
            } else K = be.indexBuffer, J = be.segments, Y = k ? Hl(m, O, oe, We) : { u_fill_translate: We };
            const qe = m.stencilModeForClipping(fe);
            Ie.draw(m.context, z, g, qe, y, vt.backCCW, Y, Me, Oe, h.id, be.layoutVertexBuffer, K, J, h.paint, m.transform.zoom, Fe);
          }
        }
        function Uh(m, r, h, p, g, y, x, E) {
          const C = m.context, R = C.gl, B = "fill-extrusion-pattern", k = h.paint.get(B), O = k.constantOr(1), z = h.getCrossfadeParameters(), H = h.paint.get("fill-extrusion-opacity"), Y = k.constantOr(null), K = m.transform;
          for (const J of p) {
            const ie = r.getTile(J), le = ie.getBucket(h);
            if (!le) continue;
            const se = m.style.map.terrain && m.style.map.terrain.getTerrainData(J), he = le.programConfigurations.get(h.id), fe = m.useProgram(O ? "fillExtrusionPattern" : "fillExtrusion", he);
            O && (m.context.activeTexture.set(R.TEXTURE0), ie.imageAtlasTexture.bind(R.LINEAR, R.CLAMP_TO_EDGE), he.updatePaintBuffers(z));
            const oe = K.getProjectionData({ overscaledTileID: J, applyGlobeMatrix: !E, applyTerrainMatrix: !0 });
            tl(he, B, Y, ie, h);
            const be = a.aD(K, ie, h.paint.get("fill-extrusion-translate"), h.paint.get("fill-extrusion-translate-anchor")), Fe = h.paint.get("fill-extrusion-vertical-gradient"), Ie = O ? qp(m, Fe, H, be, J, z, ie) : Ps(m, Fe, H, be);
            fe.draw(C, C.gl.TRIANGLES, g, y, x, vt.backCCW, Ie, se, oe, h.id, le.layoutVertexBuffer, le.indexBuffer, le.segments, h.paint, m.transform.zoom, he, m.style.map.terrain && le.centroidVertexBuffer);
          }
        }
        function vo(m, r, h, p, g, y, x, E, C) {
          var R;
          const B = m.style.projection, k = m.context, O = m.transform, z = k.gl, H = [`#define NUM_ILLUMINATION_SOURCES ${h.paint.get("hillshade-highlight-color").values.length}`], Y = m.useProgram("hillshade", null, !1, H), K = !m.options.moving;
          for (const J of p) {
            const ie = r.getTile(J), le = ie.fbo;
            if (!le) continue;
            const se = B.getMeshFromTileID(k, J.canonical, E, !0, "raster"), he = (R = m.style.map.terrain) === null || R === void 0 ? void 0 : R.getTerrainData(J);
            k.activeTexture.set(z.TEXTURE0), z.bindTexture(z.TEXTURE_2D, le.colorAttachment.get());
            const fe = O.getProjectionData({ overscaledTileID: J, aligned: K, applyGlobeMatrix: !C, applyTerrainMatrix: !0 });
            Y.draw(k, z.TRIANGLES, y, g[J.overscaledZ], x, vt.backCCW, Yp(m, ie, h), he, fe, h.id, se.vertexBuffer, se.indexBuffer, se.segments);
          }
        }
        function zh(m, r, h, p, g, y, x, E, C) {
          var R;
          const B = m.style.projection, k = m.context, O = m.transform, z = k.gl, H = m.useProgram("colorRelief"), Y = !m.options.moving;
          let K = !0, J = 0;
          for (const ie of p) {
            const le = r.getTile(ie), se = le.dem;
            if (K) {
              const Ie = z.getParameter(z.MAX_TEXTURE_SIZE), { elevationTexture: Me, colorTexture: Oe } = h.getColorRampTextures(k, Ie, se.getUnpackVector());
              k.activeTexture.set(z.TEXTURE1), Me.bind(z.NEAREST, z.CLAMP_TO_EDGE), k.activeTexture.set(z.TEXTURE4), Oe.bind(z.LINEAR, z.CLAMP_TO_EDGE), K = !1, J = Me.size[0];
            }
            if (!se || !se.data) continue;
            const he = se.stride, fe = se.getPixels();
            if (k.activeTexture.set(z.TEXTURE0), k.pixelStoreUnpackPremultiplyAlpha.set(!1), le.demTexture = le.demTexture || m.getTileTexture(he), le.demTexture) {
              const Ie = le.demTexture;
              Ie.update(fe, { premultiply: !1 }), Ie.bind(z.LINEAR, z.CLAMP_TO_EDGE);
            } else le.demTexture = new a.T(k, fe, z.RGBA, { premultiply: !1 }), le.demTexture.bind(z.LINEAR, z.CLAMP_TO_EDGE);
            const oe = B.getMeshFromTileID(k, ie.canonical, E, !0, "raster"), be = (R = m.style.map.terrain) === null || R === void 0 ? void 0 : R.getTerrainData(ie), Fe = O.getProjectionData({ overscaledTileID: ie, aligned: Y, applyGlobeMatrix: !C, applyTerrainMatrix: !0 });
            H.draw(k, z.TRIANGLES, y, g[ie.overscaledZ], x, vt.backCCW, yd(h, le.dem, J), be, Fe, h.id, oe.vertexBuffer, oe.indexBuffer, oe.segments);
          }
        }
        const tc = [new a.P(0, 0), new a.P(a.$, 0), new a.P(a.$, a.$), new a.P(0, a.$)];
        function xo(m, r, h, p, g, y, x, E, C = !1, R = !1) {
          const B = p[p.length - 1].overscaledZ, k = m.context, O = k.gl, z = m.useProgram("raster"), H = m.transform, Y = m.style.projection, K = m.colorModeForRenderPass(), J = !m.options.moving;
          for (const ie of p) {
            const le = m.getDepthModeForSublayer(ie.overscaledZ - B, h.paint.get("raster-opacity") === 1 ? Mt.ReadWrite : Mt.ReadOnly, O.LESS), se = r.getTile(ie);
            se.registerFadeDuration(h.paint.get("raster-fade-duration"));
            const he = r.findLoadedParent(ie, 0), fe = r.findLoadedSibling(ie), oe = Vh(se, he || fe || null, r, h, m.transform, m.style.map.terrain);
            let be, Fe;
            const Ie = h.paint.get("raster-resampling") === "nearest" ? O.NEAREST : O.LINEAR;
            k.activeTexture.set(O.TEXTURE0), se.texture.bind(Ie, O.CLAMP_TO_EDGE, O.LINEAR_MIPMAP_NEAREST), k.activeTexture.set(O.TEXTURE1), he ? (he.texture.bind(Ie, O.CLAMP_TO_EDGE, O.LINEAR_MIPMAP_NEAREST), be = Math.pow(2, he.tileID.overscaledZ - se.tileID.overscaledZ), Fe = [se.tileID.canonical.x * be % 1, se.tileID.canonical.y * be % 1]) : se.texture.bind(Ie, O.CLAMP_TO_EDGE, O.LINEAR_MIPMAP_NEAREST), se.texture.useMipmap && k.extTextureFilterAnisotropic && m.transform.pitch > 20 && O.texParameterf(O.TEXTURE_2D, k.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, k.extTextureFilterAnisotropicMax);
            const Me = m.style.map.terrain && m.style.map.terrain.getTerrainData(ie), Oe = H.getProjectionData({ overscaledTileID: ie, aligned: J, applyGlobeMatrix: !R, applyTerrainMatrix: !0 }), We = Wa(Fe || [0, 0], be || 1, oe, h, E), qe = Y.getMeshFromTileID(k, ie.canonical, y, x, "raster");
            z.draw(k, O.TRIANGLES, le, g ? g[ie.overscaledZ] : Vt.disabled, K, C ? vt.frontCCW : vt.backCCW, We, Me, Oe, h.id, qe.vertexBuffer, qe.indexBuffer, qe.segments);
          }
        }
        function Vh(m, r, h, p, g, y) {
          const x = p.paint.get("raster-fade-duration");
          if (!y && x > 0) {
            const E = N.now(), C = (E - m.timeAdded) / x, R = r ? (E - r.timeAdded) / x : -1, B = h.getSource(), k = lt(g, { tileSize: B.tileSize, roundZoom: B.roundZoom }), O = !r || Math.abs(r.tileID.overscaledZ - k) > Math.abs(m.tileID.overscaledZ - k), z = O && m.refreshedUponExpiration ? 1 : a.ah(O ? C : 1 - R, 0, 1);
            return m.refreshedUponExpiration && C >= 1 && (m.refreshedUponExpiration = !1), r ? { opacity: 1, mix: 1 - z } : { opacity: z, mix: 0 };
          }
          return { opacity: 1, mix: 0 };
        }
        const kd = new a.bf(1, 0, 0, 1), Nd = new a.bf(0, 1, 0, 1), ic = new a.bf(0, 0, 1, 1), jh = new a.bf(1, 0, 1, 1), l_ = new a.bf(0, 1, 1, 1);
        function Hh(m, r, h, p) {
          on(m, 0, r + h / 2, m.transform.width, h, p);
        }
        function Ei(m, r, h, p) {
          on(m, r - h / 2, 0, h, m.transform.height, p);
        }
        function on(m, r, h, p, g, y) {
          const x = m.context, E = x.gl;
          E.enable(E.SCISSOR_TEST), E.scissor(r * m.pixelRatio, h * m.pixelRatio, p * m.pixelRatio, g * m.pixelRatio), x.clear({ color: y }), E.disable(E.SCISSOR_TEST);
        }
        function ps(m, r, h) {
          const p = m.context, g = p.gl, y = m.useProgram("debug"), x = Mt.disabled, E = Vt.disabled, C = m.colorModeForRenderPass(), R = "$debug", B = m.style.map.terrain && m.style.map.terrain.getTerrainData(h);
          p.activeTexture.set(g.TEXTURE0);
          const k = r.getTileByID(h.key).latestRawTileData, O = Math.floor((k && k.byteLength || 0) / 1024), z = r.getTile(h).tileSize, H = 512 / Math.min(z, 512) * (h.overscaledZ / m.transform.zoom) * 0.5;
          let Y = h.canonical.toString();
          h.overscaledZ !== h.canonical.z && (Y += ` => ${h.overscaledZ}`), (function(J, ie) {
            J.initDebugOverlayCanvas();
            const le = J.debugOverlayCanvas, se = J.context.gl, he = J.debugOverlayCanvas.getContext("2d");
            he.clearRect(0, 0, le.width, le.height), he.shadowColor = "white", he.shadowBlur = 2, he.lineWidth = 1.5, he.strokeStyle = "white", he.textBaseline = "top", he.font = "bold 36px Open Sans, sans-serif", he.fillText(ie, 5, 5), he.strokeText(ie, 5, 5), J.debugOverlayTexture.update(le), J.debugOverlayTexture.bind(se.LINEAR, se.CLAMP_TO_EDGE);
          })(m, `${Y} ${O}kB`);
          const K = m.transform.getProjectionData({ overscaledTileID: h, applyGlobeMatrix: !0, applyTerrainMatrix: !0 });
          y.draw(p, g.TRIANGLES, x, E, ui.alphaBlended, vt.disabled, _o(a.bf.transparent, H), null, K, R, m.debugBuffer, m.quadTriangleIndexBuffer, m.debugSegments), y.draw(p, g.LINE_STRIP, x, E, C, vt.disabled, _o(a.bf.red), B, K, R, m.debugBuffer, m.tileBorderIndexBuffer, m.debugSegments);
        }
        function rc(m, r, h, p) {
          const { isRenderingGlobe: g } = p, y = m.context, x = y.gl, E = m.transform, C = m.colorModeForRenderPass(), R = m.getDepthModeFor3D(), B = m.useProgram("terrain");
          y.bindFramebuffer.set(null), y.viewport.set([0, 0, m.width, m.height]);
          for (const k of h) {
            const O = r.getTerrainMesh(k.tileID), z = m.renderToTexture.getTexture(k), H = r.getTerrainData(k.tileID);
            y.activeTexture.set(x.TEXTURE0), x.bindTexture(x.TEXTURE_2D, z.texture);
            const Y = r.getMeshFrameDelta(E.zoom), K = E.calculateFogMatrix(k.tileID.toUnwrapped()), J = Vl(Y, K, m.style.sky, E.pitch, g), ie = E.getProjectionData({ overscaledTileID: k.tileID, applyTerrainMatrix: !1, applyGlobeMatrix: !0 });
            B.draw(y, x.TRIANGLES, R, Vt.disabled, C, vt.backCCW, J, H, ie, "terrain", O.vertexBuffer, O.indexBuffer, O.segments);
          }
        }
        function il(m, r) {
          if (!r.mesh) {
            const h = new a.aL();
            h.emplaceBack(-1, -1), h.emplaceBack(1, -1), h.emplaceBack(1, 1), h.emplaceBack(-1, 1);
            const p = new a.aN();
            p.emplaceBack(0, 1, 2), p.emplaceBack(0, 2, 3), r.mesh = new $e(m.createVertexBuffer(h, at.members), m.createIndexBuffer(p), a.aM.simpleSegment(0, 0, h.length, p.length));
          }
          return r.mesh;
        }
        class Ld {
          constructor(r, h) {
            this.context = new Bd(r), this.transform = h, this._tileTextures = {}, this.terrainFacilitator = { dirty: !0, matrix: a.ag(new Float64Array(16)), renderTime: 0 }, this.setup(), this.numSublayers = Ot.maxUnderzooming + Ot.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new X();
          }
          resize(r, h, p) {
            if (this.width = Math.floor(r * p), this.height = Math.floor(h * p), this.pixelRatio = p, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const g of this.style._order) this.style._layers[g].resize();
          }
          setup() {
            const r = this.context, h = new a.aL();
            h.emplaceBack(0, 0), h.emplaceBack(a.$, 0), h.emplaceBack(0, a.$), h.emplaceBack(a.$, a.$), this.tileExtentBuffer = r.createVertexBuffer(h, at.members), this.tileExtentSegments = a.aM.simpleSegment(0, 0, 4, 2);
            const p = new a.aL();
            p.emplaceBack(0, 0), p.emplaceBack(a.$, 0), p.emplaceBack(0, a.$), p.emplaceBack(a.$, a.$), this.debugBuffer = r.createVertexBuffer(p, at.members), this.debugSegments = a.aM.simpleSegment(0, 0, 4, 5);
            const g = new a.c6();
            g.emplaceBack(0, 0, 0, 0), g.emplaceBack(a.$, 0, a.$, 0), g.emplaceBack(0, a.$, 0, a.$), g.emplaceBack(a.$, a.$, a.$, a.$), this.rasterBoundsBuffer = r.createVertexBuffer(g, Wp.members), this.rasterBoundsSegments = a.aM.simpleSegment(0, 0, 4, 2);
            const y = new a.aL();
            y.emplaceBack(0, 0), y.emplaceBack(a.$, 0), y.emplaceBack(0, a.$), y.emplaceBack(a.$, a.$), this.rasterBoundsBufferPosOnly = r.createVertexBuffer(y, at.members), this.rasterBoundsSegmentsPosOnly = a.aM.simpleSegment(0, 0, 4, 5);
            const x = new a.aL();
            x.emplaceBack(0, 0), x.emplaceBack(1, 0), x.emplaceBack(0, 1), x.emplaceBack(1, 1), this.viewportBuffer = r.createVertexBuffer(x, at.members), this.viewportSegments = a.aM.simpleSegment(0, 0, 4, 2);
            const E = new a.c7();
            E.emplaceBack(0), E.emplaceBack(1), E.emplaceBack(3), E.emplaceBack(2), E.emplaceBack(0), this.tileBorderIndexBuffer = r.createIndexBuffer(E);
            const C = new a.aN();
            C.emplaceBack(1, 0, 2), C.emplaceBack(1, 2, 3), this.quadTriangleIndexBuffer = r.createIndexBuffer(C);
            const R = this.context.gl;
            this.stencilClearMode = new Vt({ func: R.ALWAYS, mask: 0 }, 0, 255, R.ZERO, R.ZERO, R.ZERO), this.tileExtentMesh = new $e(this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
          }
          clearStencil() {
            const r = this.context, h = r.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0;
            const p = a.L();
            a.bY(p, 0, this.width, this.height, 0, 0, 1), a.N(p, p, [h.drawingBufferWidth, h.drawingBufferHeight, 0]);
            const g = { mainMatrix: p, tileMercatorCoords: [0, 0, 1, 1], clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: p };
            this.useProgram("clippingMask", null, !0).draw(r, h.TRIANGLES, Mt.disabled, this.stencilClearMode, ui.disabled, vt.disabled, null, null, g, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
          }
          _renderTileClippingMasks(r, h, p) {
            if (this.currentStencilSource === r.source || !r.isTileClipped() || !h || !h.length) return;
            this.currentStencilSource = r.source, this.nextStencilID + h.length > 256 && this.clearStencil();
            const g = this.context;
            g.setColorMode(ui.disabled), g.setDepthMode(Mt.disabled);
            const y = {};
            for (const x of h) y[x.key] = this.nextStencilID++;
            this._renderTileMasks(y, h, p, !0), this._renderTileMasks(y, h, p, !1), this._tileClippingMaskIDs = y;
          }
          _renderTileMasks(r, h, p, g) {
            const y = this.context, x = y.gl, E = this.style.projection, C = this.transform, R = this.useProgram("clippingMask");
            for (const B of h) {
              const k = r[B.key], O = this.style.map.terrain && this.style.map.terrain.getTerrainData(B), z = E.getMeshFromTileID(this.context, B.canonical, g, !0, "stencil"), H = C.getProjectionData({ overscaledTileID: B, applyGlobeMatrix: !p, applyTerrainMatrix: !0 });
              R.draw(y, x.TRIANGLES, Mt.disabled, new Vt({ func: x.ALWAYS, mask: 0 }, k, 255, x.KEEP, x.KEEP, x.REPLACE), ui.disabled, p ? vt.disabled : vt.backCCW, null, O, H, "$clipping", z.vertexBuffer, z.indexBuffer, z.segments);
            }
          }
          _renderTilesDepthBuffer() {
            const r = this.context, h = r.gl, p = this.style.projection, g = this.transform, y = this.useProgram("depth"), x = this.getDepthModeFor3D(), E = ve(g, { tileSize: g.tileSize });
            for (const C of E) {
              const R = this.style.map.terrain && this.style.map.terrain.getTerrainData(C), B = p.getMeshFromTileID(this.context, C.canonical, !0, !0, "raster"), k = g.getProjectionData({ overscaledTileID: C, applyGlobeMatrix: !0, applyTerrainMatrix: !0 });
              y.draw(r, h.TRIANGLES, x, Vt.disabled, ui.disabled, vt.backCCW, null, R, k, "$clipping", B.vertexBuffer, B.indexBuffer, B.segments);
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            const r = this.nextStencilID++, h = this.context.gl;
            return new Vt({ func: h.NOTEQUAL, mask: 255 }, r, 255, h.KEEP, h.KEEP, h.REPLACE);
          }
          stencilModeForClipping(r) {
            const h = this.context.gl;
            return new Vt({ func: h.EQUAL, mask: 255 }, this._tileClippingMaskIDs[r.key], 0, h.KEEP, h.KEEP, h.REPLACE);
          }
          getStencilConfigForOverlapAndUpdateStencilID(r) {
            const h = this.context.gl, p = r.sort(((x, E) => E.overscaledZ - x.overscaledZ)), g = p[p.length - 1].overscaledZ, y = p[0].overscaledZ - g + 1;
            if (y > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + y > 256 && this.clearStencil();
              const x = {};
              for (let E = 0; E < y; E++) x[E + g] = new Vt({ func: h.GEQUAL, mask: 255 }, E + this.nextStencilID, 255, h.KEEP, h.KEEP, h.REPLACE);
              return this.nextStencilID += y, [x, p];
            }
            return [{ [g]: Vt.disabled }, p];
          }
          stencilConfigForOverlapTwoPass(r) {
            const h = this.context.gl, p = r.sort(((x, E) => E.overscaledZ - x.overscaledZ)), g = p[p.length - 1].overscaledZ, y = p[0].overscaledZ - g + 1;
            if (this.clearStencil(), y > 1) {
              const x = {}, E = {};
              for (let C = 0; C < y; C++) x[C + g] = new Vt({ func: h.GREATER, mask: 255 }, y + 1 + C, 255, h.KEEP, h.KEEP, h.REPLACE), E[C + g] = new Vt({ func: h.GREATER, mask: 255 }, 1 + C, 255, h.KEEP, h.KEEP, h.REPLACE);
              return this.nextStencilID = 2 * y + 1, [x, E, p];
            }
            return this.nextStencilID = 3, [{ [g]: new Vt({ func: h.GREATER, mask: 255 }, 2, 255, h.KEEP, h.KEEP, h.REPLACE) }, { [g]: new Vt({ func: h.GREATER, mask: 255 }, 1, 255, h.KEEP, h.KEEP, h.REPLACE) }, p];
          }
          colorModeForRenderPass() {
            const r = this.context.gl;
            return this._showOverdrawInspector ? new ui([r.CONSTANT_COLOR, r.ONE], new a.bf(0.125, 0.125, 0.125, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? ui.unblended : ui.alphaBlended;
          }
          getDepthModeForSublayer(r, h, p) {
            if (!this.opaquePassEnabledForLayer()) return Mt.disabled;
            const g = 1 - ((1 + this.currentLayer) * this.numSublayers + r) * this.depthEpsilon;
            return new Mt(p || this.context.gl.LEQUAL, h, [g, g]);
          }
          getDepthModeFor3D() {
            return new Mt(this.context.gl.LEQUAL, Mt.ReadWrite, this.depthRangeFor3D);
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff;
          }
          render(r, h) {
            var p, g;
            this.style = r, this.options = h, this.lineAtlas = r.lineAtlas, this.imageManager = r.imageManager, this.glyphManager = r.glyphManager, this.symbolFadeChange = r.placement.symbolFadeChange(N.now()), this.imageManager.beginFrame();
            const y = this.style._order, x = this.style.sourceCaches, E = {}, C = {}, R = {}, B = { isRenderingToTexture: !1, isRenderingGlobe: ((p = r.projection) === null || p === void 0 ? void 0 : p.transitionState) > 0 };
            for (const O in x) {
              const z = x[O];
              z.used && z.prepare(this.context), E[O] = z.getVisibleCoordinates(!1), C[O] = E[O].slice().reverse(), R[O] = z.getVisibleCoordinates(!0).reverse();
            }
            this.opaquePassCutoff = 1 / 0;
            for (let O = 0; O < y.length; O++) if (this.style._layers[y[O]].is3D()) {
              this.opaquePassCutoff = O;
              break;
            }
            this.maybeDrawDepthAndCoords(!1), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
            for (const O of y) {
              const z = this.style._layers[O];
              if (!z.hasOffscreenPass() || z.isHidden(this.transform.zoom)) continue;
              const H = C[z.source];
              (z.type === "custom" || H.length) && this.renderLayer(this, x[z.source], z, H, B);
            }
            if ((g = this.style.projection) === null || g === void 0 || g.updateGPUdependent({ context: this.context, useProgram: (O) => this.useProgram(O) }), this.context.viewport.set([0, 0, this.width, this.height]), this.context.bindFramebuffer.set(null), this.context.clear({ color: h.showOverdrawInspector ? a.bf.black : a.bf.transparent, depth: 1 }), this.clearStencil(), this.style.sky && (function(O, z) {
              const H = O.context, Y = H.gl, K = ((fe, oe, be) => {
                const Fe = Math.cos(oe.rollInRadians), Ie = Math.sin(oe.rollInRadians), Me = pe(oe), Oe = oe.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }).projectionTransition;
                return { u_sky_color: fe.properties.get("sky-color"), u_horizon_color: fe.properties.get("horizon-color"), u_horizon: [(oe.width / 2 - Me * Ie) * be, (oe.height / 2 + Me * Fe) * be], u_horizon_normal: [-Ie, Fe], u_sky_horizon_blend: fe.properties.get("sky-horizon-blend") * oe.height / 2 * be, u_sky_blend: Oe };
              })(z, O.style.map.transform, O.pixelRatio), J = new Mt(Y.LEQUAL, Mt.ReadWrite, [0, 1]), ie = Vt.disabled, le = O.colorModeForRenderPass(), se = O.useProgram("sky"), he = il(H, z);
              se.draw(H, Y.TRIANGLES, J, ie, le, vt.disabled, K, null, void 0, "sky", he.vertexBuffer, he.indexBuffer, he.segments);
            })(this, this.style.sky), this._showOverdrawInspector = h.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (r._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = y.length - 1; this.currentLayer >= 0; this.currentLayer--) {
              const O = this.style._layers[y[this.currentLayer]], z = x[O.source], H = E[O.source];
              this._renderTileClippingMasks(O, H, !1), this.renderLayer(this, z, O, H, B);
            }
            this.renderPass = "translucent";
            let k = !1;
            for (this.currentLayer = 0; this.currentLayer < y.length; this.currentLayer++) {
              const O = this.style._layers[y[this.currentLayer]], z = x[O.source];
              if (this.renderToTexture && this.renderToTexture.renderLayer(O, B)) continue;
              this.opaquePassEnabledForLayer() || k || (k = !0, B.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
              const H = (O.type === "symbol" ? R : C)[O.source];
              this._renderTileClippingMasks(O, E[O.source], !!this.renderToTexture), this.renderLayer(this, z, O, H, B);
            }
            if (B.isRenderingGlobe && (function(O, z, H) {
              const Y = O.context, K = Y.gl, J = O.useProgram("atmosphere"), ie = new Mt(K.LEQUAL, Mt.ReadOnly, [0, 1]), le = O.transform, se = (function(Oe, We) {
                const qe = Oe.properties.get("position"), Ve = [-qe.x, -qe.y, -qe.z], ht = a.ag(new Float64Array(16));
                return Oe.properties.get("anchor") === "map" && (a.b6(ht, ht, We.rollInRadians), a.b7(ht, ht, -We.pitchInRadians), a.b6(ht, ht, We.bearingInRadians), a.b7(ht, ht, We.center.lat * Math.PI / 180), a.bz(ht, ht, -We.center.lng * Math.PI / 180)), a.c5(Ve, Ve, ht), Ve;
              })(H, O.transform), he = le.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }), fe = z.properties.get("atmosphere-blend") * he.projectionTransition;
              if (fe === 0) return;
              const oe = $o(le.worldSize, le.center.lat), be = le.inverseProjectionMatrix, Fe = new Float64Array(4);
              Fe[3] = 1, a.aw(Fe, Fe, le.modelViewProjectionMatrix), Fe[0] /= Fe[3], Fe[1] /= Fe[3], Fe[2] /= Fe[3], Fe[3] = 1, a.aw(Fe, Fe, be), Fe[0] /= Fe[3], Fe[1] /= Fe[3], Fe[2] /= Fe[3], Fe[3] = 1;
              const Ie = /* @__PURE__ */ ((Oe, We, qe, Ve, ht) => ({ u_sun_pos: Oe, u_atmosphere_blend: We, u_globe_position: qe, u_globe_radius: Ve, u_inv_proj_matrix: ht }))(se, fe, [Fe[0], Fe[1], Fe[2]], oe, be), Me = il(Y, z);
              J.draw(Y, K.TRIANGLES, ie, Vt.disabled, ui.alphaBlended, vt.disabled, Ie, null, null, "atmosphere", Me.vertexBuffer, Me.indexBuffer, Me.segments);
            })(this, this.style.sky, this.style.light), this.options.showTileBoundaries) {
              const O = (function(z, H) {
                let Y = null;
                const K = Object.values(z._layers).flatMap(((se) => se.source && !se.isHidden(H) ? [z.sourceCaches[se.source]] : [])), J = K.filter(((se) => se.getSource().type === "vector")), ie = K.filter(((se) => se.getSource().type !== "vector")), le = (se) => {
                  (!Y || Y.getSource().maxzoom < se.getSource().maxzoom) && (Y = se);
                };
                return J.forEach(((se) => le(se))), Y || ie.forEach(((se) => le(se))), Y;
              })(this.style, this.transform.zoom);
              O && (function(z, H, Y) {
                for (let K = 0; K < Y.length; K++) ps(z, H, Y[K]);
              })(this, O, O.getVisibleCoordinates());
            }
            this.options.showPadding && (function(O) {
              const z = O.transform.padding;
              Hh(O, O.transform.height - (z.top || 0), 3, kd), Hh(O, z.bottom || 0, 3, Nd), Ei(O, z.left || 0, 3, ic), Ei(O, O.transform.width - (z.right || 0), 3, jh);
              const H = O.transform.centerPoint;
              (function(Y, K, J, ie) {
                on(Y, K - 1, J - 10, 2, 20, ie), on(Y, K - 10, J - 1, 20, 2, ie);
              })(O, H.x, O.transform.height - H.y, l_);
            })(this), this.context.setDefault();
          }
          maybeDrawDepthAndCoords(r) {
            if (!this.style || !this.style.map || !this.style.map.terrain) return;
            const h = this.terrainFacilitator.matrix, p = this.transform.modelViewProjectionMatrix;
            let g = this.terrainFacilitator.dirty;
            g || (g = r ? !a.c8(h, p) : !a.c9(h, p)), g || (g = this.style.map.terrain.sourceCache.anyTilesAfterTime(this.terrainFacilitator.renderTime)), g && (a.ca(h, p), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = !1, (function(y, x) {
              const E = y.context, C = E.gl, R = y.transform, B = ui.unblended, k = new Mt(C.LEQUAL, Mt.ReadWrite, [0, 1]), O = x.sourceCache.getRenderableTiles(), z = y.useProgram("terrainDepth");
              E.bindFramebuffer.set(x.getFramebuffer("depth").framebuffer), E.viewport.set([0, 0, y.width / devicePixelRatio, y.height / devicePixelRatio]), E.clear({ color: a.bf.transparent, depth: 1 });
              for (const H of O) {
                const Y = x.getTerrainMesh(H.tileID), K = x.getTerrainData(H.tileID), J = R.getProjectionData({ overscaledTileID: H.tileID, applyTerrainMatrix: !1, applyGlobeMatrix: !0 }), ie = { u_ele_delta: x.getMeshFrameDelta(R.zoom) };
                z.draw(E, C.TRIANGLES, k, Vt.disabled, B, vt.backCCW, ie, K, J, "terrain", Y.vertexBuffer, Y.indexBuffer, Y.segments);
              }
              E.bindFramebuffer.set(null), E.viewport.set([0, 0, y.width, y.height]);
            })(this, this.style.map.terrain), (function(y, x) {
              const E = y.context, C = E.gl, R = y.transform, B = ui.unblended, k = new Mt(C.LEQUAL, Mt.ReadWrite, [0, 1]), O = x.getCoordsTexture(), z = x.sourceCache.getRenderableTiles(), H = y.useProgram("terrainCoords");
              E.bindFramebuffer.set(x.getFramebuffer("coords").framebuffer), E.viewport.set([0, 0, y.width / devicePixelRatio, y.height / devicePixelRatio]), E.clear({ color: a.bf.transparent, depth: 1 }), x.coordsIndex = [];
              for (const Y of z) {
                const K = x.getTerrainMesh(Y.tileID), J = x.getTerrainData(Y.tileID);
                E.activeTexture.set(C.TEXTURE0), C.bindTexture(C.TEXTURE_2D, O.texture);
                const ie = { u_terrain_coords_id: (255 - x.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: x.getMeshFrameDelta(R.zoom) }, le = R.getProjectionData({ overscaledTileID: Y.tileID, applyTerrainMatrix: !1, applyGlobeMatrix: !0 });
                H.draw(E, C.TRIANGLES, k, Vt.disabled, B, vt.backCCW, ie, J, le, "terrain", K.vertexBuffer, K.indexBuffer, K.segments), x.coordsIndex.push(Y.tileID.key);
              }
              E.bindFramebuffer.set(null), E.viewport.set([0, 0, y.width, y.height]);
            })(this, this.style.map.terrain));
          }
          renderLayer(r, h, p, g, y) {
            p.isHidden(this.transform.zoom) || (p.type === "background" || p.type === "custom" || (g || []).length) && (this.id = p.id, a.cb(p) ? (function(x, E, C, R, B, k) {
              if (x.renderPass !== "translucent") return;
              const { isRenderingToTexture: O } = k, z = Vt.disabled, H = x.colorModeForRenderPass();
              (C._unevaluatedLayout.hasValue("text-variable-anchor") || C._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && (function(Y, K, J, ie, le, se, he, fe, oe) {
                const be = K.transform, Fe = K.style.map.terrain, Ie = le === "map", Me = se === "map";
                for (const Oe of Y) {
                  const We = ie.getTile(Oe), qe = We.getBucket(J);
                  if (!qe || !qe.text || !qe.text.segments.get().length) continue;
                  const Ve = a.an(qe.textSizeData, be.zoom), ht = a.aC(We, 1, K.transform.zoom), Bt = Ti(Ie, K.transform, ht), Wt = J.layout.get("icon-text-fit") !== "none" && qe.hasIconData();
                  if (Ve) {
                    const ti = Math.pow(2, be.zoom - We.tileID.overscaledZ), Yt = Fe ? (vi, Si) => Fe.getElevation(Oe, vi, Si) : null;
                    Nh(qe, Ie, Me, oe, be, Bt, ti, Ve, Wt, a.aD(be, We, he, fe), Oe.toUnwrapped(), Yt);
                  }
                }
              })(R, x, C, E, C.layout.get("text-rotation-alignment"), C.layout.get("text-pitch-alignment"), C.paint.get("text-translate"), C.paint.get("text-translate-anchor"), B), C.paint.get("icon-opacity").constantOr(1) !== 0 && Ya(x, E, C, R, !1, C.paint.get("icon-translate"), C.paint.get("icon-translate-anchor"), C.layout.get("icon-rotation-alignment"), C.layout.get("icon-pitch-alignment"), C.layout.get("icon-keep-upright"), z, H, O), C.paint.get("text-opacity").constantOr(1) !== 0 && Ya(x, E, C, R, !0, C.paint.get("text-translate"), C.paint.get("text-translate-anchor"), C.layout.get("text-rotation-alignment"), C.layout.get("text-pitch-alignment"), C.layout.get("text-keep-upright"), z, H, O), E.map.showCollisionBoxes && (Dd(x, E, C, R, !0), Dd(x, E, C, R, !1));
            })(r, h, p, g, this.style.placement.variableOffsets, y) : a.cc(p) ? (function(x, E, C, R, B) {
              if (x.renderPass !== "translucent") return;
              const { isRenderingToTexture: k } = B, O = C.paint.get("circle-opacity"), z = C.paint.get("circle-stroke-width"), H = C.paint.get("circle-stroke-opacity"), Y = !C.layout.get("circle-sort-key").isConstant();
              if (O.constantOr(1) === 0 && (z.constantOr(1) === 0 || H.constantOr(1) === 0)) return;
              const K = x.context, J = K.gl, ie = x.transform, le = x.getDepthModeForSublayer(0, Mt.ReadOnly), se = Vt.disabled, he = x.colorModeForRenderPass(), fe = [], oe = ie.getCircleRadiusCorrection();
              for (let be = 0; be < R.length; be++) {
                const Fe = R[be], Ie = E.getTile(Fe), Me = Ie.getBucket(C);
                if (!Me) continue;
                const Oe = C.paint.get("circle-translate"), We = C.paint.get("circle-translate-anchor"), qe = a.aD(ie, Ie, Oe, We), Ve = Me.programConfigurations.get(C.id), ht = x.useProgram("circle", Ve), Bt = Me.layoutVertexBuffer, Wt = Me.indexBuffer, ti = x.style.map.terrain && x.style.map.terrain.getTerrainData(Fe), Yt = { programConfiguration: Ve, program: ht, layoutVertexBuffer: Bt, indexBuffer: Wt, uniformValues: Zp(x, Ie, C, qe, oe), terrainData: ti, projectionData: ie.getProjectionData({ overscaledTileID: Fe, applyGlobeMatrix: !k, applyTerrainMatrix: !0 }) };
                if (Y) {
                  const vi = Me.segments.get();
                  for (const Si of vi) fe.push({ segments: new a.aM([Si]), sortKey: Si.sortKey, state: Yt });
                } else fe.push({ segments: Me.segments, sortKey: 0, state: Yt });
              }
              Y && fe.sort(((be, Fe) => be.sortKey - Fe.sortKey));
              for (const be of fe) {
                const { programConfiguration: Fe, program: Ie, layoutVertexBuffer: Me, indexBuffer: Oe, uniformValues: We, terrainData: qe, projectionData: Ve } = be.state;
                Ie.draw(K, J.TRIANGLES, le, se, he, vt.backCCW, We, qe, Ve, C.id, Me, Oe, be.segments, C.paint, x.transform.zoom, Fe);
              }
            })(r, h, p, g, y) : a.cd(p) ? (function(x, E, C, R, B) {
              if (C.paint.get("heatmap-opacity") === 0) return;
              const k = x.context, { isRenderingToTexture: O, isRenderingGlobe: z } = B;
              if (x.style.map.terrain) {
                for (const H of R) {
                  const Y = E.getTile(H);
                  E.hasRenderableParent(H) || (x.renderPass === "offscreen" ? Lh(x, Y, C, H, z) : x.renderPass === "translucent" && Fd(x, C, H, O, z));
                }
                k.viewport.set([0, 0, x.width, x.height]);
              } else x.renderPass === "offscreen" ? (function(H, Y, K, J) {
                const ie = H.context, le = ie.gl, se = H.transform, he = Vt.disabled, fe = new ui([le.ONE, le.ONE], a.bf.transparent, [!0, !0, !0, !0]);
                (function(oe, be, Fe) {
                  const Ie = oe.gl;
                  oe.activeTexture.set(Ie.TEXTURE1), oe.viewport.set([0, 0, be.width / 4, be.height / 4]);
                  let Me = Fe.heatmapFbos.get(a.c2);
                  Me ? (Ie.bindTexture(Ie.TEXTURE_2D, Me.colorAttachment.get()), oe.bindFramebuffer.set(Me.framebuffer)) : (Me = Qa(oe, be.width / 4, be.height / 4), Fe.heatmapFbos.set(a.c2, Me));
                })(ie, H, K), ie.clear({ color: a.bf.transparent });
                for (let oe = 0; oe < J.length; oe++) {
                  const be = J[oe];
                  if (Y.hasRenderableParent(be)) continue;
                  const Fe = Y.getTile(be), Ie = Fe.getBucket(K);
                  if (!Ie) continue;
                  const Me = Ie.programConfigurations.get(K.id), Oe = H.useProgram("heatmap", Me), We = se.getProjectionData({ overscaledTileID: be, applyGlobeMatrix: !0, applyTerrainMatrix: !1 }), qe = se.getCircleRadiusCorrection();
                  Oe.draw(ie, le.TRIANGLES, Mt.disabled, he, fe, vt.backCCW, gd(Fe, se.zoom, K.paint.get("heatmap-intensity"), qe), null, We, K.id, Ie.layoutVertexBuffer, Ie.indexBuffer, Ie.segments, K.paint, se.zoom, Me);
                }
                ie.viewport.set([0, 0, H.width, H.height]);
              })(x, E, C, R) : x.renderPass === "translucent" && (function(H, Y) {
                const K = H.context, J = K.gl;
                K.setColorMode(H.colorModeForRenderPass());
                const ie = Y.heatmapFbos.get(a.c2);
                ie && (K.activeTexture.set(J.TEXTURE0), J.bindTexture(J.TEXTURE_2D, ie.colorAttachment.get()), K.activeTexture.set(J.TEXTURE1), el(K, Y).bind(J.LINEAR, J.CLAMP_TO_EDGE), H.useProgram("heatmapTexture").draw(K, J.TRIANGLES, Mt.disabled, Vt.disabled, H.colorModeForRenderPass(), vt.disabled, Ah(H, Y, 0, 1), null, null, Y.id, H.viewportBuffer, H.quadTriangleIndexBuffer, H.viewportSegments, Y.paint, H.transform.zoom));
              })(x, C);
            })(r, h, p, g, y) : a.ce(p) ? (function(x, E, C, R, B) {
              if (x.renderPass !== "translucent") return;
              const { isRenderingToTexture: k } = B, O = C.paint.get("line-opacity"), z = C.paint.get("line-width");
              if (O.constantOr(1) === 0 || z.constantOr(1) === 0) return;
              const H = x.getDepthModeForSublayer(0, Mt.ReadOnly), Y = x.colorModeForRenderPass(), K = C.paint.get("line-dasharray"), J = C.paint.get("line-pattern"), ie = J.constantOr(1), le = C.paint.get("line-gradient"), se = C.getCrossfadeParameters(), he = ie ? "linePattern" : K ? "lineSDF" : le ? "lineGradient" : "line", fe = x.context, oe = fe.gl, be = x.transform;
              let Fe = !0;
              for (const Ie of R) {
                const Me = E.getTile(Ie);
                if (ie && !Me.patternsLoaded()) continue;
                const Oe = Me.getBucket(C);
                if (!Oe) continue;
                const We = Oe.programConfigurations.get(C.id), qe = x.context.program.get(), Ve = x.useProgram(he, We), ht = Fe || Ve.program !== qe, Bt = x.style.map.terrain && x.style.map.terrain.getTerrainData(Ie), Wt = J.constantOr(null);
                if (Wt && Me.imageAtlas) {
                  const Rt = Me.imageAtlas, ii = Rt.patternPositions[Wt.to.toString()], Wi = Rt.patternPositions[Wt.from.toString()];
                  ii && Wi && We.setConstantPatternPositions(ii, Wi);
                }
                const ti = be.getProjectionData({ overscaledTileID: Ie, applyGlobeMatrix: !k, applyTerrainMatrix: !0 }), Yt = be.getPixelScale(), vi = ie ? vd(x, Me, C, Yt, se) : K ? go(x, Me, C, Yt, K, se) : le ? bd(x, Me, C, Yt, Oe.lineClipsArray.length) : Gl(x, Me, C, Yt);
                if (ie) fe.activeTexture.set(oe.TEXTURE0), Me.imageAtlasTexture.bind(oe.LINEAR, oe.CLAMP_TO_EDGE), We.updatePaintBuffers(se);
                else if (K && (ht || x.lineAtlas.dirty)) fe.activeTexture.set(oe.TEXTURE0), x.lineAtlas.bind(fe);
                else if (le) {
                  const Rt = Oe.gradients[C.id];
                  let ii = Rt.texture;
                  if (C.gradientVersion !== Rt.version) {
                    let Wi = 256;
                    if (C.stepInterpolant) {
                      const Qi = E.getSource().maxzoom, lr = Ie.canonical.z === Qi ? Math.ceil(1 << x.transform.maxZoom - Ie.canonical.z) : 1;
                      Wi = a.ah(a.c3(Oe.maxLineLength / a.$ * 1024 * lr), 256, fe.maxTextureSize);
                    }
                    Rt.gradient = a.c4({ expression: C.gradientExpression(), evaluationKey: "lineProgress", resolution: Wi, image: Rt.gradient || void 0, clips: Oe.lineClipsArray }), Rt.texture ? Rt.texture.update(Rt.gradient) : Rt.texture = new a.T(fe, Rt.gradient, oe.RGBA), Rt.version = C.gradientVersion, ii = Rt.texture;
                  }
                  fe.activeTexture.set(oe.TEXTURE0), ii.bind(C.stepInterpolant ? oe.NEAREST : oe.LINEAR, oe.CLAMP_TO_EDGE);
                }
                const Si = x.stencilModeForClipping(Ie);
                Ve.draw(fe, oe.TRIANGLES, H, Si, Y, vt.disabled, vi, Bt, ti, C.id, Oe.layoutVertexBuffer, Oe.indexBuffer, Oe.segments, C.paint, x.transform.zoom, We, Oe.layoutVertexBuffer2), Fe = !1;
              }
            })(r, h, p, g, y) : a.cf(p) ? (function(x, E, C, R, B) {
              const k = C.paint.get("fill-color"), O = C.paint.get("fill-opacity");
              if (O.constantOr(1) === 0) return;
              const { isRenderingToTexture: z } = B, H = x.colorModeForRenderPass(), Y = C.paint.get("fill-pattern"), K = x.opaquePassEnabledForLayer() && !Y.constantOr(1) && k.constantOr(a.bf.transparent).a === 1 && O.constantOr(0) === 1 ? "opaque" : "translucent";
              if (x.renderPass === K) {
                const J = x.getDepthModeForSublayer(1, x.renderPass === "opaque" ? Mt.ReadWrite : Mt.ReadOnly);
                ec(x, E, C, R, J, H, !1, z);
              }
              if (x.renderPass === "translucent" && C.paint.get("fill-antialias")) {
                const J = x.getDepthModeForSublayer(C.getPaintProperty("fill-outline-color") ? 2 : 0, Mt.ReadOnly);
                ec(x, E, C, R, J, H, !0, z);
              }
            })(r, h, p, g, y) : a.cg(p) ? (function(x, E, C, R, B) {
              const k = C.paint.get("fill-extrusion-opacity");
              if (k === 0) return;
              const { isRenderingToTexture: O } = B;
              if (x.renderPass === "translucent") {
                const z = new Mt(x.context.gl.LEQUAL, Mt.ReadWrite, x.depthRangeFor3D);
                if (k !== 1 || C.paint.get("fill-extrusion-pattern").constantOr(1)) Uh(x, E, C, R, z, Vt.disabled, ui.disabled, O), Uh(x, E, C, R, z, x.stencilModeFor3D(), x.colorModeForRenderPass(), O);
                else {
                  const H = x.colorModeForRenderPass();
                  Uh(x, E, C, R, z, Vt.disabled, H, O);
                }
              }
            })(r, h, p, g, y) : a.ch(p) ? (function(x, E, C, R, B) {
              if (x.renderPass !== "offscreen" && x.renderPass !== "translucent") return;
              const { isRenderingToTexture: k } = B, O = x.context, z = x.style.projection.useSubdivision, H = x.getDepthModeForSublayer(0, Mt.ReadOnly), Y = x.colorModeForRenderPass();
              if (x.renderPass === "offscreen") (function(K, J, ie, le, se, he, fe) {
                const oe = K.context, be = oe.gl;
                for (const Fe of ie) {
                  const Ie = J.getTile(Fe), Me = Ie.dem;
                  if (!Me || !Me.data || !Ie.needsHillshadePrepare) continue;
                  const Oe = Me.dim, We = Me.stride, qe = Me.getPixels();
                  if (oe.activeTexture.set(be.TEXTURE1), oe.pixelStoreUnpackPremultiplyAlpha.set(!1), Ie.demTexture = Ie.demTexture || K.getTileTexture(We), Ie.demTexture) {
                    const ht = Ie.demTexture;
                    ht.update(qe, { premultiply: !1 }), ht.bind(be.NEAREST, be.CLAMP_TO_EDGE);
                  } else Ie.demTexture = new a.T(oe, qe, be.RGBA, { premultiply: !1 }), Ie.demTexture.bind(be.NEAREST, be.CLAMP_TO_EDGE);
                  oe.activeTexture.set(be.TEXTURE0);
                  let Ve = Ie.fbo;
                  if (!Ve) {
                    const ht = new a.T(oe, { width: Oe, height: Oe, data: null }, be.RGBA);
                    ht.bind(be.LINEAR, be.CLAMP_TO_EDGE), Ve = Ie.fbo = oe.createFramebuffer(Oe, Oe, !0, !1), Ve.colorAttachment.set(ht.texture);
                  }
                  oe.bindFramebuffer.set(Ve.framebuffer), oe.viewport.set([0, 0, Oe, Oe]), K.useProgram("hillshadePrepare").draw(oe, be.TRIANGLES, se, he, fe, vt.disabled, md(Ie.tileID, Me), null, null, le.id, K.rasterBoundsBuffer, K.quadTriangleIndexBuffer, K.rasterBoundsSegments), Ie.needsHillshadePrepare = !1;
                }
              })(x, E, R, C, H, Vt.disabled, Y), O.viewport.set([0, 0, x.width, x.height]);
              else if (x.renderPass === "translucent") if (z) {
                const [K, J, ie] = x.stencilConfigForOverlapTwoPass(R);
                vo(x, E, C, ie, K, H, Y, !1, k), vo(x, E, C, ie, J, H, Y, !0, k);
              } else {
                const [K, J] = x.getStencilConfigForOverlapAndUpdateStencilID(R);
                vo(x, E, C, J, K, H, Y, !1, k);
              }
            })(r, h, p, g, y) : a.ci(p) ? (function(x, E, C, R, B) {
              if (x.renderPass !== "translucent" || !R.length) return;
              const { isRenderingToTexture: k } = B, O = x.style.projection.useSubdivision, z = x.getDepthModeForSublayer(0, Mt.ReadOnly), H = x.colorModeForRenderPass();
              if (O) {
                const [Y, K, J] = x.stencilConfigForOverlapTwoPass(R);
                zh(x, E, C, J, Y, z, H, !1, k), zh(x, E, C, J, K, z, H, !0, k);
              } else {
                const [Y, K] = x.getStencilConfigForOverlapAndUpdateStencilID(R);
                zh(x, E, C, K, Y, z, H, !1, k);
              }
            })(r, h, p, g, y) : a.cj(p) ? (function(x, E, C, R, B) {
              if (x.renderPass !== "translucent" || C.paint.get("raster-opacity") === 0 || !R.length) return;
              const { isRenderingToTexture: k } = B, O = E.getSource(), z = x.style.projection.useSubdivision;
              if (O instanceof ts) xo(x, E, C, R, null, !1, !1, O.tileCoords, O.flippedWindingOrder, k);
              else if (z) {
                const [H, Y, K] = x.stencilConfigForOverlapTwoPass(R);
                xo(x, E, C, K, H, !1, !0, tc, !1, k), xo(x, E, C, K, Y, !0, !0, tc, !1, k);
              } else {
                const [H, Y] = x.getStencilConfigForOverlapAndUpdateStencilID(R);
                xo(x, E, C, Y, H, !1, !0, tc, !1, k);
              }
            })(r, h, p, g, y) : a.ck(p) ? (function(x, E, C, R, B) {
              const k = C.paint.get("background-color"), O = C.paint.get("background-opacity");
              if (O === 0) return;
              const { isRenderingToTexture: z } = B, H = x.context, Y = H.gl, K = x.style.projection, J = x.transform, ie = J.tileSize, le = C.paint.get("background-pattern");
              if (x.isPatternMissing(le)) return;
              const se = !le && k.a === 1 && O === 1 && x.opaquePassEnabledForLayer() ? "opaque" : "translucent";
              if (x.renderPass !== se) return;
              const he = Vt.disabled, fe = x.getDepthModeForSublayer(0, se === "opaque" ? Mt.ReadWrite : Mt.ReadOnly), oe = x.colorModeForRenderPass(), be = x.useProgram(le ? "backgroundPattern" : "background"), Fe = R || ve(J, { tileSize: ie, terrain: x.style.map.terrain });
              le && (H.activeTexture.set(Y.TEXTURE0), x.imageManager.bind(x.context));
              const Ie = C.getCrossfadeParameters();
              for (const Me of Fe) {
                const Oe = J.getProjectionData({ overscaledTileID: Me, applyGlobeMatrix: !z, applyTerrainMatrix: !0 }), We = le ? Td(O, x, le, { tileID: Me, tileSize: ie }, Ie) : wd(O, k), qe = x.style.map.terrain && x.style.map.terrain.getTerrainData(Me), Ve = K.getMeshFromTileID(H, Me.canonical, !1, !0, "raster");
                be.draw(H, Y.TRIANGLES, fe, he, oe, vt.backCCW, We, qe, Oe, C.id, Ve.vertexBuffer, Ve.indexBuffer, Ve.segments);
              }
            })(r, 0, p, g, y) : a.cl(p) && (function(x, E, C, R) {
              const { isRenderingGlobe: B } = R, k = x.context, O = C.implementation, z = x.style.projection, H = x.transform, Y = H.getProjectionDataForCustomLayer(B), K = { farZ: H.farZ, nearZ: H.nearZ, fov: H.fov * Math.PI / 180, modelViewProjectionMatrix: H.modelViewProjectionMatrix, projectionMatrix: H.projectionMatrix, shaderData: { variantName: z.shaderVariantName, vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${z.shaderPreludeCode.vertexSource}`, define: z.shaderDefine }, defaultProjectionData: Y }, J = O.renderingMode ? O.renderingMode : "2d";
              if (x.renderPass === "offscreen") {
                const ie = O.prerender;
                ie && (x.setCustomLayerDefaults(), k.setColorMode(x.colorModeForRenderPass()), ie.call(O, k.gl, K), k.setDirty(), x.setBaseState());
              } else if (x.renderPass === "translucent") {
                x.setCustomLayerDefaults(), k.setColorMode(x.colorModeForRenderPass()), k.setStencilMode(Vt.disabled);
                const ie = J === "3d" ? x.getDepthModeFor3D() : x.getDepthModeForSublayer(0, Mt.ReadOnly);
                k.setDepthMode(ie), O.render(k.gl, K), k.setDirty(), x.setBaseState(), k.bindFramebuffer.set(null);
              }
            })(r, 0, p, y));
          }
          saveTileTexture(r) {
            const h = this._tileTextures[r.size[0]];
            h ? h.push(r) : this._tileTextures[r.size[0]] = [r];
          }
          getTileTexture(r) {
            const h = this._tileTextures[r];
            return h && h.length > 0 ? h.pop() : null;
          }
          isPatternMissing(r) {
            if (!r) return !1;
            if (!r.from || !r.to) return !0;
            const h = this.imageManager.getPattern(r.from.toString()), p = this.imageManager.getPattern(r.to.toString());
            return !h || !p;
          }
          useProgram(r, h, p = !1, g = []) {
            this.cache = this.cache || {};
            const y = !!this.style.map.terrain, x = this.style.projection, E = p ? ue.projectionMercator : x.shaderPreludeCode, C = p ? It : x.shaderDefine, R = r + (h ? h.cacheKey : "") + `/${p ? hi : x.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (y ? "/terrain" : "") + (g ? `/${g.join("/")}` : "");
            return this.cache[R] || (this.cache[R] = new Th(this.context, ue[r], h, Mh[r], this._showOverdrawInspector, y, E, C, g)), this.cache[R];
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
          }
          setBaseState() {
            const r = this.context.gl;
            this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(r.FUNC_ADD);
          }
          initDebugOverlayCanvas() {
            this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new a.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
          }
          destroy() {
            this.debugOverlayTexture && this.debugOverlayTexture.destroy();
          }
          overLimit() {
            const { drawingBufferWidth: r, drawingBufferHeight: h } = this.context.gl;
            return this.width !== r || this.height !== h;
          }
        }
        function wo(m, r) {
          let h, p = !1, g = null, y = null;
          const x = () => {
            g = null, p && (m.apply(y, h), g = setTimeout(x, r), p = !1);
          };
          return (...E) => (p = !0, y = this, h = E, g || x(), g);
        }
        class sc {
          constructor(r) {
            this._getCurrentHash = () => {
              const h = window.location.hash.replace("#", "");
              if (this._hashName) {
                let p;
                return h.split("&").map(((g) => g.split("="))).forEach(((g) => {
                  g[0] === this._hashName && (p = g);
                })), (p && p[1] || "").split("/");
              }
              return h.split("/");
            }, this._onHashChange = () => {
              const h = this._getCurrentHash();
              if (!this._isValidHash(h)) return !1;
              const p = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(h[3] || 0) : this._map.getBearing();
              return this._map.jumpTo({ center: [+h[2], +h[1]], zoom: +h[0], bearing: p, pitch: +(h[4] || 0) }), !0;
            }, this._updateHashUnthrottled = () => {
              const h = window.location.href.replace(/(#.*)?$/, this.getHashString());
              window.history.replaceState(window.history.state, null, h);
            }, this._removeHash = () => {
              const h = this._getCurrentHash();
              if (h.length === 0) return;
              const p = h.join("/");
              let g = p;
              g.split("&").length > 0 && (g = g.split("&")[0]), this._hashName && (g = `${this._hashName}=${p}`);
              let y = window.location.hash.replace(g, "");
              y.startsWith("#&") ? y = y.slice(0, 1) + y.slice(2) : y === "#" && (y = "");
              let x = window.location.href.replace(/(#.+)?$/, y);
              x = x.replace("&&", "&"), window.history.replaceState(window.history.state, null, x);
            }, this._updateHash = wo(this._updateHashUnthrottled, 300), this._hashName = r && encodeURIComponent(r);
          }
          addTo(r) {
            return this._map = r, addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this;
          }
          remove() {
            return removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this;
          }
          getHashString(r) {
            const h = this._map.getCenter(), p = Math.round(100 * this._map.getZoom()) / 100, g = Math.ceil((p * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), y = Math.pow(10, g), x = Math.round(h.lng * y) / y, E = Math.round(h.lat * y) / y, C = this._map.getBearing(), R = this._map.getPitch();
            let B = "";
            if (B += r ? `/${x}/${E}/${p}` : `${p}/${E}/${x}`, (C || R) && (B += "/" + Math.round(10 * C) / 10), R && (B += `/${Math.round(R)}`), this._hashName) {
              const k = this._hashName;
              let O = !1;
              const z = window.location.hash.slice(1).split("&").map(((H) => {
                const Y = H.split("=")[0];
                return Y === k ? (O = !0, `${Y}=${B}`) : H;
              })).filter(((H) => H));
              return O || z.push(`${k}=${B}`), `#${z.join("&")}`;
            }
            return `#${B}`;
          }
          _isValidHash(r) {
            if (r.length < 3 || r.some(isNaN)) return !1;
            try {
              new a.S(+r[2], +r[1]);
            } catch {
              return !1;
            }
            const h = +r[0], p = +(r[3] || 0), g = +(r[4] || 0);
            return h >= this._map.getMinZoom() && h <= this._map.getMaxZoom() && p >= -180 && p <= 180 && g >= this._map.getMinPitch() && g <= this._map.getMaxPitch();
          }
        }
        const bn = { linearity: 0.3, easing: a.cm(0, 0, 0.3, 1) }, $h = a.e({ deceleration: 2500, maxSpeed: 1400 }, bn), Ud = a.e({ deceleration: 20, maxSpeed: 1400 }, bn), zd = a.e({ deceleration: 1e3, maxSpeed: 360 }, bn), Vd = a.e({ deceleration: 1e3, maxSpeed: 90 }, bn), jd = a.e({ deceleration: 1e3, maxSpeed: 360 }, bn);
        class Hd {
          constructor(r) {
            this._map = r, this.clear();
          }
          clear() {
            this._inertiaBuffer = [];
          }
          record(r) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: N.now(), settings: r });
          }
          _drainInertiaBuffer() {
            const r = this._inertiaBuffer, h = N.now();
            for (; r.length > 0 && h - r[0].time > 160; ) r.shift();
          }
          _onMoveEnd(r) {
            if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
            const h = { zoom: 0, bearing: 0, pitch: 0, roll: 0, pan: new a.P(0, 0), pinchAround: void 0, around: void 0 };
            for (const { settings: y } of this._inertiaBuffer) h.zoom += y.zoomDelta || 0, h.bearing += y.bearingDelta || 0, h.pitch += y.pitchDelta || 0, h.roll += y.rollDelta || 0, y.panDelta && h.pan._add(y.panDelta), y.around && (h.around = y.around), y.pinchAround && (h.pinchAround = y.pinchAround);
            const p = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, g = {};
            if (h.pan.mag()) {
              const y = qo(h.pan.mag(), p, a.e({}, $h, r || {})), x = h.pan.mult(y.amount / h.pan.mag()), E = this._map.cameraHelper.handlePanInertia(x, this._map.transform);
              g.center = E.easingCenter, g.offset = E.easingOffset, Bs(g, y);
            }
            if (h.zoom) {
              const y = qo(h.zoom, p, Ud);
              g.zoom = this._map.transform.zoom + y.amount, Bs(g, y);
            }
            if (h.bearing) {
              const y = qo(h.bearing, p, zd);
              g.bearing = this._map.transform.bearing + a.ah(y.amount, -179, 179), Bs(g, y);
            }
            if (h.pitch) {
              const y = qo(h.pitch, p, Vd);
              g.pitch = this._map.transform.pitch + y.amount, Bs(g, y);
            }
            if (h.roll) {
              const y = qo(h.roll, p, jd);
              g.roll = this._map.transform.roll + a.ah(y.amount, -179, 179), Bs(g, y);
            }
            if (g.zoom || g.bearing) {
              const y = h.pinchAround === void 0 ? h.around : h.pinchAround;
              g.around = y ? this._map.unproject(y) : this._map.getCenter();
            }
            return this.clear(), a.e(g, { noMoveStart: !0 });
          }
        }
        function Bs(m, r) {
          (!m.duration || m.duration < r.duration) && (m.duration = r.duration, m.easing = r.easing);
        }
        function qo(m, r, h) {
          const { maxSpeed: p, linearity: g, deceleration: y } = h, x = a.ah(m * g / (r / 1e3), -p, p), E = Math.abs(x) / (y * g);
          return { easing: h.easing, duration: 1e3 * E, amount: x * (E / 2) };
        }
        class Wr extends a.l {
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(r, h, p, g = {}) {
            p = p instanceof MouseEvent ? p : new MouseEvent(r, p);
            const y = L.mousePos(h.getCanvas(), p), x = h.unproject(y);
            super(r, a.e({ point: y, lngLat: x, originalEvent: p }, g)), this._defaultPrevented = !1, this.target = h;
          }
        }
        class Zo extends a.l {
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(r, h, p) {
            const g = r === "touchend" ? p.changedTouches : p.touches, y = L.touchPos(h.getCanvasContainer(), g), x = y.map(((C) => h.unproject(C))), E = y.reduce(((C, R, B, k) => C.add(R.div(k.length))), new a.P(0, 0));
            super(r, { points: y, point: E, lngLats: x, lngLat: h.unproject(E), originalEvent: p }), this._defaultPrevented = !1;
          }
        }
        class Gh extends a.l {
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(r, h, p) {
            super(r, { originalEvent: p }), this._defaultPrevented = !1;
          }
        }
        class $d {
          constructor(r, h) {
            this._map = r, this._clickTolerance = h.clickTolerance;
          }
          reset() {
            delete this._mousedownPos;
          }
          wheel(r) {
            return this._firePreventable(new Gh(r.type, this._map, r));
          }
          mousedown(r, h) {
            return this._mousedownPos = h, this._firePreventable(new Wr(r.type, this._map, r));
          }
          mouseup(r) {
            this._map.fire(new Wr(r.type, this._map, r));
          }
          click(r, h) {
            this._mousedownPos && this._mousedownPos.dist(h) >= this._clickTolerance || this._map.fire(new Wr(r.type, this._map, r));
          }
          dblclick(r) {
            return this._firePreventable(new Wr(r.type, this._map, r));
          }
          mouseover(r) {
            this._map.fire(new Wr(r.type, this._map, r));
          }
          mouseout(r) {
            this._map.fire(new Wr(r.type, this._map, r));
          }
          touchstart(r) {
            return this._firePreventable(new Zo(r.type, this._map, r));
          }
          touchmove(r) {
            this._map.fire(new Zo(r.type, this._map, r));
          }
          touchend(r) {
            this._map.fire(new Zo(r.type, this._map, r));
          }
          touchcancel(r) {
            this._map.fire(new Zo(r.type, this._map, r));
          }
          _firePreventable(r) {
            if (this._map.fire(r), r.defaultPrevented) return {};
          }
          isEnabled() {
            return !0;
          }
          isActive() {
            return !1;
          }
          enable() {
          }
          disable() {
          }
        }
        class Gd {
          constructor(r) {
            this._map = r;
          }
          reset() {
            this._delayContextMenu = !1, this._ignoreContextMenu = !0, delete this._contextMenuEvent;
          }
          mousemove(r) {
            this._map.fire(new Wr(r.type, this._map, r));
          }
          mousedown() {
            this._delayContextMenu = !0, this._ignoreContextMenu = !1;
          }
          mouseup() {
            this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new Wr("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
          }
          contextmenu(r) {
            this._delayContextMenu ? this._contextMenuEvent = r : this._ignoreContextMenu || this._map.fire(new Wr(r.type, this._map, r)), this._map.listens("contextmenu") && r.preventDefault();
          }
          isEnabled() {
            return !0;
          }
          isActive() {
            return !1;
          }
          enable() {
          }
          disable() {
          }
        }
        class Ko {
          constructor(r) {
            this._map = r;
          }
          get transform() {
            return this._map._requestedCameraState || this._map.transform;
          }
          get center() {
            return { lng: this.transform.center.lng, lat: this.transform.center.lat };
          }
          get zoom() {
            return this.transform.zoom;
          }
          get pitch() {
            return this.transform.pitch;
          }
          get bearing() {
            return this.transform.bearing;
          }
          unproject(r) {
            return this.transform.screenPointToLocation(a.P.convert(r), this._map.terrain);
          }
        }
        class Wh {
          constructor(r, h) {
            this._map = r, this._tr = new Ko(r), this._el = r.getCanvasContainer(), this._container = r.getContainer(), this._clickTolerance = h.clickTolerance || 1;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
          enable() {
            this.isEnabled() || (this._enabled = !0);
          }
          disable() {
            this.isEnabled() && (this._enabled = !1);
          }
          mousedown(r, h) {
            this.isEnabled() && r.shiftKey && r.button === 0 && (L.disableDrag(), this._startPos = this._lastPos = h, this._active = !0);
          }
          mousemoveWindow(r, h) {
            if (!this._active) return;
            const p = h;
            if (this._lastPos.equals(p) || !this._box && p.dist(this._startPos) < this._clickTolerance) return;
            const g = this._startPos;
            this._lastPos = p, this._box || (this._box = L.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", r));
            const y = Math.min(g.x, p.x), x = Math.max(g.x, p.x), E = Math.min(g.y, p.y), C = Math.max(g.y, p.y);
            L.setTransform(this._box, `translate(${y}px,${E}px)`), this._box.style.width = x - y + "px", this._box.style.height = C - E + "px";
          }
          mouseupWindow(r, h) {
            if (!this._active || r.button !== 0) return;
            const p = this._startPos, g = h;
            if (this.reset(), L.suppressClick(), p.x !== g.x || p.y !== g.y) return this._map.fire(new a.l("boxzoomend", { originalEvent: r })), { cameraAnimation: (y) => y.fitScreenCoordinates(p, g, this._tr.bearing, { linear: !0 }) };
            this._fireEvent("boxzoomcancel", r);
          }
          keydown(r) {
            this._active && r.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", r));
          }
          reset() {
            this._active = !1, this._container.classList.remove("maplibregl-crosshair"), this._box && (L.remove(this._box), this._box = null), L.enableDrag(), delete this._startPos, delete this._lastPos;
          }
          _fireEvent(r, h) {
            return this._map.fire(new a.l(r, { originalEvent: h }));
          }
        }
        function Yo(m, r) {
          if (m.length !== r.length) throw new Error(`The number of touches and points are not equal - touches ${m.length}, points ${r.length}`);
          const h = {};
          for (let p = 0; p < m.length; p++) h[m[p].identifier] = r[p];
          return h;
        }
        class Wd {
          constructor(r) {
            this.reset(), this.numTouches = r.numTouches;
          }
          reset() {
            delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1;
          }
          touchstart(r, h, p) {
            (this.centroid || p.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === void 0 && (this.startTime = r.timeStamp), p.length === this.numTouches && (this.centroid = (function(g) {
              const y = new a.P(0, 0);
              for (const x of g) y._add(x);
              return y.div(g.length);
            })(h), this.touches = Yo(p, h)));
          }
          touchmove(r, h, p) {
            if (this.aborted || !this.centroid) return;
            const g = Yo(p, h);
            for (const y in this.touches) {
              const x = g[y];
              (!x || x.dist(this.touches[y]) > 30) && (this.aborted = !0);
            }
          }
          touchend(r, h, p) {
            if ((!this.centroid || r.timeStamp - this.startTime > 500) && (this.aborted = !0), p.length === 0) {
              const g = !this.aborted && this.centroid;
              if (this.reset(), g) return g;
            }
          }
        }
        class Xr {
          constructor(r) {
            this.singleTap = new Wd(r), this.numTaps = r.numTaps, this.reset();
          }
          reset() {
            this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
          }
          touchstart(r, h, p) {
            this.singleTap.touchstart(r, h, p);
          }
          touchmove(r, h, p) {
            this.singleTap.touchmove(r, h, p);
          }
          touchend(r, h, p) {
            const g = this.singleTap.touchend(r, h, p);
            if (g) {
              const y = r.timeStamp - this.lastTime < 500, x = !this.lastTap || this.lastTap.dist(g) < 30;
              if (y && x || this.reset(), this.count++, this.lastTime = r.timeStamp, this.lastTap = g, this.count === this.numTaps) return this.reset(), g;
            }
          }
        }
        class Ds {
          constructor(r) {
            this._tr = new Ko(r), this._zoomIn = new Xr({ numTouches: 1, numTaps: 2 }), this._zoomOut = new Xr({ numTouches: 2, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
          }
          touchstart(r, h, p) {
            this._zoomIn.touchstart(r, h, p), this._zoomOut.touchstart(r, h, p);
          }
          touchmove(r, h, p) {
            this._zoomIn.touchmove(r, h, p), this._zoomOut.touchmove(r, h, p);
          }
          touchend(r, h, p) {
            const g = this._zoomIn.touchend(r, h, p), y = this._zoomOut.touchend(r, h, p), x = this._tr;
            return g ? (this._active = !0, r.preventDefault(), setTimeout((() => this.reset()), 0), { cameraAnimation: (E) => E.easeTo({ duration: 300, zoom: x.zoom + 1, around: x.unproject(g) }, { originalEvent: r }) }) : y ? (this._active = !0, r.preventDefault(), setTimeout((() => this.reset()), 0), { cameraAnimation: (E) => E.easeTo({ duration: 300, zoom: x.zoom - 1, around: x.unproject(y) }, { originalEvent: r }) }) : void 0;
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Jo {
          constructor(r) {
            this._enabled = !!r.enable, this._moveStateManager = r.moveStateManager, this._clickTolerance = r.clickTolerance || 1, this._moveFunction = r.move, this._activateOnStart = !!r.activateOnStart, r.assignEvents(this), this.reset();
          }
          reset(r) {
            this._active = !1, this._moved = !1, delete this._lastPoint, this._moveStateManager.endMove(r);
          }
          _move(...r) {
            const h = this._moveFunction(...r);
            if (h.bearingDelta || h.pitchDelta || h.rollDelta || h.around || h.panDelta) return this._active = !0, h;
          }
          dragStart(r, h) {
            this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(r) && (this._moveStateManager.startMove(r), this._lastPoint = Array.isArray(h) ? h[0] : h, this._activateOnStart && this._lastPoint && (this._active = !0));
          }
          dragMove(r, h) {
            if (!this.isEnabled()) return;
            const p = this._lastPoint;
            if (!p) return;
            if (r.preventDefault(), !this._moveStateManager.isValidMoveEvent(r)) return void this.reset(r);
            const g = Array.isArray(h) ? h[0] : h;
            return !this._moved && g.dist(p) < this._clickTolerance ? void 0 : (this._moved = !0, this._lastPoint = g, this._move(p, g));
          }
          dragEnd(r) {
            this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(r) && (this._moved && L.suppressClick(), this.reset(r));
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          getClickTolerance() {
            return this._clickTolerance;
          }
        }
        const Os = 0, Qo = 2, c_ = { [Os]: 1, [Qo]: 2 };
        class rl {
          constructor(r) {
            this._correctEvent = r.checkCorrectEvent;
          }
          startMove(r) {
            const h = L.mouseButton(r);
            this._eventButton = h;
          }
          endMove(r) {
            delete this._eventButton;
          }
          isValidStartEvent(r) {
            return this._correctEvent(r);
          }
          isValidMoveEvent(r) {
            return !(function(h, p) {
              const g = c_[p];
              return h.buttons === void 0 || (h.buttons & g) !== g;
            })(r, this._eventButton);
          }
          isValidEndEvent(r) {
            return L.mouseButton(r) === this._eventButton;
          }
        }
        class h_ {
          constructor() {
            this._firstTouch = void 0;
          }
          _isOneFingerTouch(r) {
            return r.targetTouches.length === 1;
          }
          _isSameTouchEvent(r) {
            return r.targetTouches[0].identifier === this._firstTouch;
          }
          startMove(r) {
            this._firstTouch = r.targetTouches[0].identifier;
          }
          endMove(r) {
            delete this._firstTouch;
          }
          isValidStartEvent(r) {
            return this._isOneFingerTouch(r);
          }
          isValidMoveEvent(r) {
            return this._isOneFingerTouch(r) && this._isSameTouchEvent(r);
          }
          isValidEndEvent(r) {
            return this._isOneFingerTouch(r) && this._isSameTouchEvent(r);
          }
        }
        class u_ {
          constructor(r = new rl({ checkCorrectEvent: () => !0 }), h = new h_()) {
            this.mouseMoveStateManager = r, this.oneFingerTouchMoveStateManager = h;
          }
          _executeRelevantHandler(r, h, p) {
            return r instanceof MouseEvent ? h(r) : typeof TouchEvent < "u" && r instanceof TouchEvent ? p(r) : void 0;
          }
          startMove(r) {
            this._executeRelevantHandler(r, ((h) => this.mouseMoveStateManager.startMove(h)), ((h) => this.oneFingerTouchMoveStateManager.startMove(h)));
          }
          endMove(r) {
            this._executeRelevantHandler(r, ((h) => this.mouseMoveStateManager.endMove(h)), ((h) => this.oneFingerTouchMoveStateManager.endMove(h)));
          }
          isValidStartEvent(r) {
            return this._executeRelevantHandler(r, ((h) => this.mouseMoveStateManager.isValidStartEvent(h)), ((h) => this.oneFingerTouchMoveStateManager.isValidStartEvent(h)));
          }
          isValidMoveEvent(r) {
            return this._executeRelevantHandler(r, ((h) => this.mouseMoveStateManager.isValidMoveEvent(h)), ((h) => this.oneFingerTouchMoveStateManager.isValidMoveEvent(h)));
          }
          isValidEndEvent(r) {
            return this._executeRelevantHandler(r, ((h) => this.mouseMoveStateManager.isValidEndEvent(h)), ((h) => this.oneFingerTouchMoveStateManager.isValidEndEvent(h)));
          }
        }
        const sl = (m) => {
          m.mousedown = m.dragStart, m.mousemoveWindow = m.dragMove, m.mouseup = m.dragEnd, m.contextmenu = (r) => {
            r.preventDefault();
          };
        };
        class nl {
          constructor(r, h) {
            this._clickTolerance = r.clickTolerance || 1, this._map = h, this.reset();
          }
          reset() {
            this._active = !1, this._touches = {}, this._sum = new a.P(0, 0);
          }
          _shouldBePrevented(r) {
            return r < (this._map.cooperativeGestures.isEnabled() ? 2 : 1);
          }
          touchstart(r, h, p) {
            return this._calculateTransform(r, h, p);
          }
          touchmove(r, h, p) {
            if (this._active) {
              if (!this._shouldBePrevented(p.length)) return r.preventDefault(), this._calculateTransform(r, h, p);
              this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", r);
            }
          }
          touchend(r, h, p) {
            this._calculateTransform(r, h, p), this._active && this._shouldBePrevented(p.length) && this.reset();
          }
          touchcancel() {
            this.reset();
          }
          _calculateTransform(r, h, p) {
            p.length > 0 && (this._active = !0);
            const g = Yo(p, h), y = new a.P(0, 0), x = new a.P(0, 0);
            let E = 0;
            for (const R in g) {
              const B = g[R], k = this._touches[R];
              k && (y._add(B), x._add(B.sub(k)), E++, g[R] = B);
            }
            if (this._touches = g, this._shouldBePrevented(E) || !x.mag()) return;
            const C = x.div(E);
            return this._sum._add(C), this._sum.mag() < this._clickTolerance ? void 0 : { around: y.div(E), panDelta: C };
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Fs {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = !1, delete this._firstTwoTouches;
          }
          touchstart(r, h, p) {
            this._firstTwoTouches || p.length < 2 || (this._firstTwoTouches = [p[0].identifier, p[1].identifier], this._start([h[0], h[1]]));
          }
          touchmove(r, h, p) {
            if (!this._firstTwoTouches) return;
            r.preventDefault();
            const [g, y] = this._firstTwoTouches, x = nt(p, h, g), E = nt(p, h, y);
            if (!x || !E) return;
            const C = this._aroundCenter ? null : x.add(E).div(2);
            return this._move([x, E], C, r);
          }
          touchend(r, h, p) {
            if (!this._firstTwoTouches) return;
            const [g, y] = this._firstTwoTouches, x = nt(p, h, g), E = nt(p, h, y);
            x && E || (this._active && L.suppressClick(), this.reset());
          }
          touchcancel() {
            this.reset();
          }
          enable(r) {
            this._enabled = !0, this._aroundCenter = !!r && r.around === "center";
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
        }
        function nt(m, r, h) {
          for (let p = 0; p < m.length; p++) if (m[p].identifier === h) return r[p];
        }
        function Xh(m, r) {
          return Math.log(m / r) / Math.LN2;
        }
        class nc extends Fs {
          reset() {
            super.reset(), delete this._distance, delete this._startDistance;
          }
          _start(r) {
            this._startDistance = this._distance = r[0].dist(r[1]);
          }
          _move(r, h) {
            const p = this._distance;
            if (this._distance = r[0].dist(r[1]), this._active || !(Math.abs(Xh(this._distance, this._startDistance)) < 0.1)) return this._active = !0, { zoomDelta: Xh(this._distance, p), pinchAround: h };
          }
        }
        function qh(m, r) {
          return 180 * m.angleWith(r) / Math.PI;
        }
        class ea extends Fs {
          reset() {
            super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
          }
          _start(r) {
            this._startVector = this._vector = r[0].sub(r[1]), this._minDiameter = r[0].dist(r[1]);
          }
          _move(r, h, p) {
            const g = this._vector;
            if (this._vector = r[0].sub(r[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, { bearingDelta: qh(this._vector, g), pinchAround: h };
          }
          _isBelowThreshold(r) {
            this._minDiameter = Math.min(this._minDiameter, r.mag());
            const h = 25 / (Math.PI * this._minDiameter) * 360, p = qh(r, this._startVector);
            return Math.abs(p) < h;
          }
        }
        function To(m) {
          return Math.abs(m.y) > Math.abs(m.x);
        }
        class oc extends Fs {
          constructor(r) {
            super(), this._currentTouchCount = 0, this._map = r;
          }
          reset() {
            super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
          }
          touchstart(r, h, p) {
            super.touchstart(r, h, p), this._currentTouchCount = p.length;
          }
          _start(r) {
            this._lastPoints = r, To(r[0].sub(r[1])) && (this._valid = !1);
          }
          _move(r, h, p) {
            if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
            const g = r[0].sub(this._lastPoints[0]), y = r[1].sub(this._lastPoints[1]);
            return this._valid = this.gestureBeginsVertically(g, y, p.timeStamp), this._valid ? (this._lastPoints = r, this._active = !0, { pitchDelta: (g.y + y.y) / 2 * -0.5 }) : void 0;
          }
          gestureBeginsVertically(r, h, p) {
            if (this._valid !== void 0) return this._valid;
            const g = r.mag() >= 2, y = h.mag() >= 2;
            if (!g && !y) return;
            if (!g || !y) return this._firstMove === void 0 && (this._firstMove = p), p - this._firstMove < 100 && void 0;
            const x = r.y > 0 == h.y > 0;
            return To(r) && To(h) && x;
          }
        }
        const Lt = { panStep: 100, bearingStep: 15, pitchStep: 10 };
        class ac {
          constructor(r) {
            this._tr = new Ko(r);
            const h = Lt;
            this._panStep = h.panStep, this._bearingStep = h.bearingStep, this._pitchStep = h.pitchStep, this._rotationDisabled = !1;
          }
          reset() {
            this._active = !1;
          }
          keydown(r) {
            if (r.altKey || r.ctrlKey || r.metaKey) return;
            let h = 0, p = 0, g = 0, y = 0, x = 0;
            switch (r.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                h = 1;
                break;
              case 189:
              case 109:
              case 173:
                h = -1;
                break;
              case 37:
                r.shiftKey ? p = -1 : (r.preventDefault(), y = -1);
                break;
              case 39:
                r.shiftKey ? p = 1 : (r.preventDefault(), y = 1);
                break;
              case 38:
                r.shiftKey ? g = 1 : (r.preventDefault(), x = -1);
                break;
              case 40:
                r.shiftKey ? g = -1 : (r.preventDefault(), x = 1);
                break;
              default:
                return;
            }
            return this._rotationDisabled && (p = 0, g = 0), { cameraAnimation: (E) => {
              const C = this._tr;
              E.easeTo({ duration: 300, easeId: "keyboardHandler", easing: d_, zoom: h ? Math.round(C.zoom) + h * (r.shiftKey ? 2 : 1) : C.zoom, bearing: C.bearing + p * this._bearingStep, pitch: C.pitch + g * this._pitchStep, offset: [-y * this._panStep, -x * this._panStep], center: C.center }, { originalEvent: r });
            } };
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          disableRotation() {
            this._rotationDisabled = !0;
          }
          enableRotation() {
            this._rotationDisabled = !1;
          }
        }
        function d_(m) {
          return m * (2 - m);
        }
        const lc = 4.000244140625, f_ = 1 / 450;
        class Xd {
          constructor(r, h) {
            this._onTimeout = (p) => {
              this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(p);
            }, this._map = r, this._tr = new Ko(r), this._triggerRenderFrame = h, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = f_;
          }
          setZoomRate(r) {
            this._defaultZoomRate = r;
          }
          setWheelZoomRate(r) {
            this._wheelZoomRate = r;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active || this._finishTimeout !== void 0;
          }
          isZooming() {
            return !!this._zooming;
          }
          enable(r) {
            this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!r && r.around === "center");
          }
          disable() {
            this.isEnabled() && (this._enabled = !1);
          }
          _shouldBePrevented(r) {
            return !!this._map.cooperativeGestures.isEnabled() && !(r.ctrlKey || this._map.cooperativeGestures.isBypassed(r));
          }
          wheel(r) {
            if (!this.isEnabled()) return;
            if (this._shouldBePrevented(r)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", r);
            let h = r.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * r.deltaY : r.deltaY;
            const p = N.now(), g = p - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = p, h !== 0 && h % lc == 0 ? this._type = "wheel" : h !== 0 && Math.abs(h) < 4 ? this._type = "trackpad" : g > 400 ? (this._type = null, this._lastValue = h, this._timeout = setTimeout(this._onTimeout, 40, r)) : this._type || (this._type = Math.abs(g * h) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, h += this._lastValue)), r.shiftKey && h && (h /= 4), this._type && (this._lastWheelEvent = r, this._delta -= h, this._active || this._start(r)), r.preventDefault();
          }
          _start(r) {
            if (!this._delta) return;
            this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            const h = L.mousePos(this._map.getCanvas(), r), p = this._tr;
            this._aroundPoint = this._aroundCenter ? p.transform.locationToScreenPoint(a.S.convert(p.center)) : h, this._frameId || (this._frameId = !0, this._triggerRenderFrame());
          }
          renderFrame() {
            if (!this._frameId || (this._frameId = null, !this.isActive())) return;
            const r = this._tr.transform;
            if (typeof this._lastExpectedZoom == "number") {
              const E = r.zoom - this._lastExpectedZoom;
              typeof this._startZoom == "number" && (this._startZoom += E), typeof this._targetZoom == "number" && (this._targetZoom += E);
            }
            if (this._delta !== 0) {
              const E = this._type === "wheel" && Math.abs(this._delta) > lc ? this._wheelZoomRate : this._defaultZoomRate;
              let C = 2 / (1 + Math.exp(-Math.abs(this._delta * E)));
              this._delta < 0 && C !== 0 && (C = 1 / C);
              const R = typeof this._targetZoom != "number" ? r.scale : a.af(this._targetZoom);
              this._targetZoom = r.getConstrained(r.getCameraLngLat(), a.ak(R * C)).zoom, this._type === "wheel" && (this._startZoom = r.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
            }
            const h = typeof this._targetZoom != "number" ? r.zoom : this._targetZoom, p = this._startZoom, g = this._easing;
            let y, x = !1;
            if (this._type === "wheel" && p && g) {
              const E = N.now() - this._lastWheelEventTime, C = Math.min((E + 5) / 200, 1), R = g(C);
              y = a.C.number(p, h, R), C < 1 ? this._frameId || (this._frameId = !0) : x = !0;
            } else y = h, x = !0;
            return this._active = !0, x && (this._active = !1, this._finishTimeout = setTimeout((() => {
              this._zooming = !1, this._triggerRenderFrame(), delete this._targetZoom, delete this._lastExpectedZoom, delete this._finishTimeout;
            }), 200)), this._lastExpectedZoom = y, { noInertia: !0, needsRenderFrame: !x, zoomDelta: y - r.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
          }
          _smoothOutEasing(r) {
            let h = a.co;
            if (this._prevEase) {
              const p = this._prevEase, g = (N.now() - p.start) / p.duration, y = p.easing(g + 0.01) - p.easing(g), x = 0.27 / Math.sqrt(y * y + 1e-4) * 0.01, E = Math.sqrt(0.0729 - x * x);
              h = a.cm(x, E, 0.25, 1);
            }
            return this._prevEase = { start: N.now(), duration: r, easing: h }, h;
          }
          reset() {
            this._active = !1, this._zooming = !1, delete this._targetZoom, delete this._lastExpectedZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          }
        }
        class Zh {
          constructor(r, h) {
            this._clickZoom = r, this._tapZoom = h;
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable();
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable();
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive();
          }
        }
        class Kh {
          constructor(r) {
            this._tr = new Ko(r), this.reset();
          }
          reset() {
            this._active = !1;
          }
          dblclick(r, h) {
            return r.preventDefault(), { cameraAnimation: (p) => {
              p.easeTo({ duration: 300, zoom: this._tr.zoom + (r.shiftKey ? -1 : 1), around: this._tr.unproject(h) }, { originalEvent: r });
            } };
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class qd {
          constructor() {
            this._tap = new Xr({ numTouches: 1, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
          }
          touchstart(r, h, p) {
            if (!this._swipePoint) if (this._tapTime) {
              const g = h[0], y = r.timeStamp - this._tapTime < 500, x = this._tapPoint.dist(g) < 30;
              y && x ? p.length > 0 && (this._swipePoint = g, this._swipeTouch = p[0].identifier) : this.reset();
            } else this._tap.touchstart(r, h, p);
          }
          touchmove(r, h, p) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (p[0].identifier !== this._swipeTouch) return;
                const g = h[0], y = g.y - this._swipePoint.y;
                return this._swipePoint = g, r.preventDefault(), this._active = !0, { zoomDelta: y / 128 };
              }
            } else this._tap.touchmove(r, h, p);
          }
          touchend(r, h, p) {
            if (this._tapTime) this._swipePoint && p.length === 0 && this.reset();
            else {
              const g = this._tap.touchend(r, h, p);
              g && (this._tapTime = r.timeStamp, this._tapPoint = g);
            }
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Zd {
          constructor(r, h, p) {
            this._el = r, this._mousePan = h, this._touchPan = p;
          }
          enable(r) {
            this._inertiaOptions = r || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled();
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive();
          }
        }
        class Yh {
          constructor(r, h, p, g) {
            this._pitchWithRotate = r.pitchWithRotate, this._rollEnabled = r.rollEnabled, this._mouseRotate = h, this._mousePitch = p, this._mouseRoll = g;
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(), this._rollEnabled && this._mouseRoll.enable();
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable(), this._mouseRoll.disable();
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled());
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive();
          }
        }
        class Kd {
          constructor(r, h, p, g) {
            this._el = r, this._touchZoom = h, this._touchRotate = p, this._tapDragZoom = g, this._rotationDisabled = !1, this._enabled = !0;
          }
          enable(r) {
            this._touchZoom.enable(r), this._rotationDisabled || this._touchRotate.enable(r), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
          }
          disableRotation() {
            this._rotationDisabled = !0, this._touchRotate.disable();
          }
          enableRotation() {
            this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
          }
        }
        class Yd {
          constructor(r, h) {
            this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey", this._map = r, this._options = h, this._enabled = !1;
          }
          isActive() {
            return !1;
          }
          reset() {
          }
          _setupUI() {
            if (this._container) return;
            const r = this._map.getCanvasContainer();
            r.classList.add("maplibregl-cooperative-gestures"), this._container = L.create("div", "maplibregl-cooperative-gesture-screen", r);
            let h = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
            this._bypassKey === "metaKey" && (h = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
            const p = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), g = document.createElement("div");
            g.className = "maplibregl-desktop-message", g.textContent = h, this._container.appendChild(g);
            const y = document.createElement("div");
            y.className = "maplibregl-mobile-message", y.textContent = p, this._container.appendChild(y), this._container.setAttribute("aria-hidden", "true");
          }
          _destroyUI() {
            this._container && (L.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
          }
          enable() {
            this._setupUI(), this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this._destroyUI();
          }
          isEnabled() {
            return this._enabled;
          }
          isBypassed(r) {
            return r[this._bypassKey];
          }
          notifyGestureBlocked(r, h) {
            this._enabled && (this._map.fire(new a.l("cooperativegestureprevented", { gestureType: r, originalEvent: h })), this._container.classList.add("maplibregl-show"), setTimeout((() => {
              this._container.classList.remove("maplibregl-show");
            }), 100));
          }
        }
        const ks = (m) => m.zoom || m.drag || m.roll || m.pitch || m.rotate;
        class gi extends a.l {
        }
        function ta(m) {
          return m.panDelta && m.panDelta.mag() || m.zoomDelta || m.bearingDelta || m.pitchDelta || m.rollDelta;
        }
        class Jh {
          constructor(r, h) {
            this.handleWindowEvent = (g) => {
              this.handleEvent(g, `${g.type}Window`);
            }, this.handleEvent = (g, y) => {
              if (g.type === "blur") return void this.stop(!0);
              this._updatingCamera = !0;
              const x = g.type === "renderFrame" ? void 0 : g, E = { needsRenderFrame: !1 }, C = {}, R = {};
              for (const { handlerName: O, handler: z, allowed: H } of this._handlers) {
                if (!z.isEnabled()) continue;
                let Y;
                if (this._blockedByActive(R, H, O)) z.reset();
                else if (z[y || g.type]) {
                  if (a.cp(g, y || g.type)) {
                    const K = L.mousePos(this._map.getCanvas(), g);
                    Y = z[y || g.type](g, K);
                  } else if (a.cq(g, y || g.type)) {
                    const K = this._getMapTouches(g.touches), J = L.touchPos(this._map.getCanvas(), K);
                    Y = z[y || g.type](g, J, K);
                  } else a.cr(y || g.type) || (Y = z[y || g.type](g));
                  this.mergeHandlerResult(E, C, Y, O, x), Y && Y.needsRenderFrame && this._triggerRenderFrame();
                }
                (Y || z.isActive()) && (R[O] = z);
              }
              const B = {};
              for (const O in this._previousActiveHandlers) R[O] || (B[O] = x);
              this._previousActiveHandlers = R, (Object.keys(B).length || ta(E)) && (this._changes.push([E, C, B]), this._triggerRenderFrame()), (Object.keys(R).length || ta(E)) && this._map._stop(!0), this._updatingCamera = !1;
              const { cameraAnimation: k } = E;
              k && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], k(this._map));
            }, this._map = r, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Hd(r), this._bearingSnap = h.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(h);
            const p = this._el;
            this._listeners = [[p, "touchstart", { passive: !0 }], [p, "touchmove", { passive: !1 }], [p, "touchend", void 0], [p, "touchcancel", void 0], [p, "mousedown", void 0], [p, "mousemove", void 0], [p, "mouseup", void 0], [document, "mousemove", { capture: !0 }], [document, "mouseup", void 0], [p, "mouseover", void 0], [p, "mouseout", void 0], [p, "dblclick", void 0], [p, "click", void 0], [p, "keydown", { capture: !1 }], [p, "keyup", void 0], [p, "wheel", { passive: !1 }], [p, "contextmenu", void 0], [window, "blur", void 0]];
            for (const [g, y, x] of this._listeners) L.addEventListener(g, y, g === document ? this.handleWindowEvent : this.handleEvent, x);
          }
          destroy() {
            for (const [r, h, p] of this._listeners) L.removeEventListener(r, h, r === document ? this.handleWindowEvent : this.handleEvent, p);
          }
          _addDefaultHandlers(r) {
            const h = this._map, p = h.getCanvasContainer();
            this._add("mapEvent", new $d(h, r));
            const g = h.boxZoom = new Wh(h, r);
            this._add("boxZoom", g), r.interactive && r.boxZoom && g.enable();
            const y = h.cooperativeGestures = new Yd(h, r.cooperativeGestures);
            this._add("cooperativeGestures", y), r.cooperativeGestures && y.enable();
            const x = new Ds(h), E = new Kh(h);
            h.doubleClickZoom = new Zh(E, x), this._add("tapZoom", x), this._add("clickZoom", E), r.interactive && r.doubleClickZoom && h.doubleClickZoom.enable();
            const C = new qd();
            this._add("tapDragZoom", C);
            const R = h.touchPitch = new oc(h);
            this._add("touchPitch", R), r.interactive && r.touchPitch && h.touchPitch.enable(r.touchPitch);
            const B = () => h.project(h.getCenter()), k = (function({ enable: se, clickTolerance: he, aroundCenter: fe = !0, minPixelCenterThreshold: oe = 100, rotateDegreesPerPixelMoved: be = 0.8 }, Fe) {
              const Ie = new rl({ checkCorrectEvent: (Me) => L.mouseButton(Me) === 0 && Me.ctrlKey || L.mouseButton(Me) === 2 && !Me.ctrlKey });
              return new Jo({ clickTolerance: he, move: (Me, Oe) => {
                const We = Fe();
                if (fe && Math.abs(We.y - Me.y) > oe) return { bearingDelta: a.cn(new a.P(Me.x, Oe.y), Oe, We) };
                let qe = (Oe.x - Me.x) * be;
                return fe && Oe.y < We.y && (qe = -qe), { bearingDelta: qe };
              }, moveStateManager: Ie, enable: se, assignEvents: sl });
            })(r, B), O = (function({ enable: se, clickTolerance: he, pitchDegreesPerPixelMoved: fe = -0.5 }) {
              const oe = new rl({ checkCorrectEvent: (be) => L.mouseButton(be) === 0 && be.ctrlKey || L.mouseButton(be) === 2 });
              return new Jo({ clickTolerance: he, move: (be, Fe) => ({ pitchDelta: (Fe.y - be.y) * fe }), moveStateManager: oe, enable: se, assignEvents: sl });
            })(r), z = (function({ enable: se, clickTolerance: he, rollDegreesPerPixelMoved: fe = 0.3 }, oe) {
              const be = new rl({ checkCorrectEvent: (Fe) => L.mouseButton(Fe) === 2 && Fe.ctrlKey });
              return new Jo({ clickTolerance: he, move: (Fe, Ie) => {
                const Me = oe();
                let Oe = (Ie.x - Fe.x) * fe;
                return Ie.y < Me.y && (Oe = -Oe), { rollDelta: Oe };
              }, moveStateManager: be, enable: se, assignEvents: sl });
            })(r, B);
            h.dragRotate = new Yh(r, k, O, z), this._add("mouseRotate", k, ["mousePitch"]), this._add("mousePitch", O, ["mouseRotate", "mouseRoll"]), this._add("mouseRoll", z, ["mousePitch"]), r.interactive && r.dragRotate && h.dragRotate.enable();
            const H = (function({ enable: se, clickTolerance: he }) {
              const fe = new rl({ checkCorrectEvent: (oe) => L.mouseButton(oe) === 0 && !oe.ctrlKey });
              return new Jo({ clickTolerance: he, move: (oe, be) => ({ around: be, panDelta: be.sub(oe) }), activateOnStart: !0, moveStateManager: fe, enable: se, assignEvents: sl });
            })(r), Y = new nl(r, h);
            h.dragPan = new Zd(p, H, Y), this._add("mousePan", H), this._add("touchPan", Y, ["touchZoom", "touchRotate"]), r.interactive && r.dragPan && h.dragPan.enable(r.dragPan);
            const K = new ea(), J = new nc();
            h.touchZoomRotate = new Kd(p, J, K, C), this._add("touchRotate", K, ["touchPan", "touchZoom"]), this._add("touchZoom", J, ["touchPan", "touchRotate"]), r.interactive && r.touchZoomRotate && h.touchZoomRotate.enable(r.touchZoomRotate);
            const ie = h.scrollZoom = new Xd(h, (() => this._triggerRenderFrame()));
            this._add("scrollZoom", ie, ["mousePan"]), r.interactive && r.scrollZoom && h.scrollZoom.enable(r.scrollZoom);
            const le = h.keyboard = new ac(h);
            this._add("keyboard", le), r.interactive && r.keyboard && h.keyboard.enable(), this._add("blockableMapEvent", new Gd(h));
          }
          _add(r, h, p) {
            this._handlers.push({ handlerName: r, handler: h, allowed: p }), this._handlersById[r] = h;
          }
          stop(r) {
            if (!this._updatingCamera) {
              for (const { handler: h } of this._handlers) h.reset();
              this._inertia.clear(), this._fireEvents({}, {}, r), this._changes = [];
            }
          }
          isActive() {
            for (const { handler: r } of this._handlers) if (r.isActive()) return !0;
            return !1;
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
          }
          isRotating() {
            return !!this._eventsInProgress.rotate;
          }
          isMoving() {
            return !!ks(this._eventsInProgress) || this.isZooming();
          }
          _blockedByActive(r, h, p) {
            for (const g in r) if (g !== p && (!h || h.indexOf(g) < 0)) return !0;
            return !1;
          }
          _getMapTouches(r) {
            const h = [];
            for (const p of r) this._el.contains(p.target) && h.push(p);
            return h;
          }
          mergeHandlerResult(r, h, p, g, y) {
            if (!p) return;
            a.e(r, p);
            const x = { handlerName: g, originalEvent: p.originalEvent || y };
            p.zoomDelta !== void 0 && (h.zoom = x), p.panDelta !== void 0 && (h.drag = x), p.rollDelta !== void 0 && (h.roll = x), p.pitchDelta !== void 0 && (h.pitch = x), p.bearingDelta !== void 0 && (h.rotate = x);
          }
          _applyChanges() {
            const r = {}, h = {}, p = {};
            for (const [g, y, x] of this._changes) g.panDelta && (r.panDelta = (r.panDelta || new a.P(0, 0))._add(g.panDelta)), g.zoomDelta && (r.zoomDelta = (r.zoomDelta || 0) + g.zoomDelta), g.bearingDelta && (r.bearingDelta = (r.bearingDelta || 0) + g.bearingDelta), g.pitchDelta && (r.pitchDelta = (r.pitchDelta || 0) + g.pitchDelta), g.rollDelta && (r.rollDelta = (r.rollDelta || 0) + g.rollDelta), g.around !== void 0 && (r.around = g.around), g.pinchAround !== void 0 && (r.pinchAround = g.pinchAround), g.noInertia && (r.noInertia = g.noInertia), a.e(h, y), a.e(p, x);
            this._updateMapTransform(r, h, p), this._changes = [];
          }
          _updateMapTransform(r, h, p) {
            const g = this._map, y = g._getTransformForUpdate(), x = g.terrain;
            if (!(ta(r) || x && this._terrainMovement)) return this._fireEvents(h, p, !0);
            g._stop(!0);
            let { panDelta: E, zoomDelta: C, bearingDelta: R, pitchDelta: B, rollDelta: k, around: O, pinchAround: z } = r;
            z !== void 0 && (O = z), O = O || g.transform.centerPoint, x && !y.isPointOnMapSurface(O) && (O = y.centerPoint);
            const H = { panDelta: E, zoomDelta: C, rollDelta: k, pitchDelta: B, bearingDelta: R, around: O };
            this._map.cameraHelper.useGlobeControls && !y.isPointOnMapSurface(O) && (O = y.centerPoint);
            const Y = O.distSqr(y.centerPoint) < 0.01 ? y.center : y.screenPointToLocation(E ? O.sub(E) : O);
            x ? (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(H, y), this._terrainMovement || !h.drag && !h.zoom ? h.drag && this._terrainMovement ? y.setCenter(y.screenPointToLocation(y.centerPoint.sub(E))) : this._map.cameraHelper.handleMapControlsPan(H, y, Y) : (this._terrainMovement = !0, this._map._elevationFreeze = !0, this._map.cameraHelper.handleMapControlsPan(H, y, Y))) : (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(H, y), this._map.cameraHelper.handleMapControlsPan(H, y, Y)), g._applyUpdatedTransform(y), this._map._update(), r.noInertia || this._inertia.record(r), this._fireEvents(h, p, !0);
          }
          _fireEvents(r, h, p) {
            const g = ks(this._eventsInProgress), y = ks(r), x = {};
            for (const k in r) {
              const { originalEvent: O } = r[k];
              this._eventsInProgress[k] || (x[`${k}start`] = O), this._eventsInProgress[k] = r[k];
            }
            !g && y && this._fireEvent("movestart", y.originalEvent);
            for (const k in x) this._fireEvent(k, x[k]);
            y && this._fireEvent("move", y.originalEvent);
            for (const k in r) {
              const { originalEvent: O } = r[k];
              this._fireEvent(k, O);
            }
            const E = {};
            let C;
            for (const k in this._eventsInProgress) {
              const { handlerName: O, originalEvent: z } = this._eventsInProgress[k];
              this._handlersById[O].isActive() || (delete this._eventsInProgress[k], C = h[O] || z, E[`${k}end`] = C);
            }
            for (const k in E) this._fireEvent(k, E[k]);
            const R = ks(this._eventsInProgress), B = (g || y) && !R;
            if (B && this._terrainMovement) {
              this._map._elevationFreeze = !1, this._terrainMovement = !1;
              const k = this._map._getTransformForUpdate();
              this._map.getCenterClampedToGround() && k.recalculateZoomAndCenter(this._map.terrain), this._map._applyUpdatedTransform(k);
            }
            if (p && B) {
              this._updatingCamera = !0;
              const k = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), O = (z) => z !== 0 && -this._bearingSnap < z && z < this._bearingSnap;
              !k || !k.essential && N.prefersReducedMotion ? (this._map.fire(new a.l("moveend", { originalEvent: C })), O(this._map.getBearing()) && this._map.resetNorth()) : (O(k.bearing || this._map.getBearing()) && (k.bearing = 0), k.freezeElevation = !0, this._map.easeTo(k, { originalEvent: C })), this._updatingCamera = !1;
            }
          }
          _fireEvent(r, h) {
            this._map.fire(new a.l(r, h ? { originalEvent: h } : {}));
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add(((r) => {
              delete this._frameId, this.handleEvent(new gi("renderFrame", { timeStamp: r })), this._applyChanges();
            }));
          }
          _triggerRenderFrame() {
            this._frameId === void 0 && (this._frameId = this._requestFrame());
          }
        }
        class Jd extends a.E {
          constructor(r, h, p) {
            super(), this._renderFrameCallback = () => {
              const g = Math.min((N.now() - this._easeStart) / this._easeOptions.duration, 1);
              this._onEaseFrame(this._easeOptions.easing(g)), g < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
            }, this._moving = !1, this._zooming = !1, this.transform = r, this._bearingSnap = p.bearingSnap, this.cameraHelper = h, this.on("moveend", (() => {
              delete this._requestedCameraState;
            }));
          }
          migrateProjection(r, h) {
            r.apply(this.transform), this.transform = r, this.cameraHelper = h;
          }
          getCenter() {
            return new a.S(this.transform.center.lng, this.transform.center.lat);
          }
          setCenter(r, h) {
            return this.jumpTo({ center: r }, h);
          }
          getCenterElevation() {
            return this.transform.elevation;
          }
          setCenterElevation(r, h) {
            return this.jumpTo({ elevation: r }, h), this;
          }
          getCenterClampedToGround() {
            return this._centerClampedToGround;
          }
          setCenterClampedToGround(r) {
            this._centerClampedToGround = r;
          }
          panBy(r, h, p) {
            return r = a.P.convert(r).mult(-1), this.panTo(this.transform.center, a.e({ offset: r }, h), p);
          }
          panTo(r, h, p) {
            return this.easeTo(a.e({ center: r }, h), p);
          }
          getZoom() {
            return this.transform.zoom;
          }
          setZoom(r, h) {
            return this.jumpTo({ zoom: r }, h), this;
          }
          zoomTo(r, h, p) {
            return this.easeTo(a.e({ zoom: r }, h), p);
          }
          zoomIn(r, h) {
            return this.zoomTo(this.getZoom() + 1, r, h), this;
          }
          zoomOut(r, h) {
            return this.zoomTo(this.getZoom() - 1, r, h), this;
          }
          getVerticalFieldOfView() {
            return this.transform.fov;
          }
          setVerticalFieldOfView(r, h) {
            return r != this.transform.fov && (this.transform.setFov(r), this.fire(new a.l("movestart", h)).fire(new a.l("move", h)).fire(new a.l("moveend", h))), this;
          }
          getBearing() {
            return this.transform.bearing;
          }
          setBearing(r, h) {
            return this.jumpTo({ bearing: r }, h), this;
          }
          getPadding() {
            return this.transform.padding;
          }
          setPadding(r, h) {
            return this.jumpTo({ padding: r }, h), this;
          }
          rotateTo(r, h, p) {
            return this.easeTo(a.e({ bearing: r }, h), p);
          }
          resetNorth(r, h) {
            return this.rotateTo(0, a.e({ duration: 1e3 }, r), h), this;
          }
          resetNorthPitch(r, h) {
            return this.easeTo(a.e({ bearing: 0, pitch: 0, roll: 0, duration: 1e3 }, r), h), this;
          }
          snapToNorth(r, h) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(r, h) : this;
          }
          getPitch() {
            return this.transform.pitch;
          }
          setPitch(r, h) {
            return this.jumpTo({ pitch: r }, h), this;
          }
          getRoll() {
            return this.transform.roll;
          }
          setRoll(r, h) {
            return this.jumpTo({ roll: r }, h), this;
          }
          cameraForBounds(r, h) {
            r = ni.convert(r).adjustAntiMeridian();
            const p = h && h.bearing || 0;
            return this._cameraForBoxAndBearing(r.getNorthWest(), r.getSouthEast(), p, h);
          }
          _cameraForBoxAndBearing(r, h, p, g) {
            const y = { top: 0, bottom: 0, right: 0, left: 0 };
            if (typeof (g = a.e({ padding: y, offset: [0, 0], maxZoom: this.transform.maxZoom }, g)).padding == "number") {
              const R = g.padding;
              g.padding = { top: R, bottom: R, right: R, left: R };
            }
            const x = a.e(y, g.padding);
            g.padding = x;
            const E = this.transform, C = new ni(r, h);
            return this.cameraHelper.cameraForBoxAndBearing(g, x, C, p, E);
          }
          fitBounds(r, h, p) {
            return this._fitInternal(this.cameraForBounds(r, h), h, p);
          }
          fitScreenCoordinates(r, h, p, g, y) {
            return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(a.P.convert(r)), this.transform.screenPointToLocation(a.P.convert(h)), p, g), g, y);
          }
          _fitInternal(r, h, p) {
            return r ? (delete (h = a.e(r, h)).padding, h.linear ? this.easeTo(h, p) : this.flyTo(h, p)) : this;
          }
          jumpTo(r, h) {
            this.stop();
            const p = this._getTransformForUpdate();
            let g = !1, y = !1, x = !1;
            const E = p.zoom;
            this.cameraHelper.handleJumpToCenterZoom(p, r);
            const C = p.zoom !== E;
            return "elevation" in r && p.elevation !== +r.elevation && p.setElevation(+r.elevation), "bearing" in r && p.bearing !== +r.bearing && (g = !0, p.setBearing(+r.bearing)), "pitch" in r && p.pitch !== +r.pitch && (y = !0, p.setPitch(+r.pitch)), "roll" in r && p.roll !== +r.roll && (x = !0, p.setRoll(+r.roll)), r.padding == null || p.isPaddingEqual(r.padding) || p.setPadding(r.padding), this._applyUpdatedTransform(p), this.fire(new a.l("movestart", h)).fire(new a.l("move", h)), C && this.fire(new a.l("zoomstart", h)).fire(new a.l("zoom", h)).fire(new a.l("zoomend", h)), g && this.fire(new a.l("rotatestart", h)).fire(new a.l("rotate", h)).fire(new a.l("rotateend", h)), y && this.fire(new a.l("pitchstart", h)).fire(new a.l("pitch", h)).fire(new a.l("pitchend", h)), x && this.fire(new a.l("rollstart", h)).fire(new a.l("roll", h)).fire(new a.l("rollend", h)), this.fire(new a.l("moveend", h));
          }
          calculateCameraOptionsFromTo(r, h, p, g = 0) {
            const y = a.a1.fromLngLat(r, h), x = a.a1.fromLngLat(p, g), E = x.x - y.x, C = x.y - y.y, R = x.z - y.z, B = Math.hypot(E, C, R);
            if (B === 0) throw new Error("Can't calculate camera options with same From and To");
            const k = Math.hypot(E, C), O = a.ak(this.transform.cameraToCenterDistance / B / this.transform.tileSize), z = 180 * Math.atan2(E, -C) / Math.PI;
            let H = 180 * Math.acos(k / B) / Math.PI;
            return H = R < 0 ? 90 - H : 90 + H, { center: x.toLngLat(), elevation: g, zoom: O, pitch: H, bearing: z };
          }
          calculateCameraOptionsFromCameraLngLatAltRotation(r, h, p, g, y) {
            const x = this.transform.calculateCenterFromCameraLngLatAlt(r, h, p, g);
            return { center: x.center, elevation: x.elevation, zoom: x.zoom, bearing: p, pitch: g, roll: y };
          }
          easeTo(r, h) {
            this._stop(!1, r.easeId), ((r = a.e({ offset: [0, 0], duration: 500, easing: a.co }, r)).animate === !1 || !r.essential && N.prefersReducedMotion) && (r.duration = 0);
            const p = this._getTransformForUpdate(), g = this.getBearing(), y = p.pitch, x = p.roll, E = "bearing" in r ? this._normalizeBearing(r.bearing, g) : g, C = "pitch" in r ? +r.pitch : y, R = "roll" in r ? this._normalizeBearing(r.roll, x) : x, B = "padding" in r ? r.padding : p.padding, k = a.P.convert(r.offset);
            let O, z;
            r.around && (O = a.S.convert(r.around), z = p.locationToScreenPoint(O));
            const H = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching, rolling: this._rolling }, Y = this.cameraHelper.handleEaseTo(p, { bearing: E, pitch: C, roll: R, padding: B, around: O, aroundPoint: z, offsetAsPoint: k, offset: r.offset, zoom: r.zoom, center: r.center });
            return this._rotating = this._rotating || g !== E, this._pitching = this._pitching || C !== y, this._rolling = this._rolling || R !== x, this._padding = !p.isPaddingEqual(B), this._zooming = this._zooming || Y.isZooming, this._easeId = r.easeId, this._prepareEase(h, r.noMoveStart, H), this.terrain && this._prepareElevation(Y.elevationCenter), this._ease(((K) => {
              Y.easeFunc(K), this.terrain && !r.freezeElevation && this._updateElevation(K), this._applyUpdatedTransform(p), this._fireMoveEvents(h);
            }), ((K) => {
              this.terrain && r.freezeElevation && this._finalizeElevation(), this._afterEase(h, K);
            }), r), this;
          }
          _prepareEase(r, h, p = {}) {
            this._moving = !0, h || p.moving || this.fire(new a.l("movestart", r)), this._zooming && !p.zooming && this.fire(new a.l("zoomstart", r)), this._rotating && !p.rotating && this.fire(new a.l("rotatestart", r)), this._pitching && !p.pitching && this.fire(new a.l("pitchstart", r)), this._rolling && !p.rolling && this.fire(new a.l("rollstart", r));
          }
          _prepareElevation(r) {
            this._elevationCenter = r, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(r, this.transform.tileZoom), this._elevationFreeze = !0;
          }
          _updateElevation(r) {
            this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
            const h = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
            if (r < 1 && h !== this._elevationTarget) {
              const p = this._elevationTarget - this._elevationStart;
              this._elevationStart += r * (p - (h - (p * r + this._elevationStart)) / (1 - r)), this._elevationTarget = h;
            }
            this.transform.setElevation(a.C.number(this._elevationStart, this._elevationTarget, r));
          }
          _finalizeElevation() {
            this._elevationFreeze = !1, this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain);
          }
          _getTransformForUpdate() {
            return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
          }
          _elevateCameraIfInsideTerrain(r) {
            if (!this.terrain && r.elevation >= 0 && r.pitch <= 90) return {};
            const h = r.getCameraLngLat(), p = r.getCameraAltitude(), g = this.terrain ? this.terrain.getElevationForLngLatZoom(h, r.zoom) : 0;
            if (p < g) {
              const y = this.calculateCameraOptionsFromTo(h, g, r.center, r.elevation);
              return { pitch: y.pitch, zoom: y.zoom };
            }
            return {};
          }
          _applyUpdatedTransform(r) {
            const h = [];
            if (h.push(((g) => this._elevateCameraIfInsideTerrain(g))), this.transformCameraUpdate && h.push(((g) => this.transformCameraUpdate(g))), !h.length) return;
            const p = r.clone();
            for (const g of h) {
              const y = p.clone(), { center: x, zoom: E, roll: C, pitch: R, bearing: B, elevation: k } = g(y);
              x && y.setCenter(x), k !== void 0 && y.setElevation(k), E !== void 0 && y.setZoom(E), C !== void 0 && y.setRoll(C), R !== void 0 && y.setPitch(R), B !== void 0 && y.setBearing(B), p.apply(y);
            }
            this.transform.apply(p);
          }
          _fireMoveEvents(r) {
            this.fire(new a.l("move", r)), this._zooming && this.fire(new a.l("zoom", r)), this._rotating && this.fire(new a.l("rotate", r)), this._pitching && this.fire(new a.l("pitch", r)), this._rolling && this.fire(new a.l("roll", r));
          }
          _afterEase(r, h) {
            if (this._easeId && h && this._easeId === h) return;
            delete this._easeId;
            const p = this._zooming, g = this._rotating, y = this._pitching, x = this._rolling;
            this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._rolling = !1, this._padding = !1, p && this.fire(new a.l("zoomend", r)), g && this.fire(new a.l("rotateend", r)), y && this.fire(new a.l("pitchend", r)), x && this.fire(new a.l("rollend", r)), this.fire(new a.l("moveend", r));
          }
          flyTo(r, h) {
            if (!r.essential && N.prefersReducedMotion) {
              const Oe = a.Q(r, ["center", "zoom", "bearing", "pitch", "roll", "elevation"]);
              return this.jumpTo(Oe, h);
            }
            this.stop(), r = a.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: a.co }, r);
            const p = this._getTransformForUpdate(), g = p.bearing, y = p.pitch, x = p.roll, E = p.padding, C = "bearing" in r ? this._normalizeBearing(r.bearing, g) : g, R = "pitch" in r ? +r.pitch : y, B = "roll" in r ? this._normalizeBearing(r.roll, x) : x, k = "padding" in r ? r.padding : p.padding, O = a.P.convert(r.offset);
            let z = p.centerPoint.add(O);
            const H = p.screenPointToLocation(z), Y = this.cameraHelper.handleFlyTo(p, { bearing: C, pitch: R, roll: B, padding: k, locationAtOffset: H, offsetAsPoint: O, center: r.center, minZoom: r.minZoom, zoom: r.zoom });
            let K = r.curve;
            const J = Math.max(p.width, p.height), ie = J / Y.scaleOfZoom, le = Y.pixelPathLength;
            typeof Y.scaleOfMinZoom == "number" && (K = Math.sqrt(J / Y.scaleOfMinZoom / le * 2));
            const se = K * K;
            function he(Oe) {
              const We = (ie * ie - J * J + (Oe ? -1 : 1) * se * se * le * le) / (2 * (Oe ? ie : J) * se * le);
              return Math.log(Math.sqrt(We * We + 1) - We);
            }
            function fe(Oe) {
              return (Math.exp(Oe) - Math.exp(-Oe)) / 2;
            }
            function oe(Oe) {
              return (Math.exp(Oe) + Math.exp(-Oe)) / 2;
            }
            const be = he(!1);
            let Fe = function(Oe) {
              return oe(be) / oe(be + K * Oe);
            }, Ie = function(Oe) {
              return J * ((oe(be) * (fe(We = be + K * Oe) / oe(We)) - fe(be)) / se) / le;
              var We;
            }, Me = (he(!0) - be) / K;
            if (Math.abs(le) < 2e-6 || !isFinite(Me)) {
              if (Math.abs(J - ie) < 1e-6) return this.easeTo(r, h);
              const Oe = ie < J ? -1 : 1;
              Me = Math.abs(Math.log(ie / J)) / K, Ie = () => 0, Fe = (We) => Math.exp(Oe * K * We);
            }
            return r.duration = "duration" in r ? +r.duration : 1e3 * Me / ("screenSpeed" in r ? +r.screenSpeed / K : +r.speed), r.maxDuration && r.duration > r.maxDuration && (r.duration = 0), this._zooming = !0, this._rotating = g !== C, this._pitching = R !== y, this._rolling = B !== x, this._padding = !p.isPaddingEqual(k), this._prepareEase(h, !1), this.terrain && this._prepareElevation(Y.targetCenter), this._ease(((Oe) => {
              const We = Oe * Me, qe = 1 / Fe(We), Ve = Ie(We);
              this._rotating && p.setBearing(a.C.number(g, C, Oe)), this._pitching && p.setPitch(a.C.number(y, R, Oe)), this._rolling && p.setRoll(a.C.number(x, B, Oe)), this._padding && (p.interpolatePadding(E, k, Oe), z = p.centerPoint.add(O)), Y.easeFunc(Oe, qe, Ve, z), this.terrain && !r.freezeElevation && this._updateElevation(Oe), this._applyUpdatedTransform(p), this._fireMoveEvents(h);
            }), (() => {
              this.terrain && r.freezeElevation && this._finalizeElevation(), this._afterEase(h);
            }), r), this;
          }
          isEasing() {
            return !!this._easeFrameId;
          }
          stop() {
            return this._stop();
          }
          _stop(r, h) {
            var p;
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
              const g = this._onEaseEnd;
              delete this._onEaseEnd, g.call(this, h);
            }
            return r || (p = this.handlers) === null || p === void 0 || p.stop(!1), this;
          }
          _ease(r, h, p) {
            p.animate === !1 || p.duration === 0 ? (r(1), h()) : (this._easeStart = N.now(), this._easeOptions = p, this._onEaseFrame = r, this._onEaseEnd = h, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
          }
          _normalizeBearing(r, h) {
            r = a.aO(r, -180, 180);
            const p = Math.abs(r - h);
            return Math.abs(r - 360 - h) < p && (r -= 360), Math.abs(r + 360 - h) < p && (r += 360), r;
          }
          queryTerrainElevation(r) {
            return this.terrain ? this.terrain.getElevationForLngLatZoom(a.S.convert(r), this.transform.tileZoom) : null;
          }
        }
        const Qh = { compact: !0, customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>' };
        class eu {
          constructor(r = Qh) {
            this._toggleAttribution = () => {
              this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
            }, this._updateData = (h) => {
              !h || h.sourceDataType !== "metadata" && h.sourceDataType !== "visibility" && h.dataType !== "style" && h.type !== "terrain" || this._updateAttributions();
            }, this._updateCompact = () => {
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === !1 ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
            }, this._updateCompactMinimize = () => {
              this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
            }, this.options = r;
          }
          getDefaultPosition() {
            return "bottom-right";
          }
          onAdd(r) {
            return this._map = r, this._compact = this.options.compact, this._container = L.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = L.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = L.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
          }
          onRemove() {
            L.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
          }
          _setElementTitle(r, h) {
            const p = this._map._getUIString(`AttributionControl.${h}`);
            r.title = p, r.setAttribute("aria-label", p);
          }
          _updateAttributions() {
            if (!this._map.style) return;
            let r = [];
            if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? r = r.concat(this.options.customAttribution.map(((g) => typeof g != "string" ? "" : g))) : typeof this.options.customAttribution == "string" && r.push(this.options.customAttribution)), this._map.style.stylesheet) {
              const g = this._map.style.stylesheet;
              this.styleOwner = g.owner, this.styleId = g.id;
            }
            const h = this._map.style.sourceCaches;
            for (const g in h) {
              const y = h[g];
              if (y.used || y.usedForTerrain) {
                const x = y.getSource();
                x.attribution && r.indexOf(x.attribution) < 0 && r.push(x.attribution);
              }
            }
            r = r.filter(((g) => String(g).trim())), r.sort(((g, y) => g.length - y.length)), r = r.filter(((g, y) => {
              for (let x = y + 1; x < r.length; x++) if (r[x].indexOf(g) >= 0) return !1;
              return !0;
            }));
            const p = r.join(" | ");
            p !== this._attribHTML && (this._attribHTML = p, r.length ? (this._innerContainer.innerHTML = L.sanitize(p), this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
          }
        }
        class Qd {
          constructor(r = {}) {
            this._updateCompact = () => {
              const h = this._container.children;
              if (h.length) {
                const p = h[0];
                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== !1 && p.classList.add("maplibregl-compact") : p.classList.remove("maplibregl-compact");
              }
            }, this.options = r;
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(r) {
            this._map = r, this._compact = this.options && this.options.compact, this._container = L.create("div", "maplibregl-ctrl");
            const h = L.create("a", "maplibregl-ctrl-logo");
            return h.target = "_blank", h.rel = "noopener nofollow", h.href = "https://maplibre.org/", h.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), h.setAttribute("rel", "noopener nofollow"), this._container.appendChild(h), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
          }
          onRemove() {
            L.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
          }
        }
        class an {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
          }
          add(r) {
            const h = ++this._id;
            return this._queue.push({ callback: r, id: h, cancelled: !1 }), h;
          }
          remove(r) {
            const h = this._currentlyRunning, p = h ? this._queue.concat(h) : this._queue;
            for (const g of p) if (g.id === r) return void (g.cancelled = !0);
          }
          run(r = 0) {
            if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
            const h = this._currentlyRunning = this._queue;
            this._queue = [];
            for (const p of h) if (!p.cancelled && (p.callback(r), this._cleared)) break;
            this._cleared = !1, this._currentlyRunning = !1;
          }
          clear() {
            this._currentlyRunning && (this._cleared = !0), this._queue = [];
          }
        }
        var cc = a.aJ([{ name: "a_pos3d", type: "Int16", components: 3 }]);
        class dt extends a.E {
          constructor(r) {
            super(), this._lastTilesetChange = N.now(), this.sourceCache = r, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.deltaZoom = 1, this.tileSize = r._source.tileSize * 2 ** this.deltaZoom, r.usedForTerrain = !0, r.tileSize = this.tileSize;
          }
          destruct() {
            this.sourceCache.usedForTerrain = !1, this.sourceCache.tileSize = null;
          }
          update(r, h) {
            this.sourceCache.update(r, h), this._renderableTilesKeys = [];
            const p = {};
            for (const g of ve(r, { tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: !1, terrain: h, calculateTileZoom: this.sourceCache._source.calculateTileZoom })) p[g.key] = !0, this._renderableTilesKeys.push(g.key), this._tiles[g.key] || (g.terrainRttPosMatrix32f = new Float64Array(16), a.bY(g.terrainRttPosMatrix32f, 0, a.$, a.$, 0, 0, 1), this._tiles[g.key] = new gn(g, this.tileSize), this._lastTilesetChange = N.now());
            for (const g in this._tiles) p[g] || delete this._tiles[g];
          }
          freeRtt(r) {
            for (const h in this._tiles) {
              const p = this._tiles[h];
              (!r || p.tileID.equals(r) || p.tileID.isChildOf(r) || r.isChildOf(p.tileID)) && (p.rtt = []);
            }
          }
          getRenderableTiles() {
            return this._renderableTilesKeys.map(((r) => this.getTileByID(r)));
          }
          getTileByID(r) {
            return this._tiles[r];
          }
          getTerrainCoords(r, h) {
            return h ? this._getTerrainCoordsForTileRanges(r, h) : this._getTerrainCoordsForRegularTile(r);
          }
          _getTerrainCoordsForRegularTile(r) {
            const h = {};
            for (const p of this._renderableTilesKeys) {
              const g = this._tiles[p].tileID, y = r.clone(), x = a.ba();
              if (g.canonical.equals(r.canonical)) a.bY(x, 0, a.$, a.$, 0, 0, 1);
              else if (g.canonical.isChildOf(r.canonical)) {
                const E = g.canonical.z - r.canonical.z, C = g.canonical.x - (g.canonical.x >> E << E), R = g.canonical.y - (g.canonical.y >> E << E), B = a.$ >> E;
                a.bY(x, 0, B, B, 0, 0, 1), a.M(x, x, [-C * B, -R * B, 0]);
              } else {
                if (!r.canonical.isChildOf(g.canonical)) continue;
                {
                  const E = r.canonical.z - g.canonical.z, C = r.canonical.x - (r.canonical.x >> E << E), R = r.canonical.y - (r.canonical.y >> E << E), B = a.$ >> E;
                  a.bY(x, 0, a.$, a.$, 0, 0, 1), a.M(x, x, [C * B, R * B, 0]), a.N(x, x, [1 / 2 ** E, 1 / 2 ** E, 0]);
                }
              }
              y.terrainRttPosMatrix32f = new Float32Array(x), h[p] = y;
            }
            return h;
          }
          _getTerrainCoordsForTileRanges(r, h) {
            const p = {};
            for (const g of this._renderableTilesKeys) {
              const y = this._tiles[g].tileID;
              if (!this._isWithinTileRanges(y, h)) continue;
              const x = r.clone(), E = a.ba();
              if (y.canonical.z === r.canonical.z) {
                const C = r.canonical.x - y.canonical.x, R = r.canonical.y - y.canonical.y;
                a.bY(E, 0, a.$, a.$, 0, 0, 1), a.M(E, E, [C * a.$, R * a.$, 0]);
              } else if (y.canonical.z > r.canonical.z) {
                const C = y.canonical.z - r.canonical.z, R = y.canonical.x - (y.canonical.x >> C << C), B = y.canonical.y - (y.canonical.y >> C << C), k = r.canonical.x - (y.canonical.x >> C), O = r.canonical.y - (y.canonical.y >> C), z = a.$ >> C;
                a.bY(E, 0, z, z, 0, 0, 1), a.M(E, E, [-R * z + k * a.$, -B * z + O * a.$, 0]);
              } else {
                const C = r.canonical.z - y.canonical.z, R = r.canonical.x - (r.canonical.x >> C << C), B = r.canonical.y - (r.canonical.y >> C << C), k = (r.canonical.x >> C) - y.canonical.x, O = (r.canonical.y >> C) - y.canonical.y, z = a.$ << C;
                a.bY(E, 0, z, z, 0, 0, 1), a.M(E, E, [R * a.$ + k * z, B * a.$ + O * z, 0]);
              }
              x.terrainRttPosMatrix32f = new Float32Array(E), p[g] = x;
            }
            return p;
          }
          getSourceTile(r, h) {
            const p = this.sourceCache._source;
            let g = r.overscaledZ - this.deltaZoom;
            if (g > p.maxzoom && (g = p.maxzoom), g < p.minzoom) return null;
            this._sourceTileCache[r.key] || (this._sourceTileCache[r.key] = r.scaledTo(g).key);
            let y = this.sourceCache.getTileByID(this._sourceTileCache[r.key]);
            if ((!y || !y.dem) && h) for (; g >= p.minzoom && (!y || !y.dem); ) y = this.sourceCache.getTileByID(r.scaledTo(g--).key);
            return y;
          }
          anyTilesAfterTime(r = Date.now()) {
            return this._lastTilesetChange >= r;
          }
          _isWithinTileRanges(r, h) {
            return h[r.canonical.z] && r.canonical.x >= h[r.canonical.z].minTileX && r.canonical.x <= h[r.canonical.z].maxTileX && r.canonical.y >= h[r.canonical.z].minTileY && r.canonical.y <= h[r.canonical.z].maxTileY;
          }
        }
        class yt {
          constructor(r, h, p) {
            this._meshCache = {}, this.painter = r, this.sourceCache = new dt(h), this.options = p, this.exaggeration = typeof p.exaggeration == "number" ? p.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
          }
          getDEMElevation(r, h, p, g = a.$) {
            var y;
            if (!(h >= 0 && h < g && p >= 0 && p < g)) return 0;
            const x = this.getTerrainData(r), E = (y = x.tile) === null || y === void 0 ? void 0 : y.dem;
            if (!E) return 0;
            const C = a.cs([], [h / g * a.$, p / g * a.$], x.u_terrain_matrix), R = [C[0] * E.dim, C[1] * E.dim], B = Math.floor(R[0]), k = Math.floor(R[1]), O = R[0] - B, z = R[1] - k;
            return E.get(B, k) * (1 - O) * (1 - z) + E.get(B + 1, k) * O * (1 - z) + E.get(B, k + 1) * (1 - O) * z + E.get(B + 1, k + 1) * O * z;
          }
          getElevationForLngLatZoom(r, h) {
            if (!a.ct(h, r.wrap())) return 0;
            const { tileID: p, mercatorX: g, mercatorY: y } = this._getOverscaledTileIDFromLngLatZoom(r, h);
            return this.getElevation(p, g % a.$, y % a.$, a.$);
          }
          getElevation(r, h, p, g = a.$) {
            return this.getDEMElevation(r, h, p, g) * this.exaggeration;
          }
          getTerrainData(r) {
            if (!this._emptyDemTexture) {
              const g = this.painter.context, y = new a.R({ width: 1, height: 1 }, new Uint8Array(4));
              this._emptyDepthTexture = new a.T(g, y, g.gl.RGBA, { premultiply: !1 }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new a.T(g, new a.R({ width: 1, height: 1 }), g.gl.RGBA, { premultiply: !1 }), this._emptyDemTexture.bind(g.gl.NEAREST, g.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = a.ag([]);
            }
            const h = this.sourceCache.getSourceTile(r, !0);
            if (h && h.dem && (!h.demTexture || h.needsTerrainPrepare)) {
              const g = this.painter.context;
              h.demTexture = this.painter.getTileTexture(h.dem.stride), h.demTexture ? h.demTexture.update(h.dem.getPixels(), { premultiply: !1 }) : h.demTexture = new a.T(g, h.dem.getPixels(), g.gl.RGBA, { premultiply: !1 }), h.demTexture.bind(g.gl.NEAREST, g.gl.CLAMP_TO_EDGE), h.needsTerrainPrepare = !1;
            }
            const p = h && h + h.tileID.key + r.key;
            if (p && !this._demMatrixCache[p]) {
              const g = this.sourceCache.sourceCache._source.maxzoom;
              let y = r.canonical.z - h.tileID.canonical.z;
              r.overscaledZ > r.canonical.z && (r.canonical.z >= g ? y = r.canonical.z - g : a.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
              const x = r.canonical.x - (r.canonical.x >> y << y), E = r.canonical.y - (r.canonical.y >> y << y), C = a.cu(new Float64Array(16), [1 / (a.$ << y), 1 / (a.$ << y), 0]);
              a.M(C, C, [x * a.$, E * a.$, 0]), this._demMatrixCache[r.key] = { matrix: C, coord: r };
            }
            return { u_depth: 2, u_terrain: 3, u_terrain_dim: h && h.dem && h.dem.dim || 1, u_terrain_matrix: p ? this._demMatrixCache[r.key].matrix : this._emptyDemMatrix, u_terrain_unpack: h && h.dem && h.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (h && h.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: h };
          }
          getFramebuffer(r) {
            const h = this.painter, p = h.width / devicePixelRatio, g = h.height / devicePixelRatio;
            return !this._fbo || this._fbo.width === p && this._fbo.height === g || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new a.T(h.context, { width: p, height: g, data: null }, h.context.gl.RGBA, { premultiply: !1 }), this._fboCoordsTexture.bind(h.context.gl.NEAREST, h.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new a.T(h.context, { width: p, height: g, data: null }, h.context.gl.RGBA, { premultiply: !1 }), this._fboDepthTexture.bind(h.context.gl.NEAREST, h.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = h.context.createFramebuffer(p, g, !0, !1), this._fbo.depthAttachment.set(h.context.createRenderbuffer(h.context.gl.DEPTH_COMPONENT16, p, g))), this._fbo.colorAttachment.set(r === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
          }
          getCoordsTexture() {
            const r = this.painter.context;
            if (this._coordsTexture) return this._coordsTexture;
            const h = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
            for (let y = 0, x = 0; y < this._coordsTextureSize; y++) for (let E = 0; E < this._coordsTextureSize; E++, x += 4) h[x + 0] = 255 & E, h[x + 1] = 255 & y, h[x + 2] = E >> 8 << 4 | y >> 8, h[x + 3] = 0;
            const p = new a.R({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(h.buffer)), g = new a.T(r, p, r.gl.RGBA, { premultiply: !1 });
            return g.bind(r.gl.NEAREST, r.gl.CLAMP_TO_EDGE), this._coordsTexture = g, g;
          }
          pointCoordinate(r) {
            this.painter.maybeDrawDepthAndCoords(!0);
            const h = new Uint8Array(4), p = this.painter.context, g = p.gl, y = Math.round(r.x * this.painter.pixelRatio / devicePixelRatio), x = Math.round(r.y * this.painter.pixelRatio / devicePixelRatio), E = Math.round(this.painter.height / devicePixelRatio);
            p.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), g.readPixels(y, E - x - 1, 1, 1, g.RGBA, g.UNSIGNED_BYTE, h), p.bindFramebuffer.set(null);
            const C = h[0] + (h[2] >> 4 << 8), R = h[1] + ((15 & h[2]) << 8), B = this.coordsIndex[255 - h[3]], k = B && this.sourceCache.getTileByID(B);
            if (!k) return null;
            const O = this._coordsTextureSize, z = (1 << k.tileID.canonical.z) * O;
            return new a.a1((k.tileID.canonical.x * O + C) / z + k.tileID.wrap, (k.tileID.canonical.y * O + R) / z, this.getElevation(k.tileID, C, R, O));
          }
          depthAtPoint(r) {
            const h = new Uint8Array(4), p = this.painter.context, g = p.gl;
            return p.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), g.readPixels(r.x, this.painter.height / devicePixelRatio - r.y - 1, 1, 1, g.RGBA, g.UNSIGNED_BYTE, h), p.bindFramebuffer.set(null), (h[0] / 16777216 + h[1] / 65536 + h[2] / 256 + h[3]) / 256;
          }
          getTerrainMesh(r) {
            var h;
            const p = ((h = this.painter.style.projection) === null || h === void 0 ? void 0 : h.transitionState) > 0, g = p && r.canonical.y === 0, y = p && r.canonical.y === (1 << r.canonical.z) - 1, x = `m_${g ? "n" : ""}_${y ? "s" : ""}`;
            if (this._meshCache[x]) return this._meshCache[x];
            const E = this.painter.context, C = new a.cv(), R = new a.aN(), B = this.meshSize, k = a.$ / B, O = B * B;
            for (let oe = 0; oe <= B; oe++) for (let be = 0; be <= B; be++) C.emplaceBack(be * k, oe * k, 0);
            for (let oe = 0; oe < O; oe += B + 1) for (let be = 0; be < B; be++) R.emplaceBack(be + oe, B + be + oe + 1, B + be + oe + 2), R.emplaceBack(be + oe, B + be + oe + 2, be + oe + 1);
            const z = C.length, H = z + (B + 1), Y = (B + 1) * B, K = g ? a.bh : 0, J = g ? 0 : 1, ie = y ? a.bi : a.$, le = y ? 0 : 1;
            for (let oe = 0; oe <= B; oe++) C.emplaceBack(oe * k, K, J);
            for (let oe = 0; oe <= B; oe++) C.emplaceBack(oe * k, ie, le);
            for (let oe = 0; oe < B; oe++) R.emplaceBack(Y + oe, H + oe, H + oe + 1), R.emplaceBack(Y + oe, H + oe + 1, Y + oe + 1), R.emplaceBack(0 + oe, z + oe + 1, z + oe), R.emplaceBack(0 + oe, 0 + oe + 1, z + oe + 1);
            const se = C.length, he = se + 2 * (B + 1);
            for (const oe of [0, 1]) for (let be = 0; be <= B; be++) for (const Fe of [0, 1]) C.emplaceBack(oe * a.$, be * k, Fe);
            for (let oe = 0; oe < 2 * B; oe += 2) R.emplaceBack(se + oe, se + oe + 1, se + oe + 3), R.emplaceBack(se + oe, se + oe + 3, se + oe + 2), R.emplaceBack(he + oe, he + oe + 3, he + oe + 1), R.emplaceBack(he + oe, he + oe + 2, he + oe + 3);
            const fe = new $e(E.createVertexBuffer(C, cc.members), E.createIndexBuffer(R), a.aM.simpleSegment(0, 0, C.length, R.length));
            return this._meshCache[x] = fe, fe;
          }
          getMeshFrameDelta(r) {
            return 2 * Math.PI * a.bu / Math.pow(2, Math.max(r, 0)) / 5;
          }
          getMinTileElevationForLngLatZoom(r, h) {
            var p;
            const { tileID: g } = this._getOverscaledTileIDFromLngLatZoom(r, h);
            return (p = this.getMinMaxElevation(g).minElevation) !== null && p !== void 0 ? p : 0;
          }
          getMinMaxElevation(r) {
            const h = this.getTerrainData(r).tile, p = { minElevation: null, maxElevation: null };
            return h && h.dem && (p.minElevation = h.dem.min * this.exaggeration, p.maxElevation = h.dem.max * this.exaggeration), p;
          }
          _getOverscaledTileIDFromLngLatZoom(r, h) {
            const p = a.a1.fromLngLat(r.wrap()), g = (1 << h) * a.$, y = p.x * g, x = p.y * g, E = Math.floor(y / a.$), C = Math.floor(x / a.$);
            return { tileID: new a.Z(h, 0, h, E, C), mercatorX: y, mercatorY: x };
          }
        }
        class hc {
          constructor(r, h, p) {
            this._context = r, this._size = h, this._tileSize = p, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
          }
          destruct() {
            for (const r of this._objects) r.texture.destroy(), r.fbo.destroy();
          }
          _createObject(r) {
            const h = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0), p = new a.T(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
            return p.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax), h.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), h.colorAttachment.set(p.texture), { id: r, fbo: h, texture: p, stamp: -1, inUse: !1 };
          }
          getObjectForId(r) {
            return this._objects[r];
          }
          useObject(r) {
            r.inUse = !0, this._recentlyUsed = this._recentlyUsed.filter(((h) => r.id !== h)), this._recentlyUsed.push(r.id);
          }
          stampObject(r) {
            r.stamp = ++this._stamp;
          }
          getOrCreateFreeObject() {
            for (const h of this._recentlyUsed) if (!this._objects[h].inUse) return this._objects[h];
            if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
            const r = this._createObject(this._objects.length);
            return this._objects.push(r), r;
          }
          freeObject(r) {
            r.inUse = !1;
          }
          freeAllObjects() {
            for (const r of this._objects) this.freeObject(r);
          }
          isFull() {
            return !(this._objects.length < this._size) && this._objects.some(((r) => !r.inUse)) === !1;
          }
        }
        const Gn = { background: !0, fill: !0, line: !0, raster: !0, hillshade: !0, "color-relief": !0 };
        class uc {
          constructor(r, h) {
            this.painter = r, this.terrain = h, this.pool = new hc(r.context, 30, h.sourceCache.tileSize * h.qualityFactor);
          }
          destruct() {
            this.pool.destruct();
          }
          getTexture(r) {
            return this.pool.getObjectForId(r.rtt[this._stacks.length - 1].id).texture;
          }
          prepareForRender(r, h) {
            this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = r._order.filter(((p) => !r._layers[p].isHidden(h))), this._coordsAscending = {};
            for (const p in r.sourceCaches) {
              this._coordsAscending[p] = {};
              const g = r.sourceCaches[p].getVisibleCoordinates(), y = r.sourceCaches[p].getSource(), x = y instanceof ts ? y.terrainTileRanges : null;
              for (const E of g) {
                const C = this.terrain.sourceCache.getTerrainCoords(E, x);
                for (const R in C) this._coordsAscending[p][R] || (this._coordsAscending[p][R] = []), this._coordsAscending[p][R].push(C[R]);
              }
            }
            this._coordsAscendingStr = {};
            for (const p of r._order) {
              const g = r._layers[p], y = g.source;
              if (Gn[g.type] && !this._coordsAscendingStr[y]) {
                this._coordsAscendingStr[y] = {};
                for (const x in this._coordsAscending[y]) this._coordsAscendingStr[y][x] = this._coordsAscending[y][x].map(((E) => E.key)).sort().join();
              }
            }
            for (const p of this._renderableTiles) for (const g in this._coordsAscendingStr) {
              const y = this._coordsAscendingStr[g][p.tileID.key];
              y && y !== p.rttCoords[g] && (p.rtt = []);
            }
          }
          renderLayer(r, h) {
            if (r.isHidden(this.painter.transform.zoom)) return !1;
            const p = Object.assign(Object.assign({}, h), { isRenderingToTexture: !0 }), g = r.type, y = this.painter, x = this._renderableLayerIds[this._renderableLayerIds.length - 1] === r.id;
            if (Gn[g] && (this._prevType && Gn[this._prevType] || this._stacks.push([]), this._prevType = g, this._stacks[this._stacks.length - 1].push(r.id), !x)) return !0;
            if (Gn[this._prevType] || Gn[g] && x) {
              this._prevType = g;
              const E = this._stacks.length - 1, C = this._stacks[E] || [];
              for (const R of this._renderableTiles) {
                if (this.pool.isFull() && (rc(this.painter, this.terrain, this._rttTiles, p), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(R), R.rtt[E]) {
                  const k = this.pool.getObjectForId(R.rtt[E].id);
                  if (k.stamp === R.rtt[E].stamp) {
                    this.pool.useObject(k);
                    continue;
                  }
                }
                const B = this.pool.getOrCreateFreeObject();
                this.pool.useObject(B), this.pool.stampObject(B), R.rtt[E] = { id: B.id, stamp: B.stamp }, y.context.bindFramebuffer.set(B.fbo.framebuffer), y.context.clear({ color: a.bf.transparent, stencil: 0 }), y.currentStencilSource = void 0;
                for (let k = 0; k < C.length; k++) {
                  const O = y.style._layers[C[k]], z = O.source ? this._coordsAscending[O.source][R.tileID.key] : [R.tileID];
                  y.context.viewport.set([0, 0, B.fbo.width, B.fbo.height]), y._renderTileClippingMasks(O, z, !0), y.renderLayer(y, y.style.sourceCaches[O.source], O, z, p), O.source && (R.rttCoords[O.source] = this._coordsAscendingStr[O.source][R.tileID.key]);
                }
              }
              return rc(this.painter, this.terrain, this._rttTiles, p), this._rttTiles = [], this.pool.freeAllObjects(), Gn[g];
            }
            return !1;
          }
        }
        const zr = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "MapLibre logo", "Map.Title": "Map", "Marker.Title": "Map marker", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "Popup.Close": "Close popup", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "GlobeControl.Enable": "Enable globe", "GlobeControl.Disable": "Disable globe", "TerrainControl.Enable": "Enable terrain", "TerrainControl.Disable": "Disable terrain", "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map", "CooperativeGesturesHandler.MacHelpText": "Use ⌘ + scroll to zoom the map", "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map" }, ef = w, _s = { hash: !1, interactive: !0, bearingSnap: 7, attributionControl: Qh, maplibreLogo: !1, refreshExpiredTiles: !0, canvasContextAttributes: { antialias: !1, preserveDrawingBuffer: !1, powerPreference: "high-performance", failIfMajorPerformanceCaveat: !1, desynchronized: !1, contextType: void 0 }, scrollZoom: !0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, boxZoom: !0, dragRotate: !0, dragPan: !0, keyboard: !0, doubleClickZoom: !0, touchZoomRotate: !0, touchPitch: !0, cooperativeGestures: !1, trackResize: !0, center: [0, 0], elevation: 0, zoom: 0, bearing: 0, pitch: 0, roll: 0, renderWorldCopies: !0, maxTileCacheSize: null, maxTileCacheZoomLevels: a.a.MAX_TILE_CACHE_ZOOM_LEVELS, transformRequest: null, transformCameraUpdate: null, fadeDuration: 300, crossSourceCollisions: !0, clickTolerance: 3, localIdeographFontFamily: "sans-serif", pitchWithRotate: !0, rollEnabled: !1, validateStyle: !0, maxCanvasSize: [4096, 4096], cancelPendingTileRequestsWhileZooming: !0, centerClampedToGround: !0 }, p_ = { showCompass: !0, showZoom: !0, visualizePitch: !1, visualizeRoll: !0 };
        class ol {
          constructor(r, h, p = !1) {
            this.mousedown = (y) => {
              this.startMove(y, L.mousePos(this.element, y)), L.addEventListener(window, "mousemove", this.mousemove), L.addEventListener(window, "mouseup", this.mouseup);
            }, this.mousemove = (y) => {
              this.move(y, L.mousePos(this.element, y));
            }, this.mouseup = (y) => {
              this._rotatePitchHandler.dragEnd(y), this.offTemp();
            }, this.touchstart = (y) => {
              y.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = L.touchPos(this.element, y.targetTouches)[0], this.startMove(y, this._startPos), L.addEventListener(window, "touchmove", this.touchmove, { passive: !1 }), L.addEventListener(window, "touchend", this.touchend));
            }, this.touchmove = (y) => {
              y.targetTouches.length !== 1 ? this.reset() : (this._lastPos = L.touchPos(this.element, y.targetTouches)[0], this.move(y, this._lastPos));
            }, this.touchend = (y) => {
              y.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this.reset = () => {
              this._rotatePitchHandler.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this._clickTolerance = 10, this.element = h;
            const g = new u_();
            this._rotatePitchHandler = new Jo({ clickTolerance: 3, move: (y, x) => {
              const E = h.getBoundingClientRect(), C = new a.P((E.bottom - E.top) / 2, (E.right - E.left) / 2);
              return { bearingDelta: a.cn(new a.P(y.x, x.y), x, C), pitchDelta: p ? -0.5 * (x.y - y.y) : void 0 };
            }, moveStateManager: g, enable: !0, assignEvents: () => {
            } }), this.map = r, L.addEventListener(h, "mousedown", this.mousedown), L.addEventListener(h, "touchstart", this.touchstart, { passive: !1 }), L.addEventListener(h, "touchcancel", this.reset);
          }
          startMove(r, h) {
            this._rotatePitchHandler.dragStart(r, h), L.disableDrag();
          }
          move(r, h) {
            const p = this.map, { bearingDelta: g, pitchDelta: y } = this._rotatePitchHandler.dragMove(r, h) || {};
            g && p.setBearing(p.getBearing() + g), y && p.setPitch(p.getPitch() + y);
          }
          off() {
            const r = this.element;
            L.removeEventListener(r, "mousedown", this.mousedown), L.removeEventListener(r, "touchstart", this.touchstart, { passive: !1 }), L.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), L.removeEventListener(window, "touchend", this.touchend), L.removeEventListener(r, "touchcancel", this.reset), this.offTemp();
          }
          offTemp() {
            L.enableDrag(), L.removeEventListener(window, "mousemove", this.mousemove), L.removeEventListener(window, "mouseup", this.mouseup), L.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), L.removeEventListener(window, "touchend", this.touchend);
          }
        }
        let ei;
        function Di(m, r, h, p = !1) {
          if (p || !h.getCoveringTilesDetailsProvider().allowWorldCopies()) return m?.wrap();
          const g = new a.S(m.lng, m.lat);
          if (m = new a.S(m.lng, m.lat), r) {
            const y = new a.S(m.lng - 360, m.lat), x = new a.S(m.lng + 360, m.lat), E = h.locationToScreenPoint(m).distSqr(r);
            h.locationToScreenPoint(y).distSqr(r) < E ? m = y : h.locationToScreenPoint(x).distSqr(r) < E && (m = x);
          }
          for (; Math.abs(m.lng - h.center.lng) > 180; ) {
            const y = h.locationToScreenPoint(m);
            if (y.x >= 0 && y.y >= 0 && y.x <= h.width && y.y <= h.height) break;
            m.lng > h.center.lng ? m.lng -= 360 : m.lng += 360;
          }
          return m.lng !== g.lng && h.isPointOnMapSurface(h.locationToScreenPoint(m)) ? m : g;
        }
        const dc = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
        function ia(m, r, h) {
          const p = m.classList;
          for (const g in dc) p.remove(`maplibregl-${h}-anchor-${g}`);
          p.add(`maplibregl-${h}-anchor-${r}`);
        }
        class ra extends a.E {
          constructor(r) {
            if (super(), this._onKeyPress = (h) => {
              const p = h.code, g = h.charCode || h.keyCode;
              p !== "Space" && p !== "Enter" && g !== 32 && g !== 13 || this.togglePopup();
            }, this._onMapClick = (h) => {
              const p = h.originalEvent.target, g = this._element;
              this._popup && (p === g || g.contains(p)) && this.togglePopup();
            }, this._update = (h) => {
              if (!this._map) return;
              const p = this._map.loaded() && !this._map.isMoving();
              (h?.type === "terrain" || h?.type === "render" && !p) && this._map.once("render", this._update), this._lngLat = Di(this._lngLat, this._flatPos, this._map.transform), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
              let g = "";
              this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? g = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (g = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
              let y = "";
              this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? y = "rotateX(0deg)" : this._pitchAlignment === "map" && (y = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || h && h.type !== "moveend" || (this._pos = this._pos.round()), L.setTransform(this._element, `${dc[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${y} ${g}`), N.frameAsync(new AbortController()).then((() => {
                this._updateOpacity(h && h.type === "moveend");
              })).catch((() => {
              }));
            }, this._onMove = (h) => {
              if (!this._isDragging) {
                const p = this._clickTolerance || this._map._clickTolerance;
                this._isDragging = h.point.dist(this._pointerdownPos) >= p;
              }
              this._isDragging && (this._pos = h.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new a.l("dragstart"))), this.fire(new a.l("drag")));
            }, this._onUp = () => {
              this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new a.l("dragend")), this._state = "inactive";
            }, this._addDragHandler = (h) => {
              this._element.contains(h.originalEvent.target) && (h.preventDefault(), this._positionDelta = h.point.sub(this._pos).add(this._offset), this._pointerdownPos = h.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
            }, this._anchor = r && r.anchor || "center", this._color = r && r.color || "#3FB1CE", this._scale = r && r.scale || 1, this._draggable = r && r.draggable || !1, this._clickTolerance = r && r.clickTolerance || 0, this._subpixelPositioning = r && r.subpixelPositioning || !1, this._isDragging = !1, this._state = "inactive", this._rotation = r && r.rotation || 0, this._rotationAlignment = r && r.rotationAlignment || "auto", this._pitchAlignment = r && r.pitchAlignment && r.pitchAlignment !== "auto" ? r.pitchAlignment : this._rotationAlignment, this.setOpacity(r?.opacity, r?.opacityWhenCovered), r && r.element) this._element = r.element, this._offset = a.P.convert(r && r.offset || [0, 0]);
            else {
              this._defaultMarker = !0, this._element = L.create("div");
              const h = L.createNS("http://www.w3.org/2000/svg", "svg"), p = 41, g = 27;
              h.setAttributeNS(null, "display", "block"), h.setAttributeNS(null, "height", `${p}px`), h.setAttributeNS(null, "width", `${g}px`), h.setAttributeNS(null, "viewBox", `0 0 ${g} ${p}`);
              const y = L.createNS("http://www.w3.org/2000/svg", "g");
              y.setAttributeNS(null, "stroke", "none"), y.setAttributeNS(null, "stroke-width", "1"), y.setAttributeNS(null, "fill", "none"), y.setAttributeNS(null, "fill-rule", "evenodd");
              const x = L.createNS("http://www.w3.org/2000/svg", "g");
              x.setAttributeNS(null, "fill-rule", "nonzero");
              const E = L.createNS("http://www.w3.org/2000/svg", "g");
              E.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), E.setAttributeNS(null, "fill", "#000000");
              const C = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
              for (const J of C) {
                const ie = L.createNS("http://www.w3.org/2000/svg", "ellipse");
                ie.setAttributeNS(null, "opacity", "0.04"), ie.setAttributeNS(null, "cx", "10.5"), ie.setAttributeNS(null, "cy", "5.80029008"), ie.setAttributeNS(null, "rx", J.rx), ie.setAttributeNS(null, "ry", J.ry), E.appendChild(ie);
              }
              const R = L.createNS("http://www.w3.org/2000/svg", "g");
              R.setAttributeNS(null, "fill", this._color);
              const B = L.createNS("http://www.w3.org/2000/svg", "path");
              B.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), R.appendChild(B);
              const k = L.createNS("http://www.w3.org/2000/svg", "g");
              k.setAttributeNS(null, "opacity", "0.25"), k.setAttributeNS(null, "fill", "#000000");
              const O = L.createNS("http://www.w3.org/2000/svg", "path");
              O.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), k.appendChild(O);
              const z = L.createNS("http://www.w3.org/2000/svg", "g");
              z.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), z.setAttributeNS(null, "fill", "#FFFFFF");
              const H = L.createNS("http://www.w3.org/2000/svg", "g");
              H.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
              const Y = L.createNS("http://www.w3.org/2000/svg", "circle");
              Y.setAttributeNS(null, "fill", "#000000"), Y.setAttributeNS(null, "opacity", "0.25"), Y.setAttributeNS(null, "cx", "5.5"), Y.setAttributeNS(null, "cy", "5.5"), Y.setAttributeNS(null, "r", "5.4999962");
              const K = L.createNS("http://www.w3.org/2000/svg", "circle");
              K.setAttributeNS(null, "fill", "#FFFFFF"), K.setAttributeNS(null, "cx", "5.5"), K.setAttributeNS(null, "cy", "5.5"), K.setAttributeNS(null, "r", "5.4999962"), H.appendChild(Y), H.appendChild(K), x.appendChild(E), x.appendChild(R), x.appendChild(k), x.appendChild(z), x.appendChild(H), h.appendChild(x), h.setAttributeNS(null, "height", p * this._scale + "px"), h.setAttributeNS(null, "width", g * this._scale + "px"), this._element.appendChild(h), this._offset = a.P.convert(r && r.offset || [0, -14]);
            }
            if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", ((h) => {
              h.preventDefault();
            })), this._element.addEventListener("mousedown", ((h) => {
              h.preventDefault();
            })), ia(this._element, this._anchor, "marker"), r && r.className) for (const h of r.className.split(" ")) this._element.classList.add(h);
            this._popup = null;
          }
          addTo(r) {
            return this.remove(), this._map = r, this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", r._getUIString("Marker.Title")), r.getCanvasContainer().appendChild(this._element), r.on("move", this._update), r.on("moveend", this._update), r.on("terrain", this._update), r.on("projectiontransition", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
          }
          remove() {
            return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("projectiontransition", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), L.remove(this._element), this._popup && this._popup.remove(), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(r) {
            return this._lngLat = a.S.convert(r), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
          }
          getElement() {
            return this._element;
          }
          setPopup(r) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), r) {
              if (!("offset" in r.options)) {
                const g = Math.abs(13.5) / Math.SQRT2;
                r.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [g, -1 * (38.1 - 13.5 + g)], "bottom-right": [-g, -1 * (38.1 - 13.5 + g)], left: [13.5, -1 * (38.1 - 13.5)], right: [-13.5, -1 * (38.1 - 13.5)] } : this._offset;
              }
              this._popup = r, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
            }
            return this;
          }
          setSubpixelPositioning(r) {
            return this._subpixelPositioning = r, this;
          }
          getPopup() {
            return this._popup;
          }
          togglePopup() {
            const r = this._popup;
            return this._element.style.opacity === this._opacityWhenCovered ? this : r ? (r.isOpen() ? r.remove() : (r.setLngLat(this._lngLat), r.addTo(this._map)), this) : this;
          }
          _updateOpacity(r = !1) {
            var h, p;
            const g = (h = this._map) === null || h === void 0 ? void 0 : h.terrain, y = this._map.transform.isLocationOccluded(this._lngLat);
            if (!g || y) {
              const z = y ? this._opacityWhenCovered : this._opacity;
              return void (this._element.style.opacity !== z && (this._element.style.opacity = z));
            }
            if (r) this._opacityTimeout = null;
            else {
              if (this._opacityTimeout) return;
              this._opacityTimeout = setTimeout((() => {
                this._opacityTimeout = null;
              }), 100);
            }
            const x = this._map, E = x.terrain.depthAtPoint(this._pos), C = x.terrain.getElevationForLngLatZoom(this._lngLat, x.transform.tileZoom);
            if (x.transform.lngLatToCameraDepth(this._lngLat, C) - E < 6e-3) return void (this._element.style.opacity = this._opacity);
            const R = -this._offset.y / x.transform.pixelsPerMeter, B = Math.sin(x.getPitch() * Math.PI / 180) * R, k = x.terrain.depthAtPoint(new a.P(this._pos.x, this._pos.y - this._offset.y)), O = x.transform.lngLatToCameraDepth(this._lngLat, C + B) - k > 6e-3;
            !((p = this._popup) === null || p === void 0) && p.isOpen() && O && this._popup.remove(), this._element.style.opacity = O ? this._opacityWhenCovered : this._opacity;
          }
          getOffset() {
            return this._offset;
          }
          setOffset(r) {
            return this._offset = a.P.convert(r), this._update(), this;
          }
          addClassName(r) {
            this._element.classList.add(r);
          }
          removeClassName(r) {
            this._element.classList.remove(r);
          }
          toggleClassName(r) {
            return this._element.classList.toggle(r);
          }
          setDraggable(r) {
            return this._draggable = !!r, this._map && (r ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
          }
          isDraggable() {
            return this._draggable;
          }
          setRotation(r) {
            return this._rotation = r || 0, this._update(), this;
          }
          getRotation() {
            return this._rotation;
          }
          setRotationAlignment(r) {
            return this._rotationAlignment = r || "auto", this._update(), this;
          }
          getRotationAlignment() {
            return this._rotationAlignment;
          }
          setPitchAlignment(r) {
            return this._pitchAlignment = r && r !== "auto" ? r : this._rotationAlignment, this._update(), this;
          }
          getPitchAlignment() {
            return this._pitchAlignment;
          }
          setOpacity(r, h) {
            return (this._opacity === void 0 || r === void 0 && h === void 0) && (this._opacity = "1", this._opacityWhenCovered = "0.2"), r !== void 0 && (this._opacity = r), h !== void 0 && (this._opacityWhenCovered = h), this._map && this._updateOpacity(!0), this;
          }
        }
        const tu = { positionOptions: { enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: !1, showAccuracyCircle: !0, showUserLocation: !0 };
        let sa = 0, Ao = !1;
        const al = { maxWidth: 100, unit: "metric" };
        function fc(m, r, h) {
          const p = h && h.maxWidth || 100, g = m._container.clientHeight / 2, y = m._container.clientWidth / 2, x = m.unproject([y - p / 2, g]), E = m.unproject([y + p / 2, g]), C = Math.round(m.project(E).x - m.project(x).x), R = Math.min(p, C, m._container.clientWidth), B = x.distanceTo(E);
          if (h && h.unit === "imperial") {
            const k = 3.2808 * B;
            k > 5280 ? Eo(r, R, k / 5280, m._getUIString("ScaleControl.Miles")) : Eo(r, R, k, m._getUIString("ScaleControl.Feet"));
          } else h && h.unit === "nautical" ? Eo(r, R, B / 1852, m._getUIString("ScaleControl.NauticalMiles")) : B >= 1e3 ? Eo(r, R, B / 1e3, m._getUIString("ScaleControl.Kilometers")) : Eo(r, R, B, m._getUIString("ScaleControl.Meters"));
        }
        function Eo(m, r, h, p) {
          const g = (function(y) {
            const x = Math.pow(10, `${Math.floor(y)}`.length - 1);
            let E = y / x;
            return E = E >= 10 ? 10 : E >= 5 ? 5 : E >= 3 ? 3 : E >= 2 ? 2 : E >= 1 ? 1 : (function(C) {
              const R = Math.pow(10, Math.ceil(-Math.log(C) / Math.LN10));
              return Math.round(C * R) / R;
            })(E), x * E;
          })(h);
          m.style.width = r * (g / h) + "px", m.innerHTML = `${g}&nbsp;${p}`;
        }
        const iu = { closeButton: !0, closeOnClick: !0, focusAfterOpen: !0, className: "", maxWidth: "240px", subpixelPositioning: !1, locationOccludedOpacity: void 0 }, ru = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
        function pc(m) {
          if (m) {
            if (typeof m == "number") {
              const r = Math.round(Math.abs(m) / Math.SQRT2);
              return { center: new a.P(0, 0), top: new a.P(0, m), "top-left": new a.P(r, r), "top-right": new a.P(-r, r), bottom: new a.P(0, -m), "bottom-left": new a.P(r, -r), "bottom-right": new a.P(-r, -r), left: new a.P(m, 0), right: new a.P(-m, 0) };
            }
            if (m instanceof a.P || Array.isArray(m)) {
              const r = a.P.convert(m);
              return { center: r, top: r, "top-left": r, "top-right": r, bottom: r, "bottom-left": r, "bottom-right": r, left: r, right: r };
            }
            return { center: a.P.convert(m.center || [0, 0]), top: a.P.convert(m.top || [0, 0]), "top-left": a.P.convert(m["top-left"] || [0, 0]), "top-right": a.P.convert(m["top-right"] || [0, 0]), bottom: a.P.convert(m.bottom || [0, 0]), "bottom-left": a.P.convert(m["bottom-left"] || [0, 0]), "bottom-right": a.P.convert(m["bottom-right"] || [0, 0]), left: a.P.convert(m.left || [0, 0]), right: a.P.convert(m.right || [0, 0]) };
          }
          return pc(new a.P(0, 0));
        }
        const su = w;
        d.AJAXError = a.cz, d.Event = a.l, d.Evented = a.E, d.LngLat = a.S, d.MercatorCoordinate = a.a1, d.Point = a.P, d.addProtocol = a.cA, d.config = a.a, d.removeProtocol = a.cB, d.AttributionControl = eu, d.BoxZoomHandler = Wh, d.CanvasSource = Ni, d.CooperativeGesturesHandler = Yd, d.DoubleClickZoomHandler = Zh, d.DragPanHandler = Zd, d.DragRotateHandler = Yh, d.EdgeInsets = Ai, d.FullscreenControl = class extends a.E {
          constructor(m = {}) {
            super(), this._onFullscreenChange = () => {
              var r;
              let h = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
              for (; !((r = h?.shadowRoot) === null || r === void 0) && r.fullscreenElement; ) h = h.shadowRoot.fullscreenElement;
              h === this._container !== this._fullscreen && this._handleFullscreenChange();
            }, this._onClickFullscreen = () => {
              this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
            }, this._fullscreen = !1, m && m.container && (m.container instanceof HTMLElement ? this._container = m.container : a.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
          }
          onAdd(m) {
            return this._map = m, this._container || (this._container = this._map.getContainer()), this._controlContainer = L.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
          }
          onRemove() {
            L.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _setupUI() {
            const m = this._fullscreenButton = L.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
            L.create("span", "maplibregl-ctrl-icon", m).setAttribute("aria-hidden", "true"), m.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _updateTitle() {
            const m = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", m), this._fullscreenButton.title = m;
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
          }
          _isFullscreen() {
            return this._fullscreen;
          }
          _handleFullscreenChange() {
            this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new a.l("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new a.l("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
          }
          _exitFullscreen() {
            window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
          }
          _requestFullscreen() {
            this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
          }
          _togglePseudoFullScreen() {
            this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
          }
        }, d.GeoJSONSource = es, d.GeolocateControl = class extends a.E {
          constructor(m) {
            super(), this._onSuccess = (r) => {
              if (this._map) {
                if (this._isOutOfMapMaxBounds(r)) return this._setErrorState(), this.fire(new a.l("outofmaxbounds", r)), this._updateMarker(), void this._finish();
                if (this.options.trackUserLocation) switch (this._lastKnownPosition = r, this._watchState) {
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                    break;
                  case "BACKGROUND":
                  case "BACKGROUND_ERROR":
                    this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                    break;
                  default:
                    throw new Error(`Unexpected watchState ${this._watchState}`);
                }
                this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(r), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(r), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new a.l("geolocate", r)), this._finish();
              }
            }, this._updateCamera = (r) => {
              const h = new a.S(r.coords.longitude, r.coords.latitude), p = r.coords.accuracy, g = this._map.getBearing(), y = a.e({ bearing: g }, this.options.fitBoundsOptions), x = ni.fromLngLat(h, p);
              this._map.fitBounds(x, y, { geolocateSource: !0 });
            }, this._updateMarker = (r) => {
              if (r) {
                const h = new a.S(r.coords.longitude, r.coords.latitude);
                this._accuracyCircleMarker.setLngLat(h).addTo(this._map), this._userLocationDotMarker.setLngLat(h).addTo(this._map), this._accuracy = r.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
              } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
            }, this._onZoom = () => {
              this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            }, this._onError = (r) => {
              if (this._map) {
                if (r.code === 1) {
                  this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                  const h = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.title = h, this._geolocateButton.setAttribute("aria-label", h), this._geolocationWatchID !== void 0 && this._clearWatch();
                } else {
                  if (r.code === 3 && Ao) return;
                  this.options.trackUserLocation && this._setErrorState();
                }
                this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new a.l("error", r)), this._finish();
              }
            }, this._finish = () => {
              this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
            }, this._setupUI = () => {
              this._map && (this._container.addEventListener("contextmenu", ((r) => r.preventDefault())), this._geolocateButton = L.create("button", "maplibregl-ctrl-geolocate", this._container), L.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = !0);
            }, this._finishSetupUI = (r) => {
              if (this._map) {
                if (r === !1) {
                  a.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                  const h = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.disabled = !0, this._geolocateButton.title = h, this._geolocateButton.setAttribute("aria-label", h);
                } else {
                  const h = this._map._getUIString("GeolocateControl.FindMyLocation");
                  this._geolocateButton.disabled = !1, this._geolocateButton.title = h, this._geolocateButton.setAttribute("aria-label", h);
                }
                this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = L.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new ra({ element: this._dotElement }), this._circleElement = L.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new ra({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", (() => this.trigger())), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", ((h) => {
                  const p = h?.[0] instanceof ResizeObserverEntry;
                  h.geolocateSource || this._watchState !== "ACTIVE_LOCK" || p || this._map.isZooming() || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new a.l("trackuserlocationend")), this.fire(new a.l("userlocationlostfocus")));
                }));
              }
            }, this.options = a.e({}, tu, m);
          }
          onAdd(m) {
            return this._map = m, this._container = L.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), (function() {
              return a._(this, arguments, void 0, (function* (r = !1) {
                if (ei !== void 0 && !r) return ei;
                if (window.navigator.permissions === void 0) return ei = !!window.navigator.geolocation, ei;
                try {
                  ei = (yield window.navigator.permissions.query({ name: "geolocation" })).state !== "denied";
                } catch {
                  ei = !!window.navigator.geolocation;
                }
                return ei;
              }));
            })().then(((r) => this._finishSetupUI(r))), this._container;
          }
          onRemove() {
            this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), L.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, sa = 0, Ao = !1;
          }
          _isOutOfMapMaxBounds(m) {
            const r = this._map.getMaxBounds(), h = m.coords;
            return r && (h.longitude < r.getWest() || h.longitude > r.getEast() || h.latitude < r.getSouth() || h.latitude > r.getNorth());
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "ACTIVE_ERROR":
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
          }
          _updateCircleRadius() {
            const m = this._map.getBounds(), r = m.getSouthEast(), h = m.getNorthEast(), p = r.distanceTo(h), g = Math.ceil(this._accuracy / (p / this._map._container.clientHeight) * 2);
            this._circleElement.style.width = `${g}px`, this._circleElement.style.height = `${g}px`;
          }
          trigger() {
            if (!this._setup) return a.w("Geolocate control triggered before added to a map"), !1;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new a.l("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  sa--, Ao = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new a.l("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new a.l("trackuserlocationstart")), this.fire(new a.l("userlocationfocus"));
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "OFF":
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
              else if (this._geolocationWatchID === void 0) {
                let m;
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), sa++, sa > 1 ? (m = { maximumAge: 6e5, timeout: 0 }, Ao = !0) : (m = this.options.positionOptions, Ao = !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, m);
              }
            } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return !0;
          }
          _clearWatch() {
            window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
          }
        }, d.GlobeControl = class {
          constructor() {
            this._toggleProjection = () => {
              var m;
              const r = (m = this._map.getProjection()) === null || m === void 0 ? void 0 : m.type;
              this._map.setProjection(r !== "mercator" && r ? { type: "mercator" } : { type: "globe" }), this._updateGlobeIcon();
            }, this._updateGlobeIcon = () => {
              var m;
              this._globeButton.classList.remove("maplibregl-ctrl-globe"), this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"), ((m = this._map.getProjection()) === null || m === void 0 ? void 0 : m.type) === "globe" ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"), this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"), this._globeButton.title = this._map._getUIString("GlobeControl.Enable"));
            };
          }
          onAdd(m) {
            return this._map = m, this._container = L.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._globeButton = L.create("button", "maplibregl-ctrl-globe", this._container), L.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"), this._globeButton.type = "button", this._globeButton.addEventListener("click", this._toggleProjection), this._updateGlobeIcon(), this._map.on("styledata", this._updateGlobeIcon), this._container;
          }
          onRemove() {
            L.remove(this._container), this._map.off("styledata", this._updateGlobeIcon), this._globeButton.removeEventListener("click", this._toggleProjection), this._map = void 0;
          }
        }, d.Hash = sc, d.ImageSource = ts, d.KeyboardHandler = ac, d.LngLatBounds = ni, d.LogoControl = Qd, d.Map = class extends Jd {
          constructor(m) {
            var r, h;
            a.cw.mark(a.cx.create);
            const p = Object.assign(Object.assign(Object.assign({}, _s), m), { canvasContextAttributes: Object.assign(Object.assign({}, _s.canvasContextAttributes), m.canvasContextAttributes) });
            if (p.minZoom != null && p.maxZoom != null && p.minZoom > p.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
            if (p.minPitch != null && p.maxPitch != null && p.minPitch > p.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
            if (p.minPitch != null && p.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (p.maxPitch != null && p.maxPitch > 180) throw new Error("maxPitch must be less than or equal to 180");
            const g = new oi(), y = new Cr();
            if (p.minZoom !== void 0 && g.setMinZoom(p.minZoom), p.maxZoom !== void 0 && g.setMaxZoom(p.maxZoom), p.minPitch !== void 0 && g.setMinPitch(p.minPitch), p.maxPitch !== void 0 && g.setMaxPitch(p.maxPitch), p.renderWorldCopies !== void 0 && g.setRenderWorldCopies(p.renderWorldCopies), super(g, y, { bearingSnap: p.bearingSnap }), this._idleTriggered = !1, this._crossFadingFactor = 1, this._renderTaskQueue = new an(), this._controls = [], this._mapId = a.a7(), this._contextLost = (E) => {
              E.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new a.l("webglcontextlost", { originalEvent: E }));
            }, this._contextRestored = (E) => {
              this._setupPainter(), this.resize(), this._update(), this.fire(new a.l("webglcontextrestored", { originalEvent: E }));
            }, this._onMapScroll = (E) => {
              if (E.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
            }, this._onWindowOnline = () => {
              this._update();
            }, this._interactive = p.interactive, this._maxTileCacheSize = p.maxTileCacheSize, this._maxTileCacheZoomLevels = p.maxTileCacheZoomLevels, this._canvasContextAttributes = Object.assign({}, p.canvasContextAttributes), this._trackResize = p.trackResize === !0, this._bearingSnap = p.bearingSnap, this._centerClampedToGround = p.centerClampedToGround, this._refreshExpiredTiles = p.refreshExpiredTiles === !0, this._fadeDuration = p.fadeDuration, this._crossSourceCollisions = p.crossSourceCollisions === !0, this._collectResourceTiming = p.collectResourceTiming === !0, this._locale = Object.assign(Object.assign({}, zr), p.locale), this._clickTolerance = p.clickTolerance, this._overridePixelRatio = p.pixelRatio, this._maxCanvasSize = p.maxCanvasSize, this.transformCameraUpdate = p.transformCameraUpdate, this.cancelPendingTileRequestsWhileZooming = p.cancelPendingTileRequestsWhileZooming === !0, this._imageQueueHandle = Le.addThrottleControl((() => this.isMoving())), this._requestManager = new Ze(p.transformRequest), typeof p.container == "string") {
              if (this._container = document.getElementById(p.container), !this._container) throw new Error(`Container '${p.container}' not found.`);
            } else {
              if (!(p.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = p.container;
            }
            if (p.maxBounds && this.setMaxBounds(p.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", (() => this._update(!1))), this.on("moveend", (() => this._update(!1))), this.on("zoom", (() => this._update(!0))), this.on("terrain", (() => {
              this.painter.terrainFacilitator.dirty = !0, this._update(!0);
            })), this.once("idle", (() => {
              this._idleTriggered = !0;
            })), typeof window < "u") {
              addEventListener("online", this._onWindowOnline, !1);
              let E = !1;
              const C = wo(((R) => {
                this._trackResize && !this._removed && (this.resize(R), this.redraw());
              }), 50);
              this._resizeObserver = new ResizeObserver(((R) => {
                E ? C(R) : E = !0;
              })), this._resizeObserver.observe(this._container);
            }
            this.handlers = new Jh(this, p), this._hash = p.hash && new sc(typeof p.hash == "string" && p.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: p.center, elevation: p.elevation, zoom: p.zoom, bearing: p.bearing, pitch: p.pitch, roll: p.roll }), p.bounds && (this.resize(), this.fitBounds(p.bounds, a.e({}, p.fitBoundsOptions, { duration: 0 }))));
            const x = typeof p.style == "string" || ((h = (r = p.style) === null || r === void 0 ? void 0 : r.projection) === null || h === void 0 ? void 0 : h.type) !== "globe";
            this.resize(null, x), this._localIdeographFontFamily = p.localIdeographFontFamily, this._validateStyle = p.validateStyle, p.style && this.setStyle(p.style, { localIdeographFontFamily: p.localIdeographFontFamily }), p.attributionControl && this.addControl(new eu(typeof p.attributionControl == "boolean" ? void 0 : p.attributionControl)), p.maplibreLogo && this.addControl(new Qd(), p.logoPosition), this.on("style.load", (() => {
              if (x || this._resizeTransform(), this.transform.unmodified) {
                const E = a.Q(this.style.stylesheet, ["center", "zoom", "bearing", "pitch", "roll"]);
                this.jumpTo(E);
              }
            })), this.on("data", ((E) => {
              this._update(E.dataType === "style"), this.fire(new a.l(`${E.dataType}data`, E));
            })), this.on("dataloading", ((E) => {
              this.fire(new a.l(`${E.dataType}dataloading`, E));
            })), this.on("dataabort", ((E) => {
              this.fire(new a.l("sourcedataabort", E));
            }));
          }
          _getMapId() {
            return this._mapId;
          }
          setGlobalStateProperty(m, r) {
            return this.style.setGlobalStateProperty(m, r), this._update(!0);
          }
          getGlobalState() {
            return this.style.getGlobalState();
          }
          addControl(m, r) {
            if (r === void 0 && (r = m.getDefaultPosition ? m.getDefaultPosition() : "top-right"), !m || !m.onAdd) return this.fire(new a.k(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            const h = m.onAdd(this);
            this._controls.push(m);
            const p = this._controlPositions[r];
            return r.indexOf("bottom") !== -1 ? p.insertBefore(h, p.firstChild) : p.appendChild(h), this;
          }
          removeControl(m) {
            if (!m || !m.onRemove) return this.fire(new a.k(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            const r = this._controls.indexOf(m);
            return r > -1 && this._controls.splice(r, 1), m.onRemove(this), this;
          }
          hasControl(m) {
            return this._controls.indexOf(m) > -1;
          }
          calculateCameraOptionsFromTo(m, r, h, p) {
            return p == null && this.terrain && (p = this.terrain.getElevationForLngLatZoom(h, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(m, r, h, p);
          }
          resize(m, r = !0) {
            const [h, p] = this._containerDimensions(), g = this._getClampedPixelRatio(h, p);
            if (this._resizeCanvas(h, p, g), this.painter.resize(h, p, g), this.painter.overLimit()) {
              const x = this.painter.context.gl;
              this._maxCanvasSize = [x.drawingBufferWidth, x.drawingBufferHeight];
              const E = this._getClampedPixelRatio(h, p);
              this._resizeCanvas(h, p, E), this.painter.resize(h, p, E);
            }
            this._resizeTransform(r);
            const y = !this._moving;
            return y && (this.stop(), this.fire(new a.l("movestart", m)).fire(new a.l("move", m))), this.fire(new a.l("resize", m)), y && this.fire(new a.l("moveend", m)), this;
          }
          _resizeTransform(m = !0) {
            var r;
            const [h, p] = this._containerDimensions();
            this.transform.resize(h, p, m), (r = this._requestedCameraState) === null || r === void 0 || r.resize(h, p, m);
          }
          _getClampedPixelRatio(m, r) {
            const { 0: h, 1: p } = this._maxCanvasSize, g = this.getPixelRatio(), y = m * g, x = r * g;
            return Math.min(y > h ? h / y : 1, x > p ? p / x : 1) * g;
          }
          getPixelRatio() {
            var m;
            return (m = this._overridePixelRatio) !== null && m !== void 0 ? m : devicePixelRatio;
          }
          setPixelRatio(m) {
            this._overridePixelRatio = m, this.resize();
          }
          getBounds() {
            return this.transform.getBounds();
          }
          getMaxBounds() {
            return this.transform.getMaxBounds();
          }
          setMaxBounds(m) {
            return this.transform.setMaxBounds(ni.convert(m)), this._update();
          }
          setMinZoom(m) {
            if ((m = m ?? -2) >= -2 && m <= this.transform.maxZoom) return this.transform.setMinZoom(m), this._update(), this.getZoom() < m && this.setZoom(m), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
          }
          getMinZoom() {
            return this.transform.minZoom;
          }
          setMaxZoom(m) {
            if ((m = m ?? 22) >= this.transform.minZoom) return this.transform.setMaxZoom(m), this._update(), this.getZoom() > m && this.setZoom(m), this;
            throw new Error("maxZoom must be greater than the current minZoom");
          }
          getMaxZoom() {
            return this.transform.maxZoom;
          }
          setMinPitch(m) {
            if ((m = m ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (m >= 0 && m <= this.transform.maxPitch) return this.transform.setMinPitch(m), this._update(), this.getPitch() < m && this.setPitch(m), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
          }
          getMinPitch() {
            return this.transform.minPitch;
          }
          setMaxPitch(m) {
            if ((m = m ?? 60) > 180) throw new Error("maxPitch must be less than or equal to 180");
            if (m >= this.transform.minPitch) return this.transform.setMaxPitch(m), this._update(), this.getPitch() > m && this.setPitch(m), this;
            throw new Error("maxPitch must be greater than the current minPitch");
          }
          getMaxPitch() {
            return this.transform.maxPitch;
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies;
          }
          setRenderWorldCopies(m) {
            return this.transform.setRenderWorldCopies(m), this._update();
          }
          project(m) {
            return this.transform.locationToScreenPoint(a.S.convert(m), this.style && this.terrain);
          }
          unproject(m) {
            return this.transform.screenPointToLocation(a.P.convert(m), this.terrain);
          }
          isMoving() {
            var m;
            return this._moving || ((m = this.handlers) === null || m === void 0 ? void 0 : m.isMoving());
          }
          isZooming() {
            var m;
            return this._zooming || ((m = this.handlers) === null || m === void 0 ? void 0 : m.isZooming());
          }
          isRotating() {
            var m;
            return this._rotating || ((m = this.handlers) === null || m === void 0 ? void 0 : m.isRotating());
          }
          _createDelegatedListener(m, r, h) {
            if (m === "mouseenter" || m === "mouseover") {
              let p = !1;
              return { layers: r, listener: h, delegates: { mousemove: (y) => {
                const x = r.filter(((C) => this.getLayer(C))), E = x.length !== 0 ? this.queryRenderedFeatures(y.point, { layers: x }) : [];
                E.length ? p || (p = !0, h.call(this, new Wr(m, this, y.originalEvent, { features: E }))) : p = !1;
              }, mouseout: () => {
                p = !1;
              } } };
            }
            if (m === "mouseleave" || m === "mouseout") {
              let p = !1;
              return { layers: r, listener: h, delegates: { mousemove: (x) => {
                const E = r.filter(((C) => this.getLayer(C)));
                (E.length !== 0 ? this.queryRenderedFeatures(x.point, { layers: E }) : []).length ? p = !0 : p && (p = !1, h.call(this, new Wr(m, this, x.originalEvent)));
              }, mouseout: (x) => {
                p && (p = !1, h.call(this, new Wr(m, this, x.originalEvent)));
              } } };
            }
            {
              const p = (g) => {
                const y = r.filter(((E) => this.getLayer(E))), x = y.length !== 0 ? this.queryRenderedFeatures(g.point, { layers: y }) : [];
                x.length && (g.features = x, h.call(this, g), delete g.features);
              };
              return { layers: r, listener: h, delegates: { [m]: p } };
            }
          }
          _saveDelegatedListener(m, r) {
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[m] = this._delegatedListeners[m] || [], this._delegatedListeners[m].push(r);
          }
          _removeDelegatedListener(m, r, h) {
            if (!this._delegatedListeners || !this._delegatedListeners[m]) return;
            const p = this._delegatedListeners[m];
            for (let g = 0; g < p.length; g++) {
              const y = p[g];
              if (y.listener === h && y.layers.length === r.length && y.layers.every(((x) => r.includes(x)))) {
                for (const x in y.delegates) this.off(x, y.delegates[x]);
                return void p.splice(g, 1);
              }
            }
          }
          on(m, r, h) {
            if (h === void 0) return super.on(m, r);
            const p = typeof r == "string" ? [r] : r, g = this._createDelegatedListener(m, p, h);
            this._saveDelegatedListener(m, g);
            for (const y in g.delegates) this.on(y, g.delegates[y]);
            return { unsubscribe: () => {
              this._removeDelegatedListener(m, p, h);
            } };
          }
          once(m, r, h) {
            if (h === void 0) return super.once(m, r);
            const p = typeof r == "string" ? [r] : r, g = this._createDelegatedListener(m, p, h);
            for (const y in g.delegates) {
              const x = g.delegates[y];
              g.delegates[y] = (...E) => {
                this._removeDelegatedListener(m, p, h), x(...E);
              };
            }
            this._saveDelegatedListener(m, g);
            for (const y in g.delegates) this.once(y, g.delegates[y]);
            return this;
          }
          off(m, r, h) {
            return h === void 0 ? super.off(m, r) : (this._removeDelegatedListener(m, typeof r == "string" ? [r] : r, h), this);
          }
          queryRenderedFeatures(m, r) {
            if (!this.style) return [];
            let h;
            const p = m instanceof a.P || Array.isArray(m), g = p ? m : [[0, 0], [this.transform.width, this.transform.height]];
            if (r = r || (p ? {} : m) || {}, g instanceof a.P || typeof g[0] == "number") h = [a.P.convert(g)];
            else {
              const y = a.P.convert(g[0]), x = a.P.convert(g[1]);
              h = [y, new a.P(x.x, y.y), x, new a.P(y.x, x.y), y];
            }
            return this.style.queryRenderedFeatures(h, r, this.transform);
          }
          querySourceFeatures(m, r) {
            return this.style.querySourceFeatures(m, r);
          }
          setStyle(m, r) {
            return (r = a.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, r)).diff !== !1 && r.localIdeographFontFamily === this._localIdeographFontFamily && this.style && m ? (this._diffStyle(m, r), this) : (this._localIdeographFontFamily = r.localIdeographFontFamily, this._updateStyle(m, r));
          }
          setTransformRequest(m) {
            return this._requestManager.setTransformRequest(m), this;
          }
          _getUIString(m) {
            const r = this._locale[m];
            if (r == null) throw new Error(`Missing UI string '${m}'`);
            return r;
          }
          _updateStyle(m, r) {
            var h, p;
            if (r.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", (() => this._updateStyle(m, r)));
            const g = this.style && r.transformStyle ? this.style.serialize() : void 0;
            return this.style && (this.style.setEventedParent(null), this.style._remove(!m)), m ? (this.style = new xh(this, r || {}), this.style.setEventedParent(this, { style: this.style }), typeof m == "string" ? this.style.loadURL(m, r, g) : this.style.loadJSON(m, r, g), this) : ((p = (h = this.style) === null || h === void 0 ? void 0 : h.projection) === null || p === void 0 || p.destroy(), delete this.style, this);
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new xh(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
          }
          _diffStyle(m, r) {
            if (typeof m == "string") {
              const h = this._requestManager.transformRequest(m, "Style");
              a.j(h, new AbortController()).then(((p) => {
                this._updateDiff(p.data, r);
              })).catch(((p) => {
                p && this.fire(new a.k(p));
              }));
            } else typeof m == "object" && this._updateDiff(m, r);
          }
          _updateDiff(m, r) {
            try {
              this.style.setState(m, r) && this._update(!0);
            } catch (h) {
              a.w(`Unable to perform style diff: ${h.message || h.error || h}.  Rebuilding the style from scratch.`), this._updateStyle(m, r);
            }
          }
          getStyle() {
            if (this.style) return this.style.serialize();
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : a.w("There is no style added to the map.");
          }
          addSource(m, r) {
            return this._lazyInitEmptyStyle(), this.style.addSource(m, r), this._update(!0);
          }
          isSourceLoaded(m) {
            const r = this.style && this.style.sourceCaches[m];
            if (r !== void 0) return r.loaded();
            this.fire(new a.k(new Error(`There is no source with ID '${m}'`)));
          }
          setTerrain(m) {
            if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), m) {
              const r = this.style.sourceCaches[m.source];
              if (!r) throw new Error(`cannot load terrain, because there exists no source with ID: ${m.source}`);
              this.terrain === null && r.reload();
              for (const h in this.style._layers) {
                const p = this.style._layers[h];
                p.type === "hillshade" && p.source === m.source && a.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality."), p.type === "color-relief" && p.source === m.source && a.w("You are using the same source for a color-relief layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
              }
              this.terrain = new yt(this.painter, r, m), this.painter.renderToTexture = new uc(this.painter, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._terrainDataCallback = (h) => {
                var p;
                h.dataType === "style" ? this.terrain.sourceCache.freeRtt() : h.dataType === "source" && h.tile && (h.sourceId !== m.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), ((p = h.source) === null || p === void 0 ? void 0 : p.type) === "image" ? this.terrain.sourceCache.freeRtt() : this.terrain.sourceCache.freeRtt(h.tile.tileID));
              }, this.style.on("data", this._terrainDataCallback);
            } else this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0);
            return this.fire(new a.l("terrain", { terrain: m })), this;
          }
          getTerrain() {
            var m, r;
            return (r = (m = this.terrain) === null || m === void 0 ? void 0 : m.options) !== null && r !== void 0 ? r : null;
          }
          areTilesLoaded() {
            const m = this.style && this.style.sourceCaches;
            for (const r in m) {
              const h = m[r]._tiles;
              for (const p in h) {
                const g = h[p];
                if (g.state !== "loaded" && g.state !== "errored") return !1;
              }
            }
            return !0;
          }
          removeSource(m) {
            return this.style.removeSource(m), this._update(!0);
          }
          getSource(m) {
            return this.style.getSource(m);
          }
          setSourceTileLodParams(m, r, h) {
            if (h) {
              const p = this.getSource(h);
              if (!p) throw new Error(`There is no source with ID "${h}", cannot set LOD parameters`);
              p.calculateTileZoom = He(Math.max(1, m), Math.max(1, r));
            } else for (const p in this.style.sourceCaches) this.style.sourceCaches[p].getSource().calculateTileZoom = He(Math.max(1, m), Math.max(1, r));
            return this._update(!0), this;
          }
          refreshTiles(m, r) {
            const h = this.style.sourceCaches[m];
            if (!h) throw new Error(`There is no source cache with ID "${m}", cannot refresh tile`);
            r === void 0 ? h.reload(!0) : h.refreshTiles(r.map(((p) => new a.a4(p.z, p.x, p.y))));
          }
          addImage(m, r, h = {}) {
            const { pixelRatio: p = 1, sdf: g = !1, stretchX: y, stretchY: x, content: E, textFitWidth: C, textFitHeight: R } = h;
            if (this._lazyInitEmptyStyle(), !(r instanceof HTMLImageElement || a.b(r))) {
              if (r.width === void 0 || r.height === void 0) return this.fire(new a.k(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              {
                const { width: B, height: k, data: O } = r, z = r;
                return this.style.addImage(m, { data: new a.R({ width: B, height: k }, new Uint8Array(O)), pixelRatio: p, stretchX: y, stretchY: x, content: E, textFitWidth: C, textFitHeight: R, sdf: g, version: 0, userImage: z }), z.onAdd && z.onAdd(this, m), this;
              }
            }
            {
              const { width: B, height: k, data: O } = N.getImageData(r);
              this.style.addImage(m, { data: new a.R({ width: B, height: k }, O), pixelRatio: p, stretchX: y, stretchY: x, content: E, textFitWidth: C, textFitHeight: R, sdf: g, version: 0 });
            }
          }
          updateImage(m, r) {
            const h = this.style.getImage(m);
            if (!h) return this.fire(new a.k(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            const p = r instanceof HTMLImageElement || a.b(r) ? N.getImageData(r) : r, { width: g, height: y, data: x } = p;
            if (g === void 0 || y === void 0) return this.fire(new a.k(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            if (g !== h.data.width || y !== h.data.height) return this.fire(new a.k(new Error("The width and height of the updated image must be that same as the previous version of the image")));
            const E = !(r instanceof HTMLImageElement || a.b(r));
            return h.data.replace(x, E), this.style.updateImage(m, h), this;
          }
          getImage(m) {
            return this.style.getImage(m);
          }
          hasImage(m) {
            return m ? !!this.style.getImage(m) : (this.fire(new a.k(new Error("Missing required image id"))), !1);
          }
          removeImage(m) {
            this.style.removeImage(m);
          }
          loadImage(m) {
            return Le.getImage(this._requestManager.transformRequest(m, "Image"), new AbortController());
          }
          listImages() {
            return this.style.listImages();
          }
          addLayer(m, r) {
            return this._lazyInitEmptyStyle(), this.style.addLayer(m, r), this._update(!0);
          }
          moveLayer(m, r) {
            return this.style.moveLayer(m, r), this._update(!0);
          }
          removeLayer(m) {
            return this.style.removeLayer(m), this._update(!0);
          }
          getLayer(m) {
            return this.style.getLayer(m);
          }
          getLayersOrder() {
            return this.style.getLayersOrder();
          }
          setLayerZoomRange(m, r, h) {
            return this.style.setLayerZoomRange(m, r, h), this._update(!0);
          }
          setFilter(m, r, h = {}) {
            return this.style.setFilter(m, r, h), this._update(!0);
          }
          getFilter(m) {
            return this.style.getFilter(m);
          }
          setPaintProperty(m, r, h, p = {}) {
            return this.style.setPaintProperty(m, r, h, p), this._update(!0);
          }
          getPaintProperty(m, r) {
            return this.style.getPaintProperty(m, r);
          }
          setLayoutProperty(m, r, h, p = {}) {
            return this.style.setLayoutProperty(m, r, h, p), this._update(!0);
          }
          getLayoutProperty(m, r) {
            return this.style.getLayoutProperty(m, r);
          }
          setGlyphs(m, r = {}) {
            return this._lazyInitEmptyStyle(), this.style.setGlyphs(m, r), this._update(!0);
          }
          getGlyphs() {
            return this.style.getGlyphsUrl();
          }
          addSprite(m, r, h = {}) {
            return this._lazyInitEmptyStyle(), this.style.addSprite(m, r, h, ((p) => {
              p || this._update(!0);
            })), this;
          }
          removeSprite(m) {
            return this._lazyInitEmptyStyle(), this.style.removeSprite(m), this._update(!0);
          }
          getSprite() {
            return this.style.getSprite();
          }
          setSprite(m, r = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSprite(m, r, ((h) => {
              h || this._update(!0);
            })), this;
          }
          setLight(m, r = {}) {
            return this._lazyInitEmptyStyle(), this.style.setLight(m, r), this._update(!0);
          }
          getLight() {
            return this.style.getLight();
          }
          setSky(m, r = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSky(m, r), this._update(!0);
          }
          getSky() {
            return this.style.getSky();
          }
          setFeatureState(m, r) {
            return this.style.setFeatureState(m, r), this._update();
          }
          removeFeatureState(m, r) {
            return this.style.removeFeatureState(m, r), this._update();
          }
          getFeatureState(m) {
            return this.style.getFeatureState(m);
          }
          getContainer() {
            return this._container;
          }
          getCanvasContainer() {
            return this._canvasContainer;
          }
          getCanvas() {
            return this._canvas;
          }
          _containerDimensions() {
            let m = 0, r = 0;
            return this._container && (m = this._container.clientWidth || 400, r = this._container.clientHeight || 300), [m, r];
          }
          _setupContainer() {
            const m = this._container;
            m.classList.add("maplibregl-map");
            const r = this._canvasContainer = L.create("div", "maplibregl-canvas-container", m);
            this._interactive && r.classList.add("maplibregl-interactive"), this._canvas = L.create("canvas", "maplibregl-canvas", r), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
            const h = this._containerDimensions(), p = this._getClampedPixelRatio(h[0], h[1]);
            this._resizeCanvas(h[0], h[1], p);
            const g = this._controlContainer = L.create("div", "maplibregl-control-container", m), y = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach(((x) => {
              y[x] = L.create("div", `maplibregl-ctrl-${x} `, g);
            })), this._container.addEventListener("scroll", this._onMapScroll, !1);
          }
          _resizeCanvas(m, r, h) {
            this._canvas.width = Math.floor(h * m), this._canvas.height = Math.floor(h * r), this._canvas.style.width = `${m}px`, this._canvas.style.height = `${r}px`;
          }
          _setupPainter() {
            const m = Object.assign(Object.assign({}, this._canvasContextAttributes), { alpha: !0, depth: !0, stencil: !0, premultipliedAlpha: !0 });
            let r = null;
            this._canvas.addEventListener("webglcontextcreationerror", ((p) => {
              r = { requestedAttributes: m }, p && (r.statusMessage = p.statusMessage, r.type = p.type);
            }), { once: !0 });
            let h = null;
            if (h = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, m) : this._canvas.getContext("webgl2", m) || this._canvas.getContext("webgl", m), !h) {
              const p = "Failed to initialize WebGL";
              throw r ? (r.message = p, new Error(JSON.stringify(r))) : new Error(p);
            }
            this.painter = new Ld(h, this.transform), re.testSupport(h);
          }
          migrateProjection(m, r) {
            super.migrateProjection(m, r), this.painter.transform = m, this.fire(new a.l("projectiontransition", { newProjection: this.style.projection.name }));
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
          }
          _update(m) {
            return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || m, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
          }
          _requestRenderFrame(m) {
            return this._update(), this._renderTaskQueue.add(m);
          }
          _cancelRenderFrame(m) {
            this._renderTaskQueue.remove(m);
          }
          _render(m) {
            var r, h, p, g, y;
            const x = this._idleTriggered ? this._fadeDuration : 0, E = ((r = this.style.projection) === null || r === void 0 ? void 0 : r.transitionState) > 0;
            if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(m), this._removed) return;
            let C = !1;
            if (this.style && this._styleDirty) {
              this._styleDirty = !1;
              const k = this.transform.zoom, O = N.now();
              this.style.zoomHistory.update(k, O);
              const z = new a.F(k, { now: O, fadeDuration: x, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition(), globalState: this.style.getGlobalState() }), H = z.crossFadingFactor();
              H === 1 && H === this._crossFadingFactor || (C = !0, this._crossFadingFactor = H), this.style.update(z);
            }
            const R = ((h = this.style.projection) === null || h === void 0 ? void 0 : h.transitionState) > 0 !== E;
            (p = this.style.projection) === null || p === void 0 || p.setErrorQueryLatitudeDegrees(this.transform.center.lat), this.transform.setTransitionState((g = this.style.projection) === null || g === void 0 ? void 0 : g.transitionState, (y = this.style.projection) === null || y === void 0 ? void 0 : y.latitudeErrorCorrectionRadians), this.style && (this._sourcesDirty || R) && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0)), this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, x, this._crossSourceCollisions, R), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: x, showPadding: this.showPadding }), this.fire(new a.l("render")), this.loaded() && !this._loaded && (this._loaded = !0, a.cw.mark(a.cx.load), this.fire(new a.l("load"))), this.style && (this.style.hasTransitions() || C) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
            const B = this._sourcesDirty || this._styleDirty || this._placementDirty;
            return B || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new a.l("idle")), !this._loaded || this._fullyLoaded || B || (this._fullyLoaded = !0, a.cw.mark(a.cx.fullLoad)), this;
          }
          redraw() {
            return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
          }
          remove() {
            var m;
            this._hash && this._hash.remove();
            for (const h of this._controls) h.onRemove(this);
            this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && removeEventListener("online", this._onWindowOnline, !1), Le.removeThrottleControl(this._imageQueueHandle), (m = this._resizeObserver) === null || m === void 0 || m.disconnect();
            const r = this.painter.context.gl.getExtension("WEBGL_lose_context");
            r?.loseContext && r.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), L.remove(this._canvasContainer), L.remove(this._controlContainer), this._container.removeEventListener("scroll", this._onMapScroll, !1), this._container.classList.remove("maplibregl-map"), a.cw.clearMetrics(), this._removed = !0, this.fire(new a.l("remove"));
          }
          triggerRepaint() {
            this.style && !this._frameRequest && (this._frameRequest = new AbortController(), N.frame(this._frameRequest, ((m) => {
              a.cw.frame(m), this._frameRequest = null;
              try {
                this._render(m);
              } catch (r) {
                if (!a.cy(r) && !(function(h) {
                  return h.message === Ka;
                })(r)) throw r;
              }
            }), (() => {
            })));
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries;
          }
          set showTileBoundaries(m) {
            this._showTileBoundaries !== m && (this._showTileBoundaries = m, this._update());
          }
          get showPadding() {
            return !!this._showPadding;
          }
          set showPadding(m) {
            this._showPadding !== m && (this._showPadding = m, this._update());
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes;
          }
          set showCollisionBoxes(m) {
            this._showCollisionBoxes !== m && (this._showCollisionBoxes = m, m ? this.style._generateCollisionBoxes() : this._update());
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector;
          }
          set showOverdrawInspector(m) {
            this._showOverdrawInspector !== m && (this._showOverdrawInspector = m, this._update());
          }
          get repaint() {
            return !!this._repaint;
          }
          set repaint(m) {
            this._repaint !== m && (this._repaint = m, this.triggerRepaint());
          }
          get vertices() {
            return !!this._vertices;
          }
          set vertices(m) {
            this._vertices = m, this._update();
          }
          get version() {
            return ef;
          }
          getCameraTargetElevation() {
            return this.transform.elevation;
          }
          getProjection() {
            return this.style.getProjection();
          }
          setProjection(m) {
            return this._lazyInitEmptyStyle(), this.style.setProjection(m), this._update(!0);
          }
        }, d.MapMouseEvent = Wr, d.MapTouchEvent = Zo, d.MapWheelEvent = Gh, d.Marker = ra, d.NavigationControl = class {
          constructor(m) {
            this._updateZoomButtons = () => {
              const r = this._map.getZoom(), h = r === this._map.getMaxZoom(), p = r === this._map.getMinZoom();
              this._zoomInButton.disabled = h, this._zoomOutButton.disabled = p, this._zoomInButton.setAttribute("aria-disabled", h.toString()), this._zoomOutButton.setAttribute("aria-disabled", p.toString());
            }, this._rotateCompassArrow = () => {
              this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing - this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`;
            }, this._setButtonTitle = (r, h) => {
              const p = this._map._getUIString(`NavigationControl.${h}`);
              r.title = p, r.setAttribute("aria-label", p);
            }, this.options = a.e({}, p_, m), this._container = L.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", ((r) => r.preventDefault())), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", ((r) => this._map.zoomIn({}, { originalEvent: r }))), L.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", ((r) => this._map.zoomOut({}, { originalEvent: r }))), L.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", ((r) => {
              this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: r }) : this._map.resetNorth({}, { originalEvent: r });
            })), this._compassIcon = L.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
          }
          onAdd(m) {
            return this._map = m, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new ol(this._map, this._compass, this.options.visualizePitch)), this._container;
          }
          onRemove() {
            L.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
          }
          _createButton(m, r) {
            const h = L.create("button", m, this._container);
            return h.type = "button", h.addEventListener("click", r), h;
          }
        }, d.Popup = class extends a.E {
          constructor(m) {
            super(), this._updateOpacity = () => {
              this.options.locationOccludedOpacity !== void 0 && (this._container.style.opacity = this._map.transform.isLocationOccluded(this.getLngLat()) ? `${this.options.locationOccludedOpacity}` : "");
            }, this.remove = () => (this._content && L.remove(this._content), this._container && (L.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new a.l("close"))), this), this._onMouseUp = (r) => {
              this._update(r.point);
            }, this._onMouseMove = (r) => {
              this._update(r.point);
            }, this._onDrag = (r) => {
              this._update(r.point);
            }, this._update = (r) => {
              if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
              if (!this._container) {
                if (this._container = L.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = L.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (const x of this.options.className.split(" ")) this._container.classList.add(x);
                this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
              }
              if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = Di(this._lngLat, this._flatPos, this._map.transform, this._trackPointer), this._trackPointer && !r) return;
              const h = this._flatPos = this._pos = this._trackPointer && r ? r : this._map.project(this._lngLat);
              this._map.terrain && (this._flatPos = this._trackPointer && r ? r : this._map.transform.locationToScreenPoint(this._lngLat));
              let p = this.options.anchor;
              const g = pc(this.options.offset);
              if (!p) {
                const x = this._container.offsetWidth, E = this._container.offsetHeight;
                let C;
                C = h.y + g.bottom.y < E ? ["top"] : h.y > this._map.transform.height - E ? ["bottom"] : [], h.x < x / 2 ? C.push("left") : h.x > this._map.transform.width - x / 2 && C.push("right"), p = C.length === 0 ? "bottom" : C.join("-");
              }
              let y = h.add(g[p]);
              this.options.subpixelPositioning || (y = y.round()), L.setTransform(this._container, `${dc[p]} translate(${y.x}px,${y.y}px)`), ia(this._container, p, "popup"), this._updateOpacity();
            }, this._onClose = () => {
              this.remove();
            }, this.options = a.e(Object.create(iu), m);
          }
          addTo(m) {
            return this._map && this.remove(), this._map = m, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new a.l("open")), this;
          }
          isOpen() {
            return !!this._map;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(m) {
            return this._lngLat = a.S.convert(m), this._pos = null, this._flatPos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
          }
          trackPointer() {
            return this._trackPointer = !0, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
          }
          getElement() {
            return this._container;
          }
          setText(m) {
            return this.setDOMContent(document.createTextNode(m));
          }
          setHTML(m) {
            const r = document.createDocumentFragment(), h = document.createElement("body");
            let p;
            for (h.innerHTML = m; p = h.firstChild, p; ) r.appendChild(p);
            return this.setDOMContent(r);
          }
          getMaxWidth() {
            var m;
            return (m = this._container) === null || m === void 0 ? void 0 : m.style.maxWidth;
          }
          setMaxWidth(m) {
            return this.options.maxWidth = m, this._update(), this;
          }
          setDOMContent(m) {
            if (this._content) for (; this._content.hasChildNodes(); ) this._content.firstChild && this._content.removeChild(this._content.firstChild);
            else this._content = L.create("div", "maplibregl-popup-content", this._container);
            return this._content.appendChild(m), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
          }
          addClassName(m) {
            return this._container && this._container.classList.add(m), this;
          }
          removeClassName(m) {
            return this._container && this._container.classList.remove(m), this;
          }
          setOffset(m) {
            return this.options.offset = m, this._update(), this;
          }
          toggleClassName(m) {
            if (this._container) return this._container.classList.toggle(m);
          }
          setSubpixelPositioning(m) {
            this.options.subpixelPositioning = m;
          }
          _createCloseButton() {
            this.options.closeButton && (this._closeButton = L.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container) return;
            const m = this._container.querySelector(ru);
            m && m.focus();
          }
        }, d.RasterDEMTileSource = Or, d.RasterTileSource = ki, d.ScaleControl = class {
          constructor(m) {
            this._onMove = () => {
              fc(this._map, this._container, this.options);
            }, this.setUnit = (r) => {
              this.options.unit = r, fc(this._map, this._container, this.options);
            }, this.options = Object.assign(Object.assign({}, al), m);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(m) {
            return this._map = m, this._container = L.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", m.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
          }
          onRemove() {
            L.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
          }
        }, d.ScrollZoomHandler = Xd, d.Style = xh, d.TerrainControl = class {
          constructor(m) {
            this._toggleTerrain = () => {
              this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
            }, this._updateTerrainIcon = () => {
              this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
            }, this.options = m;
          }
          onAdd(m) {
            return this._map = m, this._container = L.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = L.create("button", "maplibregl-ctrl-terrain", this._container), L.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
          }
          onRemove() {
            L.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
          }
        }, d.TwoFingersTouchPitchHandler = oc, d.TwoFingersTouchRotateHandler = ea, d.TwoFingersTouchZoomHandler = nc, d.TwoFingersTouchZoomRotateHandler = Kd, d.VectorTileSource = mr, d.VideoSource = Ts, d.addSourceType = (m, r) => a._(void 0, void 0, void 0, (function* () {
          if (Ys(m)) throw new Error(`A source type called "${m}" already exists.`);
          ((h, p) => {
            Ks[h] = p;
          })(m, r);
        })), d.clearPrewarmedResources = function() {
          const m = cs;
          m && (m.isPreloaded() && m.numActive() === 1 ? (m.release(rr), cs = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
        }, d.createTileMesh = bh, d.getMaxParallelImageRequests = function() {
          return a.a.MAX_PARALLEL_IMAGE_REQUESTS;
        }, d.getRTLTextPluginStatus = function() {
          return As().getRTLTextPluginStatus();
        }, d.getVersion = function() {
          return su;
        }, d.getWorkerCount = function() {
          return wi.workerCount;
        }, d.getWorkerUrl = function() {
          return a.a.WORKER_URL;
        }, d.importScriptInWorkers = function(m) {
          return Ri().broadcast("IS", m);
        }, d.prewarm = function() {
          pn().acquire(rr);
        }, d.setMaxParallelImageRequests = function(m) {
          a.a.MAX_PARALLEL_IMAGE_REQUESTS = m;
        }, d.setRTLTextPlugin = function(m, r) {
          return As().setRTLTextPlugin(m, r);
        }, d.setWorkerCount = function(m) {
          wi.workerCount = m;
        }, d.setWorkerUrl = function(m) {
          a.a.WORKER_URL = m;
        };
      }));
      var u = i;
      return u;
    }));
  })(Kf)), Kf.exports;
}
var Ii = hC();
const uC = /* @__PURE__ */ J1(Ii), vf = /* @__PURE__ */ Y1({
  __proto__: null,
  default: uC
}, [Ii]), dC = "https://api.olamaps.io/tiles/vector/v1/styles/default-light-standard/style.json?key=0.4.0", fC = "https://api.olamaps.io/tiles/vector/v1/3dtiles/tileset.json", pC = (t) => `<svg width="108" height="18" viewBox="0 0 108 18" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M31.0629 8.9393L34.6986 15.7293H38.2743L31.0629 2.2793L23.8516 15.7293H27.4273L31.0629 8.9393Z" fill="${t}"/><path d="M19.2265 12.5798L19.2365 2.25977H16.0703V15.7298H22.163L23.851 12.5798H19.2265Z" fill="${t}"/><path d="M7.22135 1.7793C5.79466 1.77733 4.39943 2.19909 3.21222 2.99123C2.025 3.78337 1.09915 4.91029 0.551806 6.22939C0.00446369 7.5485 -0.139771 9.00051 0.137352 10.4017C0.414475 11.8029 1.1005 13.0903 2.10863 14.1011C3.11676 15.1118 4.40168 15.8004 5.80082 16.0798C7.19996 16.3592 8.65043 16.2168 9.96872 15.6707C11.287 15.1245 12.4139 14.1991 13.2067 13.0116C13.9995 11.824 14.4227 10.4277 14.4227 8.9993C14.4227 7.08617 13.6643 5.25125 12.3141 3.89753C10.9639 2.5438 9.13219 1.78195 7.22135 1.7793ZM7.22135 12.8893C6.45207 12.8933 5.69892 12.6685 5.05735 12.2435C4.41579 11.8184 3.91469 11.2123 3.61755 10.5019C3.32041 9.79141 3.24061 9.00864 3.38827 8.25274C3.53592 7.49684 3.90438 6.80184 4.44695 6.25581C4.98952 5.70978 5.68178 5.3373 6.43601 5.18558C7.19023 5.03385 7.97246 5.10971 8.68358 5.40354C9.3947 5.69737 10.0027 6.19594 10.4305 6.83607C10.8583 7.4762 11.0867 8.22908 11.0867 8.9993C11.0867 9.51015 10.9862 10.016 10.791 10.4879C10.5957 10.9599 10.3095 11.3887 9.94873 11.7499C9.58794 12.1112 9.15963 12.3977 8.68823 12.5932C8.21684 12.7887 7.71161 12.8893 7.20138 12.8893H7.22135Z" fill="${t}"/><path d="M55.5634 4.82953V4.33953L50.4296 15.7295H49.4308L44.3768 4.33953V4.82953L43.9773 15.7295H42.9785L43.438 2.26953H44.5766L49.7104 13.8095C49.8003 14.0495 49.9102 14.2895 49.9801 14.5095C50.0543 14.2675 50.1513 14.0332 50.2698 13.8095L55.3437 2.26953H56.4723L56.9318 15.7295H55.933L55.5634 4.82953Z" fill="${t}"/><path d="M60.3287 15.7495H59.25L65.2428 2.26953H66.5513L72.5441 15.7495H71.4254L69.6875 11.8395H62.0666L60.3287 15.7495ZM66.4614 4.54953C66.2216 3.96953 66.0019 3.41953 65.8621 3.01953C65.7322 3.41953 65.5125 4.01953 65.2928 4.54953L62.4462 10.9095H69.288L66.4614 4.54953Z" fill="${t}"/><path d="M79.1611 2.14062C82.6669 2.14062 84.4048 3.62063 84.4048 6.62063C84.4048 9.62063 82.6669 11.0706 79.211 11.0706H75.9949V15.5906H74.9961V2.14062H79.1611ZM79.1611 10.1406C82.0077 10.1406 83.436 8.97062 83.416 6.61062C83.396 4.25062 82.0077 3.06062 79.1411 3.06062H75.9949V10.1406H79.1611Z" fill="${t}"/><path d="M95.1406 3.9293C93.7557 3.25763 92.2346 2.91539 90.6959 2.9293C88.8481 2.9293 87.6995 4.0193 87.6995 5.2293C87.6995 6.8693 88.5984 7.3593 91.6248 8.3693C94.6511 9.3793 95.9995 10.3693 95.9995 12.3693C95.9995 14.9993 93.942 15.9293 91.6947 15.9293C89.6115 15.9429 87.5948 15.1964 86.0215 13.8293L86.5009 13.0693C87.9375 14.3316 89.7833 15.0282 91.6947 15.0293C93.902 15.0293 95.0007 14.1193 95.0007 12.4893C95.0007 10.8593 94.1617 10.2093 90.9356 9.1293C88.069 8.1793 86.7007 7.5993 86.7007 5.2793C86.7007 3.3993 88.2488 2.0293 90.6959 2.0293C92.3497 2.03153 93.9817 2.40754 95.4702 3.1293L95.1406 3.9293Z" fill="${t}"/></svg>`;
async function rd(t, e, i, s) {
  return s._parse(t, e, i, s);
}
function mi(t, e) {
  if (!t)
    throw new Error(e || "loader assertion failed.");
}
const Ap = (
  // @ts-ignore process does not exist on browser
  !!(typeof process != "object" || String(process) !== "[object process]" || process.browser)
), L0 = typeof process < "u" && process.version && /v([0-9]*)/.exec(process.version);
L0 && parseFloat(L0[1]);
const U0 = globalThis, z0 = globalThis.process || {}, _C = globalThis.navigator || {};
function ew(t) {
  if (typeof window < "u" && window.process?.type === "renderer" || typeof process < "u" && process.versions?.electron)
    return !0;
  const i = typeof navigator < "u" && navigator.userAgent;
  return !!(i && i.indexOf("Electron") >= 0);
}
function Ra() {
  return !// @ts-expect-error
  (typeof process == "object" && String(process) === "[object process]" && !process?.browser) || ew();
}
function gC(t) {
  return Ra() ? ew() ? "Electron" : (_C.userAgent || "").indexOf("Edge") > -1 ? "Edge" : globalThis.chrome ? "Chrome" : globalThis.safari ? "Safari" : globalThis.mozInnerScreenX ? "Firefox" : "Unknown" : "Node";
}
const tw = "4.0.7";
function mC(t) {
  try {
    const e = window[t], i = "__storage_test__";
    return e.setItem(i, i), e.removeItem(i), e;
  } catch {
    return null;
  }
}
class yC {
  constructor(e, i, s = "sessionStorage") {
    this.storage = mC(s), this.id = e, this.config = i, this._loadConfiguration();
  }
  getConfiguration() {
    return this.config;
  }
  setConfiguration(e) {
    if (Object.assign(this.config, e), this.storage) {
      const i = JSON.stringify(this.config);
      this.storage.setItem(this.id, i);
    }
  }
  // Get config from persistent store, if available
  _loadConfiguration() {
    let e = {};
    if (this.storage) {
      const i = this.storage.getItem(this.id);
      e = i ? JSON.parse(i) : {};
    }
    return Object.assign(this.config, e), this;
  }
}
function bC(t) {
  let e;
  return t < 10 ? e = `${t.toFixed(2)}ms` : t < 100 ? e = `${t.toFixed(1)}ms` : t < 1e3 ? e = `${t.toFixed(0)}ms` : e = `${(t / 1e3).toFixed(2)}s`, e;
}
function vC(t, e = 8) {
  const i = Math.max(e - t.length, 0);
  return `${" ".repeat(i)}${t}`;
}
var np;
(function(t) {
  t[t.BLACK = 30] = "BLACK", t[t.RED = 31] = "RED", t[t.GREEN = 32] = "GREEN", t[t.YELLOW = 33] = "YELLOW", t[t.BLUE = 34] = "BLUE", t[t.MAGENTA = 35] = "MAGENTA", t[t.CYAN = 36] = "CYAN", t[t.WHITE = 37] = "WHITE", t[t.BRIGHT_BLACK = 90] = "BRIGHT_BLACK", t[t.BRIGHT_RED = 91] = "BRIGHT_RED", t[t.BRIGHT_GREEN = 92] = "BRIGHT_GREEN", t[t.BRIGHT_YELLOW = 93] = "BRIGHT_YELLOW", t[t.BRIGHT_BLUE = 94] = "BRIGHT_BLUE", t[t.BRIGHT_MAGENTA = 95] = "BRIGHT_MAGENTA", t[t.BRIGHT_CYAN = 96] = "BRIGHT_CYAN", t[t.BRIGHT_WHITE = 97] = "BRIGHT_WHITE";
})(np || (np = {}));
const xC = 10;
function V0(t) {
  return typeof t != "string" ? t : (t = t.toUpperCase(), np[t] || np.WHITE);
}
function wC(t, e, i) {
  return !Ra && typeof t == "string" && (e && (t = `\x1B[${V0(e)}m${t}\x1B[39m`), i && (t = `\x1B[${V0(i) + xC}m${t}\x1B[49m`)), t;
}
function TC(t, e = ["constructor"]) {
  const i = Object.getPrototypeOf(t), s = Object.getOwnPropertyNames(i), o = t;
  for (const u of s) {
    const d = o[u];
    typeof d == "function" && (e.find((a) => u === a) || (o[u] = d.bind(t)));
  }
}
function qm(t, e) {
  if (!t)
    throw new Error("Assertion failed");
}
function Bc() {
  let t;
  if (Ra() && U0.performance)
    t = U0?.performance?.now?.();
  else if ("hrtime" in z0) {
    const e = z0?.hrtime?.();
    t = e[0] * 1e3 + e[1] / 1e6;
  } else
    t = Date.now();
  return t;
}
const Dc = {
  debug: Ra() && console.debug || console.log,
  log: console.log,
  info: console.info,
  warn: console.warn,
  error: console.error
}, AC = {
  enabled: !0,
  level: 0
};
function Oc() {
}
const j0 = {}, H0 = { once: !0 };
class ph {
  constructor({ id: e } = { id: "" }) {
    this.VERSION = tw, this._startTs = Bc(), this._deltaTs = Bc(), this.userData = {}, this.LOG_THROTTLE_TIMEOUT = 0, this.id = e, this.userData = {}, this._storage = new yC(`__probe-${this.id}__`, AC), this.timeStamp(`${this.id} started`), TC(this), Object.seal(this);
  }
  set level(e) {
    this.setLevel(e);
  }
  get level() {
    return this.getLevel();
  }
  isEnabled() {
    return this._storage.config.enabled;
  }
  getLevel() {
    return this._storage.config.level;
  }
  /** @return milliseconds, with fractions */
  getTotal() {
    return Number((Bc() - this._startTs).toPrecision(10));
  }
  /** @return milliseconds, with fractions */
  getDelta() {
    return Number((Bc() - this._deltaTs).toPrecision(10));
  }
  /** @deprecated use logLevel */
  set priority(e) {
    this.level = e;
  }
  /** @deprecated use logLevel */
  get priority() {
    return this.level;
  }
  /** @deprecated use logLevel */
  getPriority() {
    return this.level;
  }
  // Configure
  enable(e = !0) {
    return this._storage.setConfiguration({ enabled: e }), this;
  }
  setLevel(e) {
    return this._storage.setConfiguration({ level: e }), this;
  }
  /** return the current status of the setting */
  get(e) {
    return this._storage.config[e];
  }
  // update the status of the setting
  set(e, i) {
    this._storage.setConfiguration({ [e]: i });
  }
  /** Logs the current settings as a table */
  settings() {
    console.table ? console.table(this._storage.config) : console.log(this._storage.config);
  }
  // Unconditional logging
  assert(e, i) {
    if (!e)
      throw new Error(i || "Assertion failed");
  }
  warn(e) {
    return this._getLogFunction(0, e, Dc.warn, arguments, H0);
  }
  error(e) {
    return this._getLogFunction(0, e, Dc.error, arguments);
  }
  /** Print a deprecation warning */
  deprecated(e, i) {
    return this.warn(`\`${e}\` is deprecated and will be removed in a later version. Use \`${i}\` instead`);
  }
  /** Print a removal warning */
  removed(e, i) {
    return this.error(`\`${e}\` has been removed. Use \`${i}\` instead`);
  }
  probe(e, i) {
    return this._getLogFunction(e, i, Dc.log, arguments, {
      time: !0,
      once: !0
    });
  }
  log(e, i) {
    return this._getLogFunction(e, i, Dc.debug, arguments);
  }
  info(e, i) {
    return this._getLogFunction(e, i, console.info, arguments);
  }
  once(e, i) {
    return this._getLogFunction(e, i, Dc.debug || Dc.info, arguments, H0);
  }
  /** Logs an object as a table */
  table(e, i, s) {
    return i ? this._getLogFunction(e, i, console.table || Oc, s && [s], {
      tag: SC(i)
    }) : Oc;
  }
  time(e, i) {
    return this._getLogFunction(e, i, console.time ? console.time : console.info);
  }
  timeEnd(e, i) {
    return this._getLogFunction(e, i, console.timeEnd ? console.timeEnd : console.info);
  }
  timeStamp(e, i) {
    return this._getLogFunction(e, i, console.timeStamp || Oc);
  }
  group(e, i, s = { collapsed: !1 }) {
    const o = $0({ logLevel: e, message: i, opts: s }), { collapsed: u } = s;
    return o.method = (u ? console.groupCollapsed : console.group) || console.info, this._getLogFunction(o);
  }
  groupCollapsed(e, i, s = {}) {
    return this.group(e, i, Object.assign({}, s, { collapsed: !0 }));
  }
  groupEnd(e) {
    return this._getLogFunction(e, "", console.groupEnd || Oc);
  }
  // EXPERIMENTAL
  withGroup(e, i, s) {
    this.group(e, i)();
    try {
      s();
    } finally {
      this.groupEnd(e)();
    }
  }
  trace() {
    console.trace && console.trace();
  }
  // PRIVATE METHODS
  /** Deduces log level from a variety of arguments */
  _shouldLog(e) {
    return this.isEnabled() && this.getLevel() >= iw(e);
  }
  _getLogFunction(e, i, s, o, u) {
    if (this._shouldLog(e)) {
      u = $0({ logLevel: e, message: i, args: o, opts: u }), s = s || u.method, qm(s), u.total = this.getTotal(), u.delta = this.getDelta(), this._deltaTs = Bc();
      const d = u.tag || u.message;
      if (u.once && d)
        if (!j0[d])
          j0[d] = Bc();
        else
          return Oc;
      return i = EC(this.id, u.message, u), s.bind(console, i, ...u.args);
    }
    return Oc;
  }
}
ph.VERSION = tw;
function iw(t) {
  if (!t)
    return 0;
  let e;
  switch (typeof t) {
    case "number":
      e = t;
      break;
    case "object":
      e = t.logLevel || t.priority || 0;
      break;
    default:
      return 0;
  }
  return qm(Number.isFinite(e) && e >= 0), e;
}
function $0(t) {
  const { logLevel: e, message: i } = t;
  t.logLevel = iw(e);
  const s = t.args ? Array.from(t.args) : [];
  for (; s.length && s.shift() !== i; )
    ;
  switch (typeof e) {
    case "string":
    case "function":
      i !== void 0 && s.unshift(i), t.message = e;
      break;
    case "object":
      Object.assign(t, e);
      break;
  }
  typeof t.message == "function" && (t.message = t.message());
  const o = typeof t.message;
  return qm(o === "string" || o === "object"), Object.assign(t, { args: s }, t.opts);
}
function EC(t, e, i) {
  if (typeof e == "string") {
    const s = i.time ? vC(bC(i.total)) : "";
    e = i.time ? `${t}: ${s}  ${e}` : `${t}: ${e}`, e = wC(e, i.color, i.background);
  }
  return e;
}
function SC(t) {
  for (const e in t)
    for (const i in t[e])
      return i || "untitled";
  return "empty";
}
globalThis.probe = {};
const rw = new ph({ id: "@probe.gl/log" }), eg = "4.3.1", CC = eg[0] >= "0" && eg[0] <= "9" ? `v${eg}` : "";
function IC() {
  const t = new ph({ id: "loaders.gl" });
  return globalThis.loaders = globalThis.loaders || {}, globalThis.loaders.log = t, globalThis.loaders.version = CC, globalThis.probe = globalThis.probe || {}, globalThis.probe.loaders = t, t;
}
const MC = IC();
function RC(t, e) {
  return sw(t || {}, e);
}
function sw(t, e, i = 0) {
  if (i > 3)
    return e;
  const s = { ...t };
  for (const [o, u] of Object.entries(e))
    u && typeof u == "object" && !Array.isArray(u) ? s[o] = sw(s[o] || {}, e[o], i + 1) : s[o] = e[o];
  return s;
}
function PC(t) {
  globalThis.loaders ||= {}, globalThis.loaders.modules ||= {}, Object.assign(globalThis.loaders.modules, t);
}
function BC(t) {
  return globalThis.loaders?.modules?.[t] || null;
}
const DC = "latest";
function OC() {
  return globalThis._loadersgl_?.version || (globalThis._loadersgl_ = globalThis._loadersgl_ || {}, globalThis._loadersgl_.version = "4.3.1"), globalThis._loadersgl_.version;
}
const nw = OC();
function ko(t, e) {
  if (!t)
    throw new Error(e || "loaders.gl assertion failed.");
}
const dn = (
  // @ts-ignore process.browser
  typeof process != "object" || String(process) !== "[object process]" || process.browser
), Zm = typeof importScripts == "function", FC = typeof window < "u" && typeof window.orientation < "u", G0 = typeof process < "u" && process.version && /v([0-9]*)/.exec(process.version);
G0 && parseFloat(G0[1]);
class kC {
  name;
  workerThread;
  isRunning = !0;
  /** Promise that resolves when Job is done */
  result;
  _resolve = () => {
  };
  _reject = () => {
  };
  constructor(e, i) {
    this.name = e, this.workerThread = i, this.result = new Promise((s, o) => {
      this._resolve = s, this._reject = o;
    });
  }
  /**
   * Send a message to the job's worker thread
   * @param data any data structure, ideally consisting mostly of transferrable objects
   */
  postMessage(e, i) {
    this.workerThread.postMessage({
      source: "loaders.gl",
      // Lets worker ignore unrelated messages
      type: e,
      payload: i
    });
  }
  /**
   * Call to resolve the `result` Promise with the supplied value
   */
  done(e) {
    ko(this.isRunning), this.isRunning = !1, this._resolve(e);
  }
  /**
   * Call to reject the `result` Promise with the supplied error
   */
  error(e) {
    ko(this.isRunning), this.isRunning = !1, this._reject(e);
  }
}
class tg {
  terminate() {
  }
}
const ig = /* @__PURE__ */ new Map();
function NC(t) {
  ko(t.source && !t.url || !t.source && t.url);
  let e = ig.get(t.source || t.url);
  return e || (t.url && (e = LC(t.url), ig.set(t.url, e)), t.source && (e = ow(t.source), ig.set(t.source, e))), ko(e), e;
}
function LC(t) {
  if (!t.startsWith("http"))
    return t;
  const e = UC(t);
  return ow(e);
}
function ow(t) {
  const e = new Blob([t], { type: "application/javascript" });
  return URL.createObjectURL(e);
}
function UC(t) {
  return `try {
  importScripts('${t}');
} catch (error) {
  console.error(error);
  throw error;
}`;
}
function aw(t, e = !0, i) {
  const s = i || /* @__PURE__ */ new Set();
  if (t) {
    if (W0(t))
      s.add(t);
    else if (W0(t.buffer))
      s.add(t.buffer);
    else if (!ArrayBuffer.isView(t)) {
      if (e && typeof t == "object")
        for (const o in t)
          aw(t[o], e, s);
    }
  }
  return i === void 0 ? Array.from(s) : [];
}
function W0(t) {
  return t ? t instanceof ArrayBuffer || typeof MessagePort < "u" && t instanceof MessagePort || typeof ImageBitmap < "u" && t instanceof ImageBitmap || typeof OffscreenCanvas < "u" && t instanceof OffscreenCanvas : !1;
}
const rg = () => {
};
class sm {
  name;
  source;
  url;
  terminated = !1;
  worker;
  onMessage;
  onError;
  _loadableURL = "";
  /** Checks if workers are supported on this platform */
  static isSupported() {
    return typeof Worker < "u" && dn || typeof tg < "u" && !dn;
  }
  constructor(e) {
    const { name: i, source: s, url: o } = e;
    ko(s || o), this.name = i, this.source = s, this.url = o, this.onMessage = rg, this.onError = (u) => console.log(u), this.worker = dn ? this._createBrowserWorker() : this._createNodeWorker();
  }
  /**
   * Terminate this worker thread
   * @note Can free up significant memory
   */
  destroy() {
    this.onMessage = rg, this.onError = rg, this.worker.terminate(), this.terminated = !0;
  }
  get isRunning() {
    return !!this.onMessage;
  }
  /**
   * Send a message to this worker thread
   * @param data any data structure, ideally consisting mostly of transferrable objects
   * @param transferList If not supplied, calculated automatically by traversing data
   */
  postMessage(e, i) {
    i = i || aw(e), this.worker.postMessage(e, i);
  }
  // PRIVATE
  /**
   * Generate a standard Error from an ErrorEvent
   * @param event
   */
  _getErrorFromErrorEvent(e) {
    let i = "Failed to load ";
    return i += `worker ${this.name} from ${this.url}. `, e.message && (i += `${e.message} in `), e.lineno && (i += `:${e.lineno}:${e.colno}`), new Error(i);
  }
  /**
   * Creates a worker thread on the browser
   */
  _createBrowserWorker() {
    this._loadableURL = NC({ source: this.source, url: this.url });
    const e = new Worker(this._loadableURL, { name: this.name });
    return e.onmessage = (i) => {
      i.data ? this.onMessage(i.data) : this.onError(new Error("No data received"));
    }, e.onerror = (i) => {
      this.onError(this._getErrorFromErrorEvent(i)), this.terminated = !0;
    }, e.onmessageerror = (i) => console.error(i), e;
  }
  /**
   * Creates a worker thread in node.js
   * @todo https://nodejs.org/api/async_hooks.html#async-resource-worker-pool
   */
  _createNodeWorker() {
    let e;
    if (this.url) {
      const s = this.url.includes(":/") || this.url.startsWith("/") ? this.url : `./${this.url}`;
      e = new tg(s, { eval: !1 });
    } else if (this.source)
      e = new tg(this.source, { eval: !0 });
    else
      throw new Error("no worker");
    return e.on("message", (i) => {
      this.onMessage(i);
    }), e.on("error", (i) => {
      this.onError(i);
    }), e.on("exit", (i) => {
    }), e;
  }
}
class zC {
  name = "unnamed";
  source;
  // | Function;
  url;
  maxConcurrency = 1;
  maxMobileConcurrency = 1;
  onDebug = () => {
  };
  reuseWorkers = !0;
  props = {};
  jobQueue = [];
  idleQueue = [];
  count = 0;
  isDestroyed = !1;
  /** Checks if workers are supported on this platform */
  static isSupported() {
    return sm.isSupported();
  }
  /**
   * @param processor - worker function
   * @param maxConcurrency - max count of workers
   */
  constructor(e) {
    this.source = e.source, this.url = e.url, this.setProps(e);
  }
  /**
   * Terminates all workers in the pool
   * @note Can free up significant memory
   */
  destroy() {
    this.idleQueue.forEach((e) => e.destroy()), this.isDestroyed = !0;
  }
  setProps(e) {
    this.props = { ...this.props, ...e }, e.name !== void 0 && (this.name = e.name), e.maxConcurrency !== void 0 && (this.maxConcurrency = e.maxConcurrency), e.maxMobileConcurrency !== void 0 && (this.maxMobileConcurrency = e.maxMobileConcurrency), e.reuseWorkers !== void 0 && (this.reuseWorkers = e.reuseWorkers), e.onDebug !== void 0 && (this.onDebug = e.onDebug);
  }
  async startJob(e, i = (o, u, d) => o.done(d), s = (o, u) => o.error(u)) {
    const o = new Promise((u) => (this.jobQueue.push({ name: e, onMessage: i, onError: s, onStart: u }), this));
    return this._startQueuedJob(), await o;
  }
  // PRIVATE
  /**
   * Starts first queued job if worker is available or can be created
   * Called when job is started and whenever a worker returns to the idleQueue
   */
  async _startQueuedJob() {
    if (!this.jobQueue.length)
      return;
    const e = this._getAvailableWorker();
    if (!e)
      return;
    const i = this.jobQueue.shift();
    if (i) {
      this.onDebug({
        message: "Starting job",
        name: i.name,
        workerThread: e,
        backlog: this.jobQueue.length
      });
      const s = new kC(i.name, e);
      e.onMessage = (o) => i.onMessage(s, o.type, o.payload), e.onError = (o) => i.onError(s, o), i.onStart(s);
      try {
        await s.result;
      } catch (o) {
        console.error(`Worker exception: ${o}`);
      } finally {
        this.returnWorkerToQueue(e);
      }
    }
  }
  /**
   * Returns a worker to the idle queue
   * Destroys the worker if
   *  - pool is destroyed
   *  - if this pool doesn't reuse workers
   *  - if maxConcurrency has been lowered
   * @param worker
   */
  returnWorkerToQueue(e) {
    // Workers on Node.js prevent the process from exiting.
    // Until we figure out how to close them before exit, we always destroy them
    !dn || // If the pool is destroyed, there is no reason to keep the worker around
    this.isDestroyed || // If the app has disabled worker reuse, any completed workers should be destroyed
    !this.reuseWorkers || // If concurrency has been lowered, this worker might be surplus to requirements
    this.count > this._getMaxConcurrency() ? (e.destroy(), this.count--) : this.idleQueue.push(e), this.isDestroyed || this._startQueuedJob();
  }
  /**
   * Returns idle worker or creates new worker if maxConcurrency has not been reached
   */
  _getAvailableWorker() {
    if (this.idleQueue.length > 0)
      return this.idleQueue.shift() || null;
    if (this.count < this._getMaxConcurrency()) {
      this.count++;
      const e = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;
      return new sm({ name: e, source: this.source, url: this.url });
    }
    return null;
  }
  _getMaxConcurrency() {
    return FC ? this.maxMobileConcurrency : this.maxConcurrency;
  }
}
const VC = {
  maxConcurrency: 3,
  maxMobileConcurrency: 1,
  reuseWorkers: !0,
  onDebug: () => {
  }
};
class ba {
  props;
  workerPools = /* @__PURE__ */ new Map();
  // singleton
  static _workerFarm;
  /** Checks if workers are supported on this platform */
  static isSupported() {
    return sm.isSupported();
  }
  /** Get the singleton instance of the global worker farm */
  static getWorkerFarm(e = {}) {
    return ba._workerFarm = ba._workerFarm || new ba({}), ba._workerFarm.setProps(e), ba._workerFarm;
  }
  /** get global instance with WorkerFarm.getWorkerFarm() */
  constructor(e) {
    this.props = { ...VC }, this.setProps(e), this.workerPools = /* @__PURE__ */ new Map();
  }
  /**
   * Terminate all workers in the farm
   * @note Can free up significant memory
   */
  destroy() {
    for (const e of this.workerPools.values())
      e.destroy();
    this.workerPools = /* @__PURE__ */ new Map();
  }
  /**
   * Set props used when initializing worker pools
   * @param props
   */
  setProps(e) {
    this.props = { ...this.props, ...e };
    for (const i of this.workerPools.values())
      i.setProps(this._getWorkerPoolProps());
  }
  /**
   * Returns a worker pool for the specified worker
   * @param options - only used first time for a specific worker name
   * @param options.name - the name of the worker - used to identify worker pool
   * @param options.url -
   * @param options.source -
   * @example
   *   const job = WorkerFarm.getWorkerFarm().getWorkerPool({name, url}).startJob(...);
   */
  getWorkerPool(e) {
    const { name: i, source: s, url: o } = e;
    let u = this.workerPools.get(i);
    return u || (u = new zC({
      name: i,
      source: s,
      url: o
    }), u.setProps(this._getWorkerPoolProps()), this.workerPools.set(i, u)), u;
  }
  _getWorkerPoolProps() {
    return {
      maxConcurrency: this.props.maxConcurrency,
      maxMobileConcurrency: this.props.maxMobileConcurrency,
      reuseWorkers: this.props.reuseWorkers,
      onDebug: this.props.onDebug
    };
  }
}
function jC(t, e = {}) {
  const i = e[t.id] || {}, s = dn ? `${t.id}-worker.js` : `${t.id}-worker-node.js`;
  let o = i.workerUrl;
  if (!o && t.id === "compression" && (o = e.workerUrl), e._workerType === "test" && (dn ? o = `modules/${t.module}/dist/${s}` : o = `modules/${t.module}/src/workers/${t.id}-worker-node.ts`), !o) {
    let u = t.version;
    u === "latest" && (u = DC);
    const d = u ? `@${u}` : "";
    o = `https://unpkg.com/@loaders.gl/${t.module}${d}/dist/${s}`;
  }
  return ko(o), o;
}
function HC(t, e = nw) {
  ko(t, "no worker provided");
  const i = t.version;
  return !(!e || !i);
}
const sg = {};
async function El(t, e = null, i = {}, s = null) {
  return e && (t = $C(t, e, i, s)), sg[t] = // eslint-disable-next-line @typescript-eslint/no-misused-promises
  sg[t] || GC(t), await sg[t];
}
function $C(t, e, i = {}, s = null) {
  if (!i.useLocalLibraries && t.startsWith("http"))
    return t;
  s = s || t;
  const o = i.modules || {};
  return o[s] ? o[s] : dn ? i.CDN ? (ko(i.CDN.startsWith("http")), `${i.CDN}/${e}@${nw}/dist/libs/${s}`) : Zm ? `../src/libs/${s}` : `modules/${e}/src/libs/${s}` : `modules/${e}/dist/libs/${s}`;
}
async function GC(t) {
  if (t.endsWith("wasm"))
    return await XC(t);
  if (!dn)
    try {
      const { requireFromFile: i } = globalThis.loaders || {};
      return await i?.(t);
    } catch (i) {
      return console.error(i), null;
    }
  if (Zm)
    return importScripts(t);
  const e = await qC(t);
  return WC(e, t);
}
function WC(t, e) {
  if (!dn) {
    const { requireFromString: s } = globalThis.loaders || {};
    return s?.(t, e);
  }
  if (Zm)
    return eval.call(globalThis, t), null;
  const i = document.createElement("script");
  i.id = e;
  try {
    i.appendChild(document.createTextNode(t));
  } catch {
    i.text = t;
  }
  return document.body.appendChild(i), null;
}
async function XC(t) {
  const { readFileAsArrayBuffer: e } = globalThis.loaders || {};
  return dn || !e || t.startsWith("http") ? await (await fetch(t)).arrayBuffer() : await e(t);
}
async function qC(t) {
  const { readFileAsText: e } = globalThis.loaders || {};
  return dn || !e || t.startsWith("http") ? await (await fetch(t)).text() : await e(t);
}
function ZC(t, e) {
  return !ba.isSupported() || !dn && !e?._nodeWorkers ? !1 : t.worker && e?.worker;
}
async function KC(t, e, i, s, o) {
  const u = t.id, d = jC(t, i), w = ba.getWorkerFarm(i).getWorkerPool({ name: u, url: d });
  i = JSON.parse(JSON.stringify(i)), s = JSON.parse(JSON.stringify(s || {}));
  const S = await w.startJob(
    "process-on-worker",
    // @ts-expect-error
    YC.bind(null, o)
    // eslint-disable-line @typescript-eslint/no-misused-promises
  );
  return S.postMessage("process", {
    // @ts-ignore
    input: e,
    options: i,
    context: s
  }), await (await S.result).result;
}
async function YC(t, e, i, s) {
  switch (i) {
    case "done":
      e.done(s);
      break;
    case "error":
      e.error(new Error(s.error));
      break;
    case "process":
      const { id: o, input: u, options: d } = s;
      try {
        const a = await t(u, d);
        e.postMessage("done", { id: o, result: a });
      } catch (a) {
        const w = a instanceof Error ? a.message : "unknown error";
        e.postMessage("error", { id: o, error: w });
      }
      break;
    default:
      console.warn(`parse-with-worker unknown message ${i}`);
  }
}
function JC(t, e = 5) {
  return typeof t == "string" ? t.slice(0, e) : ArrayBuffer.isView(t) ? X0(t.buffer, t.byteOffset, e) : t instanceof ArrayBuffer ? X0(t, 0, e) : "";
}
function X0(t, e, i) {
  if (t.byteLength <= e + i)
    return "";
  const s = new DataView(t);
  let o = "";
  for (let u = 0; u < i; u++)
    o += String.fromCharCode(s.getUint8(e + u));
  return o;
}
function QC(t) {
  try {
    return JSON.parse(t);
  } catch {
    throw new Error(`Failed to parse JSON from data starting with "${JC(t)}"`);
  }
}
function e2(t, e, i) {
  if (i = i || t.byteLength, t.byteLength < i || e.byteLength < i)
    return !1;
  const s = new Uint8Array(t), o = new Uint8Array(e);
  for (let u = 0; u < s.length; ++u)
    if (s[u] !== o[u])
      return !1;
  return !0;
}
function t2(...t) {
  return i2(t);
}
function i2(t) {
  const e = t.map((u) => u instanceof ArrayBuffer ? new Uint8Array(u) : u), i = e.reduce((u, d) => u + d.byteLength, 0), s = new Uint8Array(i);
  let o = 0;
  for (const u of e)
    s.set(u, o), o += u.byteLength;
  return s.buffer;
}
function Km(t, e, i) {
  const s = i !== void 0 ? new Uint8Array(t).subarray(e, e + i) : new Uint8Array(t).subarray(e);
  return new Uint8Array(s).buffer;
}
function sd(t, e) {
  return mi(t >= 0), mi(e > 0), t + (e - 1) & -4;
}
function r2(t, e, i) {
  let s;
  if (t instanceof ArrayBuffer)
    s = new Uint8Array(t);
  else {
    const o = t.byteOffset, u = t.byteLength;
    s = new Uint8Array(t.buffer || t.arrayBuffer, o, u);
  }
  return e.set(s, i), i + sd(s.byteLength, 4);
}
async function s2(t) {
  const e = [];
  for await (const i of t)
    e.push(i);
  return t2(...e);
}
function q0() {
  let t;
  if (typeof window < "u" && window.performance)
    t = window.performance.now();
  else if (typeof process < "u" && process.hrtime) {
    const e = process.hrtime();
    t = e[0] * 1e3 + e[1] / 1e6;
  } else
    t = Date.now();
  return t;
}
class Z0 {
  constructor(e, i) {
    this.sampleSize = 1, this.time = 0, this.count = 0, this.samples = 0, this.lastTiming = 0, this.lastSampleTime = 0, this.lastSampleCount = 0, this._count = 0, this._time = 0, this._samples = 0, this._startTime = 0, this._timerPending = !1, this.name = e, this.type = i, this.reset();
  }
  reset() {
    return this.time = 0, this.count = 0, this.samples = 0, this.lastTiming = 0, this.lastSampleTime = 0, this.lastSampleCount = 0, this._count = 0, this._time = 0, this._samples = 0, this._startTime = 0, this._timerPending = !1, this;
  }
  setSampleSize(e) {
    return this.sampleSize = e, this;
  }
  /** Call to increment count (+1) */
  incrementCount() {
    return this.addCount(1), this;
  }
  /** Call to decrement count (-1) */
  decrementCount() {
    return this.subtractCount(1), this;
  }
  /** Increase count */
  addCount(e) {
    return this._count += e, this._samples++, this._checkSampling(), this;
  }
  /** Decrease count */
  subtractCount(e) {
    return this._count -= e, this._samples++, this._checkSampling(), this;
  }
  /** Add an arbitrary timing and bump the count */
  addTime(e) {
    return this._time += e, this.lastTiming = e, this._samples++, this._checkSampling(), this;
  }
  /** Start a timer */
  timeStart() {
    return this._startTime = q0(), this._timerPending = !0, this;
  }
  /** End a timer. Adds to time and bumps the timing count. */
  timeEnd() {
    return this._timerPending ? (this.addTime(q0() - this._startTime), this._timerPending = !1, this._checkSampling(), this) : this;
  }
  getSampleAverageCount() {
    return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
  }
  /** Calculate average time / count for the previous window */
  getSampleAverageTime() {
    return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
  }
  /** Calculate counts per second for the previous window */
  getSampleHz() {
    return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1e3) : 0;
  }
  getAverageCount() {
    return this.samples > 0 ? this.count / this.samples : 0;
  }
  /** Calculate average time / count */
  getAverageTime() {
    return this.samples > 0 ? this.time / this.samples : 0;
  }
  /** Calculate counts per second */
  getHz() {
    return this.time > 0 ? this.samples / (this.time / 1e3) : 0;
  }
  _checkSampling() {
    this._samples === this.sampleSize && (this.lastSampleTime = this._time, this.lastSampleCount = this._count, this.count += this._count, this.time += this._time, this.samples += this._samples, this._time = 0, this._count = 0, this._samples = 0);
  }
}
class _h {
  constructor(e) {
    this.stats = {}, this.id = e.id, this.stats = {}, this._initializeStats(e.stats), Object.seal(this);
  }
  /** Acquire a stat. Create if it doesn't exist. */
  get(e, i = "count") {
    return this._getOrCreate({ name: e, type: i });
  }
  get size() {
    return Object.keys(this.stats).length;
  }
  /** Reset all stats */
  reset() {
    for (const e of Object.values(this.stats))
      e.reset();
    return this;
  }
  forEach(e) {
    for (const i of Object.values(this.stats))
      e(i);
  }
  getTable() {
    const e = {};
    return this.forEach((i) => {
      e[i.name] = {
        time: i.time || 0,
        count: i.count || 0,
        average: i.getAverageTime() || 0,
        hz: i.getHz() || 0
      };
    }), e;
  }
  _initializeStats(e = []) {
    e.forEach((i) => this._getOrCreate(i));
  }
  _getOrCreate(e) {
    const { name: i, type: s } = e;
    let o = this.stats[i];
    return o || (e instanceof Z0 ? o = e : o = new Z0(i, s), this.stats[i] = o), o;
  }
}
const n2 = "Queued Requests", o2 = "Active Requests", a2 = "Cancelled Requests", l2 = "Queued Requests Ever", c2 = "Active Requests Ever", h2 = {
  id: "request-scheduler",
  /** Specifies if the request scheduler should throttle incoming requests, mainly for comparative testing. */
  throttleRequests: !0,
  /** The maximum number of simultaneous active requests. Un-throttled requests do not observe this limit. */
  maxRequests: 6,
  /**
   * Specifies a debounce time, in milliseconds. All requests are queued, until no new requests have
   * been added to the queue for this amount of time.
   */
  debounceTime: 0
};
class u2 {
  props;
  stats;
  activeRequestCount = 0;
  /** Tracks the number of active requests and prioritizes/cancels queued requests. */
  requestQueue = [];
  requestMap = /* @__PURE__ */ new Map();
  updateTimer = null;
  constructor(e = {}) {
    this.props = { ...h2, ...e }, this.stats = new _h({ id: this.props.id }), this.stats.get(n2), this.stats.get(o2), this.stats.get(a2), this.stats.get(l2), this.stats.get(c2);
  }
  /**
   * Called by an application that wants to issue a request, without having it deeply queued by the browser
   *
   * When the returned promise resolved, it is OK for the application to issue a request.
   * The promise resolves to an object that contains a `done` method.
   * When the application's request has completed (or failed), the application must call the `done` function
   *
   * @param handle
   * @param getPriority will be called when request "slots" open up,
   *    allowing the caller to update priority or cancel the request
   *    Highest priority executes first, priority < 0 cancels the request
   * @returns a promise
   *   - resolves to a object (with a `done` field) when the request can be issued without queueing,
   *   - resolves to `null` if the request has been cancelled (by the callback return < 0).
   *     In this case the application should not issue the request
   */
  scheduleRequest(e, i = () => 0) {
    if (!this.props.throttleRequests)
      return Promise.resolve({ done: () => {
      } });
    if (this.requestMap.has(e))
      return this.requestMap.get(e);
    const s = { handle: e, priority: 0, getPriority: i }, o = new Promise((u) => (s.resolve = u, s));
    return this.requestQueue.push(s), this.requestMap.set(e, o), this._issueNewRequests(), o;
  }
  // PRIVATE
  _issueRequest(e) {
    const { handle: i, resolve: s } = e;
    let o = !1;
    const u = () => {
      o || (o = !0, this.requestMap.delete(i), this.activeRequestCount--, this._issueNewRequests());
    };
    return this.activeRequestCount++, s ? s({ done: u }) : Promise.resolve({ done: u });
  }
  /** We check requests asynchronously, to prevent multiple updates */
  _issueNewRequests() {
    this.updateTimer !== null && clearTimeout(this.updateTimer), this.updateTimer = setTimeout(() => this._issueNewRequestsAsync(), this.props.debounceTime);
  }
  /** Refresh all requests  */
  _issueNewRequestsAsync() {
    this.updateTimer !== null && clearTimeout(this.updateTimer), this.updateTimer = null;
    const e = Math.max(this.props.maxRequests - this.activeRequestCount, 0);
    if (e !== 0) {
      this._updateAllRequests();
      for (let i = 0; i < e; ++i) {
        const s = this.requestQueue.shift();
        s && this._issueRequest(s);
      }
    }
  }
  /** Ensure all requests have updated priorities, and that no longer valid requests are cancelled */
  _updateAllRequests() {
    const e = this.requestQueue;
    for (let i = 0; i < e.length; ++i) {
      const s = e[i];
      this._updateRequest(s) || (e.splice(i, 1), this.requestMap.delete(s.handle), i--);
    }
    e.sort((i, s) => i.priority - s.priority);
  }
  /** Update a single request by calling the callback */
  _updateRequest(e) {
    return e.priority = e.getPriority(e.handle), e.priority < 0 ? (e.resolve(null), !1) : !0;
  }
}
let d2 = "";
const K0 = {};
function f2(t) {
  for (const e in K0)
    if (t.startsWith(e)) {
      const i = K0[e];
      t = t.replace(e, i);
    }
  return !t.startsWith("http://") && !t.startsWith("https://") && (t = `${d2}${t}`), t;
}
function p2(t) {
  return t && typeof t == "object" && t.isBuffer;
}
function lw(t) {
  if (p2(t))
    return t;
  if (t instanceof ArrayBuffer)
    return t;
  if (ArrayBuffer.isView(t))
    return t.byteOffset === 0 && t.byteLength === t.buffer.byteLength ? t.buffer : t.buffer.slice(t.byteOffset, t.byteOffset + t.byteLength);
  if (typeof t == "string") {
    const e = t;
    return new TextEncoder().encode(e).buffer;
  }
  if (t && typeof t == "object" && t._toArrayBuffer)
    return t._toArrayBuffer();
  throw new Error("toArrayBuffer");
}
function _2() {
  if (typeof process < "u" && typeof process.cwd < "u")
    return process.cwd();
  const t = window.location?.pathname;
  return t?.slice(0, t.lastIndexOf("/") + 1) || "";
}
function cw(t) {
  const e = t ? t.lastIndexOf("/") : -1;
  return e >= 0 ? t.substr(e + 1) : "";
}
function Ym(t) {
  const e = t ? t.lastIndexOf("/") : -1;
  return e >= 0 ? t.substr(0, e) : "";
}
function g2(...t) {
  const e = [];
  for (let u = 0; u < t.length; u++)
    e[u] = t[u];
  let i = "", s = !1, o;
  for (let u = e.length - 1; u >= -1 && !s; u--) {
    let d;
    u >= 0 ? d = e[u] : (o === void 0 && (o = _2()), d = o), d.length !== 0 && (i = `${d}/${i}`, s = d.charCodeAt(0) === Du);
  }
  return i = m2(i, !s), s ? `/${i}` : i.length > 0 ? i : ".";
}
const Du = 47, ng = 46;
function m2(t, e) {
  let i = "", s = -1, o = 0, u, d = !1;
  for (let a = 0; a <= t.length; ++a) {
    if (a < t.length)
      u = t.charCodeAt(a);
    else {
      if (u === Du)
        break;
      u = Du;
    }
    if (u === Du) {
      if (!(s === a - 1 || o === 1)) if (s !== a - 1 && o === 2) {
        if (i.length < 2 || !d || i.charCodeAt(i.length - 1) !== ng || i.charCodeAt(i.length - 2) !== ng) {
          if (i.length > 2) {
            const w = i.length - 1;
            let S = w;
            for (; S >= 0 && i.charCodeAt(S) !== Du; --S)
              ;
            if (S !== w) {
              i = S === -1 ? "" : i.slice(0, S), s = a, o = 0, d = !1;
              continue;
            }
          } else if (i.length === 2 || i.length === 1) {
            i = "", s = a, o = 0, d = !1;
            continue;
          }
        }
        e && (i.length > 0 ? i += "/.." : i = "..", d = !0);
      } else {
        const w = t.slice(s + 1, a);
        i.length > 0 ? i += `/${w}` : i = w, d = !1;
      }
      s = a, o = 0;
    } else u === ng && o !== -1 ? ++o : o = -1;
  }
  return i;
}
const y2 = (t) => typeof t == "boolean", Uu = (t) => typeof t == "function", nd = (t) => t !== null && typeof t == "object", Y0 = (t) => nd(t) && t.constructor === {}.constructor, b2 = (t) => !!t && typeof t[Symbol.iterator] == "function", v2 = (t) => t && typeof t[Symbol.asyncIterator] == "function", Pl = (t) => typeof Response < "u" && t instanceof Response || t && t.arrayBuffer && t.text && t.json, Bl = (t) => typeof Blob < "u" && t instanceof Blob, x2 = (t) => t && typeof t == "object" && t.isBuffer, w2 = (t) => typeof ReadableStream < "u" && t instanceof ReadableStream || nd(t) && Uu(t.tee) && Uu(t.cancel) && Uu(t.getReader), T2 = (t) => nd(t) && Uu(t.read) && Uu(t.pipe) && y2(t.readable), hw = (t) => w2(t) || T2(t);
class A2 extends Error {
  constructor(e, i) {
    super(e), this.reason = i.reason, this.url = i.url, this.response = i.response;
  }
  /** A best effort reason for why the fetch failed */
  reason;
  /** The URL that failed to load. Empty string if not available. */
  url;
  /** The Response object, if any. */
  response;
}
const E2 = /^data:([-\w.]+\/[-\w.+]+)(;|,)/, S2 = /^([-\w.]+\/[-\w.+]+)/;
function J0(t, e) {
  return t.toLowerCase() === e.toLowerCase();
}
function C2(t) {
  const e = S2.exec(t);
  return e ? e[1] : t;
}
function Q0(t) {
  const e = E2.exec(t);
  return e ? e[1] : "";
}
const uw = /\?.*/;
function I2(t) {
  const e = t.match(uw);
  return e && e[0];
}
function Jm(t) {
  return t.replace(uw, "");
}
function M2(t) {
  if (t.length < 50)
    return t;
  const e = t.slice(t.length - 15);
  return `${t.substr(0, 32)}...${e}`;
}
function Ep(t) {
  return Pl(t) ? t.url : Bl(t) ? t.name || "" : typeof t == "string" ? t : "";
}
function Qm(t) {
  if (Pl(t)) {
    const e = t, i = e.headers.get("content-type") || "", s = Jm(e.url);
    return C2(i) || Q0(s);
  }
  return Bl(t) ? t.type || "" : typeof t == "string" ? Q0(t) : "";
}
function R2(t) {
  return Pl(t) ? t.headers["content-length"] || -1 : Bl(t) ? t.size : typeof t == "string" ? t.length : t instanceof ArrayBuffer || ArrayBuffer.isView(t) ? t.byteLength : -1;
}
async function dw(t) {
  if (Pl(t))
    return t;
  const e = {}, i = R2(t);
  i >= 0 && (e["content-length"] = String(i));
  const s = Ep(t), o = Qm(t);
  o && (e["content-type"] = o);
  const u = await D2(t);
  u && (e["x-first-bytes"] = u), typeof t == "string" && (t = new TextEncoder().encode(t));
  const d = new Response(t, { headers: e });
  return Object.defineProperty(d, "url", { value: s }), d;
}
async function P2(t) {
  if (!t.ok)
    throw await B2(t);
}
async function B2(t) {
  const e = M2(t.url);
  let i = `Failed to fetch resource (${t.status}) ${t.statusText}: ${e}`;
  i = i.length > 100 ? `${i.slice(0, 100)}...` : i;
  const s = {
    reason: t.statusText,
    url: t.url,
    response: t
  };
  try {
    const o = t.headers.get("Content-Type");
    s.reason = !t.bodyUsed && o?.includes("application/json") ? await t.json() : await t.text();
  } catch {
  }
  return new A2(i, s);
}
async function D2(t) {
  if (typeof t == "string")
    return `data:,${t.slice(0, 5)}`;
  if (t instanceof Blob) {
    const i = t.slice(0, 5);
    return await new Promise((s) => {
      const o = new FileReader();
      o.onload = (u) => s(u?.target?.result), o.readAsDataURL(i);
    });
  }
  if (t instanceof ArrayBuffer) {
    const i = t.slice(0, 5);
    return `data:base64,${O2(i)}`;
  }
  return null;
}
function O2(t) {
  let e = "";
  const i = new Uint8Array(t);
  for (let s = 0; s < i.byteLength; s++)
    e += String.fromCharCode(i[s]);
  return btoa(e);
}
function F2(t) {
  return !k2(t) && !N2(t);
}
function k2(t) {
  return t.startsWith("http:") || t.startsWith("https:");
}
function N2(t) {
  return t.startsWith("data:");
}
async function ev(t, e) {
  if (typeof t == "string") {
    const i = f2(t);
    return F2(i) && globalThis.loaders?.fetchNode ? globalThis.loaders?.fetchNode(i, e) : await fetch(i, e);
  }
  return await dw(t);
}
const tv = new ph({ id: "loaders.gl" });
class L2 {
  log() {
    return () => {
    };
  }
  info() {
    return () => {
    };
  }
  warn() {
    return () => {
    };
  }
  error() {
    return () => {
    };
  }
}
class U2 {
  console;
  constructor() {
    this.console = console;
  }
  log(...e) {
    return this.console.log.bind(this.console, ...e);
  }
  info(...e) {
    return this.console.info.bind(this.console, ...e);
  }
  warn(...e) {
    return this.console.warn.bind(this.console, ...e);
  }
  error(...e) {
    return this.console.error.bind(this.console, ...e);
  }
}
const fw = {
  // baseUri
  fetch: null,
  mimeType: void 0,
  nothrow: !1,
  log: new U2(),
  // A probe.gl compatible (`log.log()()` syntax) that just logs to console
  useLocalLibraries: !1,
  CDN: "https://unpkg.com/@loaders.gl",
  worker: !0,
  // By default, use worker if provided by loader.
  maxConcurrency: 3,
  // How many worker instances should be created for each loader.
  maxMobileConcurrency: 1,
  // How many worker instances should be created for each loader on mobile devices.
  reuseWorkers: Ap,
  // By default reuse workers in browser (Node.js refuses to terminate if browsers are running)
  _nodeWorkers: !1,
  // By default do not support node workers
  _workerType: "",
  // 'test' to use locally generated workers
  limit: 0,
  _limitMB: 0,
  batchSize: "auto",
  batchDebounceMs: 0,
  metadata: !1,
  // TODO - currently only implemented for parseInBatches, adds initial metadata batch,
  transforms: []
}, z2 = {
  throws: "nothrow",
  dataType: "(no longer used)",
  uri: "baseUri",
  // Warn if fetch options are used on top-level
  method: "fetch.method",
  headers: "fetch.headers",
  body: "fetch.body",
  mode: "fetch.mode",
  credentials: "fetch.credentials",
  cache: "fetch.cache",
  redirect: "fetch.redirect",
  referrer: "fetch.referrer",
  referrerPolicy: "fetch.referrerPolicy",
  integrity: "fetch.integrity",
  keepalive: "fetch.keepalive",
  signal: "fetch.signal"
};
function pw() {
  globalThis.loaders = globalThis.loaders || {};
  const { loaders: t } = globalThis;
  return t._state || (t._state = {}), t._state;
}
function _w() {
  const t = pw();
  return t.globalOptions = t.globalOptions || { ...fw }, t.globalOptions;
}
function V2(t, e, i, s) {
  return i = i || [], i = Array.isArray(i) ? i : [i], j2(t, i), $2(e, t, s);
}
function j2(t, e) {
  iv(t, null, fw, z2, e);
  for (const i of e) {
    const s = t && t[i.id] || {}, o = i.options && i.options[i.id] || {}, u = i.deprecatedOptions && i.deprecatedOptions[i.id] || {};
    iv(s, i.id, o, u, e);
  }
}
function iv(t, e, i, s, o) {
  const u = e || "Top level", d = e ? `${e}.` : "";
  for (const a in t) {
    const w = !e && nd(t[a]), S = a === "baseUri" && !e, M = a === "workerUrl" && e;
    if (!(a in i) && !S && !M) {
      if (a in s)
        tv.warn(`${u} loader option '${d}${a}' no longer supported, use '${s[a]}'`)();
      else if (!w) {
        const F = H2(a, o);
        tv.warn(`${u} loader option '${d}${a}' not recognized. ${F}`)();
      }
    }
  }
}
function H2(t, e) {
  const i = t.toLowerCase();
  let s = "";
  for (const o of e)
    for (const u in o.options) {
      if (t === u)
        return `Did you mean '${o.id}.${u}'?`;
      const d = u.toLowerCase();
      (i.startsWith(d) || d.startsWith(i)) && (s = s || `Did you mean '${o.id}.${u}'?`);
    }
  return s;
}
function $2(t, e, i) {
  const o = { ...t.options || {} };
  return G2(o, i), o.log === null && (o.log = new L2()), rv(o, _w()), rv(o, e), o;
}
function rv(t, e) {
  for (const i in e)
    if (i in e) {
      const s = e[i];
      Y0(s) && Y0(t[i]) ? t[i] = {
        ...t[i],
        ...e[i]
      } : t[i] = e[i];
    }
}
function G2(t, e) {
  e && !("baseUri" in t) && (t.baseUri = e);
}
function ey(t) {
  return t ? (Array.isArray(t) && (t = t[0]), Array.isArray(t?.extensions)) : !1;
}
function ty(t) {
  mi(t, "null loader"), mi(ey(t), "invalid loader");
  let e;
  return Array.isArray(t) && (e = t[1], t = t[0], t = {
    ...t,
    options: { ...t.options, ...e }
  }), (t?.parseTextSync || t?.parseText) && (t.text = !0), t.text || (t.binary = !0), t;
}
const gw = () => {
  const t = pw();
  return t.loaderRegistry = t.loaderRegistry || [], t.loaderRegistry;
};
function W2(t) {
  const e = gw();
  t = Array.isArray(t) ? t : [t];
  for (const i of t) {
    const s = ty(i);
    e.find((o) => s === o) || e.unshift(s);
  }
}
function X2() {
  return gw();
}
const q2 = /\.([^.]+)$/;
async function Z2(t, e = [], i, s) {
  if (!mw(t))
    return null;
  let o = sv(t, e, { ...i, nothrow: !0 }, s);
  if (o)
    return o;
  if (Bl(t) && (t = await t.slice(0, 10).arrayBuffer(), o = sv(t, e, i, s)), !o && !i?.nothrow)
    throw new Error(yw(t));
  return o;
}
function sv(t, e = [], i, s) {
  if (!mw(t))
    return null;
  if (e && !Array.isArray(e))
    return ty(e);
  let o = [];
  e && (o = o.concat(e)), i?.ignoreRegisteredLoaders || o.push(...X2()), Y2(o);
  const u = K2(t, o, i, s);
  if (!u && !i?.nothrow)
    throw new Error(yw(t));
  return u;
}
function K2(t, e, i, s) {
  const o = Ep(t), u = Qm(t), d = Jm(o) || s?.url;
  let a = null, w = "";
  return i?.mimeType && (a = og(e, i?.mimeType), w = `match forced by supplied MIME type ${i?.mimeType}`), a = a || J2(e, d), w = w || (a ? `matched url ${d}` : ""), a = a || og(e, u), w = w || (a ? `matched MIME type ${u}` : ""), a = a || eI(e, t), w = w || (a ? `matched initial data ${bw(t)}` : ""), i?.fallbackMimeType && (a = a || og(e, i?.fallbackMimeType), w = w || (a ? `matched fallback MIME type ${u}` : "")), w && MC.log(1, `selectLoader selected ${a?.name}: ${w}.`), a;
}
function mw(t) {
  return !(t instanceof Response && t.status === 204);
}
function yw(t) {
  const e = Ep(t), i = Qm(t);
  let s = "No valid loader found (";
  s += e ? `${cw(e)}, ` : "no url provided, ", s += `MIME type: ${i ? `"${i}"` : "not provided"}, `;
  const o = t ? bw(t) : "";
  return s += o ? ` first bytes: "${o}"` : "first bytes: not available", s += ")", s;
}
function Y2(t) {
  for (const e of t)
    ty(e);
}
function J2(t, e) {
  const i = e && q2.exec(e), s = i && i[1];
  return s ? Q2(t, s) : null;
}
function Q2(t, e) {
  e = e.toLowerCase();
  for (const i of t)
    for (const s of i.extensions)
      if (s.toLowerCase() === e)
        return i;
  return null;
}
function og(t, e) {
  for (const i of t)
    if (i.mimeTypes?.some((s) => J0(e, s)) || J0(e, `application/x.${i.id}`))
      return i;
  return null;
}
function eI(t, e) {
  if (!e)
    return null;
  for (const i of t)
    if (typeof e == "string") {
      if (tI(e, i))
        return i;
    } else if (ArrayBuffer.isView(e)) {
      if (nv(e.buffer, e.byteOffset, i))
        return i;
    } else if (e instanceof ArrayBuffer && nv(e, 0, i))
      return i;
  return null;
}
function tI(t, e) {
  return e.testText ? e.testText(t) : (Array.isArray(e.tests) ? e.tests : [e.tests]).some((s) => t.startsWith(s));
}
function nv(t, e, i) {
  return (Array.isArray(i.tests) ? i.tests : [i.tests]).some((o) => iI(t, e, i, o));
}
function iI(t, e, i, s) {
  if (s instanceof ArrayBuffer)
    return e2(s, t, s.byteLength);
  switch (typeof s) {
    case "function":
      return s(t);
    case "string":
      const o = nm(t, e, s.length);
      return s === o;
    default:
      return !1;
  }
}
function bw(t, e = 5) {
  return typeof t == "string" ? t.slice(0, e) : ArrayBuffer.isView(t) ? nm(t.buffer, t.byteOffset, e) : t instanceof ArrayBuffer ? nm(t, 0, e) : "";
}
function nm(t, e, i) {
  if (t.byteLength < e + i)
    return "";
  const s = new DataView(t);
  let o = "";
  for (let u = 0; u < i; u++)
    o += String.fromCharCode(s.getUint8(e + u));
  return o;
}
const rI = 256 * 1024;
function* sI(t, e) {
  const i = e?.chunkSize || rI;
  let s = 0;
  const o = new TextEncoder();
  for (; s < t.length; ) {
    const u = Math.min(t.length - s, i), d = t.slice(s, s + u);
    s += u, yield o.encode(d);
  }
}
const nI = 256 * 1024;
function* oI(t, e = {}) {
  const { chunkSize: i = nI } = e;
  let s = 0;
  for (; s < t.byteLength; ) {
    const o = Math.min(t.byteLength - s, i), u = new ArrayBuffer(o), d = new Uint8Array(t, s, o);
    new Uint8Array(u).set(d), s += o, yield u;
  }
}
const aI = 1024 * 1024;
async function* lI(t, e) {
  const i = e?.chunkSize || aI;
  let s = 0;
  for (; s < t.size; ) {
    const o = s + i, u = await t.slice(s, o).arrayBuffer();
    s = o, yield u;
  }
}
function ov(t, e) {
  return Ap ? cI(t, e) : hI(t);
}
async function* cI(t, e) {
  const i = t.getReader();
  let s;
  try {
    for (; ; ) {
      const o = s || i.read();
      e?._streamReadAhead && (s = i.read());
      const { done: u, value: d } = await o;
      if (u)
        return;
      yield lw(d);
    }
  } catch {
    i.releaseLock();
  }
}
async function* hI(t, e) {
  for await (const i of t)
    yield lw(i);
}
function uI(t, e) {
  if (typeof t == "string")
    return sI(t, e);
  if (t instanceof ArrayBuffer)
    return oI(t, e);
  if (Bl(t))
    return lI(t, e);
  if (hw(t))
    return ov(t, e);
  if (Pl(t))
    return ov(t.body, e);
  throw new Error("makeIterator");
}
const vw = "Cannot convert supplied data type";
function dI(t, e, i) {
  if (e.text && typeof t == "string")
    return t;
  if (x2(t) && (t = t.buffer), t instanceof ArrayBuffer) {
    const s = t;
    return e.text && !e.binary ? new TextDecoder("utf8").decode(s) : s;
  }
  if (ArrayBuffer.isView(t)) {
    if (e.text && !e.binary)
      return new TextDecoder("utf8").decode(t);
    let s = t.buffer;
    const o = t.byteLength || t.length;
    return (t.byteOffset !== 0 || o !== s.byteLength) && (s = s.slice(t.byteOffset, t.byteOffset + o)), s;
  }
  throw new Error(vw);
}
async function fI(t, e, i) {
  const s = t instanceof ArrayBuffer || ArrayBuffer.isView(t);
  if (typeof t == "string" || s)
    return dI(t, e);
  if (Bl(t) && (t = await dw(t)), Pl(t)) {
    const o = t;
    return await P2(o), e.binary ? await o.arrayBuffer() : await o.text();
  }
  if (hw(t) && (t = uI(t, i)), b2(t) || v2(t))
    return s2(t);
  throw new Error(vw);
}
function xw(t, e) {
  const i = _w(), s = t || i;
  return typeof s.fetch == "function" ? s.fetch : nd(s.fetch) ? (o) => ev(o, s.fetch) : e?.fetch ? e?.fetch : ev;
}
function pI(t, e, i) {
  if (i)
    return i;
  const s = {
    fetch: xw(e, t),
    ...t
  };
  if (s.url) {
    const o = Jm(s.url);
    s.baseUrl = o, s.queryString = I2(s.url), s.filename = cw(o), s.baseUrl = Ym(o);
  }
  return Array.isArray(s.loaders) || (s.loaders = null), s;
}
function _I(t, e) {
  if (t && !Array.isArray(t))
    return t;
  let i;
  if (t && (i = Array.isArray(t) ? t : [t]), e && e.loaders) {
    const s = Array.isArray(e.loaders) ? e.loaders : [e.loaders];
    i = i ? [...i, ...s] : s;
  }
  return i && i.length ? i : void 0;
}
async function op(t, e, i, s) {
  e && !Array.isArray(e) && !ey(e) && (s = void 0, i = e, e = void 0), t = await t, i = i || {};
  const o = Ep(t), d = _I(e, s), a = await Z2(t, d, i);
  return a ? (i = V2(i, a, d, o), s = pI(
    // @ts-expect-error
    { url: o, _parse: op, loaders: d },
    i,
    s || null
  ), await gI(a, t, i, s)) : null;
}
async function gI(t, e, i, s) {
  if (HC(t), i = RC(t.options, i), Pl(e)) {
    const u = e, { ok: d, redirected: a, status: w, statusText: S, type: M, url: F } = u, N = Object.fromEntries(u.headers.entries());
    s.response = { headers: N, ok: d, redirected: a, status: w, statusText: S, type: M, url: F };
  }
  e = await fI(e, t, i);
  const o = t;
  if (o.parseTextSync && typeof e == "string")
    return o.parseTextSync(e, i, s);
  if (ZC(t, i))
    return await KC(t, e, i, s, op);
  if (o.parseText && typeof e == "string")
    return await o.parseText(e, i, s);
  if (o.parse)
    return await o.parse(e, i, s);
  throw ko(!o.parseSync), new Error(`${t.id} loader - no parser found and worker is disabled`);
}
function mI(t) {
  switch (t.constructor) {
    case Int8Array:
      return "int8";
    case Uint8Array:
    case Uint8ClampedArray:
      return "uint8";
    case Int16Array:
      return "int16";
    case Uint16Array:
      return "uint16";
    case Int32Array:
      return "int32";
    case Uint32Array:
      return "uint32";
    case Float32Array:
      return "float32";
    case Float64Array:
      return "float64";
    default:
      return "null";
  }
}
function ww(t) {
  let e = 1 / 0, i = 1 / 0, s = 1 / 0, o = -1 / 0, u = -1 / 0, d = -1 / 0;
  const a = t.POSITION ? t.POSITION.value : [], w = a && a.length;
  for (let S = 0; S < w; S += 3) {
    const M = a[S], F = a[S + 1], N = a[S + 2];
    e = M < e ? M : e, i = F < i ? F : i, s = N < s ? N : s, o = M > o ? M : o, u = F > u ? F : u, d = N > d ? N : d;
  }
  return [
    [e, i, s],
    [o, u, d]
  ];
}
function yI(t, e, i) {
  const s = mI(e.value), o = i || bI(e);
  return {
    name: t,
    type: { type: "fixed-size-list", listSize: e.size, children: [{ name: "value", type: s }] },
    nullable: !1,
    metadata: o
  };
}
function bI(t) {
  const e = {};
  return "byteOffset" in t && (e.byteOffset = t.byteOffset.toString(10)), "byteStride" in t && (e.byteStride = t.byteStride.toString(10)), "normalized" in t && (e.normalized = t.normalized.toString()), e;
}
async function Ea(t, e, i, s) {
  let o, u;
  !Array.isArray(e) && !ey(e) ? (o = [], u = e) : (o = e, u = i);
  const d = xw(u);
  let a = t;
  return typeof t == "string" && (a = await d(t)), Bl(t) && (a = await d(t)), Array.isArray(o) ? await op(a, o, u) : await op(a, o, u);
}
const vI = "4.3.1", xI = globalThis.loaders?.parseImageNode, om = typeof Image < "u", am = typeof ImageBitmap < "u", wI = !!xI, lm = Ap ? !0 : wI;
function TI(t) {
  switch (t) {
    case "auto":
      return am || om || lm;
    case "imagebitmap":
      return am;
    case "image":
      return om;
    case "data":
      return lm;
    default:
      throw new Error(`@loaders.gl/images: image ${t} not supported in this environment`);
  }
}
function AI() {
  if (am)
    return "imagebitmap";
  if (om)
    return "image";
  if (lm)
    return "data";
  throw new Error("Install '@loaders.gl/polyfills' to parse images under Node.js");
}
function EI(t) {
  const e = SI(t);
  if (!e)
    throw new Error("Not an image");
  return e;
}
function Tw(t) {
  switch (EI(t)) {
    case "data":
      return t;
    case "image":
    case "imagebitmap":
      const e = document.createElement("canvas"), i = e.getContext("2d");
      if (!i)
        throw new Error("getImageData");
      return e.width = t.width, e.height = t.height, i.drawImage(t, 0, 0), i.getImageData(0, 0, t.width, t.height);
    default:
      throw new Error("getImageData");
  }
}
function SI(t) {
  return typeof ImageBitmap < "u" && t instanceof ImageBitmap ? "imagebitmap" : typeof Image < "u" && t instanceof Image ? "image" : t && typeof t == "object" && t.data && t.width && t.height ? "data" : null;
}
const CI = /^data:image\/svg\+xml/, II = /\.svg((\?|#).*)?$/;
function iy(t) {
  return t && (CI.test(t) || II.test(t));
}
function MI(t, e) {
  if (iy(e)) {
    let s = new TextDecoder().decode(t);
    try {
      typeof unescape == "function" && typeof encodeURIComponent == "function" && (s = unescape(encodeURIComponent(s)));
    } catch (u) {
      throw new Error(u.message);
    }
    return `data:image/svg+xml;base64,${btoa(s)}`;
  }
  return Aw(t, e);
}
function Aw(t, e) {
  if (iy(e))
    throw new Error("SVG cannot be parsed directly to imagebitmap");
  return new Blob([new Uint8Array(t)]);
}
async function Ew(t, e, i) {
  const s = MI(t, i), o = self.URL || self.webkitURL, u = typeof s != "string" && o.createObjectURL(s);
  try {
    return await RI(u || s, e);
  } finally {
    u && o.revokeObjectURL(u);
  }
}
async function RI(t, e) {
  const i = new Image();
  return i.src = t, e.image && e.image.decode && i.decode ? (await i.decode(), i) : await new Promise((s, o) => {
    try {
      i.onload = () => s(i), i.onerror = (u) => {
        const d = u instanceof Error ? u.message : "error";
        o(new Error(d));
      };
    } catch (u) {
      o(u);
    }
  });
}
const PI = {};
let av = !0;
async function BI(t, e, i) {
  let s;
  iy(i) ? s = await Ew(t, e, i) : s = Aw(t, i);
  const o = e && e.imagebitmap;
  return await DI(s, o);
}
async function DI(t, e = null) {
  if ((OI(e) || !av) && (e = null), e)
    try {
      return await createImageBitmap(t, e);
    } catch (i) {
      console.warn(i), av = !1;
    }
  return await createImageBitmap(t);
}
function OI(t) {
  for (const e in t || PI)
    return !1;
  return !0;
}
function FI(t) {
  return !UI(t, "ftyp", 4) || (t[8] & 96) === 0 ? null : kI(t);
}
function kI(t) {
  switch (NI(t, 8, 12).replace("\0", " ").trim()) {
    case "avif":
    case "avis":
      return { extension: "avif", mimeType: "image/avif" };
    default:
      return null;
  }
}
function NI(t, e, i) {
  return String.fromCharCode(...t.slice(e, i));
}
function LI(t) {
  return [...t].map((e) => e.charCodeAt(0));
}
function UI(t, e, i = 0) {
  const s = LI(e);
  for (let o = 0; o < s.length; ++o)
    if (s[o] !== t[o + i])
      return !1;
  return !0;
}
const no = !1, zu = !0;
function ry(t) {
  const e = od(t);
  return VI(e) || $I(e) || jI(e) || HI(e) || zI(e);
}
function zI(t) {
  const e = new Uint8Array(t instanceof DataView ? t.buffer : t), i = FI(e);
  return i ? {
    mimeType: i.mimeType,
    // TODO - decode width and height
    width: 0,
    height: 0
  } : null;
}
function VI(t) {
  const e = od(t);
  return e.byteLength >= 24 && e.getUint32(0, no) === 2303741511 ? {
    mimeType: "image/png",
    width: e.getUint32(16, no),
    height: e.getUint32(20, no)
  } : null;
}
function jI(t) {
  const e = od(t);
  return e.byteLength >= 10 && e.getUint32(0, no) === 1195984440 ? {
    mimeType: "image/gif",
    width: e.getUint16(6, zu),
    height: e.getUint16(8, zu)
  } : null;
}
function HI(t) {
  const e = od(t);
  return e.byteLength >= 14 && e.getUint16(0, no) === 16973 && e.getUint32(2, zu) === e.byteLength ? {
    mimeType: "image/bmp",
    width: e.getUint32(18, zu),
    height: e.getUint32(22, zu)
  } : null;
}
function $I(t) {
  const e = od(t);
  if (!(e.byteLength >= 3 && e.getUint16(0, no) === 65496 && e.getUint8(2) === 255))
    return null;
  const { tableMarkers: s, sofMarkers: o } = GI();
  let u = 2;
  for (; u + 9 < e.byteLength; ) {
    const d = e.getUint16(u, no);
    if (o.has(d))
      return {
        mimeType: "image/jpeg",
        height: e.getUint16(u + 5, no),
        // Number of lines
        width: e.getUint16(u + 7, no)
        // Number of pixels per line
      };
    if (!s.has(d))
      return null;
    u += 2, u += e.getUint16(u, no);
  }
  return null;
}
function GI() {
  const t = /* @__PURE__ */ new Set([65499, 65476, 65484, 65501, 65534]);
  for (let i = 65504; i < 65520; ++i)
    t.add(i);
  return { tableMarkers: t, sofMarkers: /* @__PURE__ */ new Set([
    65472,
    65473,
    65474,
    65475,
    65477,
    65478,
    65479,
    65481,
    65482,
    65483,
    65485,
    65486,
    65487,
    65502
  ]) };
}
function od(t) {
  if (t instanceof DataView)
    return t;
  if (ArrayBuffer.isView(t))
    return new DataView(t.buffer);
  if (t instanceof ArrayBuffer)
    return new DataView(t);
  throw new Error("toDataView");
}
async function WI(t, e) {
  const { mimeType: i } = ry(t) || {}, s = globalThis.loaders?.parseImageNode;
  return mi(s), await s(t, i);
}
async function XI(t, e, i) {
  e = e || {};
  const o = (e.image || {}).type || "auto", { url: u } = i || {}, d = qI(o);
  let a;
  switch (d) {
    case "imagebitmap":
      a = await BI(t, e, u);
      break;
    case "image":
      a = await Ew(t, e, u);
      break;
    case "data":
      a = await WI(t);
      break;
    default:
      mi(!1);
  }
  return o === "data" && (a = Tw(a)), a;
}
function qI(t) {
  switch (t) {
    case "auto":
    case "data":
      return AI();
    default:
      return TI(t), t;
  }
}
const ZI = ["png", "jpg", "jpeg", "gif", "webp", "bmp", "ico", "svg", "avif"], KI = [
  "image/png",
  "image/jpeg",
  "image/gif",
  "image/webp",
  "image/avif",
  "image/bmp",
  "image/vnd.microsoft.icon",
  "image/svg+xml"
], YI = {
  image: {
    type: "auto",
    decode: !0
    // if format is HTML
  }
  // imagebitmap: {} - passes (platform dependent) parameters to ImageBitmap constructor
}, Sw = {
  dataType: null,
  batchType: null,
  id: "image",
  module: "images",
  name: "Images",
  version: vI,
  mimeTypes: KI,
  extensions: ZI,
  parse: XI,
  // TODO: byteOffset, byteLength;
  tests: [(t) => !!ry(new DataView(t))],
  options: YI
}, ag = {};
function JI(t) {
  if (ag[t] === void 0) {
    const e = Ap ? eM(t) : QI(t);
    ag[t] = e;
  }
  return ag[t];
}
function QI(t) {
  const e = ["image/png", "image/jpeg", "image/gif"], i = globalThis.loaders?.imageFormatsNode || e;
  return !!globalThis.loaders?.parseImageNode && i.includes(t);
}
function eM(t) {
  switch (t) {
    case "image/avif":
    // Will fail
    case "image/webp":
      return tM(t);
    default:
      return !0;
  }
}
function tM(t) {
  try {
    return document.createElement("canvas").toDataURL(t).indexOf(`data:${t}`) === 0;
  } catch {
    return !1;
  }
}
const Jt = new ph({ id: "deck" });
let cm = {};
function iM(t) {
  cm = t;
}
function Yr(t, e, i, s) {
  Jt.level > 0 && cm[t] && cm[t].call(null, e, i, s);
}
function rM(t) {
  const e = t[0], i = t[t.length - 1];
  return e === "{" && i === "}" || e === "[" && i === "]";
}
const sM = {
  dataType: null,
  batchType: null,
  id: "JSON",
  name: "JSON",
  module: "",
  version: "",
  options: {},
  extensions: ["json", "geojson"],
  mimeTypes: ["application/json", "application/geo+json"],
  testText: rM,
  parseTextSync: JSON.parse
};
function nM() {
  const t = "9.0.35", e = globalThis.deck && globalThis.deck.VERSION;
  if (e && e !== t)
    throw new Error(`deck.gl - multiple versions detected: ${e} vs ${t}`);
  return e || (Jt.log(1, `deck.gl ${t}`)(), globalThis.deck = {
    ...globalThis.deck,
    VERSION: t,
    version: t,
    log: Jt,
    // experimental
    _registerLoggers: iM
  }, W2([
    sM,
    // @ts-expect-error non-standard Loader format
    [Sw, { imagebitmap: { premultiplyAlpha: "none" } }]
  ])), t;
}
const oM = nM();
function vl(t, e) {
  if (!t)
    throw new Error(e || "shadertools: assertion failed.");
}
const lg = {
  number: {
    type: "number",
    validate(t, e) {
      return Number.isFinite(t) && typeof e == "object" && (e.max === void 0 || t <= e.max) && (e.min === void 0 || t >= e.min);
    }
  },
  array: {
    type: "array",
    validate(t, e) {
      return Array.isArray(t) || ArrayBuffer.isView(t);
    }
  }
};
function aM(t) {
  const e = {};
  for (const [i, s] of Object.entries(t))
    e[i] = cM(s);
  return e;
}
function lM(t, e, i) {
  const s = {};
  for (const [o, u] of Object.entries(e))
    t && o in t && !u.private ? (u.validate && vl(u.validate(t[o], u), `${i}: invalid ${o}`), s[o] = t[o]) : s[o] = u.value;
  return s;
}
function cM(t) {
  let e = lv(t);
  if (e !== "object")
    return { value: t, ...lg[e], type: e };
  if (typeof t == "object")
    return t ? t.type !== void 0 ? { ...t, ...lg[t.type], type: t.type } : t.value === void 0 ? { type: "object", value: t } : (e = lv(t.value), { ...t, ...lg[e], type: e }) : { type: "object", value: null };
  throw new Error("props");
}
function lv(t) {
  return Array.isArray(t) || ArrayBuffer.isView(t) ? "array" : typeof t;
}
const hM = `#ifdef MODULE_LOGDEPTH
logdepth_adjustPosition(gl_Position);
#endif
`, uM = `#ifdef MODULE_MATERIAL
gl_FragColor = material_filterColor(gl_FragColor);
#endif
#ifdef MODULE_LIGHTING
gl_FragColor = lighting_filterColor(gl_FragColor);
#endif
#ifdef MODULE_FOG
gl_FragColor = fog_filterColor(gl_FragColor);
#endif
#ifdef MODULE_PICKING
gl_FragColor = picking_filterHighlightColor(gl_FragColor);
gl_FragColor = picking_filterPickingColor(gl_FragColor);
#endif
#ifdef MODULE_LOGDEPTH
logdepth_setFragDepth();
#endif
`, dM = {
  vertex: hM,
  fragment: uM
}, cv = /void\s+main\s*\([^)]*\)\s*\{\n?/, hv = /}\n?[^{}]*$/, cg = [], Yf = "__LUMA_INJECT_DECLARATIONS__";
function fM(t) {
  const e = { vertex: {}, fragment: {} };
  for (const i in t) {
    let s = t[i];
    const o = pM(i);
    typeof s == "string" && (s = {
      order: 0,
      injection: s
    }), e[o][i] = s;
  }
  return e;
}
function pM(t) {
  const e = t.slice(0, 2);
  switch (e) {
    case "vs":
      return "vertex";
    case "fs":
      return "fragment";
    default:
      throw new Error(e);
  }
}
function ap(t, e, i, s = !1) {
  const o = e === "vertex";
  for (const u in i) {
    const d = i[u];
    d.sort((w, S) => w.order - S.order), cg.length = d.length;
    for (let w = 0, S = d.length; w < S; ++w)
      cg[w] = d[w].injection;
    const a = `${cg.join(`
`)}
`;
    switch (u) {
      // declarations are injected before the main function
      case "vs:#decl":
        o && (t = t.replace(Yf, a));
        break;
      // inject code at the beginning of the main function
      case "vs:#main-start":
        o && (t = t.replace(cv, (w) => w + a));
        break;
      // inject code at the end of main function
      case "vs:#main-end":
        o && (t = t.replace(hv, (w) => a + w));
        break;
      // declarations are injected before the main function
      case "fs:#decl":
        o || (t = t.replace(Yf, a));
        break;
      // inject code at the beginning of the main function
      case "fs:#main-start":
        o || (t = t.replace(cv, (w) => w + a));
        break;
      // inject code at the end of main function
      case "fs:#main-end":
        o || (t = t.replace(hv, (w) => a + w));
        break;
      default:
        t = t.replace(u, (w) => w + a);
    }
  }
  return t = t.replace(Yf, ""), s && (t = t.replace(/\}\s*$/, (u) => u + dM[e])), t;
}
let _M = 1;
class xl {
  name;
  vs;
  fs;
  getModuleUniforms;
  dependencies;
  deprecations;
  defines;
  injections;
  uniforms = {};
  uniformTypes = {};
  static instantiateModules(e) {
    return e.map((i) => {
      if (i instanceof xl)
        return i;
      vl(typeof i != "string", `Shader module use by name is deprecated. Import shader module '${JSON.stringify(i)}' and use it directly.`), i.name || (console.warn("shader module has no name"), i.name = `shader-module-${_M++}`);
      const s = new xl(i);
      return s.dependencies = xl.instantiateModules(i.dependencies || []), s;
    });
  }
  constructor(e) {
    const { name: i, vs: s, fs: o, dependencies: u = [], uniformTypes: d = {}, uniformPropTypes: a = {}, getUniforms: w, deprecations: S = [], defines: M = {}, inject: F = {} } = e;
    vl(typeof i == "string"), this.name = i, this.vs = s, this.fs = o, this.getModuleUniforms = w, this.dependencies = xl.instantiateModules(u), this.deprecations = this._parseDeprecationDefinitions(S), this.defines = M, this.injections = fM(F), this.uniformTypes = d, a && (this.uniforms = aM(a));
  }
  // Extracts the source code chunk for the specified shader type from the named shader module
  getModuleSource(e) {
    let i;
    switch (e) {
      case "vertex":
        i = this.vs || "";
        break;
      case "fragment":
        i = this.fs || "";
        break;
      default:
        vl(!1);
    }
    const s = this.name.toUpperCase().replace(/[^0-9a-z]/gi, "_");
    return `// ----- MODULE ${this.name} ---------------

#define MODULE_${s}
${i}

`;
  }
  getUniforms(e, i) {
    return this.getModuleUniforms ? this.getModuleUniforms(e, i) : lM(e, this.uniforms, this.name);
  }
  getDefines() {
    return this.defines;
  }
  // Warn about deprecated uniforms or functions
  checkDeprecations(e, i) {
    this.deprecations.forEach((s) => {
      s.regex?.test(e) && (s.deprecated ? i.deprecated(s.old, s.new)() : i.removed(s.old, s.new)());
    });
  }
  _parseDeprecationDefinitions(e) {
    return e.forEach((i) => {
      switch (i.type) {
        case "function":
          i.regex = new RegExp(`\\b${i.old}\\(`);
          break;
        default:
          i.regex = new RegExp(`${i.type} ${i.old};`);
      }
    }), e;
  }
  _defaultGetUniforms(e = {}) {
    const i = {}, s = this.uniforms;
    for (const o in s) {
      const u = s[o];
      o in e && !u.private ? (u.validate && vl(u.validate(e[o], u), `${this.name}: invalid ${o}`), i[o] = e[o]) : i[o] = u.value;
    }
    return i;
  }
}
function uv(t) {
  if (t.source && t.platformInfo.type === "webgpu")
    return { ...t, vs: void 0, fs: void 0 };
  if (!t.vs)
    throw new Error("no vertex shader");
  const e = dv(t.platformInfo, t.vs);
  let i;
  return t.fs && (i = dv(t.platformInfo, t.fs)), { ...t, vs: e, fs: i };
}
function dv(t, e) {
  if (typeof e == "string")
    return e;
  switch (t.type) {
    case "webgpu":
      if (e?.wgsl)
        return e.wgsl;
      throw new Error("WebGPU does not support GLSL shaders");
    default:
      if (e?.glsl)
        return e.glsl;
      throw new Error("WebGL does not support WGSL shaders");
  }
}
function Sp(t) {
  const e = xl.instantiateModules(t);
  return gM(e);
}
function gM(t) {
  const e = {}, i = {};
  return Cw({ modules: t, level: 0, moduleMap: e, moduleDepth: i }), Object.keys(i).sort((s, o) => i[o] - i[s]).map((s) => e[s]);
}
function Cw(t) {
  const { modules: e, level: i, moduleMap: s, moduleDepth: o } = t;
  if (i >= 5)
    throw new Error("Possible loop in shader dependency graph");
  for (const u of e)
    s[u.name] = u, (o[u.name] === void 0 || o[u.name] < i) && (o[u.name] = i);
  for (const u of e)
    u.dependencies && Cw({ modules: u.dependencies, level: i + 1, moduleMap: s, moduleDepth: o });
}
function mM(t) {
  switch (t?.gpu.toLowerCase()) {
    case "apple":
      return `#define APPLE_GPU
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
    case "nvidia":
      return `#define NVIDIA_GPU
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
`;
    case "intel":
      return `#define INTEL_GPU
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
    case "amd":
      return `#define AMD_GPU
`;
    default:
      return `#define DEFAULT_GPU
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
  }
}
function yM(t, e) {
  if (Number(t.match(/^#version[ \t]+(\d+)/m)?.[1] || 100) !== 300)
    throw new Error("luma.gl v9 only supports GLSL 3.00 shader sources");
  switch (e) {
    case "vertex":
      return t = fv(t, bM), t;
    case "fragment":
      return t = fv(t, vM), t;
    default:
      throw new Error(e);
  }
}
const Iw = [
  // Fix poorly formatted version directive
  [/^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/, `#version 300 es
`],
  // The individual `texture...()` functions were replaced with `texture()` overloads
  [/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g, "textureLod("],
  [/\btexture(2D|2DProj|Cube)(EXT)?\(/g, "texture("]
], bM = [
  ...Iw,
  // `attribute` keyword replaced with `in`
  [hm("attribute"), "in $1"],
  // `varying` keyword replaced with `out`
  [hm("varying"), "out $1"]
], vM = [
  ...Iw,
  // `varying` keyword replaced with `in`
  [hm("varying"), "in $1"]
];
function fv(t, e) {
  for (const [i, s] of e)
    t = t.replace(i, s);
  return t;
}
function hm(t) {
  return new RegExp(`\\b${t}[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)`, "g");
}
function Mw(t, e) {
  let i = "";
  for (const s in t) {
    const o = t[s];
    if (i += `void ${o.signature} {
`, o.header && (i += `  ${o.header}`), e[s]) {
      const u = e[s];
      u.sort((d, a) => d.order - a.order);
      for (const d of u)
        i += `  ${d.injection}
`;
    }
    o.footer && (i += `  ${o.footer}`), i += `}
`;
  }
  return i;
}
function Rw(t) {
  const e = { vertex: {}, fragment: {} };
  for (const i of t) {
    let s, o;
    typeof i != "string" ? (s = i, o = s.hook) : (s = {}, o = i), o = o.trim();
    const [u, d] = o.split(":"), a = o.replace(/\(.+/, ""), w = Object.assign(s, { signature: d });
    switch (u) {
      case "vs":
        e.vertex[a] = w;
        break;
      case "fs":
        e.fragment[a] = w;
        break;
      default:
        throw new Error(u);
    }
  }
  return e;
}
function xM(t, e) {
  return {
    name: wM(t, e),
    language: "glsl",
    version: TM(t)
  };
}
function wM(t, e = "unnamed") {
  const s = /#define[^\S\r\n]*SHADER_NAME[^\S\r\n]*([A-Za-z0-9_-]+)\s*/.exec(t);
  return s ? s[1] : e;
}
function TM(t) {
  let e = 100;
  const i = t.match(/[^\s]+/g);
  if (i && i.length >= 2 && i[0] === "#version") {
    const s = parseInt(i[1], 10);
    Number.isFinite(s) && (e = s);
  }
  if (e !== 100 && e !== 300)
    throw new Error(`Invalid GLSL version ${e}`);
  return e;
}
const Pw = `

${Yf}
`, AM = `precision highp float;
`;
function EM(t) {
  const e = Sp(t.modules || []);
  return {
    source: um(t.platformInfo, {
      ...t,
      source: t.source,
      stage: "vertex",
      modules: e
    }),
    getUniforms: sy(e)
  };
}
function SM(t) {
  const e = Sp(t.modules || []);
  return {
    vs: um(t.platformInfo, {
      ...t,
      source: t.vs,
      stage: "vertex",
      modules: e
    }),
    fs: um(t.platformInfo, {
      ...t,
      source: t.fs,
      stage: "fragment",
      modules: e
    }),
    getUniforms: sy(e)
  };
}
function CM(t) {
  const { vs: e, fs: i } = t, s = Sp(t.modules || []);
  return {
    vs: pv(t.platformInfo, {
      ...t,
      source: e,
      stage: "vertex",
      modules: s
    }),
    fs: pv(t.platformInfo, {
      ...t,
      source: i,
      stage: "fragment",
      modules: s
    }),
    getUniforms: sy(s)
  };
}
function um(t, e) {
  const {
    // id,
    source: i,
    stage: s,
    modules: o,
    // defines = {},
    hookFunctions: u = [],
    inject: d = {},
    log: a
  } = e;
  vl(typeof i == "string", "shader source must be a string");
  const w = i;
  let S = "";
  const M = Rw(u), F = {}, N = {}, L = {};
  for (const ne in d) {
    const we = typeof d[ne] == "string" ? { injection: d[ne], order: 0 } : d[ne], Se = /^(v|f)s:(#)?([\w-]+)$/.exec(ne);
    if (Se) {
      const Ee = Se[2], Ce = Se[3];
      Ee ? Ce === "decl" ? N[ne] = [we] : L[ne] = [we] : F[ne] = [we];
    } else
      L[ne] = [we];
  }
  const re = t.type !== "webgpu" ? o : [];
  for (const ne of re) {
    a && ne.checkDeprecations(w, a);
    const we = ne.getModuleSource(s, "wgsl");
    S += we;
    const Se = ne.injections[s];
    for (const Ee in Se) {
      const Ce = /^(v|f)s:#([\w-]+)$/.exec(Ee);
      if (Ce) {
        const Ze = Ce[2] === "decl" ? N : L;
        Ze[Ee] = Ze[Ee] || [], Ze[Ee].push(Se[Ee]);
      } else
        F[Ee] = F[Ee] || [], F[Ee].push(Se[Ee]);
    }
  }
  return S += Pw, S = ap(S, s, N), S += Mw(M[s], F), S += w, S = ap(S, s, L), S;
}
function pv(t, e) {
  const { id: i, source: s, stage: o, language: u = "glsl", modules: d, defines: a = {}, hookFunctions: w = [], inject: S = {}, prologue: M = !0, log: F } = e;
  vl(typeof s == "string", "shader source must be a string");
  const N = u === "glsl" ? xM(s).version : -1, L = t.shaderLanguageVersion, re = N === 100 ? "#version 100" : "#version 300 es", we = s.split(`
`).slice(1).join(`
`), Se = {};
  d.forEach((ct) => {
    Object.assign(Se, ct.getDefines());
  }), Object.assign(Se, a);
  let Ee = "";
  switch (u) {
    case "wgsl":
      break;
    case "glsl":
      Ee = M ? `${re}

// ----- PROLOGUE -------------------------
${IM({ id: i, source: s, stage: o })}
${`#define SHADER_TYPE_${o.toUpperCase()}`}
${mM(t)}
${o === "fragment" ? AM : ""}

// ----- APPLICATION DEFINES -------------------------

${MM(Se)}

` : `${re}
`;
      break;
  }
  const Ce = Rw(w), Le = {}, Ze = {}, Ke = {};
  for (const ct in S) {
    const _t = typeof S[ct] == "string" ? { injection: S[ct], order: 0 } : S[ct], st = /^(v|f)s:(#)?([\w-]+)$/.exec(ct);
    if (st) {
      const ot = st[2], bt = st[3];
      ot ? bt === "decl" ? Ze[ct] = [_t] : Ke[ct] = [_t] : Le[ct] = [_t];
    } else
      Ke[ct] = [_t];
  }
  for (const ct of d) {
    F && ct.checkDeprecations(we, F);
    const _t = ct.getModuleSource(o);
    Ee += _t;
    const st = ct.injections[o];
    for (const ot in st) {
      const bt = /^(v|f)s:#([\w-]+)$/.exec(ot);
      if (bt) {
        const jt = bt[2] === "decl" ? Ze : Ke;
        jt[ot] = jt[ot] || [], jt[ot].push(st[ot]);
      } else
        Le[ot] = Le[ot] || [], Le[ot].push(st[ot]);
    }
  }
  return Ee += "// ----- MAIN SHADER SOURCE -------------------------", Ee += Pw, Ee = ap(Ee, o, Ze), Ee += Mw(Ce[o], Le), Ee += we, Ee = ap(Ee, o, Ke), u === "glsl" && N !== L && (Ee = yM(Ee, o)), Ee.trim();
}
function sy(t) {
  return function(i) {
    const s = {};
    for (const o of t) {
      const u = o.getUniforms(i, s);
      Object.assign(s, u);
    }
    return s;
  };
}
function IM(t) {
  const { id: e, source: i, stage: s } = t;
  return e && i.indexOf("SHADER_NAME") === -1 ? `
#define SHADER_NAME ${e}_${s}

` : "";
}
function MM(t = {}) {
  let e = "";
  for (const i in t) {
    const s = t[i];
    (s || Number.isFinite(s)) && (e += `#define ${i.toUpperCase()} ${t[i]}
`);
  }
  return e;
}
class wl {
  /** Default ShaderAssembler instance */
  static defaultShaderAssembler;
  /** Hook functions */
  _hookFunctions = [];
  /** Shader modules */
  _defaultModules = [];
  /**
   * A default shader assembler instance - the natural place to register default modules and hooks
   * @returns
   */
  static getDefaultShaderAssembler() {
    return wl.defaultShaderAssembler = wl.defaultShaderAssembler || new wl(), wl.defaultShaderAssembler;
  }
  /**
   * Add a default module that does not have to be provided with every call to assembleShaders()
   */
  addDefaultModule(e) {
    this._defaultModules.find((i) => i.name === (typeof e == "string" ? e : e.name)) || this._defaultModules.push(e);
  }
  /**
   * Remove a default module
   */
  removeDefaultModule(e) {
    const i = typeof e == "string" ? e : e.name;
    this._defaultModules = this._defaultModules.filter((s) => s.name !== i);
  }
  /**
   * Register a shader hook
   * @param hook
   * @param opts
   */
  addShaderHook(e, i) {
    i && (e = Object.assign(i, { hook: e })), this._hookFunctions.push(e);
  }
  /**
   * Assemble a pair of shaders into a single shader program
   * @param platformInfo
   * @param props
   * @returns
   */
  assembleShader(e) {
    const i = this._getModuleList(e.modules), s = this._hookFunctions, o = uv(e);
    return { ...EM({
      platformInfo: e.platformInfo,
      ...o,
      modules: i,
      hookFunctions: s
    }), modules: i };
  }
  /**
   * Assemble a pair of shaders into a single shader program
   * @param platformInfo
   * @param props
   * @returns
   */
  assembleShaderPair(e) {
    const i = uv(e), s = this._getModuleList(e.modules), o = this._hookFunctions, { platformInfo: u } = e;
    return { ...e.platformInfo.shaderLanguage === "wgsl" ? SM({ platformInfo: u, ...i, modules: s, hookFunctions: o }) : CM({ platformInfo: u, ...i, modules: s, hookFunctions: o }), modules: s };
  }
  /**
   * Dedupe and combine with default modules
   */
  _getModuleList(e = []) {
    const i = new Array(this._defaultModules.length + e.length), s = {};
    let o = 0;
    for (let u = 0, d = this._defaultModules.length; u < d; ++u) {
      const a = this._defaultModules[u], w = a.name;
      i[o++] = a, s[w] = !0;
    }
    for (let u = 0, d = e.length; u < d; ++u) {
      const a = e[u], w = a.name;
      s[w] || (i[o++] = a, s[w] = !0);
    }
    return i.length = o, xl.instantiateModules(i);
  }
}
const RM = `out vec4 transform_output;
void main() {
transform_output = vec4(0);
}`, PM = `#version 300 es
${RM}`;
function BM(t) {
  const { input: e, inputChannels: i, output: s } = {};
  if (!e)
    return PM;
  if (!i)
    throw new Error("inputChannels");
  const o = DM(i), u = OM(e, i);
  return `#version 300 es
in ${o} ${e};
out vec4 ${s};
void main() {
  ${s} = ${u};
}`;
}
function DM(t) {
  switch (t) {
    case 1:
      return "float";
    case 2:
      return "vec2";
    case 3:
      return "vec3";
    case 4:
      return "vec4";
    default:
      throw new Error(`invalid channels: ${t}`);
  }
}
function OM(t, e) {
  switch (e) {
    case 1:
      return `vec4(${t}, 0.0, 0.0, 1.0)`;
    case 2:
      return `vec4(${t}, 0.0, 1.0)`;
    case 3:
      return `vec4(${t}, 1.0)`;
    case 4:
      return t;
    default:
      throw new Error(`invalid channels: ${e}`);
  }
}
const Je = new ph({ id: "luma.gl" });
class FM {
  stats = /* @__PURE__ */ new Map();
  getStats(e) {
    return this.get(e);
  }
  get(e) {
    return this.stats.has(e) || this.stats.set(e, new _h({ id: e })), this.stats.get(e);
  }
}
const ny = new FM();
function kM() {
  const t = "9.0.27", e = "set luma.log.level=1 (or higher) to trace rendering";
  if (globalThis.luma && globalThis.luma.VERSION !== t)
    throw new Error(`luma.gl - multiple VERSIONs detected: ${globalThis.luma.VERSION} vs ${t}`);
  return globalThis.luma || (Ra() && Je.log(1, `${t} - ${e}`)(), globalThis.luma = globalThis.luma || {
    VERSION: t,
    version: t,
    log: Je,
    // A global stats object that various components can add information to
    // E.g. see webgl/resource.js
    stats: ny
  }), t;
}
const NM = kM();
function LM(t) {
  return ArrayBuffer.isView(t) && !(t instanceof DataView) ? t : null;
}
function Wu(t) {
  return Array.isArray(t) ? t.length === 0 || typeof t[0] == "number" ? t : null : LM(t);
}
const hg = {};
function Pa(t = "id") {
  hg[t] = hg[t] || 1;
  const e = hg[t]++;
  return `${t}-${e}`;
}
function lp(t) {
  let e = !0;
  for (const i in t) {
    e = !1;
    break;
  }
  return e;
}
let pi = class {
  /** Default properties for resource */
  static defaultProps = {
    id: "undefined",
    handle: void 0,
    userData: void 0
  };
  /** props.id, for debugging. */
  id;
  props;
  userData = {};
  _device;
  /** Whether this resource has been destroyed */
  destroyed = !1;
  /** For resources that allocate GPU memory */
  allocatedBytes = 0;
  /** Attached resources will be destroyed when this resource is destroyed. Tracks auto-created "sub" resources. */
  _attachedResources = /* @__PURE__ */ new Set();
  /**
   * Create a new Resource. Called from Subclass
   */
  constructor(e, i, s) {
    if (!e)
      throw new Error("no device");
    this._device = e, this.props = UM(i, s);
    const o = this.props.id !== "undefined" ? this.props.id : Pa(this[Symbol.toStringTag]);
    this.props.id = o, this.id = o, this.userData = this.props.userData || {}, this.addStats();
  }
  /**
   * destroy can be called on any resource to release it before it is garbage collected.
   */
  destroy() {
    this.destroyResource();
  }
  /** @deprecated Use destroy() */
  delete() {
    return this.destroy(), this;
  }
  toString() {
    return `${this[Symbol.toStringTag] || this.constructor.name}(${this.id})`;
  }
  /**
   * Combines a map of user props and default props, only including props from defaultProps
   * @returns returns a map of overridden default props
   */
  getProps() {
    return this.props;
  }
  // ATTACHED RESOURCES
  /**
   * Attaches a resource. Attached resources are auto destroyed when this resource is destroyed
   * Called automatically when sub resources are auto created but can be called by application
   */
  attachResource(e) {
    this._attachedResources.add(e);
  }
  /**
   * Detach an attached resource. The resource will no longer be auto-destroyed when this resource is destroyed.
   */
  detachResource(e) {
    this._attachedResources.delete(e);
  }
  /**
   * Destroys a resource (only if owned), and removes from the owned (auto-destroy) list for this resource.
   */
  destroyAttachedResource(e) {
    this._attachedResources.delete(e) && e.destroy();
  }
  /** Destroy all owned resources. Make sure the resources are no longer needed before calling. */
  destroyAttachedResources() {
    for (const e of Object.values(this._attachedResources))
      e.destroy();
    this._attachedResources = /* @__PURE__ */ new Set();
  }
  // PROTECTED METHODS
  /** Perform all destroy steps. Can be called by derived resources when overriding destroy() */
  destroyResource() {
    this.destroyAttachedResources(), this.removeStats(), this.destroyed = !0;
  }
  /** Called by .destroy() to track object destruction. Subclass must call if overriding destroy() */
  removeStats() {
    const e = this._device.statsManager.getStats("Resource Counts"), i = this[Symbol.toStringTag];
    e.get(`${i}s Active`).decrementCount();
  }
  /** Called by subclass to track memory allocations */
  trackAllocatedMemory(e, i = this[Symbol.toStringTag]) {
    const s = this._device.statsManager.getStats("Resource Counts");
    s.get("GPU Memory").addCount(e), s.get(`${i} Memory`).addCount(e), this.allocatedBytes = e;
  }
  /** Called by subclass to track memory deallocations */
  trackDeallocatedMemory(e = this[Symbol.toStringTag]) {
    const i = this._device.statsManager.getStats("Resource Counts");
    i.get("GPU Memory").subtractCount(this.allocatedBytes), i.get(`${e} Memory`).subtractCount(this.allocatedBytes), this.allocatedBytes = 0;
  }
  /** Called by resource constructor to track object creation */
  addStats() {
    const e = this._device.statsManager.getStats("Resource Counts"), i = this[Symbol.toStringTag];
    e.get("Resources Created").incrementCount(), e.get(`${i}s Created`).incrementCount(), e.get(`${i}s Active`).incrementCount();
  }
};
function UM(t, e) {
  const i = { ...e };
  for (const s in t)
    t[s] !== void 0 && (i[s] = t[s]);
  return i;
}
class Mi extends pi {
  static defaultProps = {
    ...pi.defaultProps,
    usage: 0,
    // Buffer.COPY_DST | Buffer.COPY_SRC
    byteLength: 0,
    byteOffset: 0,
    data: null,
    indexType: "uint16",
    mappedAtCreation: !1
  };
  // Usage Flags
  static MAP_READ = 1;
  static MAP_WRITE = 2;
  static COPY_SRC = 4;
  static COPY_DST = 8;
  /** Index buffer */
  static INDEX = 16;
  /** Vertex buffer */
  static VERTEX = 32;
  /** Uniform buffer */
  static UNIFORM = 64;
  /** Storage buffer */
  static STORAGE = 128;
  static INDIRECT = 256;
  static QUERY_RESOLVE = 512;
  get [Symbol.toStringTag]() {
    return "Buffer";
  }
  /** The usage with which this buffer was created */
  usage;
  /** For index buffers, whether indices are 16 or 32 bit */
  indexType;
  /** "Time" of last update */
  updateTimestamp;
  constructor(e, i) {
    const s = { ...i };
    (i.usage || 0) & Mi.INDEX && !i.indexType && (i.data instanceof Uint32Array ? s.indexType = "uint32" : i.data instanceof Uint16Array && (s.indexType = "uint16")), super(e, s, Mi.defaultProps), this.usage = i.usage || 0, this.indexType = s.indexType, this.updateTimestamp = e.incrementTimestamp();
  }
  /** Read data synchronously. @note WebGL2 only */
  readSyncWebGL(e, i) {
    throw new Error("not implemented");
  }
  // PROTECTED METHODS (INTENDED FOR USE BY OTHER FRAMEWORK CODE ONLY)
  /** Max amount of debug data saved. Two vec4's */
  static DEBUG_DATA_MAX_LENGTH = 32;
  /** A partial CPU-side copy of the data in this buffer, for debugging purposes */
  debugData = new ArrayBuffer(0);
  /** This doesn't handle partial non-zero offset updates correctly */
  _setDebugData(e, i, s) {
    const o = ArrayBuffer.isView(e) ? e.buffer : e, u = Math.min(e ? e.byteLength : s, Mi.DEBUG_DATA_MAX_LENGTH);
    e === null ? this.debugData = new ArrayBuffer(u) : i === 0 && s === e.byteLength ? this.debugData = o.slice(0, u) : this.debugData = o.slice(i, i + u);
  }
}
function Bw(t) {
  const e = _v[t], i = zM(e), s = t.includes("norm"), o = !s && !t.startsWith("float"), u = t.startsWith("s");
  return {
    dataType: _v[t],
    byteLength: i,
    integer: o,
    signed: u,
    normalized: s
  };
}
function zM(t) {
  return VM[t];
}
const _v = {
  uint8: "uint8",
  sint8: "sint8",
  unorm8: "uint8",
  snorm8: "sint8",
  uint16: "uint16",
  sint16: "sint16",
  unorm16: "uint16",
  snorm16: "sint16",
  float16: "float16",
  float32: "float32",
  uint32: "uint32",
  sint32: "sint32"
}, VM = {
  uint8: 1,
  sint8: 1,
  uint16: 2,
  sint16: 2,
  float16: 2,
  float32: 4,
  uint32: 4,
  sint32: 4
}, jM = [
  "bc1",
  "bc2",
  "bc3",
  "bc4",
  "bc5",
  "bc6",
  "bc7",
  "etc1",
  "etc2",
  "eac",
  "atc",
  "astc",
  "pvrtc"
], HM = /^(rg?b?a?)([0-9]*)([a-z]*)(-srgb)?(-webgl|-unsized)?$/;
function $M(t) {
  return jM.some((e) => t.startsWith(e));
}
function Dw(t) {
  const e = HM.exec(t);
  if (e) {
    const [, i, s, o, u, d] = e;
    if (i) {
      const a = `${o}${s}`, w = Bw(a);
      return {
        format: i,
        components: i.length,
        // dataType - overwritten by decodedType
        srgb: u === "-srgb",
        unsized: d === "-unsized",
        webgl: d === "-webgl",
        ...w
      };
    }
  }
  return WM(t);
}
const GM = {
  // Packed 16 bit formats
  "rgba4unorm-webgl": { format: "rgba", bpp: 2 },
  "rgb565unorm-webgl": { format: "rgb", bpp: 2 },
  "rgb5a1unorm-webgl": { format: "rgba", bbp: 2 },
  // Packed 32 bit formats
  rgb9e5ufloat: { format: "rgb", bbp: 4 },
  rg11b10ufloat: { format: "rgb", bbp: 4 },
  rgb10a2unorm: { format: "rgba", bbp: 4 },
  "rgb10a2uint-webgl": { format: "rgba", bbp: 4 },
  // Depth/stencil
  stencil8: { components: 1, bpp: 1, a: "stencil" },
  depth16unorm: { components: 1, bpp: 2, a: "depth" },
  depth24plus: { components: 1, bpp: 3, a: "depth" },
  depth32float: { components: 1, bpp: 4, a: "depth" },
  "depth24plus-stencil8": { components: 2, bpp: 4, a: "depth-stencil" },
  // "depth24unorm-stencil8" feature
  "depth24unorm-stencil8": { components: 2, bpp: 4, a: "depth-stencil" },
  // "depth32float-stencil8" feature
  "depth32float-stencil8": { components: 2, bpp: 4, a: "depth-stencil" }
};
function WM(t) {
  const e = GM[t];
  if (!e)
    throw new Error(`Unknown format ${t}`);
  return {
    format: e.format || "",
    components: e.components || e.format?.length || 1,
    byteLength: e.bpp || 1,
    srgb: !1,
    unsized: !1
  };
}
class XM {
}
class qM {
  features;
  disabledFeatures;
  constructor(e = [], i) {
    this.features = new Set(e), this.disabledFeatures = i || {};
  }
  *[Symbol.iterator]() {
    yield* this.features;
  }
  has(e) {
    return !this.disabledFeatures[e] && this.features.has(e);
  }
}
class sh {
  static defaultProps = {
    id: null,
    canvas: null,
    container: null,
    manageState: !0,
    width: 800,
    // width are height are only used by headless gl
    height: 600,
    requestMaxLimits: !0,
    debug: !!Je.get("debug"),
    // Instrument context (at the expense of performance)
    spector: !!(Je.get("spector") || Je.get("spectorjs")),
    // Initialize the SpectorJS WebGL debugger
    break: [],
    // TODO - Change these after confirming things work as expected
    initalizeFeatures: !0,
    disabledFeatures: {
      "compilation-status-async-webgl": !0
    },
    // alpha: undefined,
    // depth: undefined,
    // stencil: undefined,
    // antialias: undefined,
    // premultipliedAlpha: undefined,
    // preserveDrawingBuffer: undefined,
    // failIfMajorPerformanceCaveat: undefined
    gl: null,
    // Callbacks
    onError: (e) => Je.error(e.message)
  };
  get [Symbol.toStringTag]() {
    return "Device";
  }
  static VERSION = NM;
  constructor(e) {
    this.props = { ...sh.defaultProps, ...e }, this.id = this.props.id || Pa(this[Symbol.toStringTag].toLowerCase());
  }
  /** id of this device, primarily for debugging */
  id;
  /** A copy of the device props  */
  props;
  /** Available for the application to store data on the device */
  userData = {};
  /** stats */
  statsManager = ny;
  /** Used by other luma.gl modules to store data on the device */
  _lumaData = {};
  /** Check if a specific texture format is GPU compressed */
  isTextureFormatCompressed(e) {
    return $M(e);
  }
  /**
   * Trigger device loss.
   * @returns `true` if context loss could actually be triggered.
   * @note primarily intended for testing how application reacts to device loss
   */
  loseDevice() {
    return !1;
  }
  /** Returns the default / primary canvas context. Throws an error if no canvas context is available (a WebGPU compute device) */
  getCanvasContext() {
    if (!this.canvasContext)
      throw new Error("Device has no CanvasContext");
    return this.canvasContext;
  }
  createTexture(e) {
    return (e instanceof Promise || typeof e == "string") && (e = { data: e }), this._createTexture(e);
  }
  createCommandEncoder(e = {}) {
    throw new Error("not implemented");
  }
  // WebGL specific HACKS - enables app to remove webgl import
  // Use until we have a better way to handle these
  /** @deprecated - will be removed - should use command encoder */
  readPixelsToArrayWebGL(e, i) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use command encoder */
  readPixelsToBufferWebGL(e, i) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */
  setParametersWebGL(e) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */
  getParametersWebGL(e) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */
  withParametersWebGL(e, i) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use clear arguments in RenderPass */
  clearWebGL(e) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use for debugging only */
  resetWebGL() {
    throw new Error("not implemented");
  }
  timestamp = 0;
  /** A monotonic counter for tracking buffer and texture updates */
  incrementTimestamp() {
    return this.timestamp++;
  }
  // Error Handling
  /** Report unhandled device errors */
  onError(e) {
    this.props.onError(e);
  }
  // IMPLEMENTATION
  _getBufferProps(e) {
    (e instanceof ArrayBuffer || ArrayBuffer.isView(e)) && (e = { data: e });
    const i = { ...e };
    return (e.usage || 0) & Mi.INDEX && !e.indexType && (e.data instanceof Uint32Array ? i.indexType = "uint32" : e.data instanceof Uint16Array ? i.indexType = "uint16" : Je.warn("indices buffer content must be of integer type")()), i;
  }
}
function si(t, e) {
  if (!t)
    throw new Error(e || "luma.gl: assertion failed.");
}
const wu = /* @__PURE__ */ new Map();
class Yc {
  static defaultProps = {
    ...sh.defaultProps,
    type: "best-available",
    devices: void 0
  };
  /** Global stats for all devices */
  static stats = ny;
  /** Global log */
  static log = Je;
  static registerDevices(e) {
    for (const i of e)
      si(i.type && i.isSupported && i.create), wu.set(i.type, i);
  }
  static getAvailableDevices() {
    return Array.from(wu).map((e) => e.type);
  }
  static getSupportedDevices() {
    return Array.from(wu).filter((e) => e.isSupported()).map((e) => e.type);
  }
  static setDefaultDeviceProps(e) {
    Object.assign(sh.defaultProps, e);
  }
  /** Attach to an existing GPU API handle (WebGL2RenderingContext or GPUDevice). */
  static async attachDevice(e) {
    const i = gv(e.devices) || wu;
    if (e.handle instanceof WebGL2RenderingContext) {
      const s = i.get("webgl");
      if (s)
        return await s.attach(e.handle);
    }
    if (e.handle === null) {
      const s = i.get("unknown");
      if (s)
        return await s.attach(null);
    }
    throw new Error("Failed to attach device. Ensure `@luma.gl/webgl` and/or `@luma.gl/webgpu` modules are imported.");
  }
  /** Creates a device. Asynchronously. */
  static async createDevice(e = {}) {
    e = { ...Yc.defaultProps, ...e }, e.gl && (e.type = "webgl");
    const i = gv(e.devices) || wu;
    let s, o;
    switch (e.type) {
      case "webgpu":
        if (s = i.get("webgpu"), s)
          return await s.create(e);
        break;
      case "webgl":
        if (o = i.get("webgl"), o)
          return await o.create(e);
        break;
      case "unknown":
        const u = i.get("unknown");
        if (u)
          return await u.create(e);
        break;
      case "best-available":
        if (s = i.get("webgpu"), s?.isSupported?.())
          return await s.create(e);
        if (o = i.get("webgl"), o?.isSupported?.())
          return await o.create(e);
        break;
    }
    throw new Error("No matching device found. Ensure `@luma.gl/webgl` and/or `@luma.gl/webgpu` modules are imported.");
  }
  static enforceWebGL2(e = !0) {
    const i = HTMLCanvasElement.prototype;
    if (!e && i.originalGetContext) {
      i.getContext = i.originalGetContext, i.originalGetContext = void 0;
      return;
    }
    i.originalGetContext = i.getContext, i.getContext = function(s, o) {
      return s === "webgl" || s === "experimental-webgl" ? this.originalGetContext("webgl2", o) : this.originalGetContext(s, o);
    };
  }
}
function gv(t) {
  if (!t || t?.length === 0)
    return null;
  const e = /* @__PURE__ */ new Map();
  for (const i of t)
    e.set(i.type, i);
  return e;
}
const ZM = Ra() && typeof document < "u", Cp = () => ZM && document.readyState === "complete", KM = {
  canvas: null,
  width: 800,
  // width are height are only used by headless gl
  height: 600,
  useDevicePixels: !0,
  autoResize: !0,
  container: null,
  visible: !0,
  colorSpace: "srgb",
  alphaMode: "opaque"
};
class Ow {
  id;
  props;
  canvas;
  htmlCanvas;
  offscreenCanvas;
  type;
  width = 1;
  height = 1;
  resizeObserver;
  /** State used by luma.gl classes: TODO - move to canvasContext*/
  _canvasSizeInfo = { clientWidth: 0, clientHeight: 0, devicePixelRatio: 1 };
  /** Check if the DOM is loaded */
  static get isPageLoaded() {
    return Cp();
  }
  /**
   * Get a 'lazy' promise that resolves when the DOM is loaded.
   * @note Since there may be limitations on number of `load` event listeners,
   * it is recommended avoid calling this function until actually needed.
   * I.e. don't call it until you know that you will be looking up a string in the DOM.
   */
  static pageLoaded = YM();
  constructor(e) {
    if (this.props = { ...KM, ...e }, e = this.props, !Ra()) {
      this.id = "node-canvas-context", this.type = "node", this.width = this.props.width, this.height = this.props.height, this.canvas = null;
      return;
    }
    if (e.canvas)
      typeof e.canvas == "string" ? this.canvas = QM(e.canvas) : this.canvas = e.canvas;
    else {
      const i = eR(e), s = JM(e?.container || null);
      s.insertBefore(i, s.firstChild), this.canvas = i, e?.visible || (this.canvas.style.visibility = "hidden");
    }
    this.canvas instanceof HTMLCanvasElement ? (this.id = this.canvas.id, this.type = "html-canvas", this.htmlCanvas = this.canvas) : (this.id = "offscreen-canvas", this.type = "offscreen-canvas", this.offscreenCanvas = this.canvas), this.canvas instanceof HTMLCanvasElement && e.autoResize && (this.resizeObserver = new ResizeObserver((i) => {
      for (const s of i)
        s.target === this.canvas && this.update();
    }), this.resizeObserver.observe(this.canvas));
  }
  /**
   * Returns the current DPR, if props.useDevicePixels is true
   * Device refers to physical
   */
  getDevicePixelRatio(e) {
    return typeof OffscreenCanvas < "u" && this.canvas instanceof OffscreenCanvas || (e = e === void 0 ? this.props.useDevicePixels : e, !e || e <= 0) ? 1 : e === !0 ? typeof window < "u" && window.devicePixelRatio || 1 : e;
  }
  /**
   * Returns the size of drawing buffer in device pixels.
   * @note This can be different from the 'CSS' size of a canvas, and also from the
   * canvas' internal drawing buffer size (.width, .height).
   * This is the size required to cover the canvas, adjusted for DPR
   */
  getPixelSize() {
    switch (this.type) {
      case "node":
        return [this.width, this.height];
      case "offscreen-canvas":
        return [this.canvas.width, this.canvas.height];
      case "html-canvas":
        const e = this.getDevicePixelRatio(), i = this.canvas;
        return i.parentElement ? [i.clientWidth * e, i.clientHeight * e] : [this.canvas.width, this.canvas.height];
      default:
        throw new Error(this.type);
    }
  }
  getAspect() {
    const [e, i] = this.getPixelSize();
    return e / i;
  }
  /**
   * Returns multiplier need to convert CSS size to Device size
   */
  cssToDeviceRatio() {
    try {
      const [e] = this.getDrawingBufferSize(), { clientWidth: i } = this._canvasSizeInfo;
      return i ? e / i : 1;
    } catch {
      return 1;
    }
  }
  /**
   * Maps CSS pixel position to device pixel position
   */
  cssToDevicePixels(e, i = !0) {
    const s = this.cssToDeviceRatio(), [o, u] = this.getDrawingBufferSize();
    return tR(e, s, o, u, i);
  }
  /**
   * Use devicePixelRatio to set canvas width and height
   * @note this is a raw port of luma.gl v8 code. Might be worth a review
   */
  setDevicePixelRatio(e, i = {}) {
    if (!this.htmlCanvas)
      return;
    let s = "width" in i ? i.width : this.htmlCanvas.clientWidth, o = "height" in i ? i.height : this.htmlCanvas.clientHeight;
    (!s || !o) && (Je.log(1, "Canvas clientWidth/clientHeight is 0")(), e = 1, s = this.htmlCanvas.width || 1, o = this.htmlCanvas.height || 1);
    const u = this._canvasSizeInfo;
    if (u.clientWidth !== s || u.clientHeight !== o || u.devicePixelRatio !== e) {
      let d = e;
      const a = Math.floor(s * d), w = Math.floor(o * d);
      this.htmlCanvas.width = a, this.htmlCanvas.height = w;
      const [S, M] = this.getDrawingBufferSize();
      (S !== a || M !== w) && (d = Math.min(S / s, M / o), this.htmlCanvas.width = Math.floor(s * d), this.htmlCanvas.height = Math.floor(o * d), Je.warn("Device pixel ratio clamped")()), this._canvasSizeInfo.clientWidth = s, this._canvasSizeInfo.clientHeight = o, this._canvasSizeInfo.devicePixelRatio = e;
    }
  }
  // PRIVATE
  /** @todo Major hack done to port the CSS methods above, base canvas context should not depend on WebGL */
  getDrawingBufferSize() {
    const e = this.device.gl;
    if (!e)
      throw new Error("canvas size");
    return [e.drawingBufferWidth, e.drawingBufferHeight];
  }
  /**
   * Allows subclass constructor to override the canvas id for auto created canvases.
   * This can really help when debugging DOM in apps that create multiple devices
   */
  _setAutoCreatedCanvasId(e) {
    this.htmlCanvas?.id === "lumagl-auto-created-canvas" && (this.htmlCanvas.id = e);
  }
}
function YM() {
  return Cp() || typeof window > "u" ? Promise.resolve() : new Promise((t) => {
    window.addEventListener("load", () => t());
  });
}
function JM(t) {
  if (typeof t == "string") {
    const e = document.getElementById(t);
    if (!e && !Cp())
      throw new Error(`Accessing '${t}' before page was loaded`);
    if (!e)
      throw new Error(`${t} is not an HTML element`);
    return e;
  } else if (t)
    return t;
  return document.body;
}
function QM(t) {
  const e = document.getElementById(t);
  if (!e && !Cp())
    throw new Error(`Accessing '${t}' before page was loaded`);
  if (!(e instanceof HTMLCanvasElement))
    throw new Error("Object is not a canvas element");
  return e;
}
function eR(t) {
  const { width: e, height: i } = t, s = document.createElement("canvas");
  return s.id = "lumagl-auto-created-canvas", s.width = e || 1, s.height = i || 1, s.style.width = Number.isFinite(e) ? `${e}px` : "100%", s.style.height = Number.isFinite(i) ? `${i}px` : "100%", s;
}
function tR(t, e, i, s, o) {
  const u = t, d = mv(u[0], e, i);
  let a = yv(u[1], e, s, o), w = mv(u[0] + 1, e, i);
  const S = w === i - 1 ? w : w - 1;
  w = yv(u[1] + 1, e, s, o);
  let M;
  return o ? (w = w === 0 ? w : w + 1, M = a, a = w) : M = w === s - 1 ? w : w - 1, {
    x: d,
    y: a,
    // when ratio < 1, current css pixel and next css pixel may point to same device pixel, set width/height to 1 in those cases.
    width: Math.max(S - d + 1, 1),
    height: Math.max(M - a + 1, 1)
  };
}
function mv(t, e, i) {
  return Math.min(Math.round(t * e), i - 1);
}
function yv(t, e, i, s) {
  return s ? Math.max(0, i - 1 - Math.round(t * e)) : Math.min(Math.round(t * e), i - 1);
}
class qs extends pi {
  static defaultProps = {
    ...pi.defaultProps,
    data: null,
    dimension: "2d",
    format: "rgba8unorm",
    width: void 0,
    height: void 0,
    depth: 1,
    mipmaps: !0,
    // type: undefined,
    compressed: !1,
    // mipLevels: 1,
    usage: 0,
    // usage: GPUTextureUsage.COPY_DST
    mipLevels: void 0,
    samples: void 0,
    type: void 0,
    sampler: {},
    view: void 0
  };
  static COPY_SRC = 1;
  static COPY_DST = 2;
  static TEXTURE_BINDING = 4;
  static STORAGE_BINDING = 8;
  static RENDER_ATTACHMENT = 16;
  get [Symbol.toStringTag]() {
    return "Texture";
  }
  /** dimension of this texture */
  dimension;
  /** format of this texture */
  format;
  /** width in pixels of this texture */
  width;
  /** height in pixels of this texture */
  height;
  /** depth of this texture */
  depth;
  /** "Time" of last update. Monotonically increasing timestamp */
  updateTimestamp;
  /** Do not use directly. Create with device.createTexture() */
  constructor(e, i, s = qs.defaultProps) {
    super(e, i, s), this.dimension = this.props.dimension, this.format = this.props.format, this.width = this.props.width, this.height = this.props.height, this.depth = this.props.depth, this.updateTimestamp = e.incrementTimestamp();
  }
}
class Ip extends pi {
  static defaultProps = {
    ...pi.defaultProps,
    format: void 0,
    dimension: void 0,
    aspect: "all",
    baseMipLevel: 0,
    mipLevelCount: void 0,
    baseArrayLayer: 0,
    arrayLayerCount: void 0
  };
  get [Symbol.toStringTag]() {
    return "TextureView";
  }
  /** Should not be constructed directly. Use `texture.createView(props)` */
  constructor(e, i) {
    super(e, i, Ip.defaultProps);
  }
}
function iR(t, e, i) {
  let s = "";
  const o = e.split(/\r?\n/), u = t.slice().sort((d, a) => d.lineNum - a.lineNum);
  switch (i?.showSourceCode || "no") {
    case "all":
      let d = 0;
      for (let a = 1; a <= o.length; a++)
        for (s += Fw(o[a - 1], a, i); u.length > d && u[d].lineNum === a; ) {
          const w = u[d++];
          s += bv(w, o, w.lineNum, {
            ...i,
            inlineSource: !1
          });
        }
      return s;
    case "issues":
    case "no":
      for (const a of t)
        s += bv(a, o, a.lineNum, {
          inlineSource: i?.showSourceCode !== "no"
        });
      return s;
  }
}
function bv(t, e, i, s) {
  if (s?.inlineSource) {
    const o = rR(e, i), u = t.linePos > 0 ? `${" ".repeat(t.linePos + 5)}^^^
` : "";
    return `
${o}${u}${t.type.toUpperCase()}: ${t.message}

`;
  }
  return s?.html ? `<div class='luma-compiler-log-error' style="color:red;"><b> ${t.type.toUpperCase()}: ${t.message}</b></div>` : `${t.type.toUpperCase()}: ${t.message}`;
}
function rR(t, e, i) {
  let s = "";
  for (let o = e - 2; o <= e; o++) {
    const u = t[o - 1];
    u !== void 0 && (s += Fw(u, e, i));
  }
  return s;
}
function Fw(t, e, i) {
  const s = i?.html ? nR(t) : t;
  return `${sR(String(e), 4)}: ${s}${i?.html ? "<br/>" : `
`}`;
}
function sR(t, e) {
  let i = "";
  for (let s = t.length; s < e; ++s)
    i += " ";
  return i + t;
}
function nR(t) {
  return t.replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;").replaceAll('"', "&quot;").replaceAll("'", "&#039;");
}
function kw(t, e) {
  return {
    name: oR(t, e),
    language: "glsl",
    version: aR(t)
  };
}
function oR(t, e = "unnamed") {
  const s = /#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/.exec(t);
  return s ? s[1] : e;
}
function aR(t) {
  let e = 100;
  const i = t.match(/[^\s]+/g);
  if (i && i.length >= 2 && i[0] === "#version") {
    const s = parseInt(i[1], 10);
    Number.isFinite(s) && (e = s);
  }
  return e;
}
class Mp extends pi {
  static defaultProps = {
    ...pi.defaultProps,
    language: "auto",
    stage: void 0,
    source: "",
    sourceMap: null,
    entryPoint: "main",
    debug: "errors"
  };
  get [Symbol.toStringTag]() {
    return "Shader";
  }
  /** The stage of this shader */
  stage;
  /** The source code of this shader */
  source;
  /** The compilation status of the shader. 'pending' if compilation is asynchronous, and on production */
  compilationStatus = "pending";
  /** Create a new Shader instance */
  constructor(e, i) {
    super(e, { id: lR(i), ...i }, Mp.defaultProps), this.stage = this.props.stage, this.source = this.props.source;
  }
  /** Get compiler log synchronously (WebGL only) */
  getCompilationInfoSync() {
    return null;
  }
  /** Get translated shader source in host platform's native language (HLSL, GLSL, and even GLSL ES), if available */
  getTranslatedSource() {
    return null;
  }
  // PORTABLE HELPERS
  /** In browser logging of errors */
  async debugShader(e = this.props.debug) {
    switch (e) {
      case "never":
        return;
      case "errors":
        if (this.compilationStatus === "success")
          return;
        break;
    }
    const i = await this.getCompilationInfo();
    this.props.debug === "warnings" && i?.length === 0 || this._displayShaderLog(i);
  }
  // PRIVATE
  /** In-browser UI logging of errors */
  _displayShaderLog(e) {
    if (typeof document > "u" || !document?.createElement)
      return;
    const i = kw(this.source).name, s = `${this.stage} ${i}`;
    let o = iR(e, this.source, { showSourceCode: "all", html: !0 });
    const u = this.getTranslatedSource();
    u && (o += `<br /><br /><h1>Translated Source</h1><br /><br /><code style="user-select:text;"><pre>${u}</pre></code>`);
    const d = document.createElement("Button");
    d.innerHTML = `
<h1>Shader Compilation Error in ${s}</h1><br /><br />
<code style="user-select:text;"><pre>
${o}
</pre></code>`, d.style.top = "10px", d.style.left = "10px", d.style.position = "absolute", d.style.zIndex = "9999", d.style.width = "100%", d.style.textAlign = "left", document.body.appendChild(d);
    const a = document.getElementsByClassName("luma-compiler-log-error");
    a[0]?.scrollIntoView && a[0].scrollIntoView(), d.onclick = () => {
      const w = `data:text/plain,${encodeURIComponent(this.source)}`;
      navigator.clipboard.writeText(w);
    };
  }
}
function lR(t) {
  return kw(t.source).name || t.id || Pa(`unnamed ${t.stage}-shader`);
}
class Rp extends pi {
  static defaultProps = {
    ...pi.defaultProps,
    type: "color-sampler",
    addressModeU: "clamp-to-edge",
    addressModeV: "clamp-to-edge",
    addressModeW: "clamp-to-edge",
    magFilter: "nearest",
    minFilter: "nearest",
    mipmapFilter: "nearest",
    lodMinClamp: 0,
    lodMaxClamp: 32,
    // Per WebGPU spec
    compare: "less-equal",
    maxAnisotropy: 1
  };
  get [Symbol.toStringTag]() {
    return "Sampler";
  }
  constructor(e, i) {
    super(e, i, Rp.defaultProps);
  }
}
class Pp extends pi {
  static defaultProps = {
    ...pi.defaultProps,
    width: 1,
    height: 1,
    colorAttachments: [],
    // ['rgba8unorm'],
    depthStencilAttachment: null
    // 'depth24plus-stencil8'
  };
  get [Symbol.toStringTag]() {
    return "Framebuffer";
  }
  /** Width of all attachments in this framebuffer */
  width;
  /** Height of all attachments in this framebuffer */
  height;
  /** Color attachments */
  colorAttachments = [];
  /** Depth-stencil attachment, if provided */
  depthStencilAttachment = null;
  constructor(e, i = {}) {
    super(e, i, Pp.defaultProps), this.width = this.props.width, this.height = this.props.height;
  }
  resize(e) {
    let i = !e;
    if (e) {
      const [s, o] = Array.isArray(e) ? e : [e.width, e.height];
      i = i || o !== this.height || s !== this.width, this.width = s, this.height = o;
    }
    i && (Je.log(2, `Resizing framebuffer ${this.id} to ${this.width}x${this.height}`)(), this.resizeAttachments(this.width, this.height));
  }
  /** Auto creates any textures */
  autoCreateAttachmentTextures() {
    if (this.props.colorAttachments.length === 0 && !this.props.depthStencilAttachment)
      throw new Error("Framebuffer has noattachments");
    this.colorAttachments = this.props.colorAttachments.map((i) => {
      if (typeof i == "string") {
        const s = this.createColorTexture(i);
        return this.attachResource(s), s.view;
      }
      return i instanceof qs ? i.view : i;
    });
    const e = this.props.depthStencilAttachment;
    if (e)
      if (typeof e == "string") {
        const i = this.createDepthStencilTexture(e);
        this.attachResource(i), this.depthStencilAttachment = i.view;
      } else e instanceof qs ? this.depthStencilAttachment = e.view : this.depthStencilAttachment = e;
  }
  /** Create a color texture */
  createColorTexture(e) {
    return this.device.createTexture({
      id: "color-attachment",
      usage: qs.RENDER_ATTACHMENT,
      format: e,
      width: this.width,
      height: this.height
    });
  }
  /** Create depth stencil texture */
  createDepthStencilTexture(e) {
    return this.device.createTexture({
      id: "depth-stencil-attachment",
      usage: qs.RENDER_ATTACHMENT,
      format: e,
      width: this.width,
      height: this.height
    });
  }
  /**
   * Default implementation of resize
   * Creates new textures with correct size for all attachments.
   * and destroys existing textures if owned
   */
  resizeAttachments(e, i) {
    for (let s = 0; s < this.colorAttachments.length; ++s)
      if (this.colorAttachments[s]) {
        const o = this.device._createTexture({
          ...this.colorAttachments[s].props,
          width: e,
          height: i
        });
        this.destroyAttachedResource(this.colorAttachments[s]), this.colorAttachments[s] = o.view, this.attachResource(o.view);
      }
    if (this.depthStencilAttachment) {
      const s = this.device._createTexture({
        ...this.depthStencilAttachment.props,
        width: e,
        height: i
      });
      this.destroyAttachedResource(this.depthStencilAttachment), this.depthStencilAttachment = s.view, this.attachResource(s);
    }
  }
}
class nh extends pi {
  static defaultProps = {
    ...pi.defaultProps,
    vs: null,
    vertexEntryPoint: "vertexMain",
    vsConstants: {},
    fs: null,
    fragmentEntryPoint: "fragmentMain",
    fsConstants: {},
    shaderLayout: null,
    bufferLayout: [],
    topology: "triangle-list",
    parameters: {},
    // isInstanced: false,
    // instanceCount: 0,
    // vertexCount: 0,
    bindings: {},
    uniforms: {}
  };
  get [Symbol.toStringTag]() {
    return "RenderPipeline";
  }
  /** The merged layout */
  shaderLayout;
  /** Buffer map describing buffer interleaving etc */
  bufferLayout;
  /** The linking status of the pipeline. 'pending' if linking is asynchronous, and on production */
  linkStatus = "pending";
  /** The hash of the pipeline */
  hash = "";
  constructor(e, i) {
    super(e, i, nh.defaultProps), this.shaderLayout = this.props.shaderLayout, this.bufferLayout = this.props.bufferLayout || [];
  }
  // DEPRECATED METHODS
  /**
   * Uniforms
   * @deprecated Use uniforms buffers
   * @note textures, samplers and uniform buffers should be set via `setBindings()`, these are not considered uniforms.
   * @note In WebGL uniforms have a performance penalty, they are reset before each call to enable pipeline sharing.
   */
  setUniformsWebGL(e) {
    throw new Error("Use uniform blocks");
  }
}
class oy extends pi {
  /** Default properties for RenderPass */
  static defaultProps = {
    ...pi.defaultProps,
    framebuffer: null,
    parameters: void 0,
    clearColor: [0, 0, 0, 0],
    clearDepth: 1,
    clearStencil: 0,
    depthReadOnly: !1,
    stencilReadOnly: !1,
    discard: !1,
    occlusionQuerySet: void 0,
    timestampQuerySet: void 0,
    beginTimestampIndex: void 0,
    endTimestampIndex: void 0
  };
  get [Symbol.toStringTag]() {
    return "RenderPass";
  }
  constructor(e, i) {
    super(e, i, oy.defaultProps);
  }
}
class cp extends pi {
  static defaultProps = {
    ...pi.defaultProps,
    shader: void 0,
    entryPoint: void 0,
    constants: {},
    shaderLayout: void 0
  };
  get [Symbol.toStringTag]() {
    return "ComputePipeline";
  }
  hash = "";
  constructor(e, i) {
    super(e, i, cp.defaultProps);
  }
}
class ay extends pi {
  static defaultProps = {
    ...pi.defaultProps,
    measureExecutionTime: void 0
  };
  get [Symbol.toStringTag]() {
    return "CommandEncoder";
  }
  constructor(e, i) {
    super(e, i, ay.defaultProps);
  }
}
class ly extends pi {
  static defaultProps = {
    ...pi.defaultProps
  };
  get [Symbol.toStringTag]() {
    return "CommandBuffer";
  }
  constructor(e, i) {
    super(e, i, ly.defaultProps);
  }
}
function cR(t) {
  const [e, i] = uR[t], s = e === "i32" || e === "u32", o = e !== "u32", u = dR[e] * i, d = hR(e, i);
  return {
    dataType: e,
    components: i,
    defaultVertexFormat: d,
    byteLength: u,
    integer: s,
    signed: o
  };
}
function hR(t, e) {
  let i;
  switch (t) {
    case "f32":
      i = "float32";
      break;
    case "i32":
      i = "sint32";
      break;
    case "u32":
      i = "uint32";
      break;
    case "f16":
      return e <= 2 ? "float16x2" : "float16x4";
  }
  return e === 1 ? i : `${i}x${e}`;
}
const uR = {
  f32: ["f32", 1],
  "vec2<f32>": ["f32", 2],
  "vec3<f32>": ["f32", 3],
  "vec4<f32>": ["f32", 4],
  f16: ["f16", 1],
  "vec2<f16>": ["f16", 2],
  "vec3<f16>": ["f16", 3],
  "vec4<f16>": ["f16", 4],
  i32: ["i32", 1],
  "vec2<i32>": ["i32", 2],
  "vec3<i32>": ["i32", 3],
  "vec4<i32>": ["i32", 4],
  u32: ["u32", 1],
  "vec2<u32>": ["u32", 2],
  "vec3<u32>": ["u32", 3],
  "vec4<u32>": ["u32", 4]
}, dR = {
  f32: 4,
  f16: 2,
  i32: 4,
  u32: 4
  // 'bool-webgl': 4,
};
function Nw(t) {
  let e;
  t.endsWith("-webgl") && (t.replace("-webgl", ""), e = !0);
  const [i, s] = t.split("x"), o = i, u = s ? parseInt(s) : 1, d = Bw(o), a = {
    type: o,
    components: u,
    byteLength: d.byteLength * u,
    integer: d.integer,
    signed: d.signed,
    normalized: d.normalized
  };
  return e && (a.webglOnly = !0), a;
}
function Lw(t, e) {
  const i = {};
  for (const s of t.attributes)
    i[s.name] = pR(t, e, s.name);
  return i;
}
function fR(t, e, i = 16) {
  const s = Lw(t, e), o = new Array(i).fill(null);
  for (const u of Object.values(s))
    o[u.location] = u;
  return o;
}
function pR(t, e, i) {
  const s = _R(t, i), o = gR(e, i);
  if (!s)
    return null;
  const u = cR(s.type), d = o?.vertexFormat || u.defaultVertexFormat, a = Nw(d);
  return {
    attributeName: o?.attributeName || s.name,
    bufferName: o?.bufferName || s.name,
    location: s.location,
    shaderType: s.type,
    shaderDataType: u.dataType,
    shaderComponents: u.components,
    vertexFormat: d,
    bufferDataType: a.type,
    bufferComponents: a.components,
    // normalized is a property of the buffer's vertex format
    normalized: a.normalized,
    // integer is a property of the shader declaration
    integer: u.integer,
    stepMode: o?.stepMode || s.stepMode,
    byteOffset: o?.byteOffset || 0,
    byteStride: o?.byteStride || 0
  };
}
function _R(t, e) {
  const i = t.attributes.find((s) => s.name === e);
  return i || Je.warn(`shader layout attribute "${e}" not present in shader`), i || null;
}
function gR(t, e) {
  mR(t);
  let i = yR(t, e);
  return i || (i = bR(t, e), i) ? i : (Je.warn(`layout for attribute "${e}" not present in buffer layout`), null);
}
function mR(t) {
  for (const e of t)
    (e.attributes && e.format || !e.attributes && !e.format) && Je.warn(`BufferLayout ${name} must have either 'attributes' or 'format' field`);
}
function yR(t, e) {
  for (const i of t)
    if (i.format && i.name === e)
      return {
        attributeName: i.name,
        bufferName: e,
        stepMode: i.stepMode,
        vertexFormat: i.format,
        // If offset is needed, use `attributes` field.
        byteOffset: 0,
        byteStride: i.byteStride || 0
      };
  return null;
}
function bR(t, e) {
  for (const i of t) {
    let s = i.byteStride;
    if (typeof i.byteStride != "number")
      for (const u of i.attributes || []) {
        const d = Nw(u.format);
        s += d.byteLength;
      }
    const o = i.attributes?.find((u) => u.attribute === e);
    if (o)
      return {
        attributeName: o.attribute,
        bufferName: i.name,
        stepMode: i.stepMode,
        vertexFormat: o.format,
        byteOffset: o.byteOffset,
        byteStride: s
      };
  }
  return null;
}
function vR(t, e) {
  const i = {
    ...t,
    attributes: t.attributes.map((s) => ({ ...s }))
  };
  for (const s of e?.attributes || []) {
    const o = i.attributes.find((u) => u.name === s.name);
    o ? (o.type = s.type || o.type, o.stepMode = s.stepMode || o.stepMode) : Je.warn(`shader layout attribute ${s.name} not present in shader`);
  }
  return i;
}
class cy extends pi {
  static defaultProps = {
    ...pi.defaultProps,
    renderPipeline: null
  };
  get [Symbol.toStringTag]() {
    return "VertexArray";
  }
  /** Max number of vertex attributes */
  maxVertexAttributes;
  /** Attribute infos indexed by location - TODO only needed by webgl module? */
  attributeInfos;
  /** Index buffer */
  indexBuffer = null;
  /** Attributes indexed by buffer slot */
  attributes;
  constructor(e, i) {
    super(e, i, cy.defaultProps), this.maxVertexAttributes = e.limits.maxVertexAttributes, this.attributes = new Array(this.maxVertexAttributes).fill(null), this.attributeInfos = fR(i.renderPipeline.shaderLayout, i.renderPipeline.bufferLayout, this.maxVertexAttributes);
  }
  // DEPRECATED METHODS
  /** @deprecated Set constant attributes (WebGL only) */
  setConstantWebGL(e, i) {
    throw new Error("constant attributes not supported");
  }
}
class hy extends pi {
  static defaultProps = {
    ...pi.defaultProps,
    layout: void 0,
    buffers: {}
  };
  get [Symbol.toStringTag]() {
    return "TransformFeedback";
  }
  constructor(e, i) {
    super(e, i, hy.defaultProps);
  }
}
class uy extends pi {
  static defaultProps = {
    ...pi.defaultProps,
    type: void 0,
    count: void 0
  };
  get [Symbol.toStringTag]() {
    return "QuerySet";
  }
  constructor(e, i) {
    super(e, i, uy.defaultProps);
  }
}
const xR = {
  f32: { type: "f32", components: 1 },
  i32: { type: "i32", components: 1 },
  u32: { type: "u32", components: 1 },
  // 'bool-webgl': {type: 'bool-webgl', components: 1},
  "vec2<f32>": { type: "f32", components: 2 },
  "vec3<f32>": { type: "f32", components: 3 },
  "vec4<f32>": { type: "f32", components: 4 },
  "vec2<i32>": { type: "i32", components: 2 },
  "vec3<i32>": { type: "i32", components: 3 },
  "vec4<i32>": { type: "i32", components: 4 },
  "vec2<u32>": { type: "u32", components: 2 },
  "vec3<u32>": { type: "u32", components: 3 },
  "vec4<u32>": { type: "u32", components: 4 },
  "mat2x2<f32>": { type: "f32", components: 4 },
  "mat2x3<f32>": { type: "f32", components: 6 },
  "mat2x4<f32>": { type: "f32", components: 8 },
  "mat3x2<f32>": { type: "f32", components: 6 },
  "mat3x3<f32>": { type: "f32", components: 9 },
  "mat3x4<f32>": { type: "f32", components: 12 },
  "mat4x2<f32>": { type: "f32", components: 8 },
  "mat4x3<f32>": { type: "f32", components: 12 },
  "mat4x4<f32>": { type: "f32", components: 16 }
};
function wR(t) {
  const e = xR[t];
  return si(t), e;
}
function TR(t, e) {
  switch (e) {
    case 1:
      return t;
    // Pad upwards to even multiple of 2
    case 2:
      return t + t % 2;
    // Pad upwards to even multiple of 2
    default:
      return t + (4 - t % 4) % 4;
  }
}
let xf;
function Uw(t) {
  return (!xf || xf.byteLength < t) && (xf = new ArrayBuffer(t)), xf;
}
function AR(t, e) {
  const i = Uw(t.BYTES_PER_ELEMENT * e);
  return new t(i, 0, e);
}
function ER(t) {
  const { target: e, source: i, start: s = 0, count: o = 1 } = t, u = i.length, d = o * u;
  let a = 0;
  for (let w = s; a < u; a++)
    e[w++] = i[a];
  for (; a < d; )
    a < d - a ? (e.copyWithin(s + a, s, s + a), a *= 2) : (e.copyWithin(s + a, s, s + d - a), a = d);
  return t.target;
}
const vv = 1024;
class SR {
  layout = {};
  /** number of bytes needed for buffer allocation */
  byteLength;
  /** Create a new UniformBufferLayout given a map of attributes. */
  constructor(e) {
    let i = 0;
    for (const [o, u] of Object.entries(e)) {
      const d = wR(u), { type: a, components: w } = d;
      i = TR(i, w);
      const S = i;
      i += w, this.layout[o] = { type: a, size: w, offset: S };
    }
    i += (4 - i % 4) % 4;
    const s = i * 4;
    this.byteLength = Math.max(s, vv);
  }
  /** Get the data for the complete buffer */
  getData(e) {
    const i = Math.max(this.byteLength, vv), s = Uw(i), o = {
      i32: new Int32Array(s),
      u32: new Uint32Array(s),
      f32: new Float32Array(s),
      // TODO not implemented
      f16: new Uint16Array(s)
    };
    for (const [u, d] of Object.entries(e)) {
      const a = this.layout[u];
      if (!a) {
        Je.warn(`Supplied uniform value ${u} not present in uniform block layout`)();
        continue;
      }
      const { type: w, size: S, offset: M } = a, F = o[w];
      if (S === 1) {
        if (typeof d != "number" && typeof d != "boolean") {
          Je.warn(`Supplied value for single component uniform ${u} is not a number: ${d}`)();
          continue;
        }
        F[M] = Number(d);
      } else {
        const N = Wu(d);
        if (!N) {
          Je.warn(`Supplied value for multi component / array uniform ${u} is not a numeric array: ${d}`)();
          continue;
        }
        F.set(N, M);
      }
    }
    return new Uint8Array(s);
  }
  /** Does this layout have a field with specified name */
  has(e) {
    return !!this.layout[e];
  }
  /** Get offset and size for a field with specified name */
  get(e) {
    return this.layout[e];
  }
}
function CR(t, e, i = 16) {
  if (t !== e)
    return !1;
  const s = Wu(t);
  if (!s)
    return !1;
  const o = Wu(e);
  if (o && s.length === o.length) {
    for (let u = 0; u < s.length; ++u)
      if (o[u] !== s[u])
        return !1;
  }
  return !0;
}
function IR(t) {
  const e = Wu(t);
  return e ? e.slice() : t;
}
class MR {
  name;
  uniforms = {};
  modifiedUniforms = {};
  modified = !0;
  bindingLayout = {};
  needsRedraw = "initialized";
  constructor(e) {
    if (this.name = e?.name, e?.name && e?.shaderLayout) {
      const i = e?.shaderLayout.bindings?.find((o) => o.type === "uniform" && o.name === e?.name);
      if (!i)
        throw new Error(e?.name);
      const s = i;
      for (const o of s.uniforms || [])
        this.bindingLayout[o.name] = o;
    }
  }
  /** Set a map of uniforms */
  setUniforms(e) {
    for (const [i, s] of Object.entries(e))
      this._setUniform(i, s), this.needsRedraw || this.setNeedsRedraw(`${this.name}.${i}=${s}`);
  }
  setNeedsRedraw(e) {
    this.needsRedraw = this.needsRedraw || e;
  }
  /** Returns all uniforms */
  getAllUniforms() {
    return this.modifiedUniforms = {}, this.needsRedraw = !1, this.uniforms || {};
  }
  /** Set a single uniform */
  _setUniform(e, i) {
    CR(this.uniforms[e], i) || (this.uniforms[e] = IR(i), this.modifiedUniforms[e] = !0, this.modified = !0);
  }
}
class RR {
  /** Stores the uniform values for each uniform block */
  uniformBlocks = /* @__PURE__ */ new Map();
  /** Can generate data for a uniform buffer for each block from data */
  uniformBufferLayouts = /* @__PURE__ */ new Map();
  /** Actual buffer for the blocks */
  uniformBuffers = /* @__PURE__ */ new Map();
  /**
   * Create a new UniformStore instance
   * @param blocks
   */
  constructor(e) {
    for (const [i, s] of Object.entries(e)) {
      const o = i, u = new SR(s.uniformTypes || {});
      this.uniformBufferLayouts.set(o, u);
      const d = new MR({ name: i });
      d.setUniforms(s.defaultUniforms || {}), this.uniformBlocks.set(o, d);
    }
  }
  /** Destroy any managed uniform buffers */
  destroy() {
    for (const e of this.uniformBuffers.values())
      e.destroy();
  }
  /**
   * Set uniforms
   * Makes all properties partial
   */
  setUniforms(e) {
    for (const [i, s] of Object.entries(e))
      this.uniformBlocks.get(i).setUniforms(s);
    this.updateUniformBuffers();
  }
  /** Get the required minimum length of the uniform buffer */
  getUniformBufferByteLength(e) {
    return this.uniformBufferLayouts.get(e).byteLength;
  }
  /** Get formatted binary memory that can be uploaded to a buffer */
  getUniformBufferData(e) {
    const i = this.uniformBlocks.get(e).getAllUniforms();
    return this.uniformBufferLayouts.get(e).getData(i);
  }
  /**
   * Creates an unmanaged uniform buffer (umnanaged means that application is responsible for destroying it)
   * The new buffer is initialized with current / supplied values
   */
  createUniformBuffer(e, i, s) {
    s && this.setUniforms(s);
    const o = this.getUniformBufferByteLength(i), u = e.createBuffer({
      usage: Mi.UNIFORM | Mi.COPY_DST,
      byteLength: o
    }), d = this.getUniformBufferData(i);
    return u.write(d), u;
  }
  /** Get the managed uniform buffer. "managed" resources are destroyed when the uniformStore is destroyed. */
  getManagedUniformBuffer(e, i) {
    if (!this.uniformBuffers.get(i)) {
      const s = this.getUniformBufferByteLength(i), o = e.createBuffer({
        usage: Mi.UNIFORM | Mi.COPY_DST,
        byteLength: s
      });
      this.uniformBuffers.set(i, o);
    }
    return this.uniformBuffers.get(i);
  }
  /** Updates all uniform buffers where values have changed */
  updateUniformBuffers() {
    let e = !1;
    for (const i of this.uniformBlocks.keys()) {
      const s = this.updateUniformBuffer(i);
      e ||= s;
    }
    return e && Je.log(3, `UniformStore.updateUniformBuffers(): ${e}`)(), e;
  }
  /** Update one uniform buffer. Only updates if values have changed */
  updateUniformBuffer(e) {
    const i = this.uniformBlocks.get(e), s = this.uniformBuffers.get(e);
    let o = !1;
    if (s && i.needsRedraw) {
      o ||= i.needsRedraw;
      const u = this.getUniformBufferData(e);
      this.uniformBuffers.get(e).write(u);
      const a = this.uniformBlocks.get(e).getAllUniforms();
      Je.log(4, `Writing to uniform buffer ${String(e)}`, u, a)();
    }
    return o;
  }
}
function zw(t) {
  const e = ArrayBuffer.isView(t) ? t.constructor : t;
  switch (e) {
    case Float32Array:
      return "float32";
    case Uint16Array:
      return "uint16";
    case Uint32Array:
      return "uint32";
    case Uint8Array:
    case Uint8ClampedArray:
      return "uint8";
    case Int8Array:
      return "sint8";
    case Int16Array:
      return "sint16";
    case Int32Array:
      return "sint32";
    default:
      throw new Error(e.constructor.name);
  }
}
function Vw(t) {
  switch (t) {
    case "float32":
      return Float32Array;
    case "uint32":
      return Uint32Array;
    case "sint32":
      return Int32Array;
    case "uint16":
    case "unorm16":
      return Uint16Array;
    case "sint16":
    case "snorm16":
      return Int16Array;
    case "uint8":
    case "unorm8":
      return Uint8Array;
    case "sint8":
    case "snorm8":
      return Int8Array;
    default:
      throw new Error(t);
  }
}
function PR(t, e, i) {
  if (!e || e > 4)
    throw new Error(`size ${e}`);
  const s = e;
  let o = zw(t);
  if (o === "uint8" && i && s === 1)
    return "unorm8-webgl";
  if (o === "uint8" && i && s === 3)
    return "unorm8x3-webgl";
  if (o === "uint8" || o === "sint8") {
    if (s === 1 || s === 3)
      throw new Error(`size: ${e}`);
    return i && (o = o.replace("int", "norm")), `${o}x${s}`;
  }
  if (o === "uint16" || o === "sint16") {
    if (s === 1 || s === 3)
      throw new Error(`size: ${e}`);
    return i && (o = o.replace("int", "norm")), `${o}x${s}`;
  }
  return s === 1 ? o : `${o}x${s}`;
}
function BR(t) {
  return Wu(t) !== null || typeof t == "number" || typeof t == "boolean";
}
function dy(t) {
  const e = { bindings: {}, uniforms: {} };
  return Object.keys(t).forEach((i) => {
    const s = t[i];
    BR(s) ? e.uniforms[i] = s : e.bindings[i] = s;
  }), e;
}
function DR(t, e, i) {
  const { removedProps: s = {}, deprecatedProps: o = {}, replacedProps: u = {} } = i;
  for (const a in s)
    if (a in e) {
      const S = s[a] ? `${t}.${s[a]}` : "N/A";
      Je.removed(`${t}.${a}`, S)();
    }
  for (const a in o)
    if (a in e) {
      const w = o[a];
      Je.deprecated(`${t}.${a}`, `${t}.${w}`)();
    }
  let d = null;
  for (const [a, w] of Object.entries(u))
    a in e && (Je.deprecated(`${t}.${a}`, `${t}.${w}`)(), d = d || Object.assign({}, e), d[w] = e[a], delete d[a]);
  return d || e;
}
let OR = "";
async function FR(t, e) {
  return await new Promise((i, s) => {
    try {
      const o = new Image();
      o.onload = () => i(o), o.onerror = () => s(new Error(`Could not load image ${t}.`)), o.crossOrigin = e?.crossOrigin || "anonymous", o.src = t.startsWith("http") ? t : OR + t;
    } catch (o) {
      s(o);
    }
  });
}
async function jw(t, e) {
  const i = document.getElementsByTagName("head")[0];
  if (!i)
    throw new Error("loadScript");
  const s = document.createElement("script");
  return s.setAttribute("type", "text/javascript"), s.setAttribute("src", t), new Promise((o, u) => {
    s.onload = o, s.onerror = (d) => u(new Error(`Unable to load script '${t}': ${d}`)), i.appendChild(s);
  });
}
function dm(t, e, i) {
  if (t === e)
    return !0;
  if (!i || !t || !e)
    return !1;
  if (Array.isArray(t)) {
    if (!Array.isArray(e) || t.length !== e.length)
      return !1;
    for (let s = 0; s < t.length; s++)
      if (!dm(t[s], e[s], i - 1))
        return !1;
    return !0;
  }
  if (Array.isArray(e))
    return !1;
  if (typeof t == "object" && typeof e == "object") {
    const s = Object.keys(t), o = Object.keys(e);
    if (s.length !== o.length)
      return !1;
    for (const u of s)
      if (!e.hasOwnProperty(u) || !dm(t[u], e[u], i - 1))
        return !1;
    return !0;
  }
  return !1;
}
function kR(t) {
  return typeof window < "u" && window.requestAnimationFrame ? window.requestAnimationFrame(t) : setTimeout(t, 1e3 / 60);
}
function NR(t) {
  return typeof window < "u" && window.cancelAnimationFrame ? window.cancelAnimationFrame(t) : clearTimeout(t);
}
class LR {
  constructor() {
    this.constants = /* @__PURE__ */ new Map(), this.aliases = /* @__PURE__ */ new Map(), this.structs = /* @__PURE__ */ new Map();
  }
}
class Lo {
  constructor() {
  }
  get isAstNode() {
    return !0;
  }
  get astNodeType() {
    return "";
  }
  evaluate(e) {
    throw new Error("Cannot evaluate node");
  }
  evaluateString(e) {
    return this.evaluate(e).toString();
  }
  search(e) {
  }
  searchBlock(e, i) {
    if (e) {
      i(hp.instance);
      for (const s of e)
        s instanceof Array ? this.searchBlock(s, i) : s.search(i);
      i(up.instance);
    }
  }
}
class hp extends Lo {
}
hp.instance = new hp();
class up extends Lo {
}
up.instance = new up();
class Oi extends Lo {
  constructor() {
    super();
  }
}
class fm extends Oi {
  constructor(e, i, s, o, u, d) {
    super(), this.calls = /* @__PURE__ */ new Set(), this.name = e, this.args = i, this.returnType = s, this.body = o, this.startLine = u, this.endLine = d;
  }
  get astNodeType() {
    return "function";
  }
  search(e) {
    this.searchBlock(this.body, e);
  }
}
class UR extends Oi {
  constructor(e) {
    super(), this.expression = e;
  }
  get astNodeType() {
    return "staticAssert";
  }
  search(e) {
    this.expression.search(e);
  }
}
class zR extends Oi {
  constructor(e, i) {
    super(), this.condition = e, this.body = i;
  }
  get astNodeType() {
    return "while";
  }
  search(e) {
    this.condition.search(e), this.searchBlock(this.body, e);
  }
}
class VR extends Oi {
  constructor(e) {
    super(), this.body = e;
  }
  get astNodeType() {
    return "continuing";
  }
  search(e) {
    this.searchBlock(this.body, e);
  }
}
class jR extends Oi {
  constructor(e, i, s, o) {
    super(), this.init = e, this.condition = i, this.increment = s, this.body = o;
  }
  get astNodeType() {
    return "for";
  }
  search(e) {
    var i, s, o;
    (i = this.init) === null || i === void 0 || i.search(e), (s = this.condition) === null || s === void 0 || s.search(e), (o = this.increment) === null || o === void 0 || o.search(e), this.searchBlock(this.body, e);
  }
}
class bl extends Oi {
  constructor(e, i, s, o, u) {
    super(), this.name = e, this.type = i, this.storage = s, this.access = o, this.value = u;
  }
  get astNodeType() {
    return "var";
  }
  search(e) {
    var i;
    e(this), (i = this.value) === null || i === void 0 || i.search(e);
  }
}
class Hw extends Oi {
  constructor(e, i, s) {
    super(), this.name = e, this.type = i, this.value = s;
  }
  get astNodeType() {
    return "override";
  }
  search(e) {
    var i;
    (i = this.value) === null || i === void 0 || i.search(e);
  }
}
class pm extends Oi {
  constructor(e, i, s, o, u) {
    super(), this.name = e, this.type = i, this.storage = s, this.access = o, this.value = u;
  }
  get astNodeType() {
    return "let";
  }
  search(e) {
    var i;
    e(this), (i = this.value) === null || i === void 0 || i.search(e);
  }
}
class xv extends Oi {
  constructor(e, i, s, o, u) {
    super(), this.name = e, this.type = i, this.storage = s, this.access = o, this.value = u;
  }
  get astNodeType() {
    return "const";
  }
  evaluate(e) {
    return this.value.evaluate(e);
  }
  search(e) {
    var i;
    e(this), (i = this.value) === null || i === void 0 || i.search(e);
  }
}
var oh;
(function(t) {
  t.increment = "++", t.decrement = "--";
})(oh || (oh = {}));
(function(t) {
  function e(i) {
    const s = i;
    if (s == "parse")
      throw new Error("Invalid value for IncrementOperator");
    return t[s];
  }
  t.parse = e;
})(oh || (oh = {}));
class HR extends Oi {
  constructor(e, i) {
    super(), this.operator = e, this.variable = i;
  }
  get astNodeType() {
    return "increment";
  }
  search(e) {
    this.variable.search(e);
  }
}
var Xu;
(function(t) {
  t.assign = "=", t.addAssign = "+=", t.subtractAssin = "-=", t.multiplyAssign = "*=", t.divideAssign = "/=", t.moduloAssign = "%=", t.andAssign = "&=", t.orAssign = "|=", t.xorAssign = "^=", t.shiftLeftAssign = "<<=", t.shiftRightAssign = ">>=";
})(Xu || (Xu = {}));
(function(t) {
  function e(i) {
    const s = i;
    if (s == "parse")
      throw new Error("Invalid value for AssignOperator");
    return s;
  }
  t.parse = e;
})(Xu || (Xu = {}));
class $R extends Oi {
  constructor(e, i, s) {
    super(), this.operator = e, this.variable = i, this.value = s;
  }
  get astNodeType() {
    return "assign";
  }
  search(e) {
    this.variable.search(e), this.value.search(e);
  }
}
class $w extends Oi {
  constructor(e, i) {
    super(), this.name = e, this.args = i;
  }
  get astNodeType() {
    return "call";
  }
  search(e) {
    for (const i of this.args)
      i.search(e);
    e(this);
  }
}
class GR extends Oi {
  constructor(e, i) {
    super(), this.body = e, this.continuing = i;
  }
  get astNodeType() {
    return "loop";
  }
}
class WR extends Oi {
  constructor(e, i) {
    super(), this.condition = e, this.body = i;
  }
  get astNodeType() {
    return "body";
  }
}
class XR extends Oi {
  constructor(e, i, s, o) {
    super(), this.condition = e, this.body = i, this.elseif = s, this.else = o;
  }
  get astNodeType() {
    return "if";
  }
  search(e) {
    this.condition.search(e), this.searchBlock(this.body, e), this.searchBlock(this.elseif, e), this.searchBlock(this.else, e);
  }
}
class qR extends Oi {
  constructor(e) {
    super(), this.value = e;
  }
  get astNodeType() {
    return "return";
  }
  search(e) {
    var i;
    (i = this.value) === null || i === void 0 || i.search(e);
  }
}
class ZR extends Oi {
  constructor(e) {
    super(), this.name = e;
  }
  get astNodeType() {
    return "enable";
  }
}
class KR extends Oi {
  constructor(e) {
    super(), this.extensions = e;
  }
  get astNodeType() {
    return "requires";
  }
}
class YR extends Oi {
  constructor(e, i) {
    super(), this.severity = e, this.rule = i;
  }
  get astNodeType() {
    return "diagnostic";
  }
}
class Gw extends Oi {
  constructor(e, i) {
    super(), this.name = e, this.type = i;
  }
  get astNodeType() {
    return "alias";
  }
}
class JR extends Oi {
  constructor() {
    super();
  }
  get astNodeType() {
    return "discard";
  }
}
class QR extends Oi {
  constructor() {
    super();
  }
  get astNodeType() {
    return "break";
  }
}
class eP extends Oi {
  constructor() {
    super();
  }
  get astNodeType() {
    return "continue";
  }
}
class Dl extends Oi {
  constructor(e) {
    super(), this.name = e;
  }
  get astNodeType() {
    return "type";
  }
  get isStruct() {
    return !1;
  }
  get isArray() {
    return !1;
  }
}
class yl extends Dl {
  constructor(e, i, s, o) {
    super(e), this.members = i, this.startLine = s, this.endLine = o;
  }
  get astNodeType() {
    return "struct";
  }
  get isStruct() {
    return !0;
  }
  /// Return the index of the member with the given name, or -1 if not found.
  getMemberIndex(e) {
    for (let i = 0; i < this.members.length; i++)
      if (this.members[i].name == e)
        return i;
    return -1;
  }
}
class Ww extends Dl {
  constructor(e, i, s) {
    super(e), this.format = i, this.access = s;
  }
  get astNodeType() {
    return "template";
  }
}
class tP extends Dl {
  constructor(e, i, s, o) {
    super(e), this.storage = i, this.type = s, this.access = o;
  }
  get astNodeType() {
    return "pointer";
  }
}
class Xw extends Dl {
  constructor(e, i, s, o) {
    super(e), this.attributes = i, this.format = s, this.count = o;
  }
  get astNodeType() {
    return "array";
  }
  get isArray() {
    return !0;
  }
}
class Ou extends Dl {
  constructor(e, i, s) {
    super(e), this.format = i, this.access = s;
  }
  get astNodeType() {
    return "sampler";
  }
}
class co extends Lo {
  constructor() {
    super();
  }
}
class iP extends co {
  constructor(e) {
    super(), this.value = e;
  }
  get astNodeType() {
    return "stringExpr";
  }
  toString() {
    return this.value;
  }
  evaluateString() {
    return this.value;
  }
}
class Hc extends co {
  constructor(e, i) {
    super(), this.type = e, this.args = i;
  }
  get astNodeType() {
    return "createExpr";
  }
  search(e) {
    if (e(this), this.args)
      for (const i of this.args)
        i.search(e);
  }
  evaluate(e) {
    return this.args[0].evaluate(e);
  }
}
class qw extends co {
  constructor(e, i) {
    super(), this.name = e, this.args = i;
  }
  get astNodeType() {
    return "callExpr";
  }
  evaluate(e) {
    switch (this.name) {
      case "abs":
        return Math.abs(this.args[0].evaluate(e));
      case "acos":
        return Math.acos(this.args[0].evaluate(e));
      case "acosh":
        return Math.acosh(this.args[0].evaluate(e));
      case "asin":
        return Math.asin(this.args[0].evaluate(e));
      case "asinh":
        return Math.asinh(this.args[0].evaluate(e));
      case "atan":
        return Math.atan(this.args[0].evaluate(e));
      case "atan2":
        return Math.atan2(this.args[0].evaluate(e), this.args[1].evaluate(e));
      case "atanh":
        return Math.atanh(this.args[0].evaluate(e));
      case "ceil":
        return Math.ceil(this.args[0].evaluate(e));
      case "clamp":
        return Math.min(Math.max(this.args[0].evaluate(e), this.args[1].evaluate(e)), this.args[2].evaluate(e));
      case "cos":
        return Math.cos(this.args[0].evaluate(e));
      //case "cross":
      //TODO: (x[i] * y[j] - x[j] * y[i])
      case "degrees":
        return this.args[0].evaluate(e) * 180 / Math.PI;
      //case "determinant":
      //TODO implement
      case "distance":
        return Math.sqrt(Math.pow(this.args[0].evaluate(e) - this.args[1].evaluate(e), 2));
      case "dot":
      //TODO: (x[i] * y[i])
      case "exp":
        return Math.exp(this.args[0].evaluate(e));
      case "exp2":
        return Math.pow(2, this.args[0].evaluate(e));
      //case "extractBits":
      //TODO: implement
      //case "firstLeadingBit":
      //TODO: implement
      case "floor":
        return Math.floor(this.args[0].evaluate(e));
      case "fma":
        return this.args[0].evaluate(e) * this.args[1].evaluate(e) + this.args[2].evaluate(e);
      case "fract":
        return this.args[0].evaluate(e) - Math.floor(this.args[0].evaluate(e));
      //case "frexp":
      //TODO: implement
      case "inverseSqrt":
        return 1 / Math.sqrt(this.args[0].evaluate(e));
      //case "length":
      //TODO: implement
      case "log":
        return Math.log(this.args[0].evaluate(e));
      case "log2":
        return Math.log2(this.args[0].evaluate(e));
      case "max":
        return Math.max(this.args[0].evaluate(e), this.args[1].evaluate(e));
      case "min":
        return Math.min(this.args[0].evaluate(e), this.args[1].evaluate(e));
      case "mix":
        return this.args[0].evaluate(e) * (1 - this.args[2].evaluate(e)) + this.args[1].evaluate(e) * this.args[2].evaluate(e);
      case "modf":
        return this.args[0].evaluate(e) - Math.floor(this.args[0].evaluate(e));
      case "pow":
        return Math.pow(this.args[0].evaluate(e), this.args[1].evaluate(e));
      case "radians":
        return this.args[0].evaluate(e) * Math.PI / 180;
      case "round":
        return Math.round(this.args[0].evaluate(e));
      case "sign":
        return Math.sign(this.args[0].evaluate(e));
      case "sin":
        return Math.sin(this.args[0].evaluate(e));
      case "sinh":
        return Math.sinh(this.args[0].evaluate(e));
      case "saturate":
        return Math.min(Math.max(this.args[0].evaluate(e), 0), 1);
      case "smoothstep":
        return this.args[0].evaluate(e) * this.args[0].evaluate(e) * (3 - 2 * this.args[0].evaluate(e));
      case "sqrt":
        return Math.sqrt(this.args[0].evaluate(e));
      case "step":
        return this.args[0].evaluate(e) < this.args[1].evaluate(e) ? 0 : 1;
      case "tan":
        return Math.tan(this.args[0].evaluate(e));
      case "tanh":
        return Math.tanh(this.args[0].evaluate(e));
      case "trunc":
        return Math.trunc(this.args[0].evaluate(e));
      default:
        throw new Error("Non const function: " + this.name);
    }
  }
  search(e) {
    for (const i of this.args)
      i.search(e);
    e(this);
  }
}
class _m extends co {
  constructor(e) {
    super(), this.name = e;
  }
  get astNodeType() {
    return "varExpr";
  }
  search(e) {
    e(this), this.postfix && this.postfix.search(e);
  }
  evaluate(e) {
    const i = e.constants.get(this.name);
    if (!i)
      throw new Error("Cannot evaluate node");
    return i.evaluate(e);
  }
}
class wv extends co {
  constructor(e, i) {
    super(), this.name = e, this.initializer = i;
  }
  get astNodeType() {
    return "constExpr";
  }
  evaluate(e) {
    var i, s;
    if (this.initializer instanceof Hc) {
      const o = (i = this.postfix) === null || i === void 0 ? void 0 : i.evaluateString(e), u = (s = this.initializer.type) === null || s === void 0 ? void 0 : s.name, d = e.structs.get(u), a = d?.getMemberIndex(o);
      return a !== void 0 && a != -1 ? this.initializer.args[a].evaluate(e) : this.initializer.evaluate(e);
    }
    return this.initializer.evaluate(e);
  }
  search(e) {
    this.initializer.search(e);
  }
}
class Tv extends co {
  constructor(e) {
    super(), this.value = e;
  }
  get astNodeType() {
    return "literalExpr";
  }
  evaluate() {
    return this.value;
  }
}
class rP extends co {
  constructor(e, i) {
    super(), this.type = e, this.value = i;
  }
  get astNodeType() {
    return "bitcastExpr";
  }
  search(e) {
    this.value.search(e);
  }
}
class Av extends co {
  constructor(e) {
    super(), this.contents = e;
  }
  get astNodeType() {
    return "groupExpr";
  }
  evaluate(e) {
    return this.contents[0].evaluate(e);
  }
  search(e) {
    this.searchBlock(this.contents, e);
  }
}
class sP extends co {
  constructor(e) {
    super(), this.index = e;
  }
  search(e) {
    this.index.search(e);
  }
}
class Zw extends co {
  constructor() {
    super();
  }
}
class nP extends Zw {
  constructor(e, i) {
    super(), this.operator = e, this.right = i;
  }
  get astNodeType() {
    return "unaryOp";
  }
  evaluate(e) {
    switch (this.operator) {
      case "+":
        return this.right.evaluate(e);
      case "-":
        return -this.right.evaluate(e);
      case "!":
        return this.right.evaluate(e) ? 0 : 1;
      case "~":
        return ~this.right.evaluate(e);
      default:
        throw new Error("Unknown unary operator: " + this.operator);
    }
  }
  search(e) {
    this.right.search(e);
  }
}
class Jn extends Zw {
  constructor(e, i, s) {
    super(), this.operator = e, this.left = i, this.right = s;
  }
  get astNodeType() {
    return "binaryOp";
  }
  evaluate(e) {
    switch (this.operator) {
      case "+":
        return this.left.evaluate(e) + this.right.evaluate(e);
      case "-":
        return this.left.evaluate(e) - this.right.evaluate(e);
      case "*":
        return this.left.evaluate(e) * this.right.evaluate(e);
      case "/":
        return this.left.evaluate(e) / this.right.evaluate(e);
      case "%":
        return this.left.evaluate(e) % this.right.evaluate(e);
      case "==":
        return this.left.evaluate(e) == this.right.evaluate(e) ? 1 : 0;
      case "!=":
        return this.left.evaluate(e) != this.right.evaluate(e) ? 1 : 0;
      case "<":
        return this.left.evaluate(e) < this.right.evaluate(e) ? 1 : 0;
      case ">":
        return this.left.evaluate(e) > this.right.evaluate(e) ? 1 : 0;
      case "<=":
        return this.left.evaluate(e) <= this.right.evaluate(e) ? 1 : 0;
      case ">=":
        return this.left.evaluate(e) >= this.right.evaluate(e) ? 1 : 0;
      case "&&":
        return this.left.evaluate(e) && this.right.evaluate(e) ? 1 : 0;
      case "||":
        return this.left.evaluate(e) || this.right.evaluate(e) ? 1 : 0;
      default:
        throw new Error(`Unknown operator ${this.operator}`);
    }
  }
  search(e) {
    this.left.search(e), this.right.search(e);
  }
}
class Kw extends Lo {
  constructor() {
    super();
  }
}
class oP extends Kw {
  constructor(e, i) {
    super(), this.selector = e, this.body = i;
  }
  get astNodeType() {
    return "case";
  }
  search(e) {
    this.searchBlock(this.body, e);
  }
}
class aP extends Kw {
  constructor(e) {
    super(), this.body = e;
  }
  get astNodeType() {
    return "default";
  }
  search(e) {
    this.searchBlock(this.body, e);
  }
}
class lP extends Lo {
  constructor(e, i, s) {
    super(), this.name = e, this.type = i, this.attributes = s;
  }
  get astNodeType() {
    return "argument";
  }
}
class cP extends Lo {
  constructor(e, i) {
    super(), this.condition = e, this.body = i;
  }
  get astNodeType() {
    return "elseif";
  }
  search(e) {
    this.condition.search(e), this.searchBlock(this.body, e);
  }
}
class hP extends Lo {
  constructor(e, i, s) {
    super(), this.name = e, this.type = i, this.attributes = s;
  }
  get astNodeType() {
    return "member";
  }
}
let uP = class extends Lo {
  constructor(e, i) {
    super(), this.name = e, this.value = i;
  }
  get astNodeType() {
    return "attribute";
  }
};
var De, Te;
(function(t) {
  t[t.token = 0] = "token", t[t.keyword = 1] = "keyword", t[t.reserved = 2] = "reserved";
})(Te || (Te = {}));
class Ae {
  constructor(e, i, s) {
    this.name = e, this.type = i, this.rule = s;
  }
  toString() {
    return this.name;
  }
}
class ee {
}
De = ee;
ee.none = new Ae("", Te.reserved, "");
ee.eof = new Ae("EOF", Te.token, "");
ee.reserved = {
  asm: new Ae("asm", Te.reserved, "asm"),
  bf16: new Ae("bf16", Te.reserved, "bf16"),
  do: new Ae("do", Te.reserved, "do"),
  enum: new Ae("enum", Te.reserved, "enum"),
  f16: new Ae("f16", Te.reserved, "f16"),
  f64: new Ae("f64", Te.reserved, "f64"),
  handle: new Ae("handle", Te.reserved, "handle"),
  i8: new Ae("i8", Te.reserved, "i8"),
  i16: new Ae("i16", Te.reserved, "i16"),
  i64: new Ae("i64", Te.reserved, "i64"),
  mat: new Ae("mat", Te.reserved, "mat"),
  premerge: new Ae("premerge", Te.reserved, "premerge"),
  regardless: new Ae("regardless", Te.reserved, "regardless"),
  typedef: new Ae("typedef", Te.reserved, "typedef"),
  u8: new Ae("u8", Te.reserved, "u8"),
  u16: new Ae("u16", Te.reserved, "u16"),
  u64: new Ae("u64", Te.reserved, "u64"),
  unless: new Ae("unless", Te.reserved, "unless"),
  using: new Ae("using", Te.reserved, "using"),
  vec: new Ae("vec", Te.reserved, "vec"),
  void: new Ae("void", Te.reserved, "void")
};
ee.keywords = {
  array: new Ae("array", Te.keyword, "array"),
  atomic: new Ae("atomic", Te.keyword, "atomic"),
  bool: new Ae("bool", Te.keyword, "bool"),
  f32: new Ae("f32", Te.keyword, "f32"),
  i32: new Ae("i32", Te.keyword, "i32"),
  mat2x2: new Ae("mat2x2", Te.keyword, "mat2x2"),
  mat2x3: new Ae("mat2x3", Te.keyword, "mat2x3"),
  mat2x4: new Ae("mat2x4", Te.keyword, "mat2x4"),
  mat3x2: new Ae("mat3x2", Te.keyword, "mat3x2"),
  mat3x3: new Ae("mat3x3", Te.keyword, "mat3x3"),
  mat3x4: new Ae("mat3x4", Te.keyword, "mat3x4"),
  mat4x2: new Ae("mat4x2", Te.keyword, "mat4x2"),
  mat4x3: new Ae("mat4x3", Te.keyword, "mat4x3"),
  mat4x4: new Ae("mat4x4", Te.keyword, "mat4x4"),
  ptr: new Ae("ptr", Te.keyword, "ptr"),
  sampler: new Ae("sampler", Te.keyword, "sampler"),
  sampler_comparison: new Ae("sampler_comparison", Te.keyword, "sampler_comparison"),
  struct: new Ae("struct", Te.keyword, "struct"),
  texture_1d: new Ae("texture_1d", Te.keyword, "texture_1d"),
  texture_2d: new Ae("texture_2d", Te.keyword, "texture_2d"),
  texture_2d_array: new Ae("texture_2d_array", Te.keyword, "texture_2d_array"),
  texture_3d: new Ae("texture_3d", Te.keyword, "texture_3d"),
  texture_cube: new Ae("texture_cube", Te.keyword, "texture_cube"),
  texture_cube_array: new Ae("texture_cube_array", Te.keyword, "texture_cube_array"),
  texture_multisampled_2d: new Ae("texture_multisampled_2d", Te.keyword, "texture_multisampled_2d"),
  texture_storage_1d: new Ae("texture_storage_1d", Te.keyword, "texture_storage_1d"),
  texture_storage_2d: new Ae("texture_storage_2d", Te.keyword, "texture_storage_2d"),
  texture_storage_2d_array: new Ae("texture_storage_2d_array", Te.keyword, "texture_storage_2d_array"),
  texture_storage_3d: new Ae("texture_storage_3d", Te.keyword, "texture_storage_3d"),
  texture_depth_2d: new Ae("texture_depth_2d", Te.keyword, "texture_depth_2d"),
  texture_depth_2d_array: new Ae("texture_depth_2d_array", Te.keyword, "texture_depth_2d_array"),
  texture_depth_cube: new Ae("texture_depth_cube", Te.keyword, "texture_depth_cube"),
  texture_depth_cube_array: new Ae("texture_depth_cube_array", Te.keyword, "texture_depth_cube_array"),
  texture_depth_multisampled_2d: new Ae("texture_depth_multisampled_2d", Te.keyword, "texture_depth_multisampled_2d"),
  texture_external: new Ae("texture_external", Te.keyword, "texture_external"),
  u32: new Ae("u32", Te.keyword, "u32"),
  vec2: new Ae("vec2", Te.keyword, "vec2"),
  vec3: new Ae("vec3", Te.keyword, "vec3"),
  vec4: new Ae("vec4", Te.keyword, "vec4"),
  bitcast: new Ae("bitcast", Te.keyword, "bitcast"),
  block: new Ae("block", Te.keyword, "block"),
  break: new Ae("break", Te.keyword, "break"),
  case: new Ae("case", Te.keyword, "case"),
  continue: new Ae("continue", Te.keyword, "continue"),
  continuing: new Ae("continuing", Te.keyword, "continuing"),
  default: new Ae("default", Te.keyword, "default"),
  diagnostic: new Ae("diagnostic", Te.keyword, "diagnostic"),
  discard: new Ae("discard", Te.keyword, "discard"),
  else: new Ae("else", Te.keyword, "else"),
  enable: new Ae("enable", Te.keyword, "enable"),
  fallthrough: new Ae("fallthrough", Te.keyword, "fallthrough"),
  false: new Ae("false", Te.keyword, "false"),
  fn: new Ae("fn", Te.keyword, "fn"),
  for: new Ae("for", Te.keyword, "for"),
  function: new Ae("function", Te.keyword, "function"),
  if: new Ae("if", Te.keyword, "if"),
  let: new Ae("let", Te.keyword, "let"),
  const: new Ae("const", Te.keyword, "const"),
  loop: new Ae("loop", Te.keyword, "loop"),
  while: new Ae("while", Te.keyword, "while"),
  private: new Ae("private", Te.keyword, "private"),
  read: new Ae("read", Te.keyword, "read"),
  read_write: new Ae("read_write", Te.keyword, "read_write"),
  return: new Ae("return", Te.keyword, "return"),
  requires: new Ae("requires", Te.keyword, "requires"),
  storage: new Ae("storage", Te.keyword, "storage"),
  switch: new Ae("switch", Te.keyword, "switch"),
  true: new Ae("true", Te.keyword, "true"),
  alias: new Ae("alias", Te.keyword, "alias"),
  type: new Ae("type", Te.keyword, "type"),
  uniform: new Ae("uniform", Te.keyword, "uniform"),
  var: new Ae("var", Te.keyword, "var"),
  override: new Ae("override", Te.keyword, "override"),
  workgroup: new Ae("workgroup", Te.keyword, "workgroup"),
  write: new Ae("write", Te.keyword, "write"),
  r8unorm: new Ae("r8unorm", Te.keyword, "r8unorm"),
  r8snorm: new Ae("r8snorm", Te.keyword, "r8snorm"),
  r8uint: new Ae("r8uint", Te.keyword, "r8uint"),
  r8sint: new Ae("r8sint", Te.keyword, "r8sint"),
  r16uint: new Ae("r16uint", Te.keyword, "r16uint"),
  r16sint: new Ae("r16sint", Te.keyword, "r16sint"),
  r16float: new Ae("r16float", Te.keyword, "r16float"),
  rg8unorm: new Ae("rg8unorm", Te.keyword, "rg8unorm"),
  rg8snorm: new Ae("rg8snorm", Te.keyword, "rg8snorm"),
  rg8uint: new Ae("rg8uint", Te.keyword, "rg8uint"),
  rg8sint: new Ae("rg8sint", Te.keyword, "rg8sint"),
  r32uint: new Ae("r32uint", Te.keyword, "r32uint"),
  r32sint: new Ae("r32sint", Te.keyword, "r32sint"),
  r32float: new Ae("r32float", Te.keyword, "r32float"),
  rg16uint: new Ae("rg16uint", Te.keyword, "rg16uint"),
  rg16sint: new Ae("rg16sint", Te.keyword, "rg16sint"),
  rg16float: new Ae("rg16float", Te.keyword, "rg16float"),
  rgba8unorm: new Ae("rgba8unorm", Te.keyword, "rgba8unorm"),
  rgba8unorm_srgb: new Ae("rgba8unorm_srgb", Te.keyword, "rgba8unorm_srgb"),
  rgba8snorm: new Ae("rgba8snorm", Te.keyword, "rgba8snorm"),
  rgba8uint: new Ae("rgba8uint", Te.keyword, "rgba8uint"),
  rgba8sint: new Ae("rgba8sint", Te.keyword, "rgba8sint"),
  bgra8unorm: new Ae("bgra8unorm", Te.keyword, "bgra8unorm"),
  bgra8unorm_srgb: new Ae("bgra8unorm_srgb", Te.keyword, "bgra8unorm_srgb"),
  rgb10a2unorm: new Ae("rgb10a2unorm", Te.keyword, "rgb10a2unorm"),
  rg11b10float: new Ae("rg11b10float", Te.keyword, "rg11b10float"),
  rg32uint: new Ae("rg32uint", Te.keyword, "rg32uint"),
  rg32sint: new Ae("rg32sint", Te.keyword, "rg32sint"),
  rg32float: new Ae("rg32float", Te.keyword, "rg32float"),
  rgba16uint: new Ae("rgba16uint", Te.keyword, "rgba16uint"),
  rgba16sint: new Ae("rgba16sint", Te.keyword, "rgba16sint"),
  rgba16float: new Ae("rgba16float", Te.keyword, "rgba16float"),
  rgba32uint: new Ae("rgba32uint", Te.keyword, "rgba32uint"),
  rgba32sint: new Ae("rgba32sint", Te.keyword, "rgba32sint"),
  rgba32float: new Ae("rgba32float", Te.keyword, "rgba32float"),
  static_assert: new Ae("static_assert", Te.keyword, "static_assert")
  // WGSL grammar has a few keywords that have different token names than the strings they
  // represent. Aliasing them here.
  /*int32: new TokenType("i32", TokenClass.keyword, "i32"),
      uint32: new TokenType("u32", TokenClass.keyword, "u32"),
      float32: new TokenType("f32", TokenClass.keyword, "f32"),
      pointer: new TokenType("ptr", TokenClass.keyword, "ptr"),*/
};
ee.tokens = {
  decimal_float_literal: new Ae("decimal_float_literal", Te.token, /((-?[0-9]*\.[0-9]+|-?[0-9]+\.[0-9]*)((e|E)(\+|-)?[0-9]+)?f?)|(-?[0-9]+(e|E)(\+|-)?[0-9]+f?)|([0-9]+f)/),
  hex_float_literal: new Ae("hex_float_literal", Te.token, /-?0x((([0-9a-fA-F]*\.[0-9a-fA-F]+|[0-9a-fA-F]+\.[0-9a-fA-F]*)((p|P)(\+|-)?[0-9]+f?)?)|([0-9a-fA-F]+(p|P)(\+|-)?[0-9]+f?))/),
  int_literal: new Ae("int_literal", Te.token, /-?0x[0-9a-fA-F]+|0i?|-?[1-9][0-9]*i?/),
  uint_literal: new Ae("uint_literal", Te.token, /0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/),
  ident: new Ae("ident", Te.token, /[_a-zA-Z][0-9a-zA-Z_]*/),
  and: new Ae("and", Te.token, "&"),
  and_and: new Ae("and_and", Te.token, "&&"),
  arrow: new Ae("arrow ", Te.token, "->"),
  attr: new Ae("attr", Te.token, "@"),
  forward_slash: new Ae("forward_slash", Te.token, "/"),
  bang: new Ae("bang", Te.token, "!"),
  bracket_left: new Ae("bracket_left", Te.token, "["),
  bracket_right: new Ae("bracket_right", Te.token, "]"),
  brace_left: new Ae("brace_left", Te.token, "{"),
  brace_right: new Ae("brace_right", Te.token, "}"),
  colon: new Ae("colon", Te.token, ":"),
  comma: new Ae("comma", Te.token, ","),
  equal: new Ae("equal", Te.token, "="),
  equal_equal: new Ae("equal_equal", Te.token, "=="),
  not_equal: new Ae("not_equal", Te.token, "!="),
  greater_than: new Ae("greater_than", Te.token, ">"),
  greater_than_equal: new Ae("greater_than_equal", Te.token, ">="),
  shift_right: new Ae("shift_right", Te.token, ">>"),
  less_than: new Ae("less_than", Te.token, "<"),
  less_than_equal: new Ae("less_than_equal", Te.token, "<="),
  shift_left: new Ae("shift_left", Te.token, "<<"),
  modulo: new Ae("modulo", Te.token, "%"),
  minus: new Ae("minus", Te.token, "-"),
  minus_minus: new Ae("minus_minus", Te.token, "--"),
  period: new Ae("period", Te.token, "."),
  plus: new Ae("plus", Te.token, "+"),
  plus_plus: new Ae("plus_plus", Te.token, "++"),
  or: new Ae("or", Te.token, "|"),
  or_or: new Ae("or_or", Te.token, "||"),
  paren_left: new Ae("paren_left", Te.token, "("),
  paren_right: new Ae("paren_right", Te.token, ")"),
  semicolon: new Ae("semicolon", Te.token, ";"),
  star: new Ae("star", Te.token, "*"),
  tilde: new Ae("tilde", Te.token, "~"),
  underscore: new Ae("underscore", Te.token, "_"),
  xor: new Ae("xor", Te.token, "^"),
  plus_equal: new Ae("plus_equal", Te.token, "+="),
  minus_equal: new Ae("minus_equal", Te.token, "-="),
  times_equal: new Ae("times_equal", Te.token, "*="),
  division_equal: new Ae("division_equal", Te.token, "/="),
  modulo_equal: new Ae("modulo_equal", Te.token, "%="),
  and_equal: new Ae("and_equal", Te.token, "&="),
  or_equal: new Ae("or_equal", Te.token, "|="),
  xor_equal: new Ae("xor_equal", Te.token, "^="),
  shift_right_equal: new Ae("shift_right_equal", Te.token, ">>="),
  shift_left_equal: new Ae("shift_left_equal", Te.token, "<<=")
};
ee.simpleTokens = {
  "@": De.tokens.attr,
  "{": De.tokens.brace_left,
  "}": De.tokens.brace_right,
  ":": De.tokens.colon,
  ",": De.tokens.comma,
  "(": De.tokens.paren_left,
  ")": De.tokens.paren_right,
  ";": De.tokens.semicolon
};
ee.literalTokens = {
  "&": De.tokens.and,
  "&&": De.tokens.and_and,
  "->": De.tokens.arrow,
  "/": De.tokens.forward_slash,
  "!": De.tokens.bang,
  "[": De.tokens.bracket_left,
  "]": De.tokens.bracket_right,
  "=": De.tokens.equal,
  "==": De.tokens.equal_equal,
  "!=": De.tokens.not_equal,
  ">": De.tokens.greater_than,
  ">=": De.tokens.greater_than_equal,
  ">>": De.tokens.shift_right,
  "<": De.tokens.less_than,
  "<=": De.tokens.less_than_equal,
  "<<": De.tokens.shift_left,
  "%": De.tokens.modulo,
  "-": De.tokens.minus,
  "--": De.tokens.minus_minus,
  ".": De.tokens.period,
  "+": De.tokens.plus,
  "++": De.tokens.plus_plus,
  "|": De.tokens.or,
  "||": De.tokens.or_or,
  "*": De.tokens.star,
  "~": De.tokens.tilde,
  _: De.tokens.underscore,
  "^": De.tokens.xor,
  "+=": De.tokens.plus_equal,
  "-=": De.tokens.minus_equal,
  "*=": De.tokens.times_equal,
  "/=": De.tokens.division_equal,
  "%=": De.tokens.modulo_equal,
  "&=": De.tokens.and_equal,
  "|=": De.tokens.or_equal,
  "^=": De.tokens.xor_equal,
  ">>=": De.tokens.shift_right_equal,
  "<<=": De.tokens.shift_left_equal
};
ee.regexTokens = {
  decimal_float_literal: De.tokens.decimal_float_literal,
  hex_float_literal: De.tokens.hex_float_literal,
  int_literal: De.tokens.int_literal,
  uint_literal: De.tokens.uint_literal,
  ident: De.tokens.ident
};
ee.storage_class = [
  De.keywords.function,
  De.keywords.private,
  De.keywords.workgroup,
  De.keywords.uniform,
  De.keywords.storage
];
ee.access_mode = [
  De.keywords.read,
  De.keywords.write,
  De.keywords.read_write
];
ee.sampler_type = [
  De.keywords.sampler,
  De.keywords.sampler_comparison
];
ee.sampled_texture_type = [
  De.keywords.texture_1d,
  De.keywords.texture_2d,
  De.keywords.texture_2d_array,
  De.keywords.texture_3d,
  De.keywords.texture_cube,
  De.keywords.texture_cube_array
];
ee.multisampled_texture_type = [
  De.keywords.texture_multisampled_2d
];
ee.storage_texture_type = [
  De.keywords.texture_storage_1d,
  De.keywords.texture_storage_2d,
  De.keywords.texture_storage_2d_array,
  De.keywords.texture_storage_3d
];
ee.depth_texture_type = [
  De.keywords.texture_depth_2d,
  De.keywords.texture_depth_2d_array,
  De.keywords.texture_depth_cube,
  De.keywords.texture_depth_cube_array,
  De.keywords.texture_depth_multisampled_2d
];
ee.texture_external_type = [De.keywords.texture_external];
ee.any_texture_type = [
  ...De.sampled_texture_type,
  ...De.multisampled_texture_type,
  ...De.storage_texture_type,
  ...De.depth_texture_type,
  ...De.texture_external_type
];
ee.texel_format = [
  De.keywords.r8unorm,
  De.keywords.r8snorm,
  De.keywords.r8uint,
  De.keywords.r8sint,
  De.keywords.r16uint,
  De.keywords.r16sint,
  De.keywords.r16float,
  De.keywords.rg8unorm,
  De.keywords.rg8snorm,
  De.keywords.rg8uint,
  De.keywords.rg8sint,
  De.keywords.r32uint,
  De.keywords.r32sint,
  De.keywords.r32float,
  De.keywords.rg16uint,
  De.keywords.rg16sint,
  De.keywords.rg16float,
  De.keywords.rgba8unorm,
  De.keywords.rgba8unorm_srgb,
  De.keywords.rgba8snorm,
  De.keywords.rgba8uint,
  De.keywords.rgba8sint,
  De.keywords.bgra8unorm,
  De.keywords.bgra8unorm_srgb,
  De.keywords.rgb10a2unorm,
  De.keywords.rg11b10float,
  De.keywords.rg32uint,
  De.keywords.rg32sint,
  De.keywords.rg32float,
  De.keywords.rgba16uint,
  De.keywords.rgba16sint,
  De.keywords.rgba16float,
  De.keywords.rgba32uint,
  De.keywords.rgba32sint,
  De.keywords.rgba32float
];
ee.const_literal = [
  De.tokens.int_literal,
  De.tokens.uint_literal,
  De.tokens.decimal_float_literal,
  De.tokens.hex_float_literal,
  De.keywords.true,
  De.keywords.false
];
ee.literal_or_ident = [
  De.tokens.ident,
  De.tokens.int_literal,
  De.tokens.uint_literal,
  De.tokens.decimal_float_literal,
  De.tokens.hex_float_literal
];
ee.element_count_expression = [
  De.tokens.int_literal,
  De.tokens.uint_literal,
  De.tokens.ident
];
ee.template_types = [
  De.keywords.vec2,
  De.keywords.vec3,
  De.keywords.vec4,
  De.keywords.mat2x2,
  De.keywords.mat2x3,
  De.keywords.mat2x4,
  De.keywords.mat3x2,
  De.keywords.mat3x3,
  De.keywords.mat3x4,
  De.keywords.mat4x2,
  De.keywords.mat4x3,
  De.keywords.mat4x4,
  De.keywords.atomic,
  De.keywords.bitcast,
  ...De.any_texture_type
];
ee.attribute_name = [De.tokens.ident, De.keywords.block, De.keywords.diagnostic];
ee.assignment_operators = [
  De.tokens.equal,
  De.tokens.plus_equal,
  De.tokens.minus_equal,
  De.tokens.times_equal,
  De.tokens.division_equal,
  De.tokens.modulo_equal,
  De.tokens.and_equal,
  De.tokens.or_equal,
  De.tokens.xor_equal,
  De.tokens.shift_right_equal,
  De.tokens.shift_left_equal
];
ee.increment_operators = [
  De.tokens.plus_plus,
  De.tokens.minus_minus
];
class Ev {
  constructor(e, i, s) {
    this.type = e, this.lexeme = i, this.line = s;
  }
  toString() {
    return this.lexeme;
  }
  isTemplateType() {
    return ee.template_types.indexOf(this.type) != -1;
  }
  isArrayType() {
    return this.type == ee.keywords.array;
  }
  isArrayOrTemplateType() {
    return this.isArrayType() || this.isTemplateType();
  }
}
class dP {
  constructor(e) {
    this._tokens = [], this._start = 0, this._current = 0, this._line = 1, this._source = e ?? "";
  }
  /// Scan all tokens from the source.
  scanTokens() {
    for (; !this._isAtEnd(); )
      if (this._start = this._current, !this.scanToken())
        throw `Invalid syntax at line ${this._line}`;
    return this._tokens.push(new Ev(ee.eof, "", this._line)), this._tokens;
  }
  /// Scan a single token from the source.
  scanToken() {
    let e = this._advance();
    if (e == `
`)
      return this._line++, !0;
    if (this._isWhitespace(e))
      return !0;
    if (e == "/") {
      if (this._peekAhead() == "/") {
        for (; e != `
`; ) {
          if (this._isAtEnd())
            return !0;
          e = this._advance();
        }
        return this._line++, !0;
      } else if (this._peekAhead() == "*") {
        this._advance();
        let d = 1;
        for (; d > 0; ) {
          if (this._isAtEnd())
            return !0;
          if (e = this._advance(), e == `
`)
            this._line++;
          else if (e == "*") {
            if (this._peekAhead() == "/" && (this._advance(), d--, d == 0))
              return !0;
          } else e == "/" && this._peekAhead() == "*" && (this._advance(), d++);
        }
        return !0;
      }
    }
    const i = ee.simpleTokens[e];
    if (i)
      return this._addToken(i), !0;
    let s = ee.none;
    const o = this._isAlpha(e), u = e === "_";
    if (this._isAlphaNumeric(e)) {
      let d = this._peekAhead();
      for (; this._isAlphaNumeric(d); )
        e += this._advance(), d = this._peekAhead();
    }
    if (o) {
      const d = ee.keywords[e];
      if (d)
        return this._addToken(d), !0;
    }
    if (o || u)
      return this._addToken(ee.tokens.ident), !0;
    for (; ; ) {
      let d = this._findType(e);
      const a = this._peekAhead();
      if (e == "-" && this._tokens.length > 0) {
        if (a == "=")
          return this._current++, e += a, this._addToken(ee.tokens.minus_equal), !0;
        if (a == "-")
          return this._current++, e += a, this._addToken(ee.tokens.minus_minus), !0;
        const w = this._tokens.length - 1;
        if ((ee.literal_or_ident.indexOf(this._tokens[w].type) != -1 || this._tokens[w].type == ee.tokens.paren_right) && a != ">")
          return this._addToken(d), !0;
      }
      if (e == ">" && (a == ">" || a == "=")) {
        let w = !1, S = this._tokens.length - 1;
        for (let M = 0; M < 5 && S >= 0 && ee.assignment_operators.indexOf(this._tokens[S].type) === -1; ++M, --S)
          if (this._tokens[S].type === ee.tokens.less_than) {
            S > 0 && this._tokens[S - 1].isArrayOrTemplateType() && (w = !0);
            break;
          }
        if (w)
          return this._addToken(d), !0;
      }
      if (d === ee.none) {
        let w = e, S = 0;
        const M = 2;
        for (let F = 0; F < M; ++F)
          if (w += this._peekAhead(F), d = this._findType(w), d !== ee.none) {
            S = F;
            break;
          }
        if (d === ee.none)
          return s === ee.none ? !1 : (this._current--, this._addToken(s), !0);
        e = w, this._current += S + 1;
      }
      if (s = d, this._isAtEnd())
        break;
      e += this._advance();
    }
    return s === ee.none ? !1 : (this._addToken(s), !0);
  }
  _findType(e) {
    for (const s in ee.regexTokens) {
      const o = ee.regexTokens[s];
      if (this._match(e, o.rule))
        return o;
    }
    const i = ee.literalTokens[e];
    return i || ee.none;
  }
  _match(e, i) {
    const s = i.exec(e);
    return s && s.index == 0 && s[0] == e;
  }
  _isAtEnd() {
    return this._current >= this._source.length;
  }
  _isAlpha(e) {
    return e >= "a" && e <= "z" || e >= "A" && e <= "Z";
  }
  _isAlphaNumeric(e) {
    return e >= "a" && e <= "z" || e >= "A" && e <= "Z" || e == "_" || e >= "0" && e <= "9";
  }
  _isWhitespace(e) {
    return e == " " || e == "	" || e == "\r";
  }
  _advance(e = 0) {
    let i = this._source[this._current];
    return e = e || 0, e++, this._current += e, i;
  }
  _peekAhead(e = 0) {
    return e = e || 0, this._current + e >= this._source.length ? "\0" : this._source[this._current + e];
  }
  _addToken(e) {
    const i = this._source.substring(this._start, this._current);
    this._tokens.push(new Ev(e, i, this._line));
  }
}
class fP {
  constructor() {
    this._tokens = [], this._current = 0, this._currentLine = 0, this._context = new LR(), this._deferArrayCountEval = [];
  }
  parse(e) {
    this._initialize(e), this._deferArrayCountEval.length = 0;
    const i = [];
    for (; !this._isAtEnd(); ) {
      const s = this._global_decl_or_directive();
      if (!s)
        break;
      i.push(s);
    }
    if (this._deferArrayCountEval.length > 0) {
      for (const s of this._deferArrayCountEval) {
        const o = s.arrayType, u = s.countNode;
        if (u instanceof _m) {
          const a = u.name, w = this._context.constants.get(a);
          if (w)
            try {
              const S = w.evaluate(this._context);
              o.count = S;
            } catch {
            }
        }
      }
      this._deferArrayCountEval.length = 0;
    }
    return i;
  }
  _initialize(e) {
    if (e)
      if (typeof e == "string") {
        const i = new dP(e);
        this._tokens = i.scanTokens();
      } else
        this._tokens = e;
    else
      this._tokens = [];
    this._current = 0;
  }
  _error(e, i) {
    return {
      token: e,
      message: i,
      toString: function() {
        return `${i}`;
      }
    };
  }
  _isAtEnd() {
    return this._current >= this._tokens.length || this._peek().type == ee.eof;
  }
  _match(e) {
    if (e instanceof Ae)
      return this._check(e) ? (this._advance(), !0) : !1;
    for (let i = 0, s = e.length; i < s; ++i) {
      const o = e[i];
      if (this._check(o))
        return this._advance(), !0;
    }
    return !1;
  }
  _consume(e, i) {
    if (this._check(e))
      return this._advance();
    throw this._error(this._peek(), i);
  }
  _check(e) {
    if (this._isAtEnd())
      return !1;
    const i = this._peek();
    if (e instanceof Array) {
      const s = i.type;
      return e.indexOf(s) != -1;
    }
    return i.type == e;
  }
  _advance() {
    var e, i;
    return this._currentLine = (i = (e = this._peek()) === null || e === void 0 ? void 0 : e.line) !== null && i !== void 0 ? i : -1, this._isAtEnd() || this._current++, this._previous();
  }
  _peek() {
    return this._tokens[this._current];
  }
  _previous() {
    return this._tokens[this._current - 1];
  }
  _global_decl_or_directive() {
    for (; this._match(ee.tokens.semicolon) && !this._isAtEnd(); )
      ;
    if (this._match(ee.keywords.alias)) {
      const i = this._type_alias();
      return this._consume(ee.tokens.semicolon, "Expected ';'"), i;
    }
    if (this._match(ee.keywords.diagnostic)) {
      const i = this._diagnostic();
      return this._consume(ee.tokens.semicolon, "Expected ';'"), i;
    }
    if (this._match(ee.keywords.requires)) {
      const i = this._requires_directive();
      return this._consume(ee.tokens.semicolon, "Expected ';'"), i;
    }
    if (this._match(ee.keywords.enable)) {
      const i = this._enable_directive();
      return this._consume(ee.tokens.semicolon, "Expected ';'"), i;
    }
    const e = this._attribute();
    if (this._check(ee.keywords.var)) {
      const i = this._global_variable_decl();
      return i != null && (i.attributes = e), this._consume(ee.tokens.semicolon, "Expected ';'."), i;
    }
    if (this._check(ee.keywords.override)) {
      const i = this._override_variable_decl();
      return i != null && (i.attributes = e), this._consume(ee.tokens.semicolon, "Expected ';'."), i;
    }
    if (this._check(ee.keywords.let)) {
      const i = this._global_let_decl();
      return i != null && (i.attributes = e), this._consume(ee.tokens.semicolon, "Expected ';'."), i;
    }
    if (this._check(ee.keywords.const)) {
      const i = this._global_const_decl();
      return i != null && (i.attributes = e), this._consume(ee.tokens.semicolon, "Expected ';'."), i;
    }
    if (this._check(ee.keywords.struct)) {
      const i = this._struct_decl();
      return i != null && (i.attributes = e), i;
    }
    if (this._check(ee.keywords.fn)) {
      const i = this._function_decl();
      return i != null && (i.attributes = e), i;
    }
    return null;
  }
  _function_decl() {
    if (!this._match(ee.keywords.fn))
      return null;
    const e = this._currentLine, i = this._consume(ee.tokens.ident, "Expected function name.").toString();
    this._consume(ee.tokens.paren_left, "Expected '(' for function arguments.");
    const s = [];
    if (!this._check(ee.tokens.paren_right))
      do {
        if (this._check(ee.tokens.paren_right))
          break;
        const a = this._attribute(), w = this._consume(ee.tokens.ident, "Expected argument name.").toString();
        this._consume(ee.tokens.colon, "Expected ':' for argument type.");
        const S = this._attribute(), M = this._type_decl();
        M != null && (M.attributes = S, s.push(new lP(w, M, a)));
      } while (this._match(ee.tokens.comma));
    this._consume(ee.tokens.paren_right, "Expected ')' after function arguments.");
    let o = null;
    if (this._match(ee.tokens.arrow)) {
      const a = this._attribute();
      o = this._type_decl(), o != null && (o.attributes = a);
    }
    const u = this._compound_statement(), d = this._currentLine;
    return new fm(i, s, o, u, e, d);
  }
  _compound_statement() {
    const e = [];
    for (this._consume(ee.tokens.brace_left, "Expected '{' for block."); !this._check(ee.tokens.brace_right); ) {
      const i = this._statement();
      i !== null && e.push(i);
    }
    return this._consume(ee.tokens.brace_right, "Expected '}' for block."), e;
  }
  _statement() {
    for (; this._match(ee.tokens.semicolon) && !this._isAtEnd(); )
      ;
    if (this._check(ee.tokens.attr) && this._attribute(), this._check(ee.keywords.if))
      return this._if_statement();
    if (this._check(ee.keywords.switch))
      return this._switch_statement();
    if (this._check(ee.keywords.loop))
      return this._loop_statement();
    if (this._check(ee.keywords.for))
      return this._for_statement();
    if (this._check(ee.keywords.while))
      return this._while_statement();
    if (this._check(ee.keywords.continuing))
      return this._continuing_statement();
    if (this._check(ee.keywords.static_assert))
      return this._static_assert_statement();
    if (this._check(ee.tokens.brace_left))
      return this._compound_statement();
    let e = null;
    return this._check(ee.keywords.return) ? e = this._return_statement() : this._check([
      ee.keywords.var,
      ee.keywords.let,
      ee.keywords.const
    ]) ? e = this._variable_statement() : this._match(ee.keywords.discard) ? e = new JR() : this._match(ee.keywords.break) ? e = new QR() : this._match(ee.keywords.continue) ? e = new eP() : e = this._increment_decrement_statement() || this._func_call_statement() || this._assignment_statement(), e != null && this._consume(ee.tokens.semicolon, "Expected ';' after statement."), e;
  }
  _static_assert_statement() {
    if (!this._match(ee.keywords.static_assert))
      return null;
    const e = this._optional_paren_expression();
    return new UR(e);
  }
  _while_statement() {
    if (!this._match(ee.keywords.while))
      return null;
    const e = this._optional_paren_expression();
    this._check(ee.tokens.attr) && this._attribute();
    const i = this._compound_statement();
    return new zR(e, i);
  }
  _continuing_statement() {
    if (!this._match(ee.keywords.continuing))
      return null;
    const e = this._compound_statement();
    return new VR(e);
  }
  _for_statement() {
    if (!this._match(ee.keywords.for))
      return null;
    this._consume(ee.tokens.paren_left, "Expected '('.");
    const e = this._check(ee.tokens.semicolon) ? null : this._for_init();
    this._consume(ee.tokens.semicolon, "Expected ';'.");
    const i = this._check(ee.tokens.semicolon) ? null : this._short_circuit_or_expression();
    this._consume(ee.tokens.semicolon, "Expected ';'.");
    const s = this._check(ee.tokens.paren_right) ? null : this._for_increment();
    this._consume(ee.tokens.paren_right, "Expected ')'."), this._check(ee.tokens.attr) && this._attribute();
    const o = this._compound_statement();
    return new jR(e, i, s, o);
  }
  _for_init() {
    return this._variable_statement() || this._func_call_statement() || this._assignment_statement();
  }
  _for_increment() {
    return this._func_call_statement() || this._increment_decrement_statement() || this._assignment_statement();
  }
  _variable_statement() {
    if (this._check(ee.keywords.var)) {
      const e = this._variable_decl();
      if (e === null)
        throw this._error(this._peek(), "Variable declaration expected.");
      let i = null;
      return this._match(ee.tokens.equal) && (i = this._short_circuit_or_expression()), new bl(e.name, e.type, e.storage, e.access, i);
    }
    if (this._match(ee.keywords.let)) {
      const e = this._consume(ee.tokens.ident, "Expected name for let.").toString();
      let i = null;
      if (this._match(ee.tokens.colon)) {
        const o = this._attribute();
        i = this._type_decl(), i != null && (i.attributes = o);
      }
      this._consume(ee.tokens.equal, "Expected '=' for let.");
      const s = this._short_circuit_or_expression();
      return new pm(e, i, null, null, s);
    }
    if (this._match(ee.keywords.const)) {
      const e = this._consume(ee.tokens.ident, "Expected name for const.").toString();
      let i = null;
      if (this._match(ee.tokens.colon)) {
        const o = this._attribute();
        i = this._type_decl(), i != null && (i.attributes = o);
      }
      this._consume(ee.tokens.equal, "Expected '=' for const.");
      const s = this._short_circuit_or_expression();
      return new xv(e, i, null, null, s);
    }
    return null;
  }
  _increment_decrement_statement() {
    const e = this._current, i = this._unary_expression();
    if (i == null)
      return null;
    if (!this._check(ee.increment_operators))
      return this._current = e, null;
    const s = this._consume(ee.increment_operators, "Expected increment operator");
    return new HR(s.type === ee.tokens.plus_plus ? oh.increment : oh.decrement, i);
  }
  _assignment_statement() {
    let e = null;
    if (this._check(ee.tokens.brace_right))
      return null;
    let i = this._match(ee.tokens.underscore);
    if (i || (e = this._unary_expression()), !i && e == null)
      return null;
    const s = this._consume(ee.assignment_operators, "Expected assignment operator."), o = this._short_circuit_or_expression();
    return new $R(Xu.parse(s.lexeme), e, o);
  }
  _func_call_statement() {
    if (!this._check(ee.tokens.ident))
      return null;
    const e = this._current, i = this._consume(ee.tokens.ident, "Expected function name."), s = this._argument_expression_list();
    return s === null ? (this._current = e, null) : new $w(i.lexeme, s);
  }
  _loop_statement() {
    if (!this._match(ee.keywords.loop))
      return null;
    this._check(ee.tokens.attr) && this._attribute(), this._consume(ee.tokens.brace_left, "Expected '{' for loop.");
    const e = [];
    let i = this._statement();
    for (; i !== null; ) {
      if (Array.isArray(i))
        for (let o of i)
          e.push(o);
      else
        e.push(i);
      i = this._statement();
    }
    let s = null;
    return this._match(ee.keywords.continuing) && (s = this._compound_statement()), this._consume(ee.tokens.brace_right, "Expected '}' for loop."), new GR(e, s);
  }
  _switch_statement() {
    if (!this._match(ee.keywords.switch))
      return null;
    const e = this._optional_paren_expression();
    this._check(ee.tokens.attr) && this._attribute(), this._consume(ee.tokens.brace_left, "Expected '{' for switch.");
    const i = this._switch_body();
    if (i == null || i.length == 0)
      throw this._error(this._previous(), "Expected 'case' or 'default'.");
    return this._consume(ee.tokens.brace_right, "Expected '}' for switch."), new WR(e, i);
  }
  _switch_body() {
    const e = [];
    if (this._match(ee.keywords.case)) {
      const i = this._case_selectors();
      this._match(ee.tokens.colon), this._check(ee.tokens.attr) && this._attribute(), this._consume(ee.tokens.brace_left, "Exected '{' for switch case.");
      const s = this._case_body();
      this._consume(ee.tokens.brace_right, "Exected '}' for switch case."), e.push(new oP(i, s));
    }
    if (this._match(ee.keywords.default)) {
      this._match(ee.tokens.colon), this._check(ee.tokens.attr) && this._attribute(), this._consume(ee.tokens.brace_left, "Exected '{' for switch default.");
      const i = this._case_body();
      this._consume(ee.tokens.brace_right, "Exected '}' for switch default."), e.push(new aP(i));
    }
    if (this._check([ee.keywords.default, ee.keywords.case])) {
      const i = this._switch_body();
      e.push(i[0]);
    }
    return e;
  }
  _case_selectors() {
    const e = [
      this._shift_expression()
      //?.evaluate(this._context).toString() ?? "",
    ];
    for (; this._match(ee.tokens.comma); )
      e.push(this._shift_expression());
    return e;
  }
  _case_body() {
    if (this._match(ee.keywords.fallthrough))
      return this._consume(ee.tokens.semicolon, "Expected ';'"), [];
    let e = this._statement();
    if (e == null)
      return [];
    e instanceof Array || (e = [e]);
    const i = this._case_body();
    return i.length == 0 ? e : [...e, i[0]];
  }
  _if_statement() {
    if (!this._match(ee.keywords.if))
      return null;
    const e = this._optional_paren_expression();
    this._check(ee.tokens.attr) && this._attribute();
    const i = this._compound_statement();
    let s = [];
    this._match_elseif() && (this._check(ee.tokens.attr) && this._attribute(), s = this._elseif_statement(s));
    let o = null;
    return this._match(ee.keywords.else) && (this._check(ee.tokens.attr) && this._attribute(), o = this._compound_statement()), new XR(e, i, s, o);
  }
  _match_elseif() {
    return this._tokens[this._current].type === ee.keywords.else && this._tokens[this._current + 1].type === ee.keywords.if ? (this._advance(), this._advance(), !0) : !1;
  }
  _elseif_statement(e = []) {
    const i = this._optional_paren_expression(), s = this._compound_statement();
    return e.push(new cP(i, s)), this._match_elseif() && (this._check(ee.tokens.attr) && this._attribute(), this._elseif_statement(e)), e;
  }
  _return_statement() {
    if (!this._match(ee.keywords.return))
      return null;
    const e = this._short_circuit_or_expression();
    return new qR(e);
  }
  _short_circuit_or_expression() {
    let e = this._short_circuit_and_expr();
    for (; this._match(ee.tokens.or_or); )
      e = new Jn(this._previous().toString(), e, this._short_circuit_and_expr());
    return e;
  }
  _short_circuit_and_expr() {
    let e = this._inclusive_or_expression();
    for (; this._match(ee.tokens.and_and); )
      e = new Jn(this._previous().toString(), e, this._inclusive_or_expression());
    return e;
  }
  _inclusive_or_expression() {
    let e = this._exclusive_or_expression();
    for (; this._match(ee.tokens.or); )
      e = new Jn(this._previous().toString(), e, this._exclusive_or_expression());
    return e;
  }
  _exclusive_or_expression() {
    let e = this._and_expression();
    for (; this._match(ee.tokens.xor); )
      e = new Jn(this._previous().toString(), e, this._and_expression());
    return e;
  }
  _and_expression() {
    let e = this._equality_expression();
    for (; this._match(ee.tokens.and); )
      e = new Jn(this._previous().toString(), e, this._equality_expression());
    return e;
  }
  _equality_expression() {
    const e = this._relational_expression();
    return this._match([ee.tokens.equal_equal, ee.tokens.not_equal]) ? new Jn(this._previous().toString(), e, this._relational_expression()) : e;
  }
  _relational_expression() {
    let e = this._shift_expression();
    for (; this._match([
      ee.tokens.less_than,
      ee.tokens.greater_than,
      ee.tokens.less_than_equal,
      ee.tokens.greater_than_equal
    ]); )
      e = new Jn(this._previous().toString(), e, this._shift_expression());
    return e;
  }
  _shift_expression() {
    let e = this._additive_expression();
    for (; this._match([ee.tokens.shift_left, ee.tokens.shift_right]); )
      e = new Jn(this._previous().toString(), e, this._additive_expression());
    return e;
  }
  _additive_expression() {
    let e = this._multiplicative_expression();
    for (; this._match([ee.tokens.plus, ee.tokens.minus]); )
      e = new Jn(this._previous().toString(), e, this._multiplicative_expression());
    return e;
  }
  _multiplicative_expression() {
    let e = this._unary_expression();
    for (; this._match([
      ee.tokens.star,
      ee.tokens.forward_slash,
      ee.tokens.modulo
    ]); )
      e = new Jn(this._previous().toString(), e, this._unary_expression());
    return e;
  }
  _unary_expression() {
    return this._match([
      ee.tokens.minus,
      ee.tokens.bang,
      ee.tokens.tilde,
      ee.tokens.star,
      ee.tokens.and
    ]) ? new nP(this._previous().toString(), this._unary_expression()) : this._singular_expression();
  }
  _singular_expression() {
    const e = this._primary_expression(), i = this._postfix_expression();
    return i && (e.postfix = i), e;
  }
  _postfix_expression() {
    if (this._match(ee.tokens.bracket_left)) {
      const e = this._short_circuit_or_expression();
      this._consume(ee.tokens.bracket_right, "Expected ']'.");
      const i = new sP(e), s = this._postfix_expression();
      return s && (i.postfix = s), i;
    }
    if (this._match(ee.tokens.period)) {
      const e = this._consume(ee.tokens.ident, "Expected member name."), i = this._postfix_expression(), s = new iP(e.lexeme);
      return i && (s.postfix = i), s;
    }
    return null;
  }
  _getStruct(e) {
    return this._context.aliases.has(e) ? this._context.aliases.get(e).type : this._context.structs.has(e) ? this._context.structs.get(e) : null;
  }
  _primary_expression() {
    if (this._match(ee.tokens.ident)) {
      const s = this._previous().toString();
      if (this._check(ee.tokens.paren_left)) {
        const o = this._argument_expression_list(), u = this._getStruct(s);
        return u != null ? new Hc(u, o) : new qw(s, o);
      }
      if (this._context.constants.has(s)) {
        const o = this._context.constants.get(s);
        return new wv(s, o.value);
      }
      return new _m(s);
    }
    if (this._match(ee.const_literal))
      return new Tv(parseFloat(this._previous().toString()));
    if (this._check(ee.tokens.paren_left))
      return this._paren_expression();
    if (this._match(ee.keywords.bitcast)) {
      this._consume(ee.tokens.less_than, "Expected '<'.");
      const s = this._type_decl();
      this._consume(ee.tokens.greater_than, "Expected '>'.");
      const o = this._paren_expression();
      return new rP(s, o);
    }
    const e = this._type_decl(), i = this._argument_expression_list();
    return new Hc(e, i);
  }
  _argument_expression_list() {
    if (!this._match(ee.tokens.paren_left))
      return null;
    const e = [];
    do {
      if (this._check(ee.tokens.paren_right))
        break;
      const i = this._short_circuit_or_expression();
      e.push(i);
    } while (this._match(ee.tokens.comma));
    return this._consume(ee.tokens.paren_right, "Expected ')' for agument list"), e;
  }
  _optional_paren_expression() {
    this._match(ee.tokens.paren_left);
    const e = this._short_circuit_or_expression();
    return this._match(ee.tokens.paren_right), new Av([e]);
  }
  _paren_expression() {
    this._consume(ee.tokens.paren_left, "Expected '('.");
    const e = this._short_circuit_or_expression();
    return this._consume(ee.tokens.paren_right, "Expected ')'."), new Av([e]);
  }
  _struct_decl() {
    if (!this._match(ee.keywords.struct))
      return null;
    const e = this._currentLine, i = this._consume(ee.tokens.ident, "Expected name for struct.").toString();
    this._consume(ee.tokens.brace_left, "Expected '{' for struct body.");
    const s = [];
    for (; !this._check(ee.tokens.brace_right); ) {
      const d = this._attribute(), a = this._consume(ee.tokens.ident, "Expected variable name.").toString();
      this._consume(ee.tokens.colon, "Expected ':' for struct member type.");
      const w = this._attribute(), S = this._type_decl();
      S != null && (S.attributes = w), this._check(ee.tokens.brace_right) ? this._match(ee.tokens.comma) : this._consume(ee.tokens.comma, "Expected ',' for struct member."), s.push(new hP(a, S, d));
    }
    this._consume(ee.tokens.brace_right, "Expected '}' after struct body.");
    const o = this._currentLine, u = new yl(i, s, e, o);
    return this._context.structs.set(i, u), u;
  }
  _global_variable_decl() {
    const e = this._variable_decl();
    return e && this._match(ee.tokens.equal) && (e.value = this._const_expression()), e;
  }
  _override_variable_decl() {
    const e = this._override_decl();
    return e && this._match(ee.tokens.equal) && (e.value = this._const_expression()), e;
  }
  _global_const_decl() {
    if (!this._match(ee.keywords.const))
      return null;
    const e = this._consume(ee.tokens.ident, "Expected variable name");
    let i = null;
    if (this._match(ee.tokens.colon)) {
      const u = this._attribute();
      i = this._type_decl(), i != null && (i.attributes = u);
    }
    let s = null;
    if (this._match(ee.tokens.equal)) {
      const u = this._short_circuit_or_expression();
      if (u instanceof Hc)
        s = u;
      else if (u instanceof wv && u.initializer instanceof Hc)
        s = u.initializer;
      else
        try {
          const d = u.evaluate(this._context);
          s = new Tv(d);
        } catch {
          s = u;
        }
    }
    const o = new xv(e.toString(), i, "", "", s);
    return this._context.constants.set(o.name, o), o;
  }
  _global_let_decl() {
    if (!this._match(ee.keywords.let))
      return null;
    const e = this._consume(ee.tokens.ident, "Expected variable name");
    let i = null;
    if (this._match(ee.tokens.colon)) {
      const o = this._attribute();
      i = this._type_decl(), i != null && (i.attributes = o);
    }
    let s = null;
    return this._match(ee.tokens.equal) && (s = this._const_expression()), new pm(e.toString(), i, "", "", s);
  }
  _const_expression() {
    return this._short_circuit_or_expression();
  }
  _variable_decl() {
    if (!this._match(ee.keywords.var))
      return null;
    let e = "", i = "";
    this._match(ee.tokens.less_than) && (e = this._consume(ee.storage_class, "Expected storage_class.").toString(), this._match(ee.tokens.comma) && (i = this._consume(ee.access_mode, "Expected access_mode.").toString()), this._consume(ee.tokens.greater_than, "Expected '>'."));
    const s = this._consume(ee.tokens.ident, "Expected variable name");
    let o = null;
    if (this._match(ee.tokens.colon)) {
      const u = this._attribute();
      o = this._type_decl(), o != null && (o.attributes = u);
    }
    return new bl(s.toString(), o, e, i, null);
  }
  _override_decl() {
    if (!this._match(ee.keywords.override))
      return null;
    const e = this._consume(ee.tokens.ident, "Expected variable name");
    let i = null;
    if (this._match(ee.tokens.colon)) {
      const s = this._attribute();
      i = this._type_decl(), i != null && (i.attributes = s);
    }
    return new Hw(e.toString(), i, null);
  }
  _diagnostic() {
    this._consume(ee.tokens.paren_left, "Expected '('");
    const e = this._consume(ee.tokens.ident, "Expected severity control name.");
    this._consume(ee.tokens.comma, "Expected ','");
    const i = this._consume(ee.tokens.ident, "Expected diagnostic rule name.");
    return this._consume(ee.tokens.paren_right, "Expected ')'"), new YR(e.toString(), i.toString());
  }
  _enable_directive() {
    const e = this._consume(ee.tokens.ident, "identity expected.");
    return new ZR(e.toString());
  }
  _requires_directive() {
    const e = [this._consume(ee.tokens.ident, "identity expected.").toString()];
    for (; this._match(ee.tokens.comma); ) {
      const i = this._consume(ee.tokens.ident, "identity expected.");
      e.push(i.toString());
    }
    return new KR(e);
  }
  _type_alias() {
    const e = this._consume(ee.tokens.ident, "identity expected.");
    this._consume(ee.tokens.equal, "Expected '=' for type alias.");
    let i = this._type_decl();
    if (i === null)
      throw this._error(this._peek(), "Expected Type for Alias.");
    this._context.aliases.has(i.name) && (i = this._context.aliases.get(i.name).type);
    const s = new Gw(e.toString(), i);
    return this._context.aliases.set(s.name, s), s;
  }
  _type_decl() {
    if (this._check([
      ee.tokens.ident,
      ...ee.texel_format,
      ee.keywords.bool,
      ee.keywords.f32,
      ee.keywords.i32,
      ee.keywords.u32
    ])) {
      const s = this._advance(), o = s.toString();
      return this._context.structs.has(o) ? this._context.structs.get(o) : this._context.aliases.has(o) ? this._context.aliases.get(o).type : new Dl(s.toString());
    }
    let e = this._texture_sampler_types();
    if (e)
      return e;
    if (this._check(ee.template_types)) {
      let s = this._advance().toString(), o = null, u = null;
      return this._match(ee.tokens.less_than) && (o = this._type_decl(), u = null, this._match(ee.tokens.comma) && (u = this._consume(ee.access_mode, "Expected access_mode for pointer").toString()), this._consume(ee.tokens.greater_than, "Expected '>' for type.")), new Ww(s, o, u);
    }
    if (this._match(ee.keywords.ptr)) {
      let s = this._previous().toString();
      this._consume(ee.tokens.less_than, "Expected '<' for pointer.");
      const o = this._consume(ee.storage_class, "Expected storage_class for pointer");
      this._consume(ee.tokens.comma, "Expected ',' for pointer.");
      const u = this._type_decl();
      let d = null;
      return this._match(ee.tokens.comma) && (d = this._consume(ee.access_mode, "Expected access_mode for pointer").toString()), this._consume(ee.tokens.greater_than, "Expected '>' for pointer."), new tP(s, o.toString(), u, d);
    }
    const i = this._attribute();
    if (this._match(ee.keywords.array)) {
      let s = null, o = -1;
      const u = this._previous();
      let d = null;
      if (this._match(ee.tokens.less_than)) {
        s = this._type_decl(), this._context.aliases.has(s.name) && (s = this._context.aliases.get(s.name).type);
        let w = "";
        if (this._match(ee.tokens.comma)) {
          d = this._shift_expression();
          try {
            w = d.evaluate(this._context).toString(), d = null;
          } catch {
            w = "1";
          }
        }
        this._consume(ee.tokens.greater_than, "Expected '>' for array."), o = w ? parseInt(w) : 0;
      }
      const a = new Xw(u.toString(), i, s, o);
      return d && this._deferArrayCountEval.push({ arrayType: a, countNode: d }), a;
    }
    return null;
  }
  _texture_sampler_types() {
    if (this._match(ee.sampler_type))
      return new Ou(this._previous().toString(), null, null);
    if (this._match(ee.depth_texture_type))
      return new Ou(this._previous().toString(), null, null);
    if (this._match(ee.sampled_texture_type) || this._match(ee.multisampled_texture_type)) {
      const e = this._previous();
      this._consume(ee.tokens.less_than, "Expected '<' for sampler type.");
      const i = this._type_decl();
      return this._consume(ee.tokens.greater_than, "Expected '>' for sampler type."), new Ou(e.toString(), i, null);
    }
    if (this._match(ee.storage_texture_type)) {
      const e = this._previous();
      this._consume(ee.tokens.less_than, "Expected '<' for sampler type.");
      const i = this._consume(ee.texel_format, "Invalid texel format.").toString();
      this._consume(ee.tokens.comma, "Expected ',' after texel format.");
      const s = this._consume(ee.access_mode, "Expected access mode for storage texture type.").toString();
      return this._consume(ee.tokens.greater_than, "Expected '>' for sampler type."), new Ou(e.toString(), i, s);
    }
    return null;
  }
  _attribute() {
    let e = [];
    for (; this._match(ee.tokens.attr); ) {
      const i = this._consume(ee.attribute_name, "Expected attribute name"), s = new uP(i.toString(), null);
      if (this._match(ee.tokens.paren_left)) {
        if (s.value = this._consume(ee.literal_or_ident, "Expected attribute value").toString(), this._check(ee.tokens.comma)) {
          this._advance();
          do {
            const o = this._consume(ee.literal_or_ident, "Expected attribute value").toString();
            s.value instanceof Array || (s.value = [s.value]), s.value.push(o);
          } while (this._match(ee.tokens.comma));
        }
        this._consume(ee.tokens.paren_right, "Expected ')'");
      }
      e.push(s);
    }
    return e.length == 0 ? null : e;
  }
}
class Jc {
  constructor(e, i) {
    this.name = e, this.attributes = i, this.size = 0;
  }
  get isArray() {
    return !1;
  }
  get isStruct() {
    return !1;
  }
  get isTemplate() {
    return !1;
  }
}
class Sv {
  constructor(e, i, s) {
    this.name = e, this.type = i, this.attributes = s, this.offset = 0, this.size = 0;
  }
  get isArray() {
    return this.type.isArray;
  }
  get isStruct() {
    return this.type.isStruct;
  }
  get isTemplate() {
    return this.type.isTemplate;
  }
  get align() {
    return this.type.isStruct ? this.type.align : 0;
  }
  get members() {
    return this.type.isStruct ? this.type.members : null;
  }
  get format() {
    return this.type.isArray ? this.type.format : this.type.isTemplate ? this.type.format : null;
  }
  get count() {
    return this.type.isArray ? this.type.count : 0;
  }
  get stride() {
    return this.type.isArray ? this.type.stride : this.size;
  }
}
class wf extends Jc {
  constructor(e, i) {
    super(e, i), this.members = [], this.align = 0, this.startLine = -1, this.endLine = -1, this.inUse = !1;
  }
  get isStruct() {
    return !0;
  }
}
class ug extends Jc {
  constructor(e, i) {
    super(e, i), this.count = 0, this.stride = 0;
  }
  get isArray() {
    return !0;
  }
}
class Cv extends Jc {
  constructor(e, i, s, o) {
    super(e, s), this.format = i, this.access = o;
  }
  get isTemplate() {
    return !0;
  }
}
var ya;
(function(t) {
  t[t.Uniform = 0] = "Uniform", t[t.Storage = 1] = "Storage", t[t.Texture = 2] = "Texture", t[t.Sampler = 3] = "Sampler", t[t.StorageTexture = 4] = "StorageTexture";
})(ya || (ya = {}));
class Tf {
  constructor(e, i, s, o, u, d, a) {
    this.name = e, this.type = i, this.group = s, this.binding = o, this.attributes = u, this.resourceType = d, this.access = a;
  }
  get isArray() {
    return this.type.isArray;
  }
  get isStruct() {
    return this.type.isStruct;
  }
  get isTemplate() {
    return this.type.isTemplate;
  }
  get size() {
    return this.type.size;
  }
  get align() {
    return this.type.isStruct ? this.type.align : 0;
  }
  get members() {
    return this.type.isStruct ? this.type.members : null;
  }
  get format() {
    return this.type.isArray ? this.type.format : this.type.isTemplate ? this.type.format : null;
  }
  get count() {
    return this.type.isArray ? this.type.count : 0;
  }
  get stride() {
    return this.type.isArray ? this.type.stride : this.size;
  }
}
class pP {
  constructor(e, i) {
    this.name = e, this.type = i;
  }
}
class Af {
  constructor(e, i) {
    this.align = e, this.size = i;
  }
}
class _P {
  constructor(e, i, s, o) {
    this.name = e, this.type = i, this.locationType = s, this.location = o, this.interpolation = null;
  }
}
class Iv {
  constructor(e, i, s, o) {
    this.name = e, this.type = i, this.locationType = s, this.location = o;
  }
}
class gP {
  constructor(e, i, s, o) {
    this.name = e, this.type = i, this.attributes = s, this.id = o;
  }
}
class mP {
  constructor(e, i) {
    this.name = e, this.type = i;
  }
}
class yP {
  constructor(e, i = null) {
    this.stage = null, this.inputs = [], this.outputs = [], this.arguments = [], this.returnType = null, this.resources = [], this.overrides = [], this.startLine = -1, this.endLine = -1, this.inUse = !1, this.calls = /* @__PURE__ */ new Set(), this.name = e, this.stage = i;
  }
}
class bP {
  constructor() {
    this.vertex = [], this.fragment = [], this.compute = [];
  }
}
class vP {
  constructor(e) {
    this.resources = null, this.inUse = !1, this.info = null, this.node = e;
  }
}
class Bo {
  constructor(e) {
    this.uniforms = [], this.storage = [], this.textures = [], this.samplers = [], this.aliases = [], this.overrides = [], this.structs = [], this.entry = new bP(), this.functions = [], this._types = /* @__PURE__ */ new Map(), this._functions = /* @__PURE__ */ new Map(), e && this.update(e);
  }
  _isStorageTexture(e) {
    return e.name == "texture_storage_1d" || e.name == "texture_storage_2d" || e.name == "texture_storage_2d_array" || e.name == "texture_storage_3d";
  }
  update(e) {
    const s = new fP().parse(e);
    for (const o of s)
      o instanceof fm && this._functions.set(o.name, new vP(o));
    for (const o of s)
      if (o instanceof yl) {
        const u = this._getTypeInfo(o, null);
        u instanceof wf && this.structs.push(u);
      }
    for (const o of s) {
      if (o instanceof Gw) {
        this.aliases.push(this._getAliasInfo(o));
        continue;
      }
      if (o instanceof Hw) {
        const u = o, d = this._getAttributeNum(u.attributes, "id", 0), a = u.type != null ? this._getTypeInfo(u.type, u.attributes) : null;
        this.overrides.push(new gP(u.name, a, u.attributes, d));
        continue;
      }
      if (this._isUniformVar(o)) {
        const u = o, d = this._getAttributeNum(u.attributes, "group", 0), a = this._getAttributeNum(u.attributes, "binding", 0), w = this._getTypeInfo(u.type, u.attributes), S = new Tf(u.name, w, d, a, u.attributes, ya.Uniform, u.access);
        this.uniforms.push(S);
        continue;
      }
      if (this._isStorageVar(o)) {
        const u = o, d = this._getAttributeNum(u.attributes, "group", 0), a = this._getAttributeNum(u.attributes, "binding", 0), w = this._getTypeInfo(u.type, u.attributes), S = this._isStorageTexture(w), M = new Tf(u.name, w, d, a, u.attributes, S ? ya.StorageTexture : ya.Storage, u.access);
        this.storage.push(M);
        continue;
      }
      if (this._isTextureVar(o)) {
        const u = o, d = this._getAttributeNum(u.attributes, "group", 0), a = this._getAttributeNum(u.attributes, "binding", 0), w = this._getTypeInfo(u.type, u.attributes), S = this._isStorageTexture(w), M = new Tf(u.name, w, d, a, u.attributes, S ? ya.StorageTexture : ya.Texture, u.access);
        S ? this.storage.push(M) : this.textures.push(M);
        continue;
      }
      if (this._isSamplerVar(o)) {
        const u = o, d = this._getAttributeNum(u.attributes, "group", 0), a = this._getAttributeNum(u.attributes, "binding", 0), w = this._getTypeInfo(u.type, u.attributes), S = new Tf(u.name, w, d, a, u.attributes, ya.Sampler, u.access);
        this.samplers.push(S);
        continue;
      }
      if (o instanceof fm) {
        const u = this._getAttribute(o, "vertex"), d = this._getAttribute(o, "fragment"), a = this._getAttribute(o, "compute"), w = u || d || a, S = new yP(o.name, w?.name);
        S.startLine = o.startLine, S.endLine = o.endLine, this.functions.push(S), this._functions.get(o.name).info = S, w ? (this._functions.get(o.name).inUse = !0, S.inUse = !0, S.resources = this._findResources(o, !!w), S.inputs = this._getInputs(o.args), S.outputs = this._getOutputs(o.returnType), this.entry[w.name].push(S)) : (S.arguments = o.args.map((M) => new mP(M.name, this._getTypeInfo(M.type, M.attributes))), S.returnType = o.returnType ? this._getTypeInfo(o.returnType, o.attributes) : null);
        continue;
      }
    }
    for (const o of this._functions.values())
      o.info && (o.info.inUse = o.inUse, this._addCalls(o.node, o.info.calls));
    for (const o of this._functions.values())
      o.node.search((u) => {
        var d;
        if (u.astNodeType === "varExpr") {
          const a = u;
          for (const w of this.overrides)
            a.name == w.name && ((d = o.info) === null || d === void 0 || d.overrides.push(w));
        }
      });
    for (const o of this.uniforms)
      this._markStructsInUse(o.type);
    for (const o of this.storage)
      this._markStructsInUse(o.type);
  }
  _markStructsInUse(e) {
    if (e)
      if (e.isStruct) {
        if (e.inUse = !0, e.members)
          for (const i of e.members)
            this._markStructsInUse(i.type);
      } else if (e.isArray)
        this._markStructsInUse(e.format);
      else if (e.isTemplate)
        e.format && this._markStructsInUse(e.format);
      else {
        const i = this._getAlias(e.name);
        i && this._markStructsInUse(i);
      }
  }
  _addCalls(e, i) {
    var s;
    for (const o of e.calls) {
      const u = (s = this._functions.get(o.name)) === null || s === void 0 ? void 0 : s.info;
      u && i.add(u);
    }
  }
  /// Find a resource by its group and binding.
  findResource(e, i) {
    for (const s of this.uniforms)
      if (s.group == e && s.binding == i)
        return s;
    for (const s of this.storage)
      if (s.group == e && s.binding == i)
        return s;
    for (const s of this.textures)
      if (s.group == e && s.binding == i)
        return s;
    for (const s of this.samplers)
      if (s.group == e && s.binding == i)
        return s;
    return null;
  }
  _findResource(e) {
    for (const i of this.uniforms)
      if (i.name == e)
        return i;
    for (const i of this.storage)
      if (i.name == e)
        return i;
    for (const i of this.textures)
      if (i.name == e)
        return i;
    for (const i of this.samplers)
      if (i.name == e)
        return i;
    return null;
  }
  _markStructsFromAST(e) {
    const i = this._getTypeInfo(e, null);
    this._markStructsInUse(i);
  }
  _findResources(e, i) {
    const s = [], o = this, u = [];
    return e.search((d) => {
      if (d instanceof hp)
        u.push({});
      else if (d instanceof up)
        u.pop();
      else if (d instanceof bl) {
        const a = d;
        i && a.type !== null && this._markStructsFromAST(a.type), u.length > 0 && (u[u.length - 1][a.name] = a);
      } else if (d instanceof Hc) {
        const a = d;
        i && a.type !== null && this._markStructsFromAST(a.type);
      } else if (d instanceof pm) {
        const a = d;
        i && a.type !== null && this._markStructsFromAST(a.type), u.length > 0 && (u[u.length - 1][a.name] = a);
      } else if (d instanceof _m) {
        const a = d;
        if (u.length > 0 && u[u.length - 1][a.name])
          return;
        const w = o._findResource(a.name);
        w && s.push(w);
      } else if (d instanceof qw) {
        const a = d, w = o._functions.get(a.name);
        w && (i && (w.inUse = !0), e.calls.add(w.node), w.resources === null && (w.resources = o._findResources(w.node, i)), s.push(...w.resources));
      } else if (d instanceof $w) {
        const a = d, w = o._functions.get(a.name);
        w && (i && (w.inUse = !0), e.calls.add(w.node), w.resources === null && (w.resources = o._findResources(w.node, i)), s.push(...w.resources));
      }
    }), [...new Map(s.map((d) => [d.name, d])).values()];
  }
  getBindGroups() {
    const e = [];
    function i(s, o) {
      s >= e.length && (e.length = s + 1), e[s] === void 0 && (e[s] = []), o >= e[s].length && (e[s].length = o + 1);
    }
    for (const s of this.uniforms) {
      i(s.group, s.binding);
      const o = e[s.group];
      o[s.binding] = s;
    }
    for (const s of this.storage) {
      i(s.group, s.binding);
      const o = e[s.group];
      o[s.binding] = s;
    }
    for (const s of this.textures) {
      i(s.group, s.binding);
      const o = e[s.group];
      o[s.binding] = s;
    }
    for (const s of this.samplers) {
      i(s.group, s.binding);
      const o = e[s.group];
      o[s.binding] = s;
    }
    return e;
  }
  _getOutputs(e, i = void 0) {
    if (i === void 0 && (i = []), e instanceof yl)
      this._getStructOutputs(e, i);
    else {
      const s = this._getOutputInfo(e);
      s !== null && i.push(s);
    }
    return i;
  }
  _getStructOutputs(e, i) {
    for (const s of e.members)
      if (s.type instanceof yl)
        this._getStructOutputs(s.type, i);
      else {
        const o = this._getAttribute(s, "location") || this._getAttribute(s, "builtin");
        if (o !== null) {
          const u = this._getTypeInfo(s.type, s.type.attributes), d = this._parseInt(o.value), a = new Iv(s.name, u, o.name, d);
          i.push(a);
        }
      }
  }
  _getOutputInfo(e) {
    const i = this._getAttribute(e, "location") || this._getAttribute(e, "builtin");
    if (i !== null) {
      const s = this._getTypeInfo(e, e.attributes), o = this._parseInt(i.value);
      return new Iv("", s, i.name, o);
    }
    return null;
  }
  _getInputs(e, i = void 0) {
    i === void 0 && (i = []);
    for (const s of e)
      if (s.type instanceof yl)
        this._getStructInputs(s.type, i);
      else {
        const o = this._getInputInfo(s);
        o !== null && i.push(o);
      }
    return i;
  }
  _getStructInputs(e, i) {
    for (const s of e.members)
      if (s.type instanceof yl)
        this._getStructInputs(s.type, i);
      else {
        const o = this._getInputInfo(s);
        o !== null && i.push(o);
      }
  }
  _getInputInfo(e) {
    const i = this._getAttribute(e, "location") || this._getAttribute(e, "builtin");
    if (i !== null) {
      const s = this._getAttribute(e, "interpolation"), o = this._getTypeInfo(e.type, e.attributes), u = this._parseInt(i.value), d = new _P(e.name, o, i.name, u);
      return s !== null && (d.interpolation = this._parseString(s.value)), d;
    }
    return null;
  }
  _parseString(e) {
    return e instanceof Array && (e = e[0]), e;
  }
  _parseInt(e) {
    e instanceof Array && (e = e[0]);
    const i = parseInt(e);
    return isNaN(i) ? e : i;
  }
  _getAlias(e) {
    for (const i of this.aliases)
      if (i.name == e)
        return i.type;
    return null;
  }
  _getAliasInfo(e) {
    return new pP(e.name, this._getTypeInfo(e.type, null));
  }
  _getTypeInfo(e, i) {
    if (this._types.has(e))
      return this._types.get(e);
    if (e instanceof Xw) {
      const o = e, u = o.format ? this._getTypeInfo(o.format, o.attributes) : null, d = new ug(o.name, i);
      return d.format = u, d.count = o.count, this._types.set(e, d), this._updateTypeInfo(d), d;
    }
    if (e instanceof yl) {
      const o = e, u = new wf(o.name, i);
      u.startLine = o.startLine, u.endLine = o.endLine;
      for (const d of o.members) {
        const a = this._getTypeInfo(d.type, d.attributes);
        u.members.push(new Sv(d.name, a, d.attributes));
      }
      return this._types.set(e, u), this._updateTypeInfo(u), u;
    }
    if (e instanceof Ou) {
      const o = e, u = o.format instanceof Dl, d = o.format ? u ? this._getTypeInfo(o.format, null) : new Jc(o.format, null) : null, a = new Cv(o.name, d, i, o.access);
      return this._types.set(e, a), this._updateTypeInfo(a), a;
    }
    if (e instanceof Ww) {
      const o = e, u = o.format ? this._getTypeInfo(o.format, null) : null, d = new Cv(o.name, u, i, o.access);
      return this._types.set(e, d), this._updateTypeInfo(d), d;
    }
    const s = new Jc(e.name, i);
    return this._types.set(e, s), this._updateTypeInfo(s), s;
  }
  _updateTypeInfo(e) {
    var i, s;
    const o = this._getTypeSize(e);
    if (e.size = (i = o?.size) !== null && i !== void 0 ? i : 0, e instanceof ug && e.format) {
      const u = this._getTypeSize(e.format);
      e.stride = (s = u?.size) !== null && s !== void 0 ? s : 0, this._updateTypeInfo(e.format);
    }
    e instanceof wf && this._updateStructInfo(e);
  }
  _updateStructInfo(e) {
    var i;
    let s = 0, o = 0, u = 0, d = 0;
    for (let a = 0, w = e.members.length; a < w; ++a) {
      const S = e.members[a], M = this._getTypeSize(S);
      if (!M)
        continue;
      (i = this._getAlias(S.type.name)) !== null && i !== void 0 || S.type;
      const F = M.align, N = M.size;
      s = this._roundUp(F, s + o), o = N, u = s, d = Math.max(d, F), S.offset = s, S.size = N, this._updateTypeInfo(S.type);
    }
    e.size = this._roundUp(d, u + o), e.align = d;
  }
  _getTypeSize(e) {
    var i, s;
    if (e == null)
      return null;
    const o = this._getAttributeNum(e.attributes, "size", 0), u = this._getAttributeNum(e.attributes, "align", 0);
    if (e instanceof Sv && (e = e.type), e instanceof Jc) {
      const d = this._getAlias(e.name);
      d !== null && (e = d);
    }
    {
      const d = Bo._typeInfo[e.name];
      if (d !== void 0) {
        const a = ((i = e.format) === null || i === void 0 ? void 0 : i.name) === "f16" ? 2 : 1;
        return new Af(Math.max(u, d.align / a), Math.max(o, d.size / a));
      }
    }
    {
      const d = Bo._typeInfo[e.name.substring(0, e.name.length - 1)];
      if (d) {
        const a = e.name[e.name.length - 1] === "h" ? 2 : 1;
        return new Af(Math.max(u, d.align / a), Math.max(o, d.size / a));
      }
    }
    if (e instanceof ug) {
      let d = e, a = 8, w = 8;
      const S = this._getTypeSize(d.format);
      S !== null && (w = S.size, a = S.align);
      const M = d.count, F = this._getAttributeNum((s = e?.attributes) !== null && s !== void 0 ? s : null, "stride", this._roundUp(a, w));
      return w = M * F, o && (w = o), new Af(Math.max(u, a), Math.max(o, w));
    }
    if (e instanceof wf) {
      let d = 0, a = 0, w = 0, S = 0, M = 0;
      for (const F of e.members) {
        const N = this._getTypeSize(F.type);
        N !== null && (d = Math.max(N.align, d), w = this._roundUp(N.align, w + S), S = N.size, M = w);
      }
      return a = this._roundUp(d, M + S), new Af(Math.max(u, d), Math.max(o, a));
    }
    return null;
  }
  _isUniformVar(e) {
    return e instanceof bl && e.storage == "uniform";
  }
  _isStorageVar(e) {
    return e instanceof bl && e.storage == "storage";
  }
  _isTextureVar(e) {
    return e instanceof bl && e.type !== null && Bo._textureTypes.indexOf(e.type.name) != -1;
  }
  _isSamplerVar(e) {
    return e instanceof bl && e.type !== null && Bo._samplerTypes.indexOf(e.type.name) != -1;
  }
  _getAttribute(e, i) {
    const s = e;
    if (!s || !s.attributes)
      return null;
    const o = s.attributes;
    for (let u of o)
      if (u.name == i)
        return u;
    return null;
  }
  _getAttributeNum(e, i, s) {
    if (e === null)
      return s;
    for (let o of e)
      if (o.name == i) {
        let u = o !== null && o.value !== null ? o.value : s;
        return u instanceof Array && (u = u[0]), typeof u == "number" ? u : typeof u == "string" ? parseInt(u) : s;
      }
    return s;
  }
  _roundUp(e, i) {
    return Math.ceil(i / e) * e;
  }
}
Bo._typeInfo = {
  f16: { align: 2, size: 2 },
  i32: { align: 4, size: 4 },
  u32: { align: 4, size: 4 },
  f32: { align: 4, size: 4 },
  atomic: { align: 4, size: 4 },
  vec2: { align: 8, size: 8 },
  vec3: { align: 16, size: 12 },
  vec4: { align: 16, size: 16 },
  mat2x2: { align: 8, size: 16 },
  mat3x2: { align: 8, size: 24 },
  mat4x2: { align: 8, size: 32 },
  mat2x3: { align: 16, size: 32 },
  mat3x3: { align: 16, size: 48 },
  mat4x3: { align: 16, size: 64 },
  mat2x4: { align: 16, size: 32 },
  mat3x4: { align: 16, size: 48 },
  mat4x4: { align: 16, size: 64 }
};
Bo._textureTypes = ee.any_texture_type.map((t) => t.name);
Bo._samplerTypes = ee.sampler_type.map((t) => t.name);
function xP(t) {
  const e = { attributes: [], bindings: [] };
  let i;
  try {
    i = wP(t);
  } catch (u) {
    return Je.error(u.message)(), e;
  }
  for (const u of i.uniforms) {
    const d = [];
    for (const a of u.type?.members || [])
      d.push({
        name: a.name,
        type: Mv(a.type)
      });
    e.bindings.push({
      type: "uniform",
      name: u.name,
      location: u.binding,
      // @ts-expect-error
      group: u.group,
      members: d
    });
  }
  const s = i.entry.vertex[0], o = s?.inputs.length || 0;
  for (let u = 0; u < o; u++) {
    const d = s.inputs[u];
    if (d.locationType === "location") {
      const a = Mv(d.type);
      e.attributes.push({
        name: d.name,
        location: Number(d.location),
        type: a
      });
    }
  }
  return e;
}
function Mv(t) {
  return t.format ? `${t.name}<${t.format.name}>` : t.name;
}
function wP(t) {
  try {
    return new Bo(t);
  } catch (e) {
    if (e instanceof Error)
      throw e;
    let i = "WGSL parse error";
    throw typeof e == "object" && e?.message && (i += `: ${e.message} `), typeof e == "object" && e?.token && (i += e.token.line || ""), new Error(i, { cause: e });
  }
}
const TP = `#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND
const float TWO_PI = 6.2831854820251465;
const float PI_2 = 1.5707963705062866;
const float PI_16 = 0.1963495463132858;
const float SIN_TABLE_0 = 0.19509032368659973;
const float SIN_TABLE_1 = 0.3826834261417389;
const float SIN_TABLE_2 = 0.5555702447891235;
const float SIN_TABLE_3 = 0.7071067690849304;
const float COS_TABLE_0 = 0.9807852506637573;
const float COS_TABLE_1 = 0.9238795042037964;
const float COS_TABLE_2 = 0.8314695954322815;
const float COS_TABLE_3 = 0.7071067690849304;
const float INVERSE_FACTORIAL_3 = 1.666666716337204e-01;
const float INVERSE_FACTORIAL_5 = 8.333333767950535e-03;
const float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04;
const float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06;
float sin_taylor_fp32(float a) {
float r, s, t, x;
if (a == 0.0) {
return 0.0;
}
x = -a * a;
s = a;
r = a;
r = r * x;
t = r * INVERSE_FACTORIAL_3;
s = s + t;
r = r * x;
t = r * INVERSE_FACTORIAL_5;
s = s + t;
r = r * x;
t = r * INVERSE_FACTORIAL_7;
s = s + t;
r = r * x;
t = r * INVERSE_FACTORIAL_9;
s = s + t;
return s;
}
void sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {
if (a == 0.0) {
sin_t = 0.0;
cos_t = 1.0;
}
sin_t = sin_taylor_fp32(a);
cos_t = sqrt(1.0 - sin_t * sin_t);
}
float tan_taylor_fp32(float a) {
float sin_a;
float cos_a;
if (a == 0.0) {
return 0.0;
}
float z = floor(a / TWO_PI);
float r = a - TWO_PI * z;
float t;
float q = floor(r / PI_2 + 0.5);
int j = int(q);
if (j < -2 || j > 2) {
return 1.0 / 0.0;
}
t = r - PI_2 * q;
q = floor(t / PI_16 + 0.5);
int k = int(q);
int abs_k = int(abs(float(k)));
if (abs_k > 4) {
return 1.0 / 0.0;
} else {
t = t - PI_16 * q;
}
float u = 0.0;
float v = 0.0;
float sin_t, cos_t;
float s, c;
sincos_taylor_fp32(t, sin_t, cos_t);
if (k == 0) {
s = sin_t;
c = cos_t;
} else {
if (abs(float(abs_k) - 1.0) < 0.5) {
u = COS_TABLE_0;
v = SIN_TABLE_0;
} else if (abs(float(abs_k) - 2.0) < 0.5) {
u = COS_TABLE_1;
v = SIN_TABLE_1;
} else if (abs(float(abs_k) - 3.0) < 0.5) {
u = COS_TABLE_2;
v = SIN_TABLE_2;
} else if (abs(float(abs_k) - 4.0) < 0.5) {
u = COS_TABLE_3;
v = SIN_TABLE_3;
}
if (k > 0) {
s = u * sin_t + v * cos_t;
c = u * cos_t - v * sin_t;
} else {
s = u * sin_t - v * cos_t;
c = u * cos_t + v * sin_t;
}
}
if (j == 0) {
sin_a = s;
cos_a = c;
} else if (j == 1) {
sin_a = c;
cos_a = -s;
} else if (j == -1) {
sin_a = -c;
cos_a = s;
} else {
sin_a = -s;
cos_a = -c;
}
return sin_a / cos_a;
}
#endif
float tan_fp32(float a) {
#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND
return tan_taylor_fp32(a);
#else
return tan(a);
#endif
}
`, AP = {
  name: "fp32",
  vs: TP
}, EP = [0, 1, 1, 1], SP = `uniform pickingUniforms {
float isActive;
float isAttribute;
float isHighlightActive;
float useFloatColors;
vec3 highlightedObjectColor;
vec4 highlightColor;
} picking;
out vec4 picking_vRGBcolor_Avalid;
vec3 picking_normalizeColor(vec3 color) {
return picking.useFloatColors > 0.5 ? color : color / 255.0;
}
vec4 picking_normalizeColor(vec4 color) {
return picking.useFloatColors > 0.5 ? color : color / 255.0;
}
bool picking_isColorZero(vec3 color) {
return dot(color, vec3(1.0)) < 0.00001;
}
bool picking_isColorValid(vec3 color) {
return dot(color, vec3(1.0)) > 0.00001;
}
bool isVertexHighlighted(vec3 vertexColor) {
vec3 highlightedObjectColor = picking_normalizeColor(picking.highlightedObjectColor);
return
bool(picking.isHighlightActive) && picking_isColorZero(abs(vertexColor - highlightedObjectColor));
}
void picking_setPickingColor(vec3 pickingColor) {
pickingColor = picking_normalizeColor(pickingColor);
if (bool(picking.isActive)) {
picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));
if (!bool(picking.isAttribute)) {
picking_vRGBcolor_Avalid.rgb = pickingColor;
}
} else {
picking_vRGBcolor_Avalid.a = float(isVertexHighlighted(pickingColor));
}
}
void picking_setPickingAttribute(float value) {
if (bool(picking.isAttribute)) {
picking_vRGBcolor_Avalid.r = value;
}
}
void picking_setPickingAttribute(vec2 value) {
if (bool(picking.isAttribute)) {
picking_vRGBcolor_Avalid.rg = value;
}
}
void picking_setPickingAttribute(vec3 value) {
if (bool(picking.isAttribute)) {
picking_vRGBcolor_Avalid.rgb = value;
}
}
`, CP = `uniform pickingUniforms {
float isActive;
float isAttribute;
float isHighlightActive;
float useFloatColors;
vec3 highlightedObjectColor;
vec4 highlightColor;
} picking;
in vec4 picking_vRGBcolor_Avalid;
vec4 picking_filterHighlightColor(vec4 color) {
if (picking.isActive > 0.5) {
return color;
}
bool selected = bool(picking_vRGBcolor_Avalid.a);
if (selected) {
float highLightAlpha = picking.highlightColor.a;
float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);
float highLightRatio = highLightAlpha / blendedAlpha;
vec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);
return vec4(blendedRGB, blendedAlpha);
} else {
return color;
}
}
vec4 picking_filterPickingColor(vec4 color) {
if (bool(picking.isActive)) {
if (picking_vRGBcolor_Avalid.a == 0.0) {
discard;
}
return picking_vRGBcolor_Avalid;
}
return color;
}
vec4 picking_filterColor(vec4 color) {
vec4 highlightColor = picking_filterHighlightColor(color);
return picking_filterPickingColor(highlightColor);
}
`, Rv = {
  name: "picking",
  vs: SP,
  fs: CP,
  uniformTypes: {
    isActive: "f32",
    isAttribute: "f32",
    isHighlightActive: "f32",
    useFloatColors: "f32",
    highlightedObjectColor: "vec3<f32>",
    highlightColor: "vec4<f32>"
  },
  defaultUniforms: {
    isActive: !1,
    isAttribute: !1,
    isHighlightActive: !1,
    useFloatColors: !0,
    highlightedObjectColor: [0, 0, 0],
    highlightColor: EP
  },
  getUniforms: IP
};
function IP(t = {}, e) {
  const i = {};
  if (t.highlightedObjectColor !== void 0) if (t.highlightedObjectColor === null)
    i.isHighlightActive = !1;
  else {
    i.isHighlightActive = !0;
    const s = t.highlightedObjectColor.slice(0, 3);
    i.highlightedObjectColor = s;
  }
  if (t.highlightColor) {
    const s = Array.from(t.highlightColor, (o) => o / 255);
    Number.isFinite(s[3]) || (s[3] = 1), i.highlightColor = s;
  }
  return t.isActive !== void 0 && (i.isActive = !!t.isActive, i.isAttribute = !!t.isAttribute), t.useFloatColors !== void 0 && (i.useFloatColors = !!t.useFloatColors), i;
}
function Yw(t, e = [], i = 0) {
  const s = Math.fround(t), o = t - s;
  return e[i] = s, e[i + 1] = o, e;
}
function MP(t) {
  return t - Math.fround(t);
}
function RP(t) {
  const e = new Float32Array(32);
  for (let i = 0; i < 4; ++i)
    for (let s = 0; s < 4; ++s) {
      const o = i * 4 + s;
      Yw(t[s * 4 + i], e, o * 2);
    }
  return e;
}
const PP = `uniform float ONE;
vec2 split(float a) {
const float SPLIT = 4097.0;
float t = a * SPLIT;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float a_hi = t * ONE - (t - a);
float a_lo = a * ONE - a_hi;
#else
float a_hi = t - (t - a);
float a_lo = a - a_hi;
#endif
return vec2(a_hi, a_lo);
}
vec2 split2(vec2 a) {
vec2 b = split(a.x);
b.y += a.y;
return b;
}
vec2 quickTwoSum(float a, float b) {
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float sum = (a + b) * ONE;
float err = b - (sum - a) * ONE;
#else
float sum = a + b;
float err = b - (sum - a);
#endif
return vec2(sum, err);
}
vec2 twoSum(float a, float b) {
float s = (a + b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float v = (s * ONE - a) * ONE;
float err = (a - (s - v) * ONE) * ONE * ONE * ONE + (b - v);
#else
float v = s - a;
float err = (a - (s - v)) + (b - v);
#endif
return vec2(s, err);
}
vec2 twoSub(float a, float b) {
float s = (a - b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float v = (s * ONE - a) * ONE;
float err = (a - (s - v) * ONE) * ONE * ONE * ONE - (b + v);
#else
float v = s - a;
float err = (a - (s - v)) - (b + v);
#endif
return vec2(s, err);
}
vec2 twoSqr(float a) {
float prod = a * a;
vec2 a_fp64 = split(a);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float err = ((a_fp64.x * a_fp64.x - prod) * ONE + 2.0 * a_fp64.x *
a_fp64.y * ONE * ONE) + a_fp64.y * a_fp64.y * ONE * ONE * ONE;
#else
float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;
#endif
return vec2(prod, err);
}
vec2 twoProd(float a, float b) {
float prod = a * b;
vec2 a_fp64 = split(a);
vec2 b_fp64 = split(b);
float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +
a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;
return vec2(prod, err);
}
vec2 sum_fp64(vec2 a, vec2 b) {
vec2 s, t;
s = twoSum(a.x, b.x);
t = twoSum(a.y, b.y);
s.y += t.x;
s = quickTwoSum(s.x, s.y);
s.y += t.y;
s = quickTwoSum(s.x, s.y);
return s;
}
vec2 sub_fp64(vec2 a, vec2 b) {
vec2 s, t;
s = twoSub(a.x, b.x);
t = twoSub(a.y, b.y);
s.y += t.x;
s = quickTwoSum(s.x, s.y);
s.y += t.y;
s = quickTwoSum(s.x, s.y);
return s;
}
vec2 mul_fp64(vec2 a, vec2 b) {
vec2 prod = twoProd(a.x, b.x);
prod.y += a.x * b.y;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
prod = split2(prod);
#endif
prod = quickTwoSum(prod.x, prod.y);
prod.y += a.y * b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
prod = split2(prod);
#endif
prod = quickTwoSum(prod.x, prod.y);
return prod;
}
vec2 div_fp64(vec2 a, vec2 b) {
float xn = 1.0 / b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
vec2 yn = mul_fp64(a, vec2(xn, 0));
#else
vec2 yn = a * xn;
#endif
float diff = (sub_fp64(a, mul_fp64(b, yn))).x;
vec2 prod = twoProd(xn, diff);
return sum_fp64(yn, prod);
}
vec2 sqrt_fp64(vec2 a) {
if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);
if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);
float x = 1.0 / sqrt(a.x);
float yn = a.x * x;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
vec2 yn_sqr = twoSqr(yn) * ONE;
#else
vec2 yn_sqr = twoSqr(yn);
#endif
float diff = sub_fp64(a, yn_sqr).x;
vec2 prod = twoProd(x * 0.5, diff);
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
return sum_fp64(split(yn), prod);
#else
return sum_fp64(vec2(yn, 0.0), prod);
#endif
}
`, BP = {
  // Used in LUMA_FP64_CODE_ELIMINATION_WORKAROUND
  ONE: 1
};
function DP() {
  return BP;
}
const OP = {
  name: "fp64-arithmetic",
  vs: PP,
  getUniforms: DP,
  fp64ify: Yw,
  fp64LowPart: MP,
  fp64ifyMatrix4: RP
}, FP = 1 / Math.PI * 180, kP = 1 / 180 * Math.PI, NP = {
  EPSILON: 1e-12,
  debug: !1,
  precision: 4,
  printTypes: !1,
  printDegrees: !1,
  printRowMajor: !0,
  _cartographicRadians: !1
};
globalThis.mathgl = globalThis.mathgl || { config: { ...NP } };
const Ar = globalThis.mathgl.config;
function LP(t, { precision: e = Ar.precision } = {}) {
  return t = jP(t), `${parseFloat(t.toPrecision(e))}`;
}
function Sa(t) {
  return Array.isArray(t) || ArrayBuffer.isView(t) && !(t instanceof DataView);
}
function UP(t) {
  return VP(t);
}
function zP(t) {
  return Cn(t);
}
function VP(t, e) {
  return fy(t, (i) => i * kP, e);
}
function Cn(t, e) {
  return fy(t, (i) => i * FP, e);
}
function Do(t, e, i) {
  return fy(t, (s) => Math.max(e, Math.min(i, s)));
}
function dp(t, e, i) {
  return Sa(t) ? t.map((s, o) => dp(s, e[o], i)) : i * e + (1 - i) * t;
}
function On(t, e, i) {
  const s = Ar.EPSILON;
  i && (Ar.EPSILON = i);
  try {
    if (t === e)
      return !0;
    if (Sa(t) && Sa(e)) {
      if (t.length !== e.length)
        return !1;
      for (let o = 0; o < t.length; ++o)
        if (!On(t[o], e[o]))
          return !1;
      return !0;
    }
    return t && t.equals ? t.equals(e) : e && e.equals ? e.equals(t) : typeof t == "number" && typeof e == "number" ? Math.abs(t - e) <= Ar.EPSILON * Math.max(1, Math.abs(t), Math.abs(e)) : !1;
  } finally {
    Ar.EPSILON = s;
  }
}
function jP(t) {
  return Math.round(t / Ar.EPSILON) * Ar.EPSILON;
}
function HP(t) {
  return t.clone ? t.clone() : new Array(t.length);
}
function fy(t, e, i) {
  if (Sa(t)) {
    const s = t;
    i = i || HP(s);
    for (let o = 0; o < i.length && o < s.length; ++o) {
      const u = typeof t == "number" ? t : t[o];
      i[o] = e(u, o, i);
    }
    return i;
  }
  return e(t);
}
class py extends Array {
  // Common methods
  /**
   * Clone the current object
   * @returns a new copy of this object
   */
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, i = 0) {
    for (let s = 0; s < this.ELEMENTS; ++s)
      this[s] = e[s + i];
    return this.check();
  }
  toArray(e = [], i = 0) {
    for (let s = 0; s < this.ELEMENTS; ++s)
      e[i + s] = this[s];
    return e;
  }
  toObject(e) {
    return e;
  }
  from(e) {
    return Array.isArray(e) ? this.copy(e) : (
      // @ts-ignore
      this.fromObject(e)
    );
  }
  to(e) {
    return e === this ? this : Sa(e) ? this.toArray(e) : this.toObject(e);
  }
  toTarget(e) {
    return e ? this.to(e) : this;
  }
  /** @deprecated */
  toFloat32Array() {
    return new Float32Array(this);
  }
  toString() {
    return this.formatString(Ar);
  }
  /** Formats string according to options */
  formatString(e) {
    let i = "";
    for (let s = 0; s < this.ELEMENTS; ++s)
      i += (s > 0 ? ", " : "") + LP(this[s], e);
    return `${e.printTypes ? this.constructor.name : ""}[${i}]`;
  }
  equals(e) {
    if (!e || this.length !== e.length)
      return !1;
    for (let i = 0; i < this.ELEMENTS; ++i)
      if (!On(this[i], e[i]))
        return !1;
    return !0;
  }
  exactEquals(e) {
    if (!e || this.length !== e.length)
      return !1;
    for (let i = 0; i < this.ELEMENTS; ++i)
      if (this[i] !== e[i])
        return !1;
    return !0;
  }
  // Modifiers
  /** Negates all values in this object */
  negate() {
    for (let e = 0; e < this.ELEMENTS; ++e)
      this[e] = -this[e];
    return this.check();
  }
  lerp(e, i, s) {
    if (s === void 0)
      return this.lerp(this, e, i);
    for (let o = 0; o < this.ELEMENTS; ++o) {
      const u = e[o], d = typeof i == "number" ? i : i[o];
      this[o] = u + s * (d - u);
    }
    return this.check();
  }
  /** Minimal */
  min(e) {
    for (let i = 0; i < this.ELEMENTS; ++i)
      this[i] = Math.min(e[i], this[i]);
    return this.check();
  }
  /** Maximal */
  max(e) {
    for (let i = 0; i < this.ELEMENTS; ++i)
      this[i] = Math.max(e[i], this[i]);
    return this.check();
  }
  clamp(e, i) {
    for (let s = 0; s < this.ELEMENTS; ++s)
      this[s] = Math.min(Math.max(this[s], e[s]), i[s]);
    return this.check();
  }
  add(...e) {
    for (const i of e)
      for (let s = 0; s < this.ELEMENTS; ++s)
        this[s] += i[s];
    return this.check();
  }
  subtract(...e) {
    for (const i of e)
      for (let s = 0; s < this.ELEMENTS; ++s)
        this[s] -= i[s];
    return this.check();
  }
  scale(e) {
    if (typeof e == "number")
      for (let i = 0; i < this.ELEMENTS; ++i)
        this[i] *= e;
    else
      for (let i = 0; i < this.ELEMENTS && i < e.length; ++i)
        this[i] *= e[i];
    return this.check();
  }
  /**
   * Multiplies all elements by `scale`
   * Note: `Matrix4.multiplyByScalar` only scales its 3x3 "minor"
   */
  multiplyByScalar(e) {
    for (let i = 0; i < this.ELEMENTS; ++i)
      this[i] *= e;
    return this.check();
  }
  // Debug checks
  /** Throws an error if array length is incorrect or contains illegal values */
  check() {
    if (Ar.debug && !this.validate())
      throw new Error(`math.gl: ${this.constructor.name} some fields set to invalid numbers'`);
    return this;
  }
  /** Returns false if the array length is incorrect or contains illegal values */
  validate() {
    let e = this.length === this.ELEMENTS;
    for (let i = 0; i < this.ELEMENTS; ++i)
      e = e && Number.isFinite(this[i]);
    return e;
  }
  // three.js compatibility
  /** @deprecated */
  sub(e) {
    return this.subtract(e);
  }
  /** @deprecated */
  setScalar(e) {
    for (let i = 0; i < this.ELEMENTS; ++i)
      this[i] = e;
    return this.check();
  }
  /** @deprecated */
  addScalar(e) {
    for (let i = 0; i < this.ELEMENTS; ++i)
      this[i] += e;
    return this.check();
  }
  /** @deprecated */
  subScalar(e) {
    return this.addScalar(-e);
  }
  /** @deprecated */
  multiplyScalar(e) {
    for (let i = 0; i < this.ELEMENTS; ++i)
      this[i] *= e;
    return this.check();
  }
  /** @deprecated */
  divideScalar(e) {
    return this.multiplyByScalar(1 / e);
  }
  /** @deprecated */
  clampScalar(e, i) {
    for (let s = 0; s < this.ELEMENTS; ++s)
      this[s] = Math.min(Math.max(this[s], e), i);
    return this.check();
  }
  /** @deprecated */
  get elements() {
    return this;
  }
}
function $P(t, e) {
  if (t.length !== e)
    return !1;
  for (let i = 0; i < t.length; ++i)
    if (!Number.isFinite(t[i]))
      return !1;
  return !0;
}
function ri(t) {
  if (!Number.isFinite(t))
    throw new Error(`Invalid number ${JSON.stringify(t)}`);
  return t;
}
function Vu(t, e, i = "") {
  if (Ar.debug && !$P(t, e))
    throw new Error(`math.gl: ${i} some fields set to invalid numbers'`);
  return t;
}
function In(t, e) {
  if (!t)
    throw new Error(`math.gl assertion ${e}`);
}
class _y extends py {
  // ACCESSORS
  get x() {
    return this[0];
  }
  set x(e) {
    this[0] = ri(e);
  }
  get y() {
    return this[1];
  }
  set y(e) {
    this[1] = ri(e);
  }
  /**
   * Returns the length of the vector from the origin to the point described by this vector
   *
   * @note `length` is a reserved word for Arrays, so `v.length()` will return number of elements
   * Instead we provide `len` and `magnitude`
   */
  len() {
    return Math.sqrt(this.lengthSquared());
  }
  /**
   * Returns the length of the vector from the origin to the point described by this vector
   */
  magnitude() {
    return this.len();
  }
  /**
   * Returns the squared length of the vector from the origin to the point described by this vector
   */
  lengthSquared() {
    let e = 0;
    for (let i = 0; i < this.ELEMENTS; ++i)
      e += this[i] * this[i];
    return e;
  }
  /**
   * Returns the squared length of the vector from the origin to the point described by this vector
   */
  magnitudeSquared() {
    return this.lengthSquared();
  }
  distance(e) {
    return Math.sqrt(this.distanceSquared(e));
  }
  distanceSquared(e) {
    let i = 0;
    for (let s = 0; s < this.ELEMENTS; ++s) {
      const o = this[s] - e[s];
      i += o * o;
    }
    return ri(i);
  }
  dot(e) {
    let i = 0;
    for (let s = 0; s < this.ELEMENTS; ++s)
      i += this[s] * e[s];
    return ri(i);
  }
  // MODIFIERS
  normalize() {
    const e = this.magnitude();
    if (e !== 0)
      for (let i = 0; i < this.ELEMENTS; ++i)
        this[i] /= e;
    return this.check();
  }
  multiply(...e) {
    for (const i of e)
      for (let s = 0; s < this.ELEMENTS; ++s)
        this[s] *= i[s];
    return this.check();
  }
  divide(...e) {
    for (const i of e)
      for (let s = 0; s < this.ELEMENTS; ++s)
        this[s] /= i[s];
    return this.check();
  }
  // THREE.js compatibility
  lengthSq() {
    return this.lengthSquared();
  }
  distanceTo(e) {
    return this.distance(e);
  }
  distanceToSquared(e) {
    return this.distanceSquared(e);
  }
  getComponent(e) {
    return In(e >= 0 && e < this.ELEMENTS, "index is out of range"), ri(this[e]);
  }
  setComponent(e, i) {
    return In(e >= 0 && e < this.ELEMENTS, "index is out of range"), this[e] = i, this.check();
  }
  addVectors(e, i) {
    return this.copy(e).add(i);
  }
  subVectors(e, i) {
    return this.copy(e).subtract(i);
  }
  multiplyVectors(e, i) {
    return this.copy(e).multiply(i);
  }
  addScaledVector(e, i) {
    return this.add(new this.constructor(e).multiplyScalar(i));
  }
}
const ju = 1e-6;
let kn = typeof Float32Array < "u" ? Float32Array : Array;
function GP() {
  const t = new kn(2);
  return kn != Float32Array && (t[0] = 0, t[1] = 0), t;
}
function Pv(t, e, i) {
  return t[0] = e[0] + i[0], t[1] = e[1] + i[1], t;
}
function WP(t, e) {
  return t[0] = -e[0], t[1] = -e[1], t;
}
function Jw(t, e, i, s) {
  const o = e[0], u = e[1];
  return t[0] = o + s * (i[0] - o), t[1] = u + s * (i[1] - u), t;
}
function XP(t, e, i) {
  const s = e[0], o = e[1];
  return t[0] = i[0] * s + i[2] * o, t[1] = i[1] * s + i[3] * o, t;
}
function qP(t, e, i) {
  const s = e[0], o = e[1];
  return t[0] = i[0] * s + i[2] * o + i[4], t[1] = i[1] * s + i[3] * o + i[5], t;
}
function Qw(t, e, i) {
  const s = e[0], o = e[1];
  return t[0] = i[0] * s + i[3] * o + i[6], t[1] = i[1] * s + i[4] * o + i[7], t;
}
function eT(t, e, i) {
  const s = e[0], o = e[1];
  return t[0] = i[0] * s + i[4] * o + i[12], t[1] = i[1] * s + i[5] * o + i[13], t;
}
(function() {
  const t = GP();
  return function(e, i, s, o, u, d) {
    let a, w;
    for (i || (i = 2), s || (s = 0), o ? w = Math.min(o * i + s, e.length) : w = e.length, a = s; a < w; a += i)
      t[0] = e[a], t[1] = e[a + 1], u(t, t, d), e[a] = t[0], e[a + 1] = t[1];
    return e;
  };
})();
function tT(t, e, i) {
  const s = e[0], o = e[1], u = i[3] * s + i[7] * o || 1;
  return t[0] = (i[0] * s + i[4] * o) / u, t[1] = (i[1] * s + i[5] * o) / u, t;
}
function iT(t, e, i) {
  const s = e[0], o = e[1], u = e[2], d = i[3] * s + i[7] * o + i[11] * u || 1;
  return t[0] = (i[0] * s + i[4] * o + i[8] * u) / d, t[1] = (i[1] * s + i[5] * o + i[9] * u) / d, t[2] = (i[2] * s + i[6] * o + i[10] * u) / d, t;
}
function ZP(t, e, i) {
  const s = e[0], o = e[1];
  return t[0] = i[0] * s + i[2] * o, t[1] = i[1] * s + i[3] * o, t[2] = e[2], t;
}
function KP(t, e, i) {
  const s = e[0], o = e[1];
  return t[0] = i[0] * s + i[2] * o, t[1] = i[1] * s + i[3] * o, t[2] = e[2], t[3] = e[3], t;
}
function rT(t, e, i) {
  const s = e[0], o = e[1], u = e[2];
  return t[0] = i[0] * s + i[3] * o + i[6] * u, t[1] = i[1] * s + i[4] * o + i[7] * u, t[2] = i[2] * s + i[5] * o + i[8] * u, t[3] = e[3], t;
}
class gy extends _y {
  // Creates a new, empty vec2
  constructor(e = 0, i = 0) {
    super(2), Sa(e) && arguments.length === 1 ? this.copy(e) : (Ar.debug && (ri(e), ri(i)), this[0] = e, this[1] = i);
  }
  set(e, i) {
    return this[0] = e, this[1] = i, this.check();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this.check();
  }
  fromObject(e) {
    return Ar.debug && (ri(e.x), ri(e.y)), this[0] = e.x, this[1] = e.y, this.check();
  }
  toObject(e) {
    return e.x = this[0], e.y = this[1], e;
  }
  // Getters/setters
  get ELEMENTS() {
    return 2;
  }
  /**
   * Returns angle from x axis
   * @returns
   */
  horizontalAngle() {
    return Math.atan2(this.y, this.x);
  }
  /**
   * Returns angle from y axis
   * @returns
   */
  verticalAngle() {
    return Math.atan2(this.x, this.y);
  }
  // Transforms
  /**
   * Transforms as point
   * @param matrix4
   * @returns
   */
  transform(e) {
    return this.transformAsPoint(e);
  }
  /**
   * transforms as point (4th component is implicitly 1)
   * @param matrix4
   * @returns
   */
  transformAsPoint(e) {
    return eT(this, this, e), this.check();
  }
  /**
   * transforms as vector (4th component is implicitly 0, ignores translation. slightly faster)
   * @param matrix4
   * @returns
   */
  transformAsVector(e) {
    return tT(this, this, e), this.check();
  }
  transformByMatrix3(e) {
    return Qw(this, this, e), this.check();
  }
  transformByMatrix2x3(e) {
    return qP(this, this, e), this.check();
  }
  transformByMatrix2(e) {
    return XP(this, this, e), this.check();
  }
}
function sT() {
  const t = new kn(3);
  return kn != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t;
}
function nT(t) {
  const e = t[0], i = t[1], s = t[2];
  return Math.sqrt(e * e + i * i + s * s);
}
function Bv(t, e, i) {
  const s = new kn(3);
  return s[0] = t, s[1] = e, s[2] = i, s;
}
function YP(t, e, i) {
  return t[0] = e[0] - i[0], t[1] = e[1] - i[1], t[2] = e[2] - i[2], t;
}
function JP(t, e) {
  return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t;
}
function QP(t, e) {
  const i = e[0], s = e[1], o = e[2];
  let u = i * i + s * s + o * o;
  return u > 0 && (u = 1 / Math.sqrt(u)), t[0] = e[0] * u, t[1] = e[1] * u, t[2] = e[2] * u, t;
}
function my(t, e) {
  return t[0] * e[0] + t[1] * e[1] + t[2] * e[2];
}
function Jf(t, e, i) {
  const s = e[0], o = e[1], u = e[2], d = i[0], a = i[1], w = i[2];
  return t[0] = o * w - u * a, t[1] = u * d - s * w, t[2] = s * a - o * d, t;
}
function yy(t, e, i) {
  const s = e[0], o = e[1], u = e[2];
  let d = i[3] * s + i[7] * o + i[11] * u + i[15];
  return d = d || 1, t[0] = (i[0] * s + i[4] * o + i[8] * u + i[12]) / d, t[1] = (i[1] * s + i[5] * o + i[9] * u + i[13]) / d, t[2] = (i[2] * s + i[6] * o + i[10] * u + i[14]) / d, t;
}
function oT(t, e, i) {
  const s = e[0], o = e[1], u = e[2];
  return t[0] = s * i[0] + o * i[3] + u * i[6], t[1] = s * i[1] + o * i[4] + u * i[7], t[2] = s * i[2] + o * i[5] + u * i[8], t;
}
function aT(t, e, i) {
  const s = i[0], o = i[1], u = i[2], d = i[3], a = e[0], w = e[1], S = e[2];
  let M = o * S - u * w, F = u * a - s * S, N = s * w - o * a, L = o * N - u * F, re = u * M - s * N, ne = s * F - o * M;
  const we = d * 2;
  return M *= we, F *= we, N *= we, L *= 2, re *= 2, ne *= 2, t[0] = a + M + L, t[1] = w + F + re, t[2] = S + N + ne, t;
}
function e3(t, e, i, s) {
  const o = [], u = [];
  return o[0] = e[0] - i[0], o[1] = e[1] - i[1], o[2] = e[2] - i[2], u[0] = o[0], u[1] = o[1] * Math.cos(s) - o[2] * Math.sin(s), u[2] = o[1] * Math.sin(s) + o[2] * Math.cos(s), t[0] = u[0] + i[0], t[1] = u[1] + i[1], t[2] = u[2] + i[2], t;
}
function t3(t, e, i, s) {
  const o = [], u = [];
  return o[0] = e[0] - i[0], o[1] = e[1] - i[1], o[2] = e[2] - i[2], u[0] = o[2] * Math.sin(s) + o[0] * Math.cos(s), u[1] = o[1], u[2] = o[2] * Math.cos(s) - o[0] * Math.sin(s), t[0] = u[0] + i[0], t[1] = u[1] + i[1], t[2] = u[2] + i[2], t;
}
function i3(t, e, i, s) {
  const o = [], u = [];
  return o[0] = e[0] - i[0], o[1] = e[1] - i[1], o[2] = e[2] - i[2], u[0] = o[0] * Math.cos(s) - o[1] * Math.sin(s), u[1] = o[0] * Math.sin(s) + o[1] * Math.cos(s), u[2] = o[2], t[0] = u[0] + i[0], t[1] = u[1] + i[1], t[2] = u[2] + i[2], t;
}
function r3(t, e) {
  const i = t[0], s = t[1], o = t[2], u = e[0], d = e[1], a = e[2], w = Math.sqrt((i * i + s * s + o * o) * (u * u + d * d + a * a)), S = w && my(t, e) / w;
  return Math.acos(Math.min(Math.max(S, -1), 1));
}
const s3 = YP, n3 = nT;
(function() {
  const t = sT();
  return function(e, i, s, o, u, d) {
    let a, w;
    for (i || (i = 3), s || (s = 0), o ? w = Math.min(o * i + s, e.length) : w = e.length, a = s; a < w; a += i)
      t[0] = e[a], t[1] = e[a + 1], t[2] = e[a + 2], u(t, t, d), e[a] = t[0], e[a + 1] = t[1], e[a + 2] = t[2];
    return e;
  };
})();
const dg = [0, 0, 0];
let Ef;
class Be extends _y {
  static get ZERO() {
    return Ef || (Ef = new Be(0, 0, 0), Object.freeze(Ef)), Ef;
  }
  /**
   * @class
   * @param x
   * @param y
   * @param z
   */
  constructor(e = 0, i = 0, s = 0) {
    super(-0, -0, -0), arguments.length === 1 && Sa(e) ? this.copy(e) : (Ar.debug && (ri(e), ri(i), ri(s)), this[0] = e, this[1] = i, this[2] = s);
  }
  set(e, i, s) {
    return this[0] = e, this[1] = i, this[2] = s, this.check();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this.check();
  }
  fromObject(e) {
    return Ar.debug && (ri(e.x), ri(e.y), ri(e.z)), this[0] = e.x, this[1] = e.y, this[2] = e.z, this.check();
  }
  toObject(e) {
    return e.x = this[0], e.y = this[1], e.z = this[2], e;
  }
  // Getters/setters
  get ELEMENTS() {
    return 3;
  }
  get z() {
    return this[2];
  }
  set z(e) {
    this[2] = ri(e);
  }
  // ACCESSORS
  angle(e) {
    return r3(this, e);
  }
  // MODIFIERS
  cross(e) {
    return Jf(this, this, e), this.check();
  }
  rotateX({ radians: e, origin: i = dg }) {
    return e3(this, this, i, e), this.check();
  }
  rotateY({ radians: e, origin: i = dg }) {
    return t3(this, this, i, e), this.check();
  }
  rotateZ({ radians: e, origin: i = dg }) {
    return i3(this, this, i, e), this.check();
  }
  // Transforms
  // transforms as point (4th component is implicitly 1)
  transform(e) {
    return this.transformAsPoint(e);
  }
  // transforms as point (4th component is implicitly 1)
  transformAsPoint(e) {
    return yy(this, this, e), this.check();
  }
  // transforms as vector  (4th component is implicitly 0, ignores translation. slightly faster)
  transformAsVector(e) {
    return iT(this, this, e), this.check();
  }
  transformByMatrix3(e) {
    return oT(this, this, e), this.check();
  }
  transformByMatrix2(e) {
    return ZP(this, this, e), this.check();
  }
  transformByQuaternion(e) {
    return aT(this, this, e), this.check();
  }
}
let Sf;
class by extends _y {
  static get ZERO() {
    return Sf || (Sf = new by(0, 0, 0, 0), Object.freeze(Sf)), Sf;
  }
  constructor(e = 0, i = 0, s = 0, o = 0) {
    super(-0, -0, -0, -0), Sa(e) && arguments.length === 1 ? this.copy(e) : (Ar.debug && (ri(e), ri(i), ri(s), ri(o)), this[0] = e, this[1] = i, this[2] = s, this[3] = o);
  }
  set(e, i, s, o) {
    return this[0] = e, this[1] = i, this[2] = s, this[3] = o, this.check();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this[3] = e[3], this.check();
  }
  fromObject(e) {
    return Ar.debug && (ri(e.x), ri(e.y), ri(e.z), ri(e.w)), this[0] = e.x, this[1] = e.y, this[2] = e.z, this[3] = e.w, this;
  }
  toObject(e) {
    return e.x = this[0], e.y = this[1], e.z = this[2], e.w = this[3], e;
  }
  // Getters/setters
  /* eslint-disable no-multi-spaces, brace-style, no-return-assign */
  get ELEMENTS() {
    return 4;
  }
  get z() {
    return this[2];
  }
  set z(e) {
    this[2] = ri(e);
  }
  get w() {
    return this[3];
  }
  set w(e) {
    this[3] = ri(e);
  }
  transform(e) {
    return yy(this, this, e), this.check();
  }
  transformByMatrix3(e) {
    return rT(this, this, e), this.check();
  }
  transformByMatrix2(e) {
    return KP(this, this, e), this.check();
  }
  transformByQuaternion(e) {
    return aT(this, this, e), this.check();
  }
  // three.js compatibility
  applyMatrix4(e) {
    return e.transform(this, this), this;
  }
}
class lT extends py {
  // fromObject(object) {
  //   const array = object.elements;
  //   return this.fromRowMajor(array);
  // }
  // toObject(object) {
  //   const array = object.elements;
  //   this.toRowMajor(array);
  //   return object;
  // }
  // TODO better override formatString?
  toString() {
    let e = "[";
    if (Ar.printRowMajor) {
      e += "row-major:";
      for (let i = 0; i < this.RANK; ++i)
        for (let s = 0; s < this.RANK; ++s)
          e += ` ${this[s * this.RANK + i]}`;
    } else {
      e += "column-major:";
      for (let i = 0; i < this.ELEMENTS; ++i)
        e += ` ${this[i]}`;
    }
    return e += "]", e;
  }
  getElementIndex(e, i) {
    return i * this.RANK + e;
  }
  // By default assumes row major indices
  getElement(e, i) {
    return this[i * this.RANK + e];
  }
  // By default assumes row major indices
  setElement(e, i, s) {
    return this[i * this.RANK + e] = ri(s), this;
  }
  getColumn(e, i = new Array(this.RANK).fill(-0)) {
    const s = e * this.RANK;
    for (let o = 0; o < this.RANK; ++o)
      i[o] = this[s + o];
    return i;
  }
  setColumn(e, i) {
    const s = e * this.RANK;
    for (let o = 0; o < this.RANK; ++o)
      this[s + o] = i[o];
    return this;
  }
}
function o3() {
  const t = new kn(9);
  return kn != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[5] = 0, t[6] = 0, t[7] = 0), t[0] = 1, t[4] = 1, t[8] = 1, t;
}
function a3(t, e) {
  if (t === e) {
    const i = e[1], s = e[2], o = e[5];
    t[1] = e[3], t[2] = e[6], t[3] = i, t[5] = e[7], t[6] = s, t[7] = o;
  } else
    t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8];
  return t;
}
function l3(t, e) {
  const i = e[0], s = e[1], o = e[2], u = e[3], d = e[4], a = e[5], w = e[6], S = e[7], M = e[8], F = M * d - a * S, N = -M * u + a * w, L = S * u - d * w;
  let re = i * F + s * N + o * L;
  return re ? (re = 1 / re, t[0] = F * re, t[1] = (-M * s + o * S) * re, t[2] = (a * s - o * d) * re, t[3] = N * re, t[4] = (M * i - o * w) * re, t[5] = (-a * i + o * u) * re, t[6] = L * re, t[7] = (-S * i + s * w) * re, t[8] = (d * i - s * u) * re, t) : null;
}
function c3(t) {
  const e = t[0], i = t[1], s = t[2], o = t[3], u = t[4], d = t[5], a = t[6], w = t[7], S = t[8];
  return e * (S * u - d * w) + i * (-S * o + d * a) + s * (w * o - u * a);
}
function Dv(t, e, i) {
  const s = e[0], o = e[1], u = e[2], d = e[3], a = e[4], w = e[5], S = e[6], M = e[7], F = e[8], N = i[0], L = i[1], re = i[2], ne = i[3], we = i[4], Se = i[5], Ee = i[6], Ce = i[7], Le = i[8];
  return t[0] = N * s + L * d + re * S, t[1] = N * o + L * a + re * M, t[2] = N * u + L * w + re * F, t[3] = ne * s + we * d + Se * S, t[4] = ne * o + we * a + Se * M, t[5] = ne * u + we * w + Se * F, t[6] = Ee * s + Ce * d + Le * S, t[7] = Ee * o + Ce * a + Le * M, t[8] = Ee * u + Ce * w + Le * F, t;
}
function h3(t, e, i) {
  const s = e[0], o = e[1], u = e[2], d = e[3], a = e[4], w = e[5], S = e[6], M = e[7], F = e[8], N = i[0], L = i[1];
  return t[0] = s, t[1] = o, t[2] = u, t[3] = d, t[4] = a, t[5] = w, t[6] = N * s + L * d + S, t[7] = N * o + L * a + M, t[8] = N * u + L * w + F, t;
}
function u3(t, e, i) {
  const s = e[0], o = e[1], u = e[2], d = e[3], a = e[4], w = e[5], S = e[6], M = e[7], F = e[8], N = Math.sin(i), L = Math.cos(i);
  return t[0] = L * s + N * d, t[1] = L * o + N * a, t[2] = L * u + N * w, t[3] = L * d - N * s, t[4] = L * a - N * o, t[5] = L * w - N * u, t[6] = S, t[7] = M, t[8] = F, t;
}
function Ov(t, e, i) {
  const s = i[0], o = i[1];
  return t[0] = s * e[0], t[1] = s * e[1], t[2] = s * e[2], t[3] = o * e[3], t[4] = o * e[4], t[5] = o * e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t;
}
function d3(t, e) {
  const i = e[0], s = e[1], o = e[2], u = e[3], d = i + i, a = s + s, w = o + o, S = i * d, M = s * d, F = s * a, N = o * d, L = o * a, re = o * w, ne = u * d, we = u * a, Se = u * w;
  return t[0] = 1 - F - re, t[3] = M - Se, t[6] = N + we, t[1] = M + Se, t[4] = 1 - S - re, t[7] = L - ne, t[2] = N - we, t[5] = L + ne, t[8] = 1 - S - F, t;
}
var gm;
(function(t) {
  t[t.COL0ROW0 = 0] = "COL0ROW0", t[t.COL0ROW1 = 1] = "COL0ROW1", t[t.COL0ROW2 = 2] = "COL0ROW2", t[t.COL1ROW0 = 3] = "COL1ROW0", t[t.COL1ROW1 = 4] = "COL1ROW1", t[t.COL1ROW2 = 5] = "COL1ROW2", t[t.COL2ROW0 = 6] = "COL2ROW0", t[t.COL2ROW1 = 7] = "COL2ROW1", t[t.COL2ROW2 = 8] = "COL2ROW2";
})(gm || (gm = {}));
const f3 = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);
class Yi extends lT {
  static get IDENTITY() {
    return _3();
  }
  static get ZERO() {
    return p3();
  }
  get ELEMENTS() {
    return 9;
  }
  get RANK() {
    return 3;
  }
  get INDICES() {
    return gm;
  }
  constructor(e, ...i) {
    super(-0, -0, -0, -0, -0, -0, -0, -0, -0), arguments.length === 1 && Array.isArray(e) ? this.copy(e) : i.length > 0 ? this.copy([e, ...i]) : this.identity();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this[3] = e[3], this[4] = e[4], this[5] = e[5], this[6] = e[6], this[7] = e[7], this[8] = e[8], this.check();
  }
  // Constructors
  identity() {
    return this.copy(f3);
  }
  /**
   *
   * @param object
   * @returns self
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  fromObject(e) {
    return this.check();
  }
  /** Calculates a 3x3 matrix from the given quaternion
   * q quat  Quaternion to create matrix from
   */
  fromQuaternion(e) {
    return d3(this, e), this.check();
  }
  /**
   * accepts column major order, stores in column major order
   */
  // eslint-disable-next-line max-params
  set(e, i, s, o, u, d, a, w, S) {
    return this[0] = e, this[1] = i, this[2] = s, this[3] = o, this[4] = u, this[5] = d, this[6] = a, this[7] = w, this[8] = S, this.check();
  }
  /**
   * accepts row major order, stores as column major
   */
  // eslint-disable-next-line max-params
  setRowMajor(e, i, s, o, u, d, a, w, S) {
    return this[0] = e, this[1] = o, this[2] = a, this[3] = i, this[4] = u, this[5] = w, this[6] = s, this[7] = d, this[8] = S, this.check();
  }
  // Accessors
  determinant() {
    return c3(this);
  }
  // Modifiers
  transpose() {
    return a3(this, this), this.check();
  }
  /** Invert a matrix. Note that this can fail if the matrix is not invertible */
  invert() {
    return l3(this, this), this.check();
  }
  // Operations
  multiplyLeft(e) {
    return Dv(this, e, this), this.check();
  }
  multiplyRight(e) {
    return Dv(this, this, e), this.check();
  }
  rotate(e) {
    return u3(this, this, e), this.check();
  }
  scale(e) {
    return Array.isArray(e) ? Ov(this, this, e) : Ov(this, this, [e, e]), this.check();
  }
  translate(e) {
    return h3(this, this, e), this.check();
  }
  // Transforms
  transform(e, i) {
    let s;
    switch (e.length) {
      case 2:
        s = Qw(i || [-0, -0], e, this);
        break;
      case 3:
        s = oT(i || [-0, -0, -0], e, this);
        break;
      case 4:
        s = rT(i || [-0, -0, -0, -0], e, this);
        break;
      default:
        throw new Error("Illegal vector");
    }
    return Vu(s, e.length), s;
  }
  /** @deprecated */
  transformVector(e, i) {
    return this.transform(e, i);
  }
  /** @deprecated */
  transformVector2(e, i) {
    return this.transform(e, i);
  }
  /** @deprecated */
  transformVector3(e, i) {
    return this.transform(e, i);
  }
}
let Cf, If = null;
function p3() {
  return Cf || (Cf = new Yi([0, 0, 0, 0, 0, 0, 0, 0, 0]), Object.freeze(Cf)), Cf;
}
function _3() {
  return If || (If = new Yi(), Object.freeze(If)), If;
}
function g3(t) {
  return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
}
function m3(t, e) {
  if (t === e) {
    const i = e[1], s = e[2], o = e[3], u = e[6], d = e[7], a = e[11];
    t[1] = e[4], t[2] = e[8], t[3] = e[12], t[4] = i, t[6] = e[9], t[7] = e[13], t[8] = s, t[9] = u, t[11] = e[14], t[12] = o, t[13] = d, t[14] = a;
  } else
    t[0] = e[0], t[1] = e[4], t[2] = e[8], t[3] = e[12], t[4] = e[1], t[5] = e[5], t[6] = e[9], t[7] = e[13], t[8] = e[2], t[9] = e[6], t[10] = e[10], t[11] = e[14], t[12] = e[3], t[13] = e[7], t[14] = e[11], t[15] = e[15];
  return t;
}
function mm(t, e) {
  const i = e[0], s = e[1], o = e[2], u = e[3], d = e[4], a = e[5], w = e[6], S = e[7], M = e[8], F = e[9], N = e[10], L = e[11], re = e[12], ne = e[13], we = e[14], Se = e[15], Ee = i * a - s * d, Ce = i * w - o * d, Le = i * S - u * d, Ze = s * w - o * a, Ke = s * S - u * a, ct = o * S - u * w, _t = M * ne - F * re, st = M * we - N * re, ot = M * Se - L * re, bt = F * we - N * ne, Ft = F * Se - L * ne, jt = N * Se - L * we;
  let Et = Ee * jt - Ce * Ft + Le * bt + Ze * ot - Ke * st + ct * _t;
  return Et ? (Et = 1 / Et, t[0] = (a * jt - w * Ft + S * bt) * Et, t[1] = (o * Ft - s * jt - u * bt) * Et, t[2] = (ne * ct - we * Ke + Se * Ze) * Et, t[3] = (N * Ke - F * ct - L * Ze) * Et, t[4] = (w * ot - d * jt - S * st) * Et, t[5] = (i * jt - o * ot + u * st) * Et, t[6] = (we * Le - re * ct - Se * Ce) * Et, t[7] = (M * ct - N * Le + L * Ce) * Et, t[8] = (d * Ft - a * ot + S * _t) * Et, t[9] = (s * ot - i * Ft - u * _t) * Et, t[10] = (re * Ke - ne * Le + Se * Ee) * Et, t[11] = (F * Le - M * Ke - L * Ee) * Et, t[12] = (a * st - d * bt - w * _t) * Et, t[13] = (i * bt - s * st + o * _t) * Et, t[14] = (ne * Ce - re * Ze - we * Ee) * Et, t[15] = (M * Ze - F * Ce + N * Ee) * Et, t) : null;
}
function y3(t) {
  const e = t[0], i = t[1], s = t[2], o = t[3], u = t[4], d = t[5], a = t[6], w = t[7], S = t[8], M = t[9], F = t[10], N = t[11], L = t[12], re = t[13], ne = t[14], we = t[15], Se = e * d - i * u, Ee = e * a - s * u, Ce = i * a - s * d, Le = S * re - M * L, Ze = S * ne - F * L, Ke = M * ne - F * re, ct = e * Ke - i * Ze + s * Le, _t = u * Ke - d * Ze + a * Le, st = S * Ce - M * Ee + F * Se, ot = L * Ce - re * Ee + ne * Se;
  return w * ct - o * _t + we * st - N * ot;
}
function Sl(t, e, i) {
  const s = e[0], o = e[1], u = e[2], d = e[3], a = e[4], w = e[5], S = e[6], M = e[7], F = e[8], N = e[9], L = e[10], re = e[11], ne = e[12], we = e[13], Se = e[14], Ee = e[15];
  let Ce = i[0], Le = i[1], Ze = i[2], Ke = i[3];
  return t[0] = Ce * s + Le * a + Ze * F + Ke * ne, t[1] = Ce * o + Le * w + Ze * N + Ke * we, t[2] = Ce * u + Le * S + Ze * L + Ke * Se, t[3] = Ce * d + Le * M + Ze * re + Ke * Ee, Ce = i[4], Le = i[5], Ze = i[6], Ke = i[7], t[4] = Ce * s + Le * a + Ze * F + Ke * ne, t[5] = Ce * o + Le * w + Ze * N + Ke * we, t[6] = Ce * u + Le * S + Ze * L + Ke * Se, t[7] = Ce * d + Le * M + Ze * re + Ke * Ee, Ce = i[8], Le = i[9], Ze = i[10], Ke = i[11], t[8] = Ce * s + Le * a + Ze * F + Ke * ne, t[9] = Ce * o + Le * w + Ze * N + Ke * we, t[10] = Ce * u + Le * S + Ze * L + Ke * Se, t[11] = Ce * d + Le * M + Ze * re + Ke * Ee, Ce = i[12], Le = i[13], Ze = i[14], Ke = i[15], t[12] = Ce * s + Le * a + Ze * F + Ke * ne, t[13] = Ce * o + Le * w + Ze * N + Ke * we, t[14] = Ce * u + Le * S + Ze * L + Ke * Se, t[15] = Ce * d + Le * M + Ze * re + Ke * Ee, t;
}
function fp(t, e, i) {
  const s = i[0], o = i[1], u = i[2];
  let d, a, w, S, M, F, N, L, re, ne, we, Se;
  return e === t ? (t[12] = e[0] * s + e[4] * o + e[8] * u + e[12], t[13] = e[1] * s + e[5] * o + e[9] * u + e[13], t[14] = e[2] * s + e[6] * o + e[10] * u + e[14], t[15] = e[3] * s + e[7] * o + e[11] * u + e[15]) : (d = e[0], a = e[1], w = e[2], S = e[3], M = e[4], F = e[5], N = e[6], L = e[7], re = e[8], ne = e[9], we = e[10], Se = e[11], t[0] = d, t[1] = a, t[2] = w, t[3] = S, t[4] = M, t[5] = F, t[6] = N, t[7] = L, t[8] = re, t[9] = ne, t[10] = we, t[11] = Se, t[12] = d * s + M * o + re * u + e[12], t[13] = a * s + F * o + ne * u + e[13], t[14] = w * s + N * o + we * u + e[14], t[15] = S * s + L * o + Se * u + e[15]), t;
}
function vy(t, e, i) {
  const s = i[0], o = i[1], u = i[2];
  return t[0] = e[0] * s, t[1] = e[1] * s, t[2] = e[2] * s, t[3] = e[3] * s, t[4] = e[4] * o, t[5] = e[5] * o, t[6] = e[6] * o, t[7] = e[7] * o, t[8] = e[8] * u, t[9] = e[9] * u, t[10] = e[10] * u, t[11] = e[11] * u, t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t;
}
function b3(t, e, i, s) {
  let o = s[0], u = s[1], d = s[2], a = Math.sqrt(o * o + u * u + d * d), w, S, M, F, N, L, re, ne, we, Se, Ee, Ce, Le, Ze, Ke, ct, _t, st, ot, bt, Ft, jt, Et, bi;
  return a < ju ? null : (a = 1 / a, o *= a, u *= a, d *= a, S = Math.sin(i), w = Math.cos(i), M = 1 - w, F = e[0], N = e[1], L = e[2], re = e[3], ne = e[4], we = e[5], Se = e[6], Ee = e[7], Ce = e[8], Le = e[9], Ze = e[10], Ke = e[11], ct = o * o * M + w, _t = u * o * M + d * S, st = d * o * M - u * S, ot = o * u * M - d * S, bt = u * u * M + w, Ft = d * u * M + o * S, jt = o * d * M + u * S, Et = u * d * M - o * S, bi = d * d * M + w, t[0] = F * ct + ne * _t + Ce * st, t[1] = N * ct + we * _t + Le * st, t[2] = L * ct + Se * _t + Ze * st, t[3] = re * ct + Ee * _t + Ke * st, t[4] = F * ot + ne * bt + Ce * Ft, t[5] = N * ot + we * bt + Le * Ft, t[6] = L * ot + Se * bt + Ze * Ft, t[7] = re * ot + Ee * bt + Ke * Ft, t[8] = F * jt + ne * Et + Ce * bi, t[9] = N * jt + we * Et + Le * bi, t[10] = L * jt + Se * Et + Ze * bi, t[11] = re * jt + Ee * Et + Ke * bi, e !== t && (t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t);
}
function cT(t, e, i) {
  const s = Math.sin(i), o = Math.cos(i), u = e[4], d = e[5], a = e[6], w = e[7], S = e[8], M = e[9], F = e[10], N = e[11];
  return e !== t && (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[4] = u * o + S * s, t[5] = d * o + M * s, t[6] = a * o + F * s, t[7] = w * o + N * s, t[8] = S * o - u * s, t[9] = M * o - d * s, t[10] = F * o - a * s, t[11] = N * o - w * s, t;
}
function v3(t, e, i) {
  const s = Math.sin(i), o = Math.cos(i), u = e[0], d = e[1], a = e[2], w = e[3], S = e[8], M = e[9], F = e[10], N = e[11];
  return e !== t && (t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = u * o - S * s, t[1] = d * o - M * s, t[2] = a * o - F * s, t[3] = w * o - N * s, t[8] = u * s + S * o, t[9] = d * s + M * o, t[10] = a * s + F * o, t[11] = w * s + N * o, t;
}
function hT(t, e, i) {
  const s = Math.sin(i), o = Math.cos(i), u = e[0], d = e[1], a = e[2], w = e[3], S = e[4], M = e[5], F = e[6], N = e[7];
  return e !== t && (t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = u * o + S * s, t[1] = d * o + M * s, t[2] = a * o + F * s, t[3] = w * o + N * s, t[4] = S * o - u * s, t[5] = M * o - d * s, t[6] = F * o - a * s, t[7] = N * o - w * s, t;
}
function x3(t, e) {
  const i = e[0], s = e[1], o = e[2], u = e[4], d = e[5], a = e[6], w = e[8], S = e[9], M = e[10];
  return t[0] = Math.sqrt(i * i + s * s + o * o), t[1] = Math.sqrt(u * u + d * d + a * a), t[2] = Math.sqrt(w * w + S * S + M * M), t;
}
function w3(t, e) {
  const i = e[0], s = e[1], o = e[2], u = e[3], d = i + i, a = s + s, w = o + o, S = i * d, M = s * d, F = s * a, N = o * d, L = o * a, re = o * w, ne = u * d, we = u * a, Se = u * w;
  return t[0] = 1 - F - re, t[1] = M + Se, t[2] = N - we, t[3] = 0, t[4] = M - Se, t[5] = 1 - S - re, t[6] = L + ne, t[7] = 0, t[8] = N + we, t[9] = L - ne, t[10] = 1 - S - F, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
}
function T3(t, e, i, s, o, u, d) {
  const a = 1 / (i - e), w = 1 / (o - s), S = 1 / (u - d);
  return t[0] = u * 2 * a, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = u * 2 * w, t[6] = 0, t[7] = 0, t[8] = (i + e) * a, t[9] = (o + s) * w, t[10] = (d + u) * S, t[11] = -1, t[12] = 0, t[13] = 0, t[14] = d * u * 2 * S, t[15] = 0, t;
}
function A3(t, e, i, s, o) {
  const u = 1 / Math.tan(e / 2);
  if (t[0] = u / i, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = u, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, o != null && o !== 1 / 0) {
    const d = 1 / (s - o);
    t[10] = (o + s) * d, t[14] = 2 * o * s * d;
  } else
    t[10] = -1, t[14] = -2 * s;
  return t;
}
const E3 = A3;
function S3(t, e, i, s, o, u, d) {
  const a = 1 / (e - i), w = 1 / (s - o), S = 1 / (u - d);
  return t[0] = -2 * a, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * w, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 2 * S, t[11] = 0, t[12] = (e + i) * a, t[13] = (o + s) * w, t[14] = (d + u) * S, t[15] = 1, t;
}
const C3 = S3;
function I3(t, e, i, s) {
  let o, u, d, a, w, S, M, F, N, L;
  const re = e[0], ne = e[1], we = e[2], Se = s[0], Ee = s[1], Ce = s[2], Le = i[0], Ze = i[1], Ke = i[2];
  return Math.abs(re - Le) < ju && Math.abs(ne - Ze) < ju && Math.abs(we - Ke) < ju ? g3(t) : (F = re - Le, N = ne - Ze, L = we - Ke, o = 1 / Math.sqrt(F * F + N * N + L * L), F *= o, N *= o, L *= o, u = Ee * L - Ce * N, d = Ce * F - Se * L, a = Se * N - Ee * F, o = Math.sqrt(u * u + d * d + a * a), o ? (o = 1 / o, u *= o, d *= o, a *= o) : (u = 0, d = 0, a = 0), w = N * a - L * d, S = L * u - F * a, M = F * d - N * u, o = Math.sqrt(w * w + S * S + M * M), o ? (o = 1 / o, w *= o, S *= o, M *= o) : (w = 0, S = 0, M = 0), t[0] = u, t[1] = w, t[2] = F, t[3] = 0, t[4] = d, t[5] = S, t[6] = N, t[7] = 0, t[8] = a, t[9] = M, t[10] = L, t[11] = 0, t[12] = -(u * re + d * ne + a * we), t[13] = -(w * re + S * ne + M * we), t[14] = -(F * re + N * ne + L * we), t[15] = 1, t);
}
function M3() {
  const t = new kn(4);
  return kn != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0), t;
}
function R3(t, e, i) {
  return t[0] = e[0] + i[0], t[1] = e[1] + i[1], t[2] = e[2] + i[2], t[3] = e[3] + i[3], t;
}
function uT(t, e, i) {
  return t[0] = e[0] * i, t[1] = e[1] * i, t[2] = e[2] * i, t[3] = e[3] * i, t;
}
function P3(t) {
  const e = t[0], i = t[1], s = t[2], o = t[3];
  return Math.sqrt(e * e + i * i + s * s + o * o);
}
function B3(t) {
  const e = t[0], i = t[1], s = t[2], o = t[3];
  return e * e + i * i + s * s + o * o;
}
function D3(t, e) {
  const i = e[0], s = e[1], o = e[2], u = e[3];
  let d = i * i + s * s + o * o + u * u;
  return d > 0 && (d = 1 / Math.sqrt(d)), t[0] = i * d, t[1] = s * d, t[2] = o * d, t[3] = u * d, t;
}
function O3(t, e) {
  return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] * e[3];
}
function F3(t, e, i, s) {
  const o = e[0], u = e[1], d = e[2], a = e[3];
  return t[0] = o + s * (i[0] - o), t[1] = u + s * (i[1] - u), t[2] = d + s * (i[2] - d), t[3] = a + s * (i[3] - a), t;
}
function ad(t, e, i) {
  const s = e[0], o = e[1], u = e[2], d = e[3];
  return t[0] = i[0] * s + i[4] * o + i[8] * u + i[12] * d, t[1] = i[1] * s + i[5] * o + i[9] * u + i[13] * d, t[2] = i[2] * s + i[6] * o + i[10] * u + i[14] * d, t[3] = i[3] * s + i[7] * o + i[11] * u + i[15] * d, t;
}
function k3(t, e, i) {
  const s = e[0], o = e[1], u = e[2], d = i[0], a = i[1], w = i[2], S = i[3], M = S * s + a * u - w * o, F = S * o + w * s - d * u, N = S * u + d * o - a * s, L = -d * s - a * o - w * u;
  return t[0] = M * S + L * -d + F * -w - N * -a, t[1] = F * S + L * -a + N * -d - M * -w, t[2] = N * S + L * -w + M * -a - F * -d, t[3] = e[3], t;
}
(function() {
  const t = M3();
  return function(e, i, s, o, u, d) {
    let a, w;
    for (i || (i = 4), s || (s = 0), o ? w = Math.min(o * i + s, e.length) : w = e.length, a = s; a < w; a += i)
      t[0] = e[a], t[1] = e[a + 1], t[2] = e[a + 2], t[3] = e[a + 3], u(t, t, d), e[a] = t[0], e[a + 1] = t[1], e[a + 2] = t[2], e[a + 3] = t[3];
    return e;
  };
})();
var ym;
(function(t) {
  t[t.COL0ROW0 = 0] = "COL0ROW0", t[t.COL0ROW1 = 1] = "COL0ROW1", t[t.COL0ROW2 = 2] = "COL0ROW2", t[t.COL0ROW3 = 3] = "COL0ROW3", t[t.COL1ROW0 = 4] = "COL1ROW0", t[t.COL1ROW1 = 5] = "COL1ROW1", t[t.COL1ROW2 = 6] = "COL1ROW2", t[t.COL1ROW3 = 7] = "COL1ROW3", t[t.COL2ROW0 = 8] = "COL2ROW0", t[t.COL2ROW1 = 9] = "COL2ROW1", t[t.COL2ROW2 = 10] = "COL2ROW2", t[t.COL2ROW3 = 11] = "COL2ROW3", t[t.COL3ROW0 = 12] = "COL3ROW0", t[t.COL3ROW1 = 13] = "COL3ROW1", t[t.COL3ROW2 = 14] = "COL3ROW2", t[t.COL3ROW3 = 15] = "COL3ROW3";
})(ym || (ym = {}));
const N3 = 45 * Math.PI / 180, L3 = 1, fg = 0.1, pg = 500, U3 = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
class Gt extends lT {
  static get IDENTITY() {
    return V3();
  }
  static get ZERO() {
    return z3();
  }
  get ELEMENTS() {
    return 16;
  }
  get RANK() {
    return 4;
  }
  get INDICES() {
    return ym;
  }
  constructor(e) {
    super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0), arguments.length === 1 && Array.isArray(e) ? this.copy(e) : this.identity();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this[3] = e[3], this[4] = e[4], this[5] = e[5], this[6] = e[6], this[7] = e[7], this[8] = e[8], this[9] = e[9], this[10] = e[10], this[11] = e[11], this[12] = e[12], this[13] = e[13], this[14] = e[14], this[15] = e[15], this.check();
  }
  // eslint-disable-next-line max-params
  set(e, i, s, o, u, d, a, w, S, M, F, N, L, re, ne, we) {
    return this[0] = e, this[1] = i, this[2] = s, this[3] = o, this[4] = u, this[5] = d, this[6] = a, this[7] = w, this[8] = S, this[9] = M, this[10] = F, this[11] = N, this[12] = L, this[13] = re, this[14] = ne, this[15] = we, this.check();
  }
  // accepts row major order, stores as column major
  // eslint-disable-next-line max-params
  setRowMajor(e, i, s, o, u, d, a, w, S, M, F, N, L, re, ne, we) {
    return this[0] = e, this[1] = u, this[2] = S, this[3] = L, this[4] = i, this[5] = d, this[6] = M, this[7] = re, this[8] = s, this[9] = a, this[10] = F, this[11] = ne, this[12] = o, this[13] = w, this[14] = N, this[15] = we, this.check();
  }
  toRowMajor(e) {
    return e[0] = this[0], e[1] = this[4], e[2] = this[8], e[3] = this[12], e[4] = this[1], e[5] = this[5], e[6] = this[9], e[7] = this[13], e[8] = this[2], e[9] = this[6], e[10] = this[10], e[11] = this[14], e[12] = this[3], e[13] = this[7], e[14] = this[11], e[15] = this[15], e;
  }
  // Constructors
  /** Set to identity matrix */
  identity() {
    return this.copy(U3);
  }
  /**
   *
   * @param object
   * @returns self
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  fromObject(e) {
    return this.check();
  }
  /**
   * Calculates a 4x4 matrix from the given quaternion
   * @param quaternion Quaternion to create matrix from
   * @returns self
   */
  fromQuaternion(e) {
    return w3(this, e), this.check();
  }
  /**
   * Generates a frustum matrix with the given bounds
   * @param view.left - Left bound of the frustum
   * @param view.right - Right bound of the frustum
   * @param view.bottom - Bottom bound of the frustum
   * @param view.top - Top bound of the frustum
   * @param view.near - Near bound of the frustum
   * @param view.far - Far bound of the frustum. Can be set to Infinity.
   * @returns self
   */
  frustum(e) {
    const { left: i, right: s, bottom: o, top: u, near: d = fg, far: a = pg } = e;
    return a === 1 / 0 ? j3(this, i, s, o, u, d) : T3(this, i, s, o, u, d, a), this.check();
  }
  /**
   * Generates a look-at matrix with the given eye position, focal point,
   * and up axis
   * @param view.eye - (vector) Position of the viewer
   * @param view.center - (vector) Point the viewer is looking at
   * @param view.up - (vector) Up axis
   * @returns self
   */
  lookAt(e) {
    const { eye: i, center: s = [0, 0, 0], up: o = [0, 1, 0] } = e;
    return I3(this, i, s, o), this.check();
  }
  /**
   * Generates a orthogonal projection matrix with the given bounds
   * from "traditional" view space parameters
   * @param view.left - Left bound of the frustum
   * @param view.right number  Right bound of the frustum
   * @param view.bottom - Bottom bound of the frustum
   * @param view.top number  Top bound of the frustum
   * @param view.near - Near bound of the frustum
   * @param view.far number  Far bound of the frustum
   * @returns self
   */
  ortho(e) {
    const { left: i, right: s, bottom: o, top: u, near: d = fg, far: a = pg } = e;
    return C3(this, i, s, o, u, d, a), this.check();
  }
  /**
   * Generates an orthogonal projection matrix with the same parameters
   * as a perspective matrix (plus focalDistance)
   * @param view.fovy Vertical field of view in radians
   * @param view.aspect Aspect ratio. Typically viewport width / viewport height
   * @param view.focalDistance Distance in the view frustum used for extent calculations
   * @param view.near Near bound of the frustum
   * @param view.far Far bound of the frustum
   * @returns self
   */
  orthographic(e) {
    const { fovy: i = N3, aspect: s = L3, focalDistance: o = 1, near: u = fg, far: d = pg } = e;
    Fv(i);
    const a = i / 2, w = o * Math.tan(a), S = w * s;
    return this.ortho({
      left: -S,
      right: S,
      bottom: -w,
      top: w,
      near: u,
      far: d
    });
  }
  /**
   * Generates a perspective projection matrix with the given bounds
   * @param view.fovy Vertical field of view in radians
   * @param view.aspect Aspect ratio. typically viewport width/height
   * @param view.near Near bound of the frustum
   * @param view.far Far bound of the frustum
   * @returns self
   */
  perspective(e) {
    const { fovy: i = 45 * Math.PI / 180, aspect: s = 1, near: o = 0.1, far: u = 500 } = e;
    return Fv(i), E3(this, i, s, o, u), this.check();
  }
  // Accessors
  determinant() {
    return y3(this);
  }
  /**
   * Extracts the non-uniform scale assuming the matrix is an affine transformation.
   * The scales are the "lengths" of the column vectors in the upper-left 3x3 matrix.
   * @param result
   * @returns self
   */
  getScale(e = [-0, -0, -0]) {
    return e[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]), e[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]), e[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]), e;
  }
  /**
   * Gets the translation portion, assuming the matrix is a affine transformation matrix.
   * @param result
   * @returns self
   */
  getTranslation(e = [-0, -0, -0]) {
    return e[0] = this[12], e[1] = this[13], e[2] = this[14], e;
  }
  /**
   * Gets upper left 3x3 pure rotation matrix (non-scaling), assume affine transformation matrix
   * @param result
   * @param scaleResult
   * @returns self
   */
  getRotation(e, i) {
    e = e || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0], i = i || [-0, -0, -0];
    const s = this.getScale(i), o = 1 / s[0], u = 1 / s[1], d = 1 / s[2];
    return e[0] = this[0] * o, e[1] = this[1] * u, e[2] = this[2] * d, e[3] = 0, e[4] = this[4] * o, e[5] = this[5] * u, e[6] = this[6] * d, e[7] = 0, e[8] = this[8] * o, e[9] = this[9] * u, e[10] = this[10] * d, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
  }
  /**
   *
   * @param result
   * @param scaleResult
   * @returns self
   */
  getRotationMatrix3(e, i) {
    e = e || [-0, -0, -0, -0, -0, -0, -0, -0, -0], i = i || [-0, -0, -0];
    const s = this.getScale(i), o = 1 / s[0], u = 1 / s[1], d = 1 / s[2];
    return e[0] = this[0] * o, e[1] = this[1] * u, e[2] = this[2] * d, e[3] = this[4] * o, e[4] = this[5] * u, e[5] = this[6] * d, e[6] = this[8] * o, e[7] = this[9] * u, e[8] = this[10] * d, e;
  }
  // Modifiers
  transpose() {
    return m3(this, this), this.check();
  }
  invert() {
    return mm(this, this), this.check();
  }
  // Operations
  multiplyLeft(e) {
    return Sl(this, e, this), this.check();
  }
  multiplyRight(e) {
    return Sl(this, this, e), this.check();
  }
  // Rotates a matrix by the given angle around the X axis
  rotateX(e) {
    return cT(this, this, e), this.check();
  }
  // Rotates a matrix by the given angle around the Y axis.
  rotateY(e) {
    return v3(this, this, e), this.check();
  }
  /**
   * Rotates a matrix by the given angle around the Z axis.
   * @param radians
   * @returns self
   */
  rotateZ(e) {
    return hT(this, this, e), this.check();
  }
  /**
   *
   * @param param0
   * @returns self
   */
  rotateXYZ(e) {
    return this.rotateX(e[0]).rotateY(e[1]).rotateZ(e[2]);
  }
  /**
   *
   * @param radians
   * @param axis
   * @returns self
   */
  rotateAxis(e, i) {
    return b3(this, this, e, i), this.check();
  }
  /**
   *
   * @param factor
   * @returns self
   */
  scale(e) {
    return vy(this, this, Array.isArray(e) ? e : [e, e, e]), this.check();
  }
  /**
   *
   * @param vec
   * @returns self
   */
  translate(e) {
    return fp(this, this, e), this.check();
  }
  // Transforms
  /**
   * Transforms any 2, 3 or 4 element vector. 2 and 3 elements are treated as points
   * @param vector
   * @param result
   * @returns self
   */
  transform(e, i) {
    return e.length === 4 ? (i = ad(i || [-0, -0, -0, -0], e, this), Vu(i, 4), i) : this.transformAsPoint(e, i);
  }
  /**
   * Transforms any 2 or 3 element array as point (w implicitly 1)
   * @param vector
   * @param result
   * @returns self
   */
  transformAsPoint(e, i) {
    const { length: s } = e;
    let o;
    switch (s) {
      case 2:
        o = eT(i || [-0, -0], e, this);
        break;
      case 3:
        o = yy(i || [-0, -0, -0], e, this);
        break;
      default:
        throw new Error("Illegal vector");
    }
    return Vu(o, e.length), o;
  }
  /**
   * Transforms any 2 or 3 element array as vector (w implicitly 0)
   * @param vector
   * @param result
   * @returns self
   */
  transformAsVector(e, i) {
    let s;
    switch (e.length) {
      case 2:
        s = tT(i || [-0, -0], e, this);
        break;
      case 3:
        s = iT(i || [-0, -0, -0], e, this);
        break;
      default:
        throw new Error("Illegal vector");
    }
    return Vu(s, e.length), s;
  }
  /** @deprecated */
  transformPoint(e, i) {
    return this.transformAsPoint(e, i);
  }
  /** @deprecated */
  transformVector(e, i) {
    return this.transformAsPoint(e, i);
  }
  /** @deprecated */
  transformDirection(e, i) {
    return this.transformAsVector(e, i);
  }
  // three.js math API compatibility
  makeRotationX(e) {
    return this.identity().rotateX(e);
  }
  makeTranslation(e, i, s) {
    return this.identity().translate([e, i, s]);
  }
}
let Mf, Rf;
function z3() {
  return Mf || (Mf = new Gt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), Object.freeze(Mf)), Mf;
}
function V3() {
  return Rf || (Rf = new Gt(), Object.freeze(Rf)), Rf;
}
function Fv(t) {
  if (t > Math.PI * 2)
    throw Error("expected radians");
}
function j3(t, e, i, s, o, u) {
  const d = 2 * u / (i - e), a = 2 * u / (o - s), w = (i + e) / (i - e), S = (o + s) / (o - s), M = -1, F = -1, N = -2 * u;
  return t[0] = d, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = a, t[6] = 0, t[7] = 0, t[8] = w, t[9] = S, t[10] = M, t[11] = F, t[12] = 0, t[13] = 0, t[14] = N, t[15] = 0, t;
}
function kv() {
  const t = new kn(4);
  return kn != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t[3] = 1, t;
}
function H3(t) {
  return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t;
}
function dT(t, e, i) {
  i = i * 0.5;
  const s = Math.sin(i);
  return t[0] = s * e[0], t[1] = s * e[1], t[2] = s * e[2], t[3] = Math.cos(i), t;
}
function Nv(t, e, i) {
  const s = e[0], o = e[1], u = e[2], d = e[3], a = i[0], w = i[1], S = i[2], M = i[3];
  return t[0] = s * M + d * a + o * S - u * w, t[1] = o * M + d * w + u * a - s * S, t[2] = u * M + d * S + s * w - o * a, t[3] = d * M - s * a - o * w - u * S, t;
}
function $3(t, e, i) {
  i *= 0.5;
  const s = e[0], o = e[1], u = e[2], d = e[3], a = Math.sin(i), w = Math.cos(i);
  return t[0] = s * w + d * a, t[1] = o * w + u * a, t[2] = u * w - o * a, t[3] = d * w - s * a, t;
}
function G3(t, e, i) {
  i *= 0.5;
  const s = e[0], o = e[1], u = e[2], d = e[3], a = Math.sin(i), w = Math.cos(i);
  return t[0] = s * w - u * a, t[1] = o * w + d * a, t[2] = u * w + s * a, t[3] = d * w - o * a, t;
}
function W3(t, e, i) {
  i *= 0.5;
  const s = e[0], o = e[1], u = e[2], d = e[3], a = Math.sin(i), w = Math.cos(i);
  return t[0] = s * w + o * a, t[1] = o * w - s * a, t[2] = u * w + d * a, t[3] = d * w - u * a, t;
}
function X3(t, e) {
  const i = e[0], s = e[1], o = e[2];
  return t[0] = i, t[1] = s, t[2] = o, t[3] = Math.sqrt(Math.abs(1 - i * i - s * s - o * o)), t;
}
function Qf(t, e, i, s) {
  const o = e[0], u = e[1], d = e[2], a = e[3];
  let w = i[0], S = i[1], M = i[2], F = i[3], N, L, re, ne, we;
  return N = o * w + u * S + d * M + a * F, N < 0 && (N = -N, w = -w, S = -S, M = -M, F = -F), 1 - N > ju ? (L = Math.acos(N), we = Math.sin(L), re = Math.sin((1 - s) * L) / we, ne = Math.sin(s * L) / we) : (re = 1 - s, ne = s), t[0] = re * o + ne * w, t[1] = re * u + ne * S, t[2] = re * d + ne * M, t[3] = re * a + ne * F, t;
}
function q3(t, e) {
  const i = e[0], s = e[1], o = e[2], u = e[3], d = i * i + s * s + o * o + u * u, a = d ? 1 / d : 0;
  return t[0] = -i * a, t[1] = -s * a, t[2] = -o * a, t[3] = u * a, t;
}
function Z3(t, e) {
  return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = e[3], t;
}
function fT(t, e) {
  const i = e[0] + e[4] + e[8];
  let s;
  if (i > 0)
    s = Math.sqrt(i + 1), t[3] = 0.5 * s, s = 0.5 / s, t[0] = (e[5] - e[7]) * s, t[1] = (e[6] - e[2]) * s, t[2] = (e[1] - e[3]) * s;
  else {
    let o = 0;
    e[4] > e[0] && (o = 1), e[8] > e[o * 3 + o] && (o = 2);
    const u = (o + 1) % 3, d = (o + 2) % 3;
    s = Math.sqrt(e[o * 3 + o] - e[u * 3 + u] - e[d * 3 + d] + 1), t[o] = 0.5 * s, s = 0.5 / s, t[3] = (e[u * 3 + d] - e[d * 3 + u]) * s, t[u] = (e[u * 3 + o] + e[o * 3 + u]) * s, t[d] = (e[d * 3 + o] + e[o * 3 + d]) * s;
  }
  return t;
}
const K3 = R3, Y3 = uT, J3 = O3, Q3 = F3, eB = P3, tB = B3, pT = D3, iB = (function() {
  const t = sT(), e = Bv(1, 0, 0), i = Bv(0, 1, 0);
  return function(s, o, u) {
    const d = my(o, u);
    return d < -0.999999 ? (Jf(t, e, o), n3(t) < 1e-6 && Jf(t, i, o), QP(t, t), dT(s, t, Math.PI), s) : d > 0.999999 ? (s[0] = 0, s[1] = 0, s[2] = 0, s[3] = 1, s) : (Jf(t, o, u), s[0] = t[0], s[1] = t[1], s[2] = t[2], s[3] = 1 + d, pT(s, s));
  };
})();
(function() {
  const t = kv(), e = kv();
  return function(i, s, o, u, d, a) {
    return Qf(t, s, d, a), Qf(e, o, u, a), Qf(i, t, e, 2 * a * (1 - a)), i;
  };
})();
(function() {
  const t = o3();
  return function(e, i, s, o) {
    return t[0] = s[0], t[3] = s[1], t[6] = s[2], t[1] = o[0], t[4] = o[1], t[7] = o[2], t[2] = -i[0], t[5] = -i[1], t[8] = -i[2], pT(e, fT(e, t));
  };
})();
const rB = [0, 0, 0, 1];
class qu extends py {
  constructor(e = 0, i = 0, s = 0, o = 1) {
    super(-0, -0, -0, -0), Array.isArray(e) && arguments.length === 1 ? this.copy(e) : this.set(e, i, s, o);
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this[3] = e[3], this.check();
  }
  set(e, i, s, o) {
    return this[0] = e, this[1] = i, this[2] = s, this[3] = o, this.check();
  }
  fromObject(e) {
    return this[0] = e.x, this[1] = e.y, this[2] = e.z, this[3] = e.w, this.check();
  }
  /**
   * Creates a quaternion from the given 3x3 rotation matrix.
   * NOTE: The resultant quaternion is not normalized, so you should
   * be sure to renormalize the quaternion yourself where necessary.
   * @param m
   * @returns
   */
  fromMatrix3(e) {
    return fT(this, e), this.check();
  }
  fromAxisRotation(e, i) {
    return dT(this, e, i), this.check();
  }
  /** Set a quat to the identity quaternion */
  identity() {
    return H3(this), this.check();
  }
  // Set the components of a quat to the given values
  // set(i, j, k, l) {
  //   quat_set(this, i, j, k, l);
  //   return this.check();
  // }
  // Sets a quat from the given angle and rotation axis, then returns it.
  setAxisAngle(e, i) {
    return this.fromAxisRotation(e, i);
  }
  // Getters/setters
  get ELEMENTS() {
    return 4;
  }
  get x() {
    return this[0];
  }
  set x(e) {
    this[0] = ri(e);
  }
  get y() {
    return this[1];
  }
  set y(e) {
    this[1] = ri(e);
  }
  get z() {
    return this[2];
  }
  set z(e) {
    this[2] = ri(e);
  }
  get w() {
    return this[3];
  }
  set w(e) {
    this[3] = ri(e);
  }
  // Calculates the length of a quat
  len() {
    return eB(this);
  }
  // Calculates the squared length of a quat
  lengthSquared() {
    return tB(this);
  }
  // Calculates the dot product of two quat's
  // @return {Number}
  dot(e) {
    return J3(this, e);
  }
  // Gets the rotation axis and angle for a given quaternion.
  // If a quaternion is created with setAxisAngle, this method will
  // return the same values as providied in the original parameter
  // list OR functionally equivalent values.
  // Example: The quaternion formed by axis [0, 0, 1] and angle -90
  // is the same as the quaternion formed by [0, 0, 1] and 270.
  // This method favors the latter.
  // @return {{[x,y,z], Number}}
  // getAxisAngle() {
  //   const axis = [];
  // //   const angle = quat_getAxisAngle(axis, this);
  //   return {axis, angle};
  // }
  // MODIFIERS
  // Sets a quaternion to represent the shortest rotation from one vector
  // to another. Both vectors are assumed to be unit length.
  rotationTo(e, i) {
    return iB(this, e, i), this.check();
  }
  // Sets the specified quaternion with values corresponding to the given axes.
  // Each axis is a vec3 and is expected to be unit length and perpendicular
  // to all other specified axes.
  // setAxes() {
  //   Number
  // }
  // Performs a spherical linear interpolation with two control points
  // sqlerp() {
  //   Number;
  // }
  // Adds two quat's
  add(e) {
    return K3(this, this, e), this.check();
  }
  // Calculates the W component of a quat from the X, Y, and Z components.
  // Any existing W component will be ignored.
  calculateW() {
    return X3(this, this), this.check();
  }
  // Calculates the conjugate of a quat If the quaternion is normalized,
  // this function is faster than quat_invert and produces the same result.
  conjugate() {
    return Z3(this, this), this.check();
  }
  // Calculates the inverse of a quat
  invert() {
    return q3(this, this), this.check();
  }
  // Performs a linear interpolation between two quat's
  lerp(e, i, s) {
    return s === void 0 ? this.lerp(this, e, i) : (Q3(this, e, i, s), this.check());
  }
  // Multiplies two quat's
  multiplyRight(e) {
    return Nv(this, this, e), this.check();
  }
  multiplyLeft(e) {
    return Nv(this, e, this), this.check();
  }
  // Normalize a quat
  normalize() {
    const e = this.len(), i = e > 0 ? 1 / e : 0;
    return this[0] = this[0] * i, this[1] = this[1] * i, this[2] = this[2] * i, this[3] = this[3] * i, e === 0 && (this[3] = 1), this.check();
  }
  // Rotates a quaternion by the given angle about the X axis
  rotateX(e) {
    return $3(this, this, e), this.check();
  }
  // Rotates a quaternion by the given angle about the Y axis
  rotateY(e) {
    return G3(this, this, e), this.check();
  }
  // Rotates a quaternion by the given angle about the Z axis
  rotateZ(e) {
    return W3(this, this, e), this.check();
  }
  // Scales a quat by a scalar number
  scale(e) {
    return Y3(this, this, e), this.check();
  }
  // Performs a spherical linear interpolation between two quat
  slerp(e, i, s) {
    let o, u, d;
    switch (arguments.length) {
      case 1:
        ({
          start: o = rB,
          target: u,
          ratio: d
        } = e);
        break;
      case 2:
        o = this, u = e, d = i;
        break;
      default:
        o = e, u = i, d = s;
    }
    return Qf(this, o, u, d), this.check();
  }
  transformVector4(e, i = new by()) {
    return k3(i, e, this), Vu(i, 4);
  }
  // THREE.js Math API compatibility
  lengthSq() {
    return this.lengthSquared();
  }
  setFromAxisAngle(e, i) {
    return this.setAxisAngle(e, i);
  }
  premultiply(e) {
    return this.multiplyLeft(e);
  }
  multiply(e) {
    return this.multiplyRight(e);
  }
}
const sB = 0.1, nB = 1e-12, _T = 1e-15, oB = 1e-20, Lv = `#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))
struct AmbientLight {
vec3 color;
};
struct PointLight {
vec3 color;
vec3 position;
vec3 attenuation;
};
struct DirectionalLight {
vec3 color;
vec3 direction;
};
uniform AmbientLight lighting_uAmbientLight;
uniform PointLight lighting_uPointLight[MAX_LIGHTS];
uniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];
uniform int lighting_uPointLightCount;
uniform int lighting_uDirectionalLightCount;
uniform bool lighting_uEnabled;
float getPointLightAttenuation(PointLight pointLight, float distance) {
return pointLight.attenuation.x
+ pointLight.attenuation.y * distance
+ pointLight.attenuation.z * distance * distance;
}
#endif
`, aB = {
  lightSources: {}
};
function _g(t = {}) {
  const { color: e = [0, 0, 0], intensity: i = 1 } = t;
  return e.map((s) => s * i / 255);
}
function lB({ ambientLight: t, pointLights: e = [], directionalLights: i = [] }) {
  const s = {};
  return t ? s["lighting_uAmbientLight.color"] = _g(t) : s["lighting_uAmbientLight.color"] = [0, 0, 0], e.forEach((o, u) => {
    s[`lighting_uPointLight[${u}].color`] = _g(o), s[`lighting_uPointLight[${u}].position`] = o.position, s[`lighting_uPointLight[${u}].attenuation`] = o.attenuation || [
      1,
      0,
      0
    ];
  }), s.lighting_uPointLightCount = e.length, i.forEach((o, u) => {
    s[`lighting_uDirectionalLight[${u}].color`] = _g(o), s[`lighting_uDirectionalLight[${u}].direction`] = o.direction;
  }), s.lighting_uDirectionalLightCount = i.length, s;
}
function gT(t = aB) {
  if ("lightSources" in t) {
    const { ambientLight: e, pointLights: i, directionalLights: s } = t.lightSources || {};
    return e || i && i.length > 0 || s && s.length > 0 ? Object.assign({}, lB({ ambientLight: e, pointLights: i, directionalLights: s }), {
      lighting_uEnabled: !0
    }) : { lighting_uEnabled: !1 };
  }
  if ("lights" in t) {
    const e = { pointLights: [], directionalLights: [] };
    for (const i of t.lights || [])
      switch (i.type) {
        case "ambient":
          e.ambientLight = i;
          break;
        case "directional":
          e.directionalLights?.push(i);
          break;
        case "point":
          e.pointLights?.push(i);
          break;
      }
    return gT({ lightSources: e });
  }
  return {};
}
const xy = {
  name: "lights",
  vs: Lv,
  fs: Lv,
  getUniforms: gT,
  defines: {
    MAX_LIGHTS: 3
  }
}, mT = `uniform float lighting_uAmbient;
uniform float lighting_uDiffuse;
uniform float lighting_uShininess;
uniform vec3  lighting_uSpecularColor;
vec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {
vec3 halfway_direction = normalize(light_direction + view_direction);
float lambertian = dot(light_direction, normal_worldspace);
float specular = 0.0;
if (lambertian > 0.0) {
float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
specular = pow(specular_angle, lighting_uShininess);
}
lambertian = max(lambertian, 0.0);
return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;
}
vec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
vec3 lightColor = surfaceColor;
if (lighting_uEnabled) {
vec3 view_direction = normalize(cameraPosition - position_worldspace);
lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;
for (int i = 0; i < MAX_LIGHTS; i++) {
if (i >= lighting_uPointLightCount) {
break;
}
PointLight pointLight = lighting_uPointLight[i];
vec3 light_position_worldspace = pointLight.position;
vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
}
for (int i = 0; i < MAX_LIGHTS; i++) {
if (i >= lighting_uDirectionalLightCount) {
break;
}
DirectionalLight directionalLight = lighting_uDirectionalLight[i];
lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
}
}
return lightColor;
}
vec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
vec3 lightColor = vec3(0, 0, 0);
vec3 surfaceColor = vec3(0, 0, 0);
if (lighting_uEnabled) {
vec3 view_direction = normalize(cameraPosition - position_worldspace);
for (int i = 0; i < MAX_LIGHTS; i++) {
if (i >= lighting_uPointLightCount) {
break;
}
PointLight pointLight = lighting_uPointLight[i];
vec3 light_position_worldspace = pointLight.position;
vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
}
for (int i = 0; i < MAX_LIGHTS; i++) {
if (i >= lighting_uDirectionalLightCount) {
break;
}
DirectionalLight directionalLight = lighting_uDirectionalLight[i];
lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
}
}
return lightColor;
}
`, cB = {};
function hB(t) {
  const { ambient: e = 0.35, diffuse: i = 0.6, shininess: s = 32, specularColor: o = [30, 30, 30] } = t;
  return {
    lighting_uAmbient: e,
    lighting_uDiffuse: i,
    lighting_uShininess: s,
    lighting_uSpecularColor: o.map((u) => u / 255)
  };
}
function yT(t = cB) {
  if (!("material" in t))
    return {};
  const { material: e } = t;
  return e ? hB(e) : { lighting_uEnabled: !1 };
}
const uB = {
  name: "gouraud-lighting",
  dependencies: [xy],
  vs: mT,
  defines: {
    LIGHTING_VERTEX: 1
  },
  getUniforms: yT
}, dB = {
  name: "phong-lighting",
  dependencies: [xy],
  fs: mT,
  defines: {
    LIGHTING_FRAGMENT: 1
  },
  getUniforms: yT
}, fB = `uniform mat4 u_MVPMatrix;
uniform mat4 u_ModelMatrix;
uniform mat4 u_NormalMatrix;
out vec3 pbr_vPosition;
out vec2 pbr_vUV;
#ifdef HAS_NORMALS
# ifdef HAS_TANGENTS
out mat3 pbr_vTBN;
# else
out vec3 pbr_vNormal;
# endif
#endif
void pbr_setPositionNormalTangentUV(vec4 position, vec4 normal, vec4 tangent, vec2 uv)
{
vec4 pos = u_ModelMatrix * position;
pbr_vPosition = vec3(pos.xyz) / pos.w;
#ifdef HAS_NORMALS
#ifdef HAS_TANGENTS
vec3 normalW = normalize(vec3(u_NormalMatrix * vec4(normal.xyz, 0.0)));
vec3 tangentW = normalize(vec3(u_ModelMatrix * vec4(tangent.xyz, 0.0)));
vec3 bitangentW = cross(normalW, tangentW) * tangent.w;
pbr_vTBN = mat3(tangentW, bitangentW, normalW);
#else
pbr_vNormal = normalize(vec3(u_ModelMatrix * vec4(normal.xyz, 0.0)));
#endif
#endif
#ifdef HAS_UV
pbr_vUV = uv;
#else
pbr_vUV = vec2(0.,0.);
#endif
}
`, pB = `precision highp float;
uniform bool pbr_uUnlit;
#ifdef USE_IBL
uniform samplerCube u_DiffuseEnvSampler;
uniform samplerCube u_SpecularEnvSampler;
uniform sampler2D u_brdfLUT;
uniform vec2 u_ScaleIBLAmbient;
#endif
#ifdef HAS_BASECOLORMAP
uniform sampler2D u_BaseColorSampler;
#endif
#ifdef HAS_NORMALMAP
uniform sampler2D u_NormalSampler;
uniform float u_NormalScale;
#endif
#ifdef HAS_EMISSIVEMAP
uniform sampler2D u_EmissiveSampler;
uniform vec3 u_EmissiveFactor;
#endif
#ifdef HAS_METALROUGHNESSMAP
uniform sampler2D u_MetallicRoughnessSampler;
#endif
#ifdef HAS_OCCLUSIONMAP
uniform sampler2D u_OcclusionSampler;
uniform float u_OcclusionStrength;
#endif
#ifdef ALPHA_CUTOFF
uniform float u_AlphaCutoff;
#endif
uniform vec2 u_MetallicRoughnessValues;
uniform vec4 u_BaseColorFactor;
uniform vec3 u_Camera;
#ifdef PBR_DEBUG
uniform vec4 u_ScaleDiffBaseMR;
uniform vec4 u_ScaleFGDSpec;
#endif
in vec3 pbr_vPosition;
in vec2 pbr_vUV;
#ifdef HAS_NORMALS
#ifdef HAS_TANGENTS
in mat3 pbr_vTBN;
#else
in vec3 pbr_vNormal;
#endif
#endif
struct PBRInfo
{
float NdotL;
float NdotV;
float NdotH;
float LdotH;
float VdotH;
float perceptualRoughness;
float metalness;
vec3 reflectance0;
vec3 reflectance90;
float alphaRoughness;
vec3 diffuseColor;
vec3 specularColor;
vec3 n;
vec3 v;
};
const float M_PI = 3.141592653589793;
const float c_MinRoughness = 0.04;
vec4 SRGBtoLINEAR(vec4 srgbIn)
{
#ifdef MANUAL_SRGB
#ifdef SRGB_FAST_APPROXIMATION
vec3 linOut = pow(srgbIn.xyz,vec3(2.2));
#else
vec3 bLess = step(vec3(0.04045),srgbIn.xyz);
vec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );
#endif
return vec4(linOut,srgbIn.w);;
#else
return srgbIn;
#endif
}
vec3 getNormal()
{
#ifndef HAS_TANGENTS
vec3 pos_dx = dFdx(pbr_vPosition);
vec3 pos_dy = dFdy(pbr_vPosition);
vec3 tex_dx = dFdx(vec3(pbr_vUV, 0.0));
vec3 tex_dy = dFdy(vec3(pbr_vUV, 0.0));
vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);
#ifdef HAS_NORMALS
vec3 ng = normalize(pbr_vNormal);
#else
vec3 ng = cross(pos_dx, pos_dy);
#endif
t = normalize(t - ng * dot(ng, t));
vec3 b = normalize(cross(ng, t));
mat3 tbn = mat3(t, b, ng);
#else
mat3 tbn = pbr_vTBN;
#endif
#ifdef HAS_NORMALMAP
vec3 n = texture(u_NormalSampler, pbr_vUV).rgb;
n = normalize(tbn * ((2.0 * n - 1.0) * vec3(u_NormalScale, u_NormalScale, 1.0)));
#else
vec3 n = normalize(tbn[2].xyz);
#endif
return n;
}
#ifdef USE_IBL
vec3 getIBLContribution(PBRInfo pbrInputs, vec3 n, vec3 reflection)
{
float mipCount = 9.0;
float lod = (pbrInputs.perceptualRoughness * mipCount);
vec3 brdf = SRGBtoLINEAR(texture(u_brdfLUT,
vec2(pbrInputs.NdotV, 1.0 - pbrInputs.perceptualRoughness))).rgb;
vec3 diffuseLight = SRGBtoLINEAR(textureCube(u_DiffuseEnvSampler, n)).rgb;
#ifdef USE_TEX_LOD
vec3 specularLight = SRGBtoLINEAR(textureCubeLod(u_SpecularEnvSampler, reflection, lod)).rgb;
#else
vec3 specularLight = SRGBtoLINEAR(textureCube(u_SpecularEnvSampler, reflection)).rgb;
#endif
vec3 diffuse = diffuseLight * pbrInputs.diffuseColor;
vec3 specular = specularLight * (pbrInputs.specularColor * brdf.x + brdf.y);
diffuse *= u_ScaleIBLAmbient.x;
specular *= u_ScaleIBLAmbient.y;
return diffuse + specular;
}
#endif
vec3 diffuse(PBRInfo pbrInputs)
{
return pbrInputs.diffuseColor / M_PI;
}
vec3 specularReflection(PBRInfo pbrInputs)
{
return pbrInputs.reflectance0 +
(pbrInputs.reflectance90 - pbrInputs.reflectance0) *
pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);
}
float geometricOcclusion(PBRInfo pbrInputs)
{
float NdotL = pbrInputs.NdotL;
float NdotV = pbrInputs.NdotV;
float r = pbrInputs.alphaRoughness;
float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));
float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));
return attenuationL * attenuationV;
}
float microfacetDistribution(PBRInfo pbrInputs)
{
float roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;
float f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;
return roughnessSq / (M_PI * f * f);
}
void PBRInfo_setAmbientLight(inout PBRInfo pbrInputs) {
pbrInputs.NdotL = 1.0;
pbrInputs.NdotH = 0.0;
pbrInputs.LdotH = 0.0;
pbrInputs.VdotH = 1.0;
}
void PBRInfo_setDirectionalLight(inout PBRInfo pbrInputs, vec3 lightDirection) {
vec3 n = pbrInputs.n;
vec3 v = pbrInputs.v;
vec3 l = normalize(lightDirection);
vec3 h = normalize(l+v);
pbrInputs.NdotL = clamp(dot(n, l), 0.001, 1.0);
pbrInputs.NdotH = clamp(dot(n, h), 0.0, 1.0);
pbrInputs.LdotH = clamp(dot(l, h), 0.0, 1.0);
pbrInputs.VdotH = clamp(dot(v, h), 0.0, 1.0);
}
void PBRInfo_setPointLight(inout PBRInfo pbrInputs, PointLight pointLight) {
vec3 light_direction = normalize(pointLight.position - pbr_vPosition);
PBRInfo_setDirectionalLight(pbrInputs, light_direction);
}
vec3 calculateFinalColor(PBRInfo pbrInputs, vec3 lightColor) {
vec3 F = specularReflection(pbrInputs);
float G = geometricOcclusion(pbrInputs);
float D = microfacetDistribution(pbrInputs);
vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInputs);
vec3 specContrib = F * G * D / (4.0 * pbrInputs.NdotL * pbrInputs.NdotV);
return pbrInputs.NdotL * lightColor * (diffuseContrib + specContrib);
}
vec4 pbr_filterColor(vec4 colorUnused)
{
#ifdef HAS_BASECOLORMAP
vec4 baseColor = SRGBtoLINEAR(texture(u_BaseColorSampler, pbr_vUV)) * u_BaseColorFactor;
#else
vec4 baseColor = u_BaseColorFactor;
#endif
#ifdef ALPHA_CUTOFF
if (baseColor.a < u_AlphaCutoff) {
discard;
}
#endif
vec3 color = vec3(0, 0, 0);
if(pbr_uUnlit){
color.rgb = baseColor.rgb;
}
else{
float perceptualRoughness = u_MetallicRoughnessValues.y;
float metallic = u_MetallicRoughnessValues.x;
#ifdef HAS_METALROUGHNESSMAP
vec4 mrSample = texture(u_MetallicRoughnessSampler, pbr_vUV);
perceptualRoughness = mrSample.g * perceptualRoughness;
metallic = mrSample.b * metallic;
#endif
perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);
metallic = clamp(metallic, 0.0, 1.0);
float alphaRoughness = perceptualRoughness * perceptualRoughness;
vec3 f0 = vec3(0.04);
vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);
diffuseColor *= 1.0 - metallic;
vec3 specularColor = mix(f0, baseColor.rgb, metallic);
float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);
float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);
vec3 specularEnvironmentR0 = specularColor.rgb;
vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;
vec3 n = getNormal();
vec3 v = normalize(u_Camera - pbr_vPosition);
float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);
vec3 reflection = -normalize(reflect(v, n));
PBRInfo pbrInputs = PBRInfo(
0.0,
NdotV,
0.0,
0.0,
0.0,
perceptualRoughness,
metallic,
specularEnvironmentR0,
specularEnvironmentR90,
alphaRoughness,
diffuseColor,
specularColor,
n,
v
);
#ifdef USE_LIGHTS
PBRInfo_setAmbientLight(pbrInputs);
color += calculateFinalColor(pbrInputs, lighting_uAmbientLight.color);
for(int i = 0; i < lighting_uDirectionalLightCount; i++) {
if (i < lighting_uDirectionalLightCount) {
PBRInfo_setDirectionalLight(pbrInputs, lighting_uDirectionalLight[i].direction);
color += calculateFinalColor(pbrInputs, lighting_uDirectionalLight[i].color);
}
}
for(int i = 0; i < lighting_uPointLightCount; i++) {
if (i < lighting_uPointLightCount) {
PBRInfo_setPointLight(pbrInputs, lighting_uPointLight[i]);
float attenuation = getPointLightAttenuation(lighting_uPointLight[i], distance(lighting_uPointLight[i].position, pbr_vPosition));
color += calculateFinalColor(pbrInputs, lighting_uPointLight[i].color / attenuation);
}
}
#endif
#ifdef USE_IBL
color += getIBLContribution(pbrInputs, n, reflection);
#endif
#ifdef HAS_OCCLUSIONMAP
float ao = texture(u_OcclusionSampler, pbr_vUV).r;
color = mix(color, color * ao, u_OcclusionStrength);
#endif
#ifdef HAS_EMISSIVEMAP
vec3 emissive = SRGBtoLINEAR(texture(u_EmissiveSampler, pbr_vUV)).rgb * u_EmissiveFactor;
color += emissive;
#endif
#ifdef PBR_DEBUG
color = mix(color, baseColor.rgb, u_ScaleDiffBaseMR.y);
color = mix(color, vec3(metallic), u_ScaleDiffBaseMR.z);
color = mix(color, vec3(perceptualRoughness), u_ScaleDiffBaseMR.w);
#endif
}
return vec4(pow(color,vec3(1.0/2.2)), baseColor.a);
}
`, wy = {
  name: "pbr",
  vs: fB,
  fs: pB,
  defines: {
    LIGHTING_FRAGMENT: 1
  },
  dependencies: [xy]
}, bT = "#define SMOOTH_EDGE_RADIUS 0.5", _B = `
${bT}

struct VertexGeometry {
  vec4 position;
  vec3 worldPosition;
  vec3 worldPositionAlt;
  vec3 normal;
  vec2 uv;
  vec3 pickingColor;
} geometry = VertexGeometry(
  vec4(0.0, 0.0, 1.0, 0.0),
  vec3(0.0),
  vec3(0.0),
  vec3(0.0),
  vec2(0.0),
  vec3(0.0)
);
`, gB = `
${bT}

struct FragmentGeometry {
  vec2 uv;
} geometry;

float smoothedge(float edge, float x) {
  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);
}
`, mB = { name: "geometry", vs: _B, fs: gB }, Xt = {
  /**
   * `LNGLAT` if rendering into a geospatial viewport, `CARTESIAN` otherwise
   */
  DEFAULT: -1,
  /**
   * Positions are interpreted as [longitude, latitude, elevation]
   * longitude/latitude are in degrees, elevation is in meters.
   * Dimensions are in meters.
   */
  LNGLAT: 1,
  /**
   * Positions are interpreted as [x, y, z] in meter offsets from the coordinate origin.
   * Dimensions are in meters.
   */
  METER_OFFSETS: 2,
  /**
   * Positions are interpreted as [deltaLng, deltaLat, elevation] from the coordinate origin.
   * deltaLng/deltaLat are in degrees, elevation is in meters.
   * Dimensions are in meters.
   */
  LNGLAT_OFFSETS: 3,
  /**
   * Positions and dimensions are in the common units of the viewport.
   */
  CARTESIAN: 0
};
Object.defineProperty(Xt, "IDENTITY", {
  get: () => (Jt.deprecated("COORDINATE_SYSTEM.IDENTITY", "COORDINATE_SYSTEM.CARTESIAN")(), 0)
});
const ao = {
  /**
   * Render geospatial data in Web Mercator projection
   */
  WEB_MERCATOR: 1,
  /**
   * Render geospatial data as a 3D globe
   */
  GLOBE: 2,
  /**
   * (Internal use only) Web Mercator projection at high zoom
   */
  WEB_MERCATOR_AUTO_OFFSET: 4,
  /**
   * No transformation
   */
  IDENTITY: 0
}, bm = {
  common: 0,
  meters: 1,
  pixels: 2
}, vm = {
  click: { handler: "onClick" },
  panstart: { handler: "onDragStart" },
  panmove: { handler: "onDrag" },
  panend: { handler: "onDragEnd" }
}, yB = Object.keys(Xt).map((t) => `const int COORDINATE_SYSTEM_${t} = ${Xt[t]};`).join(""), bB = Object.keys(ao).map((t) => `const int PROJECTION_MODE_${t} = ${ao[t]};`).join(""), vB = Object.keys(bm).map((t) => `const int UNIT_${t.toUpperCase()} = ${bm[t]};`).join(""), xB = `${yB}
${bB}
${vB}
uniform int project_uCoordinateSystem;
uniform int project_uProjectionMode;
uniform float project_uScale;
uniform bool project_uWrapLongitude;
uniform vec3 project_uCommonUnitsPerMeter;
uniform vec3 project_uCommonUnitsPerWorldUnit;
uniform vec3 project_uCommonUnitsPerWorldUnit2;
uniform vec4 project_uCenter;
uniform mat4 project_uModelMatrix;
uniform mat4 project_uViewProjectionMatrix;
uniform vec2 project_uViewportSize;
uniform float project_uDevicePixelRatio;
uniform float project_uFocalDistance;
uniform vec3 project_uCameraPosition;
uniform vec3 project_uCoordinateOrigin;
uniform vec3 project_uCommonOrigin;
uniform bool project_uPseudoMeters;
const float TILE_SIZE = 512.0;
const float PI = 3.1415926536;
const float WORLD_SCALE = TILE_SIZE / (PI * 2.0);
const vec3 ZERO_64_LOW = vec3(0.0);
const float EARTH_RADIUS = 6370972.0;
const float GLOBE_RADIUS = 256.0;
float project_size_at_latitude(float lat) {
float y = clamp(lat, -89.9, 89.9);
return 1.0 / cos(radians(y));
}
float project_size() {
if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR &&
project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT &&
project_uPseudoMeters == false) {
if (geometry.position.w == 0.0) {
return project_size_at_latitude(geometry.worldPosition.y);
}
float y = geometry.position.y / TILE_SIZE * 2.0 - 1.0;
float y2 = y * y;
float y4 = y2 * y2;
float y6 = y4 * y2;
return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;
}
return 1.0;
}
float project_size_at_latitude(float meters, float lat) {
return meters * project_uCommonUnitsPerMeter.z * project_size_at_latitude(lat);
}
float project_size(float meters) {
return meters * project_uCommonUnitsPerMeter.z * project_size();
}
vec2 project_size(vec2 meters) {
return meters * project_uCommonUnitsPerMeter.xy * project_size();
}
vec3 project_size(vec3 meters) {
return meters * project_uCommonUnitsPerMeter * project_size();
}
vec4 project_size(vec4 meters) {
return vec4(meters.xyz * project_uCommonUnitsPerMeter, meters.w);
}
mat3 project_get_orientation_matrix(vec3 up) {
vec3 uz = normalize(up);
vec3 ux = abs(uz.z) == 1.0 ? vec3(1.0, 0.0, 0.0) : normalize(vec3(uz.y, -uz.x, 0));
vec3 uy = cross(uz, ux);
return mat3(ux, uy, uz);
}
bool project_needs_rotation(vec3 commonPosition, out mat3 transform) {
if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {
transform = project_get_orientation_matrix(commonPosition);
return true;
}
return false;
}
vec3 project_normal(vec3 vector) {
vec4 normal_modelspace = project_uModelMatrix * vec4(vector, 0.0);
vec3 n = normalize(normal_modelspace.xyz * project_uCommonUnitsPerMeter);
mat3 rotation;
if (project_needs_rotation(geometry.position.xyz, rotation)) {
n = rotation * n;
}
return n;
}
vec4 project_offset_(vec4 offset) {
float dy = offset.y;
vec3 commonUnitsPerWorldUnit = project_uCommonUnitsPerWorldUnit + project_uCommonUnitsPerWorldUnit2 * dy;
return vec4(offset.xyz * commonUnitsPerWorldUnit, offset.w);
}
vec2 project_mercator_(vec2 lnglat) {
float x = lnglat.x;
if (project_uWrapLongitude) {
x = mod(x + 180., 360.0) - 180.;
}
float y = clamp(lnglat.y, -89.9, 89.9);
return vec2(
radians(x) + PI,
PI + log(tan_fp32(PI * 0.25 + radians(y) * 0.5))
) * WORLD_SCALE;
}
vec3 project_globe_(vec3 lnglatz) {
float lambda = radians(lnglatz.x);
float phi = radians(lnglatz.y);
float cosPhi = cos(phi);
float D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;
return vec3(
sin(lambda) * cosPhi,
-cos(lambda) * cosPhi,
sin(phi)
) * D;
}
vec4 project_position(vec4 position, vec3 position64Low) {
vec4 position_world = project_uModelMatrix * position;
if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR) {
if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
return vec4(
project_mercator_(position_world.xy),
project_size_at_latitude(position_world.z, position_world.y),
position_world.w
);
}
if (project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {
position_world.xyz += project_uCoordinateOrigin;
}
}
if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {
if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
return vec4(
project_globe_(position_world.xyz),
position_world.w
);
}
}
if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
if (abs(position_world.y - project_uCoordinateOrigin.y) > 0.25) {
return vec4(
project_mercator_(position_world.xy) - project_uCommonOrigin.xy,
project_size(position_world.z),
position_world.w
);
}
}
}
if (project_uProjectionMode == PROJECTION_MODE_IDENTITY ||
(project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&
(project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {
position_world.xyz -= project_uCoordinateOrigin;
}
return project_offset_(position_world) + project_offset_(project_uModelMatrix * vec4(position64Low, 0.0));
}
vec4 project_position(vec4 position) {
return project_position(position, ZERO_64_LOW);
}
vec3 project_position(vec3 position, vec3 position64Low) {
vec4 projected_position = project_position(vec4(position, 1.0), position64Low);
return projected_position.xyz;
}
vec3 project_position(vec3 position) {
vec4 projected_position = project_position(vec4(position, 1.0), ZERO_64_LOW);
return projected_position.xyz;
}
vec2 project_position(vec2 position) {
vec4 projected_position = project_position(vec4(position, 0.0, 1.0), ZERO_64_LOW);
return projected_position.xy;
}
vec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {
return viewProjectionMatrix * position + center;
}
vec4 project_common_position_to_clipspace(vec4 position) {
return project_common_position_to_clipspace(position, project_uViewProjectionMatrix, project_uCenter);
}
vec2 project_pixel_size_to_clipspace(vec2 pixels) {
vec2 offset = pixels / project_uViewportSize * project_uDevicePixelRatio * 2.0;
return offset * project_uFocalDistance;
}
float project_size_to_pixel(float meters) {
return project_size(meters) * project_uScale;
}
float project_size_to_pixel(float size, int unit) {
if (unit == UNIT_METERS) return project_size_to_pixel(size);
if (unit == UNIT_COMMON) return size * project_uScale;
return size;
}
float project_pixel_size(float pixels) {
return pixels / project_uScale;
}
vec2 project_pixel_size(vec2 pixels) {
return pixels / project_uScale;
}
`;
function wB(t, e) {
  if (t === e)
    return !0;
  if (Array.isArray(t)) {
    const i = t.length;
    if (!e || e.length !== i)
      return !1;
    for (let s = 0; s < i; s++)
      if (t[s] !== e[s])
        return !1;
    return !0;
  }
  return !1;
}
function ld(t) {
  let e = {}, i;
  return (s) => {
    for (const o in s)
      if (!wB(s[o], e[o])) {
        i = t(s), e = s;
        break;
      }
    return i;
  };
}
const Uv = [0, 0, 0, 0], TB = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], vT = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], AB = [0, 0, 0], xT = [0, 0, 0], EB = ld(IB);
function wT(t, e, i = xT) {
  i.length < 3 && (i = [i[0], i[1], 0]);
  let s = i, o, u = !0;
  switch (e === Xt.LNGLAT_OFFSETS || e === Xt.METER_OFFSETS ? o = i : o = t.isGeospatial ? (
    // @ts-expect-error longitude and latitude are not defined on the base Viewport, but is expected on geospatial viewports
    [Math.fround(t.longitude), Math.fround(t.latitude), 0]
  ) : null, t.projectionMode) {
    case ao.WEB_MERCATOR:
      (e === Xt.LNGLAT || e === Xt.CARTESIAN) && (o = [0, 0, 0], u = !1);
      break;
    case ao.WEB_MERCATOR_AUTO_OFFSET:
      e === Xt.LNGLAT ? s = o : e === Xt.CARTESIAN && (s = [
        Math.fround(t.center[0]),
        Math.fround(t.center[1]),
        0
      ], o = t.unprojectPosition(s), s[0] -= i[0], s[1] -= i[1], s[2] -= i[2]);
      break;
    case ao.IDENTITY:
      s = t.position.map(Math.fround), s[2] = s[2] || 0;
      break;
    case ao.GLOBE:
      u = !1, o = null;
      break;
    default:
      u = !1;
  }
  return { geospatialOrigin: o, shaderCoordinateOrigin: s, offsetMode: u };
}
function SB(t, e, i) {
  const { viewMatrixUncentered: s, projectionMatrix: o } = t;
  let { viewMatrix: u, viewProjectionMatrix: d } = t, a = Uv, w = Uv, S = t.cameraPosition;
  const { geospatialOrigin: M, shaderCoordinateOrigin: F, offsetMode: N } = wT(t, e, i);
  return N && (w = t.projectPosition(M || F), S = [
    S[0] - w[0],
    S[1] - w[1],
    S[2] - w[2]
  ], w[3] = 1, a = ad([], w, d), u = s || u, d = Sl([], o, u), d = Sl([], d, TB)), {
    viewMatrix: u,
    viewProjectionMatrix: d,
    projectionCenter: a,
    originCommon: w,
    cameraPosCommon: S,
    shaderCoordinateOrigin: F,
    geospatialOrigin: M
  };
}
function CB({
  viewport: t,
  devicePixelRatio: e = 1,
  modelMatrix: i = null,
  // Match Layer.defaultProps
  coordinateSystem: s = Xt.DEFAULT,
  coordinateOrigin: o = xT,
  autoWrapLongitude: u = !1
}) {
  s === Xt.DEFAULT && (s = t.isGeospatial ? Xt.LNGLAT : Xt.CARTESIAN);
  const d = EB({
    viewport: t,
    devicePixelRatio: e,
    coordinateSystem: s,
    coordinateOrigin: o
  });
  return d.project_uWrapLongitude = u, d.project_uModelMatrix = i || vT, d;
}
function IB({ viewport: t, devicePixelRatio: e, coordinateSystem: i, coordinateOrigin: s }) {
  const { projectionCenter: o, viewProjectionMatrix: u, originCommon: d, cameraPosCommon: a, shaderCoordinateOrigin: w, geospatialOrigin: S } = SB(t, i, s), M = t.getDistanceScales(), F = [
    t.width * e,
    t.height * e
  ], N = ad([], [0, 0, -t.focalDistance, 1], t.projectionMatrix)[3] || 1, L = {
    // Projection mode values
    project_uCoordinateSystem: i,
    project_uProjectionMode: t.projectionMode,
    project_uCoordinateOrigin: w,
    project_uCommonOrigin: d.slice(0, 3),
    project_uCenter: o,
    // Backward compatibility
    // TODO: remove in v9
    // @ts-expect-error _pseudoMeters is only defined on WebMercator viewport
    project_uPseudoMeters: !!t._pseudoMeters,
    // Screen size
    project_uViewportSize: F,
    project_uDevicePixelRatio: e,
    project_uFocalDistance: N,
    project_uCommonUnitsPerMeter: M.unitsPerMeter,
    project_uCommonUnitsPerWorldUnit: M.unitsPerMeter,
    project_uCommonUnitsPerWorldUnit2: AB,
    project_uScale: t.scale,
    // This is the mercator scale (2 ** zoom)
    project_uWrapLongitude: !1,
    project_uViewProjectionMatrix: u,
    project_uModelMatrix: vT,
    // This is for lighting calculations
    project_uCameraPosition: a
  };
  if (S) {
    const re = t.getDistanceScales(S);
    switch (i) {
      case Xt.METER_OFFSETS:
        L.project_uCommonUnitsPerWorldUnit = re.unitsPerMeter, L.project_uCommonUnitsPerWorldUnit2 = re.unitsPerMeter2;
        break;
      case Xt.LNGLAT:
      case Xt.LNGLAT_OFFSETS:
        t._pseudoMeters || (L.project_uCommonUnitsPerMeter = re.unitsPerMeter), L.project_uCommonUnitsPerWorldUnit = re.unitsPerDegree, L.project_uCommonUnitsPerWorldUnit2 = re.unitsPerDegree2;
        break;
      // a.k.a "preprojected" positions
      case Xt.CARTESIAN:
        L.project_uCommonUnitsPerWorldUnit = [1, 1, re.unitsPerMeter[2]], L.project_uCommonUnitsPerWorldUnit2 = [
          0,
          0,
          re.unitsPerMeter2[2]
        ];
        break;
    }
  }
  return L;
}
const MB = {};
function RB(t = MB) {
  return "viewport" in t ? CB(t) : {};
}
const Ty = {
  name: "project",
  dependencies: [AP, mB],
  vs: xB,
  getUniforms: RB
}, PB = `
vec4 project_position_to_clipspace(
  vec3 position, vec3 position64Low, vec3 offset, out vec4 commonPosition
) {
  vec3 projectedPosition = project_position(position, position64Low);
  mat3 rotation;
  if (project_needs_rotation(projectedPosition, rotation)) {
    // offset is specified as ENU
    // when in globe projection, rotate offset so that the ground alighs with the surface of the globe
    offset = rotation * offset;
  }
  commonPosition = vec4(projectedPosition + offset, 1.0);
  return project_common_position_to_clipspace(commonPosition);
}

vec4 project_position_to_clipspace(
  vec3 position, vec3 position64Low, vec3 offset
) {
  vec4 commonPosition;
  return project_position_to_clipspace(position, position64Low, offset, commonPosition);
}
`, Ay = {
  name: "project32",
  dependencies: [Ty],
  vs: PB
};
function BB() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function Qc(t, e) {
  const i = ad([], e, t);
  return uT(i, i, 1 / i[3]), i;
}
function zv(t, e) {
  const i = t % e;
  return i < 0 ? e + i : i;
}
function xm(t, e, i) {
  return t < e ? e : t > i ? i : t;
}
function DB(t) {
  return Math.log(t) * Math.LOG2E;
}
const Ey = Math.log2 || DB;
function No(t, e) {
  if (!t)
    throw new Error(e || "@math.gl/web-mercator: assertion failed.");
}
const Rn = Math.PI, TT = Rn / 4, fn = Rn / 180, wm = 180 / Rn, ah = 512, pp = 4003e4, Pf = 85.051129, OB = 1.5;
function FB(t) {
  return Ey(t);
}
function Zu(t) {
  const [e, i] = t;
  No(Number.isFinite(e)), No(Number.isFinite(i) && i >= -90 && i <= 90, "invalid latitude");
  const s = e * fn, o = i * fn, u = ah * (s + Rn) / (2 * Rn), d = ah * (Rn + Math.log(Math.tan(TT + o * 0.5))) / (2 * Rn);
  return [u, d];
}
function lh(t) {
  const [e, i] = t, s = e / ah * (2 * Rn) - Rn, o = 2 * (Math.atan(Math.exp(i / ah * (2 * Rn) - Rn)) - TT);
  return [s * wm, o * wm];
}
function kB(t) {
  const { latitude: e } = t;
  No(Number.isFinite(e));
  const i = Math.cos(e * fn);
  return FB(pp * i) - 9;
}
function ep(t) {
  const e = Math.cos(t * fn);
  return ah / pp / e;
}
function Tm(t) {
  const { latitude: e, longitude: i, highPrecision: s = !1 } = t;
  No(Number.isFinite(e) && Number.isFinite(i));
  const o = ah, u = Math.cos(e * fn), d = o / 360, a = d / u, w = o / pp / u, S = {
    unitsPerMeter: [w, w, w],
    metersPerUnit: [1 / w, 1 / w, 1 / w],
    unitsPerDegree: [d, a, w],
    degreesPerUnit: [1 / d, 1 / a, 1 / w]
  };
  if (s) {
    const M = fn * Math.tan(e * fn) / u, F = d * M / 2, N = o / pp * M, L = N / a * w;
    S.unitsPerDegree2 = [0, F, N], S.unitsPerMeter2 = [L, 0, L];
  }
  return S;
}
function AT(t, e) {
  const [i, s, o] = t, [u, d, a] = e, { unitsPerMeter: w, unitsPerMeter2: S } = Tm({
    longitude: i,
    latitude: s,
    highPrecision: !0
  }), M = Zu(t);
  M[0] += u * (w[0] + S[0] * d), M[1] += d * (w[1] + S[1] * d);
  const F = lh(M), N = (o || 0) + (a || 0);
  return Number.isFinite(o) || Number.isFinite(a) ? [F[0], F[1], N] : F;
}
function NB(t) {
  const {
    // Viewport props
    height: e,
    pitch: i,
    bearing: s,
    altitude: o,
    // Pre-calculated parameters
    scale: u,
    center: d
  } = t, a = BB();
  fp(a, a, [0, 0, -o]), cT(a, a, -i * fn), hT(a, a, s * fn);
  const w = u / e;
  return vy(a, a, [w, w, w]), d && fp(a, a, JP([], d)), a;
}
function LB(t) {
  const { width: e, height: i, altitude: s, pitch: o = 0, offset: u, center: d, scale: a, nearZMultiplier: w = 1, farZMultiplier: S = 1 } = t;
  let { fovy: M = _p(OB) } = t;
  s !== void 0 && (M = _p(s));
  const F = M * fn, N = o * fn, L = ET(M);
  let re = L;
  d && (re += d[2] * a / Math.cos(N) / i);
  const ne = F * (0.5 + (u ? u[1] : 0) / i), we = Math.sin(ne) * re / Math.sin(xm(Math.PI / 2 - N - ne, 0.01, Math.PI - 0.01)), Se = Math.sin(N) * we + re, Ee = re * 10, Ce = Math.min(Se * S, Ee);
  return {
    fov: F,
    aspect: e / i,
    focalDistance: L,
    near: w,
    far: Ce
  };
}
function _p(t) {
  return 2 * Math.atan(0.5 / t) * wm;
}
function ET(t) {
  return 0.5 / Math.tan(0.5 * t * fn);
}
function ST(t, e) {
  const [i, s, o = 0] = t;
  return No(Number.isFinite(i) && Number.isFinite(s) && Number.isFinite(o)), Qc(e, [i, s, o, 1]);
}
function Sy(t, e, i = 0) {
  const [s, o, u] = t;
  if (No(Number.isFinite(s) && Number.isFinite(o), "invalid pixel coordinate"), Number.isFinite(u))
    return Qc(e, [s, o, u, 1]);
  const d = Qc(e, [s, o, 0, 1]), a = Qc(e, [s, o, 1, 1]), w = d[2], S = a[2], M = w === S ? 0 : ((i || 0) - w) / (S - w);
  return Jw([], d, a, M);
}
function UB(t) {
  const {
    width: e,
    height: i,
    bounds: s,
    minExtent: o = 0,
    // 0.01 would be about 1000 meters (degree is ~110KM)
    maxZoom: u = 24,
    // ~x4,000,000 => About 10 meter extents
    offset: d = [0, 0]
  } = t, [[a, w], [S, M]] = s, F = zB(t.padding), N = Zu([a, xm(M, -Pf, Pf)]), L = Zu([S, xm(w, -Pf, Pf)]), re = [
    Math.max(Math.abs(L[0] - N[0]), o),
    Math.max(Math.abs(L[1] - N[1]), o)
  ], ne = [
    e - F.left - F.right - Math.abs(d[0]) * 2,
    i - F.top - F.bottom - Math.abs(d[1]) * 2
  ];
  No(ne[0] > 0 && ne[1] > 0);
  const we = ne[0] / re[0], Se = ne[1] / re[1], Ee = (F.right - F.left) / 2 / we, Ce = (F.top - F.bottom) / 2 / Se, Le = [(L[0] + N[0]) / 2 + Ee, (L[1] + N[1]) / 2 + Ce], Ze = lh(Le), Ke = Math.min(u, Ey(Math.abs(Math.min(we, Se))));
  return No(Number.isFinite(Ke)), {
    longitude: Ze[0],
    latitude: Ze[1],
    zoom: Ke
  };
}
function zB(t = 0) {
  return typeof t == "number" ? {
    top: t,
    bottom: t,
    left: t,
    right: t
  } : (No(Number.isFinite(t.top) && Number.isFinite(t.bottom) && Number.isFinite(t.left) && Number.isFinite(t.right)), t);
}
const Vv = Math.PI / 180;
function VB(t, e = 0) {
  const { width: i, height: s, unproject: o } = t, u = { targetZ: e }, d = o([0, s], u), a = o([i, s], u);
  let w, S;
  const M = t.fovy ? 0.5 * t.fovy * Vv : Math.atan(0.5 / t.altitude), F = (90 - t.pitch) * Vv;
  return M > F - 0.01 ? (w = jv(t, 0, e), S = jv(t, i, e)) : (w = o([0, 0], u), S = o([i, 0], u)), [d, a, S, w];
}
function jv(t, e, i) {
  const { pixelUnprojectionMatrix: s } = t, o = Qc(s, [e, 0, 1, 1]), u = Qc(s, [e, t.height, 1, 1]), a = (i * t.distanceScales.unitsPerMeter[2] - o[2]) / (u[2] - o[2]), w = Jw([], o, u, a), S = lh(w);
  return S.push(i), S;
}
const Hv = 512;
function jB(t) {
  const { width: e, height: i, pitch: s = 0 } = t;
  let { longitude: o, latitude: u, zoom: d, bearing: a = 0 } = t;
  (o < -180 || o > 180) && (o = zv(o + 180, 360) - 180), (a < -180 || a > 180) && (a = zv(a + 180, 360) - 180);
  const w = Ey(i / Hv);
  if (d <= w)
    d = w, u = 0;
  else {
    const S = i / 2 / Math.pow(2, d), M = lh([0, S])[1];
    if (u < M)
      u = M;
    else {
      const F = lh([0, Hv - S])[1];
      u > F && (u = F);
    }
  }
  return { width: e, height: i, longitude: o, latitude: u, zoom: d, pitch: s, bearing: a };
}
const HB = `
const int max_lights = 2;
uniform mat4 shadow_uViewProjectionMatrices[max_lights];
uniform vec4 shadow_uProjectCenters[max_lights];
uniform bool shadow_uDrawShadowMap;
uniform bool shadow_uUseShadowMap;
uniform int shadow_uLightId;
uniform float shadow_uLightCount;

out vec3 shadow_vPosition[max_lights];

vec4 shadow_setVertexPosition(vec4 position_commonspace) {
  if (shadow_uDrawShadowMap) {
    return project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[shadow_uLightId], shadow_uProjectCenters[shadow_uLightId]);
  }
  if (shadow_uUseShadowMap) {
    for (int i = 0; i < max_lights; i++) {
      if(i < int(shadow_uLightCount)) {
        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[i], shadow_uProjectCenters[i]);
        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;
      }
    }
  }
  return gl_Position;
}
`, $B = `
const int max_lights = 2;
uniform bool shadow_uDrawShadowMap;
uniform bool shadow_uUseShadowMap;
uniform sampler2D shadow_uShadowMap0;
uniform sampler2D shadow_uShadowMap1;
uniform vec4 shadow_uColor;
uniform float shadow_uLightCount;

in vec3 shadow_vPosition[max_lights];

const vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);
const vec4 bitUnpackShift = 1.0 / bitPackShift;
const vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);

float shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {
  vec4 rgbaDepth = texture(shadowMap, position.xy);

  float z = dot(rgbaDepth, bitUnpackShift);
  return smoothstep(0.001, 0.01, position.z - z);
}

vec4 shadow_filterShadowColor(vec4 color) {
  if (shadow_uDrawShadowMap) {
    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);
    rgbaDepth -= rgbaDepth.gbaa * bitMask;
    return rgbaDepth;
  }
  if (shadow_uUseShadowMap) {
    float shadowAlpha = 0.0;
    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);
    if(shadow_uLightCount > 1.0) {
      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);
    }
    shadowAlpha *= shadow_uColor.a / shadow_uLightCount;
    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);

    return vec4(
      mix(color.rgb, shadow_uColor.rgb, shadowAlpha / blendedAlpha),
      blendedAlpha
    );
  }
  return color;
}
`, GB = ld(KB), WB = ld(YB), XB = [0, 0, 0, 1], qB = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
function ZB(t, e) {
  const [i, s, o] = t, u = Sy([i, s, o], e);
  return Number.isFinite(o) ? u : [u[0], u[1], 0];
}
function KB({ viewport: t, center: e }) {
  return new Gt(t.viewProjectionMatrix).invert().transform(e);
}
function YB({ viewport: t, shadowMatrices: e }) {
  const i = [], s = t.pixelUnprojectionMatrix, o = t.isGeospatial ? void 0 : 1, u = [
    [0, 0, o],
    // top left ground
    [t.width, 0, o],
    // top right ground
    [0, t.height, o],
    // bottom left ground
    [t.width, t.height, o],
    // bottom right ground
    [0, 0, -1],
    // top left near
    [t.width, 0, -1],
    // top right near
    [0, t.height, -1],
    // bottom left near
    [t.width, t.height, -1]
    // bottom right near
  ].map((d) => (
    // @ts-expect-error z may be undefined
    ZB(d, s)
  ));
  for (const d of e) {
    const a = d.clone().translate(new Be(t.center).negate()), w = u.map((M) => a.transform(M)), S = new Gt().ortho({
      left: Math.min(...w.map((M) => M[0])),
      right: Math.max(...w.map((M) => M[0])),
      bottom: Math.min(...w.map((M) => M[1])),
      top: Math.max(...w.map((M) => M[1])),
      near: Math.min(...w.map((M) => -M[2])),
      far: Math.max(...w.map((M) => -M[2]))
    });
    i.push(S.multiplyRight(d));
  }
  return i;
}
function JB(t, e) {
  const { shadowEnabled: i = !0 } = t;
  if (!i || !t.shadowMatrices || !t.shadowMatrices.length)
    return {
      shadow_uDrawShadowMap: !1,
      shadow_uUseShadowMap: !1,
      shadow_uShadowMap0: t.dummyShadowMap,
      shadow_uShadowMap1: t.dummyShadowMap
    };
  const s = {
    shadow_uDrawShadowMap: !!t.drawToShadowMap,
    shadow_uUseShadowMap: t.shadowMaps ? t.shadowMaps.length > 0 : !1,
    shadow_uColor: t.shadowColor || XB,
    shadow_uLightId: t.shadowLightId || 0,
    shadow_uLightCount: t.shadowMatrices.length
  }, o = GB({
    viewport: t.viewport,
    center: e.project_uCenter
  }), u = [], d = WB({
    shadowMatrices: t.shadowMatrices,
    viewport: t.viewport
  }).slice();
  for (let a = 0; a < t.shadowMatrices.length; a++) {
    const w = d[a], S = w.clone().translate(new Be(t.viewport.center).negate());
    e.project_uCoordinateSystem === Xt.LNGLAT && e.project_uProjectionMode === ao.WEB_MERCATOR ? (d[a] = S, u[a] = o) : (d[a] = w.clone().multiplyRight(qB), u[a] = S.transform(o));
  }
  for (let a = 0; a < d.length; a++)
    s[`shadow_uViewProjectionMatrices[${a}]`] = d[a], s[`shadow_uProjectCenters[${a}]`] = u[a];
  for (let a = 0; a < 2; a++)
    s[`shadow_uShadowMap${a}`] = t.shadowMaps && t.shadowMaps[a] || t.dummyShadowMap;
  return s;
}
const $v = {
  name: "shadow",
  dependencies: [Ty],
  vs: HB,
  fs: $B,
  inject: {
    "vs:DECKGL_FILTER_GL_POSITION": `
    position = shadow_setVertexPosition(geometry.position);
    `,
    "fs:DECKGL_FILTER_COLOR": `
    color = shadow_filterShadowColor(color);
    `
  },
  // @ts-expect-error stricter luma gl types
  getUniforms: (t = {}, e = {}) => "viewport" in t && (t.drawToShadowMap || t.shadowMaps && t.shadowMaps.length > 0) ? JB(t, e) : {}
}, Cy = {
  ...Rv,
  defaultUniforms: { ...Rv.defaultUniforms, useFloatColors: !1 },
  inject: {
    "vs:DECKGL_FILTER_GL_POSITION": `
    // for picking depth values
    picking_setPickingAttribute(position.z / position.w);
  `,
    "vs:DECKGL_FILTER_COLOR": `
  picking_setPickingColor(geometry.pickingColor);
  `,
    "fs:DECKGL_FILTER_COLOR": {
      order: 99,
      injection: `
  // use highlight color if this fragment belongs to the selected object.
  color = picking_filterHighlightColor(color);

  // use picking color if rendering to picking FBO.
  color = picking_filterPickingColor(color);
    `
    }
  }
}, QB = [Ty], eD = [
  "vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)",
  "vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)",
  "vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)",
  "fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)"
];
function tD() {
  const t = wl.getDefaultShaderAssembler();
  for (const e of QB)
    t.addDefaultModule(e);
  for (const e of eD)
    t.addShaderHook(e);
  return t;
}
const iD = [255, 255, 255], rD = 1;
let sD = 0;
class nD {
  constructor(e = {}) {
    this.type = "ambient";
    const { color: i = iD } = e, { intensity: s = rD } = e;
    this.id = e.id || `ambient-${sD++}`, this.color = i, this.intensity = s;
  }
}
const oD = [255, 255, 255], aD = 1, lD = [0, 0, -1];
let cD = 0;
class Gv {
  constructor(e = {}) {
    this.type = "directional";
    const { color: i = oD } = e, { intensity: s = aD } = e, { direction: o = lD } = e, { _shadow: u = !1 } = e;
    this.id = e.id || `directional-${cD++}`, this.color = i, this.intensity = s, this.type = "directional", this.direction = new Be(o).normalize().toArray(), this.shadow = u;
  }
  getProjectedLight(e) {
    return this;
  }
}
class hD {
  /** Create a new Pass instance */
  constructor(e, i = { id: "pass" }) {
    const { id: s } = i;
    this.id = s, this.device = e, this.props = { ...i };
  }
  setProps(e) {
    Object.assign(this.props, e);
  }
  render(e) {
  }
  // eslint-disable-line @typescript-eslint/no-empty-function
  cleanup() {
  }
  // eslint-disable-line @typescript-eslint/no-empty-function
}
class Iy extends hD {
  constructor() {
    super(...arguments), this._lastRenderIndex = -1;
  }
  render(e) {
    const [i, s] = this.device.canvasContext.getDrawingBufferSize(), o = e.clearCanvas ?? !0, u = e.clearColor ?? (o ? [0, 0, 0, 0] : !1), d = o ? 1 : !1, a = o ? 0 : !1, w = e.colorMask ?? 15, S = { viewport: [0, 0, i, s] };
    e.colorMask && (S.colorMask = w), e.scissorRect && (S.scissorRect = e.scissorRect);
    const M = this.device.beginRenderPass({
      framebuffer: e.target,
      parameters: S,
      clearColor: u,
      clearDepth: d,
      clearStencil: a
    });
    try {
      return this._drawLayers(M, e);
    } finally {
      M.end();
    }
  }
  /** Draw a list of layers in a list of viewports */
  _drawLayers(e, i) {
    const { target: s, moduleParameters: o, viewports: u, views: d, onViewportActive: a, clearStack: w = !0 } = i;
    i.pass = i.pass || "unknown", w && (this._lastRenderIndex = -1);
    const S = [];
    for (const M of u) {
      const F = d && d[M.id];
      a?.(M);
      const N = this._getDrawLayerParams(M, i), L = M.subViewports || [M];
      for (const re of L) {
        const ne = this._drawLayersInViewport(e, {
          target: s,
          moduleParameters: o,
          viewport: re,
          view: F,
          pass: i.pass,
          layers: i.layers
        }, N);
        S.push(ne);
      }
    }
    return S;
  }
  // When a viewport contains multiple subviewports (e.g. repeated web mercator map),
  // this is only done once for the parent viewport
  /* Resolve the parameters needed to draw each layer */
  _getDrawLayerParams(e, { layers: i, pass: s, isPicking: o = !1, layerFilter: u, cullRect: d, effects: a, moduleParameters: w }, S = !1) {
    const M = [], F = CT(this._lastRenderIndex + 1), N = {
      layer: i[0],
      viewport: e,
      isPicking: o,
      renderPass: s,
      cullRect: d
    }, L = {};
    for (let re = 0; re < i.length; re++) {
      const ne = i[re], we = this._shouldDrawLayer(ne, N, u, L), Se = {
        shouldDrawLayer: we
      };
      we && !S && (Se.layerRenderIndex = F(ne, we), Se.moduleParameters = this._getModuleParameters(ne, a, s, w), Se.layerParameters = {
        ...ne.context.deck?.props.parameters,
        ...this.getLayerParameters(ne, re, e)
      }), M[re] = Se;
    }
    return M;
  }
  // Draws a list of layers in one viewport
  // TODO - when picking we could completely skip rendering viewports that dont
  // intersect with the picking rect
  /* eslint-disable max-depth, max-statements */
  _drawLayersInViewport(e, { layers: i, moduleParameters: s, pass: o, target: u, viewport: d, view: a }, w) {
    const S = uD(this.device, {
      moduleParameters: s,
      target: u,
      viewport: d
    });
    if (a && a.props.clear) {
      const F = a.props.clear === !0 ? { color: !0, depth: !0 } : a.props.clear;
      this.device.withParametersWebGL({
        scissorTest: !0,
        scissor: S
      }, () => this.device.clearWebGL(F));
    }
    const M = {
      totalCount: i.length,
      visibleCount: 0,
      compositeCount: 0,
      pickableCount: 0
    };
    e.setParameters({ viewport: S });
    for (let F = 0; F < i.length; F++) {
      const N = i[F], { shouldDrawLayer: L, layerRenderIndex: re, moduleParameters: ne, layerParameters: we } = w[F];
      if (L && N.props.pickable && M.pickableCount++, N.isComposite)
        M.compositeCount++;
      else if (L) {
        M.visibleCount++, this._lastRenderIndex = Math.max(this._lastRenderIndex, re), ne.viewport = d, N.context.renderPass = e;
        try {
          N._drawLayer({
            renderPass: e,
            moduleParameters: ne,
            uniforms: { layerIndex: re },
            parameters: we
          });
        } catch (Se) {
          N.raiseError(Se, `drawing ${N} to ${o}`);
        }
      }
    }
    return M;
  }
  /* eslint-enable max-depth, max-statements */
  /* Methods for subclass overrides */
  shouldDrawLayer(e) {
    return !0;
  }
  getModuleParameters(e, i) {
    return null;
  }
  getLayerParameters(e, i, s) {
    return e.props.parameters;
  }
  /* Private */
  _shouldDrawLayer(e, i, s, o) {
    if (!(e.props.visible && this.shouldDrawLayer(e)))
      return !1;
    i.layer = e;
    let d = e.parent;
    for (; d; ) {
      if (!d.props.visible || !d.filterSubLayer(i))
        return !1;
      i.layer = d, d = d.parent;
    }
    if (s) {
      const a = i.layer.id;
      if (a in o || (o[a] = s(i)), !o[a])
        return !1;
    }
    return e.activateViewport(i.viewport), !0;
  }
  _getModuleParameters(e, i, s, o) {
    const u = this.device.canvasContext.cssToDeviceRatio(), d = Object.assign(Object.create(e.internalState?.propsInTransition || e.props), {
      autoWrapLongitude: e.wrapLongitude,
      viewport: e.context.viewport,
      mousePosition: e.context.mousePosition,
      picking: {
        isActive: 0
      },
      devicePixelRatio: u
    });
    if (i)
      for (const a of i)
        Object.assign(d, a.getModuleParameters?.(e));
    return Object.assign(d, this.getModuleParameters(e, i), o);
  }
}
function CT(t = 0, e = {}) {
  const i = {}, s = (o, u) => {
    const d = o.props._offset, a = o.id, w = o.parent && o.parent.id;
    let S;
    if (w && !(w in e) && s(o.parent, !1), w in i) {
      const M = i[w] = i[w] || CT(e[w], e);
      S = M(o, u), i[a] = M;
    } else Number.isFinite(d) ? (S = d + (e[w] || 0), i[a] = null) : S = t;
    return u && S >= t && (t = S + 1), e[a] = S, S;
  };
  return s;
}
function uD(t, { moduleParameters: e, target: i, viewport: s }) {
  const o = e && e.devicePixelRatio || // @ts-expect-error TODO - assuming WebGL context
  t.canvasContext.cssToDeviceRatio(), [, u] = t.canvasContext.getDrawingBufferSize(), d = i ? i.height : u, a = s;
  return [
    a.x * o,
    d - (a.y + a.height) * o,
    a.width * o,
    a.height * o
  ];
}
class dD extends Iy {
  constructor(e, i) {
    super(e, i), this.shadowMap = e.createTexture({
      width: 1,
      height: 1,
      sampler: {
        minFilter: "linear",
        magFilter: "linear",
        addressModeU: "clamp-to-edge",
        addressModeV: "clamp-to-edge"
      }
    }), this.depthBuffer = e.createTexture({
      format: "depth16unorm",
      width: 1,
      height: 1,
      mipmaps: !1,
      // TODO fix getWebGLTextureParameters() in luma to avoid passing deprecated parameters
      dataFormat: 6402,
      // gl.DEPTH_COMPONENT
      type: 5125
      // gl.UNSIGNED_INT
    }), this.fbo = e.createFramebuffer({
      id: "shadowmap",
      width: 1,
      height: 1,
      colorAttachments: [this.shadowMap],
      // Depth attachment has to be specified for depth test to work
      depthStencilAttachment: this.depthBuffer
    });
  }
  render(e) {
    const i = this.fbo, s = this.device.canvasContext.cssToDeviceRatio(), o = e.viewports[0], u = o.width * s, d = o.height * s, a = [1, 1, 1, 1];
    (u !== i.width || d !== i.height) && i.resize({ width: u, height: d }), super.render({ ...e, clearColor: a, target: i, pass: "shadow" });
  }
  getLayerParameters(e, i, s) {
    return { ...e.props.parameters, blend: !1, depthRange: [0, 1], depthTest: !0 };
  }
  shouldDrawLayer(e) {
    return e.props.shadowEnabled !== !1;
  }
  getModuleParameters() {
    return {
      drawToShadowMap: !0
    };
  }
  delete() {
    this.fbo && (this.fbo.destroy(), this.fbo = null), this.shadowMap && (this.shadowMap.destroy(), this.shadowMap = null), this.depthBuffer && (this.depthBuffer.destroy(), this.depthBuffer = null);
  }
}
const fD = { color: [255, 255, 255], intensity: 1 }, Wv = [
  {
    color: [255, 255, 255],
    intensity: 1,
    direction: [-1, 3, -1]
  },
  {
    color: [255, 255, 255],
    intensity: 0.9,
    direction: [1, -8, -2.5]
  }
], pD = [0, 0, 0, 200 / 255];
class IT {
  constructor(e = {}) {
    this.id = "lighting-effect", this.shadowColor = pD, this.shadow = !1, this.ambientLight = null, this.directionalLights = [], this.pointLights = [], this.shadowPasses = [], this.shadowMaps = [], this.dummyShadowMap = null, this.setProps(e);
  }
  setup(e) {
    this.context = e;
    const { device: i, deck: s } = e;
    this.shadow && !this.dummyShadowMap && (this._createShadowPasses(i), s._addDefaultShaderModule($v), this.dummyShadowMap = i.createTexture({
      width: 1,
      height: 1
    }));
  }
  setProps(e) {
    this.ambientLight = null, this.directionalLights = [], this.pointLights = [];
    for (const i in e) {
      const s = e[i];
      switch (s.type) {
        case "ambient":
          this.ambientLight = s;
          break;
        case "directional":
          this.directionalLights.push(s);
          break;
        case "point":
          this.pointLights.push(s);
          break;
      }
    }
    this._applyDefaultLights(), this.shadow = this.directionalLights.some((i) => i.shadow), this.context && this.setup(this.context), this.props = e;
  }
  preRender({ layers: e, layerFilter: i, viewports: s, onViewportActive: o, views: u }) {
    if (this.shadow) {
      this.shadowMatrices = this._calculateMatrices();
      for (let d = 0; d < this.shadowPasses.length; d++)
        this.shadowPasses[d].render({
          layers: e,
          layerFilter: i,
          viewports: s,
          onViewportActive: o,
          views: u,
          moduleParameters: {
            shadowLightId: d,
            dummyShadowMap: this.dummyShadowMap,
            shadowMatrices: this.shadowMatrices
          }
        });
    }
  }
  getModuleParameters(e) {
    const i = this.shadow ? {
      shadowMaps: this.shadowMaps,
      dummyShadowMap: this.dummyShadowMap,
      shadowColor: this.shadowColor,
      shadowMatrices: this.shadowMatrices
    } : {};
    return i.lightSources = {
      ambientLight: this.ambientLight,
      directionalLights: this.directionalLights.map((s) => s.getProjectedLight({ layer: e })),
      pointLights: this.pointLights.map((s) => s.getProjectedLight({ layer: e }))
    }, i;
  }
  cleanup(e) {
    for (const i of this.shadowPasses)
      i.delete();
    this.shadowPasses.length = 0, this.shadowMaps.length = 0, this.dummyShadowMap && (this.dummyShadowMap.destroy(), this.dummyShadowMap = null, e.deck._removeDefaultShaderModule($v));
  }
  _calculateMatrices() {
    const e = [];
    for (const i of this.directionalLights) {
      const s = new Gt().lookAt({
        eye: new Be(i.direction).negate()
      });
      e.push(s);
    }
    return e;
  }
  _createShadowPasses(e) {
    for (let i = 0; i < this.directionalLights.length; i++) {
      const s = new dD(e);
      this.shadowPasses[i] = s, this.shadowMaps[i] = s.shadowMap;
    }
  }
  _applyDefaultLights() {
    const { ambientLight: e, pointLights: i, directionalLights: s } = this;
    !e && i.length === 0 && s.length === 0 && (this.ambientLight = new nD(fD), this.directionalLights.push(new Gv(Wv[0]), new Gv(Wv[1])));
  }
}
class _D {
  constructor(e = {}) {
    this._pool = [], this.opts = { overAlloc: 2, poolSize: 100 }, this.setOptions(e);
  }
  setOptions(e) {
    Object.assign(this.opts, e);
  }
  allocate(e, i, { size: s = 1, type: o, padding: u = 0, copy: d = !1, initialize: a = !1, maxCount: w }) {
    const S = o || e && e.constructor || Float32Array, M = i * s + u;
    if (ArrayBuffer.isView(e)) {
      if (M <= e.length)
        return e;
      if (M * e.BYTES_PER_ELEMENT <= e.buffer.byteLength)
        return new S(e.buffer, 0, M);
    }
    let F = 1 / 0;
    w && (F = w * s + u);
    const N = this._allocate(S, M, a, F);
    return e && d ? N.set(e) : a || N.fill(0, 0, 4), this._release(e), N;
  }
  release(e) {
    this._release(e);
  }
  _allocate(e, i, s, o) {
    let u = Math.max(Math.ceil(i * this.opts.overAlloc), 1);
    u > o && (u = o);
    const d = this._pool, a = e.BYTES_PER_ELEMENT * u, w = d.findIndex((S) => S.byteLength >= a);
    if (w >= 0) {
      const S = new e(d.splice(w, 1)[0], 0, u);
      return s && S.fill(0), S;
    }
    return new e(u);
  }
  _release(e) {
    if (!ArrayBuffer.isView(e))
      return;
    const i = this._pool, { buffer: s } = e, { byteLength: o } = s, u = i.findIndex((d) => d.byteLength >= o);
    u < 0 ? i.push(s) : (u > 0 || i.length < this.opts.poolSize) && i.splice(u, 0, s), i.length > this.opts.poolSize && i.shift();
  }
}
const Ku = new _D();
function Fu() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function gD(t) {
  return [t[12], t[13], t[14]];
}
function mD(t) {
  return {
    left: Fc(t[3] + t[0], t[7] + t[4], t[11] + t[8], t[15] + t[12]),
    right: Fc(t[3] - t[0], t[7] - t[4], t[11] - t[8], t[15] - t[12]),
    bottom: Fc(t[3] + t[1], t[7] + t[5], t[11] + t[9], t[15] + t[13]),
    top: Fc(t[3] - t[1], t[7] - t[5], t[11] - t[9], t[15] - t[13]),
    near: Fc(t[3] + t[2], t[7] + t[6], t[11] + t[10], t[15] + t[14]),
    far: Fc(t[3] - t[2], t[7] - t[6], t[11] - t[10], t[15] - t[14])
  };
}
const Xv = new Be();
function Fc(t, e, i, s) {
  Xv.set(t, e, i);
  const o = Xv.len();
  return { distance: s / o, normal: new Be(-t / o, -e / o, -i / o) };
}
function yD(t) {
  return t - Math.fround(t);
}
let Tu;
function gg(t, e) {
  const { size: i = 1, startIndex: s = 0 } = e, o = e.endIndex !== void 0 ? e.endIndex : t.length, u = (o - s) / i;
  Tu = Ku.allocate(Tu, u, {
    type: Float32Array,
    size: i * 2
  });
  let d = s, a = 0;
  for (; d < o; ) {
    for (let w = 0; w < i; w++) {
      const S = t[d++];
      Tu[a + w] = S, Tu[a + w + i] = yD(S);
    }
    a += i * 2;
  }
  return Tu.subarray(0, u * i * 2);
}
function bD(t) {
  let e = null, i = !1;
  for (const s of t)
    s && (e ? (i || (e = [
      [e[0][0], e[0][1]],
      [e[1][0], e[1][1]]
    ], i = !0), e[0][0] = Math.min(e[0][0], s[0][0]), e[0][1] = Math.min(e[0][1], s[0][1]), e[1][0] = Math.max(e[1][0], s[1][0]), e[1][1] = Math.max(e[1][1], s[1][1])) : e = s);
  return e;
}
const vD = Math.PI / 180, xD = Fu(), qv = [0, 0, 0], wD = {
  unitsPerMeter: [1, 1, 1],
  metersPerUnit: [1, 1, 1]
};
function TD({ width: t, height: e, orthographic: i, fovyRadians: s, focalDistance: o, padding: u, near: d, far: a }) {
  const w = t / e, S = i ? new Gt().orthographic({ fovy: s, aspect: w, focalDistance: o, near: d, far: a }) : new Gt().perspective({ fovy: s, aspect: w, near: d, far: a });
  if (u) {
    const { left: M = 0, right: F = 0, top: N = 0, bottom: L = 0 } = u, re = Do((M + t - F) / 2, 0, t) - t / 2, ne = Do((N + e - L) / 2, 0, e) - e / 2;
    S[8] -= re * 2 / t, S[9] += ne * 2 / e;
  }
  return S;
}
class cd {
  // eslint-disable-next-line complexity
  constructor(e = {}) {
    this._frustumPlanes = {}, this.id = e.id || this.constructor.displayName || "viewport", this.x = e.x || 0, this.y = e.y || 0, this.width = e.width || 1, this.height = e.height || 1, this.zoom = e.zoom || 0, this.padding = e.padding, this.distanceScales = e.distanceScales || wD, this.focalDistance = e.focalDistance || 1, this.position = e.position || qv, this.modelMatrix = e.modelMatrix || null;
    const { longitude: i, latitude: s } = e;
    this.isGeospatial = Number.isFinite(s) && Number.isFinite(i), this._initProps(e), this._initMatrices(e), this.equals = this.equals.bind(this), this.project = this.project.bind(this), this.unproject = this.unproject.bind(this), this.projectPosition = this.projectPosition.bind(this), this.unprojectPosition = this.unprojectPosition.bind(this), this.projectFlat = this.projectFlat.bind(this), this.unprojectFlat = this.unprojectFlat.bind(this);
  }
  get subViewports() {
    return null;
  }
  get metersPerPixel() {
    return this.distanceScales.metersPerUnit[2] / this.scale;
  }
  get projectionMode() {
    return this.isGeospatial ? this.zoom < 12 ? ao.WEB_MERCATOR : ao.WEB_MERCATOR_AUTO_OFFSET : ao.IDENTITY;
  }
  // Two viewports are equal if width and height are identical, and if
  // their view and projection matrices are (approximately) equal.
  equals(e) {
    return e instanceof cd ? this === e ? !0 : e.width === this.width && e.height === this.height && e.scale === this.scale && On(e.projectionMatrix, this.projectionMatrix) && On(e.viewMatrix, this.viewMatrix) : !1;
  }
  /**
   * Projects xyz (possibly latitude and longitude) to pixel coordinates in window
   * using viewport projection parameters
   * - [longitude, latitude] to [x, y]
   * - [longitude, latitude, Z] => [x, y, z]
   * Note: By default, returns top-left coordinates for canvas/SVG type render
   *
   * @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]
   * @param {Object} opts - options
   * @param {Object} opts.topLeft=true - Whether projected coords are top left
   * @return {Array} - [x, y] or [x, y, z] in top left coords
   */
  project(e, { topLeft: i = !0 } = {}) {
    const s = this.projectPosition(e), o = ST(s, this.pixelProjectionMatrix), [u, d] = o, a = i ? d : this.height - d;
    return e.length === 2 ? [u, a] : [u, a, o[2]];
  }
  /**
   * Unproject pixel coordinates on screen onto world coordinates,
   * (possibly [lon, lat]) on map.
   * - [x, y] => [lng, lat]
   * - [x, y, z] => [lng, lat, Z]
   * @param {Array} xyz -
   * @param {Object} opts - options
   * @param {Object} opts.topLeft=true - Whether origin is top left
   * @return {Array|null} - [lng, lat, Z] or [X, Y, Z]
   */
  unproject(e, { topLeft: i = !0, targetZ: s } = {}) {
    const [o, u, d] = e, a = i ? u : this.height - u, w = s && s * this.distanceScales.unitsPerMeter[2], S = Sy([o, a, d], this.pixelUnprojectionMatrix, w), [M, F, N] = this.unprojectPosition(S);
    return Number.isFinite(d) ? [M, F, N] : Number.isFinite(s) ? [M, F, s] : [M, F];
  }
  // NON_LINEAR PROJECTION HOOKS
  // Used for web meractor projection
  projectPosition(e) {
    const [i, s] = this.projectFlat(e), o = (e[2] || 0) * this.distanceScales.unitsPerMeter[2];
    return [i, s, o];
  }
  unprojectPosition(e) {
    const [i, s] = this.unprojectFlat(e), o = (e[2] || 0) * this.distanceScales.metersPerUnit[2];
    return [i, s, o];
  }
  /**
   * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
   * Performs the nonlinear part of the web mercator projection.
   * Remaining projection is done with 4x4 matrices which also handles
   * perspective.
   * @param {Array} lngLat - [lng, lat] coordinates
   *   Specifies a point on the sphere to project onto the map.
   * @return {Array} [x,y] coordinates.
   */
  projectFlat(e) {
    if (this.isGeospatial) {
      const i = Zu(e);
      return i[1] = Do(i[1], -318, 830), i;
    }
    return e;
  }
  /**
   * Unproject world point [x,y] on map onto {lat, lon} on sphere
   * @param {object|Vector} xy - object with {x,y} members
   *  representing point on projected map plane
   * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
   *   Has toArray method if you need a GeoJSON Array.
   *   Per cartographic tradition, lat and lon are specified as degrees.
   */
  unprojectFlat(e) {
    return this.isGeospatial ? lh(e) : e;
  }
  /**
   * Get bounds of the current viewport
   * @return {Array} - [minX, minY, maxX, maxY]
   */
  getBounds(e = {}) {
    const i = { targetZ: e.z || 0 }, s = this.unproject([0, 0], i), o = this.unproject([this.width, 0], i), u = this.unproject([0, this.height], i), d = this.unproject([this.width, this.height], i);
    return [
      Math.min(s[0], o[0], u[0], d[0]),
      Math.min(s[1], o[1], u[1], d[1]),
      Math.max(s[0], o[0], u[0], d[0]),
      Math.max(s[1], o[1], u[1], d[1])
    ];
  }
  getDistanceScales(e) {
    return e ? Tm({
      longitude: e[0],
      latitude: e[1],
      highPrecision: !0
    }) : this.distanceScales;
  }
  containsPixel({ x: e, y: i, width: s = 1, height: o = 1 }) {
    return e < this.x + this.width && this.x < e + s && i < this.y + this.height && this.y < i + o;
  }
  // Extract frustum planes in common space
  getFrustumPlanes() {
    return this._frustumPlanes.near ? this._frustumPlanes : (Object.assign(this._frustumPlanes, mD(this.viewProjectionMatrix)), this._frustumPlanes);
  }
  // EXPERIMENTAL METHODS
  /**
   * Needed by panning and linear transition
   * Pan the viewport to place a given world coordinate at screen point [x, y]
   *
   * @param {Array} coords - world coordinates
   * @param {Array} pixel - [x,y] coordinates on screen
   * @return {Object} props of the new viewport
   */
  panByPosition(e, i) {
    return null;
  }
  // INTERNAL METHODS
  /* eslint-disable complexity, max-statements */
  _initProps(e) {
    const i = e.longitude, s = e.latitude;
    this.isGeospatial && (Number.isFinite(e.zoom) || (this.zoom = kB({ latitude: s }) + Math.log2(this.focalDistance)), this.distanceScales = e.distanceScales || Tm({ latitude: s, longitude: i }));
    const o = Math.pow(2, this.zoom);
    this.scale = o;
    const { position: u, modelMatrix: d } = e;
    let a = qv;
    if (u && (a = d ? new Gt(d).transformAsVector(u, []) : u), this.isGeospatial) {
      const w = this.projectPosition([i, s, 0]);
      this.center = new Be(a).scale(this.distanceScales.unitsPerMeter).add(w);
    } else
      this.center = this.projectPosition(a);
  }
  /* eslint-enable complexity, max-statements */
  _initMatrices(e) {
    const {
      // View matrix
      viewMatrix: i = xD,
      // Projection matrix
      projectionMatrix: s = null,
      // Projection matrix parameters, used if projectionMatrix not supplied
      orthographic: o = !1,
      fovyRadians: u,
      fovy: d = 75,
      near: a = 0.1,
      // Distance of near clipping plane
      far: w = 1e3,
      // Distance of far clipping plane
      padding: S = null,
      // Center offset in pixels
      focalDistance: M = 1
    } = e;
    this.viewMatrixUncentered = i, this.viewMatrix = new Gt().multiplyRight(i).translate(new Be(this.center).negate()), this.projectionMatrix = s || TD({
      width: this.width,
      height: this.height,
      orthographic: o,
      fovyRadians: u || d * vD,
      focalDistance: M,
      padding: S,
      near: a,
      far: w
    });
    const F = Fu();
    Sl(F, F, this.projectionMatrix), Sl(F, F, this.viewMatrix), this.viewProjectionMatrix = F, this.viewMatrixInverse = mm([], this.viewMatrix) || this.viewMatrix, this.cameraPosition = gD(this.viewMatrixInverse);
    const N = Fu(), L = Fu();
    vy(N, N, [this.width / 2, -this.height / 2, 1]), fp(N, N, [1, -1, 0]), Sl(L, N, this.viewProjectionMatrix), this.pixelProjectionMatrix = L, this.pixelUnprojectionMatrix = mm(Fu(), this.pixelProjectionMatrix), this.pixelUnprojectionMatrix || Jt.warn("Pixel project matrix not invertible")();
  }
}
cd.displayName = "Viewport";
class Il extends cd {
  /* eslint-disable complexity, max-statements */
  constructor(e = {}) {
    const {
      latitude: i = 0,
      longitude: s = 0,
      zoom: o = 0,
      pitch: u = 0,
      bearing: d = 0,
      nearZMultiplier: a = 0.1,
      farZMultiplier: w = 1.01,
      nearZ: S,
      farZ: M,
      orthographic: F = !1,
      projectionMatrix: N,
      repeat: L = !1,
      worldOffset: re = 0,
      position: ne,
      padding: we,
      // backward compatibility
      // TODO: remove in v9
      legacyMeterSizes: Se = !1
    } = e;
    let { width: Ee, height: Ce, altitude: Le = 1.5 } = e;
    const Ze = Math.pow(2, o);
    Ee = Ee || 1, Ce = Ce || 1;
    let Ke, ct = null;
    if (N)
      Le = N[5] / 2, Ke = _p(Le);
    else {
      e.fovy ? (Ke = e.fovy, Le = ET(Ke)) : Ke = _p(Le);
      let st;
      if (we) {
        const { top: ot = 0, bottom: bt = 0 } = we;
        st = [0, Do((ot + Ce - bt) / 2, 0, Ce) - Ce / 2];
      }
      ct = LB({
        width: Ee,
        height: Ce,
        scale: Ze,
        center: ne && [0, 0, ne[2] * ep(i)],
        offset: st,
        pitch: u,
        fovy: Ke,
        nearZMultiplier: a,
        farZMultiplier: w
      }), Number.isFinite(S) && (ct.near = S), Number.isFinite(M) && (ct.far = M);
    }
    let _t = NB({
      height: Ce,
      pitch: u,
      bearing: d,
      scale: Ze,
      altitude: Le
    });
    re && (_t = new Gt().translate([512 * re, 0, 0]).multiplyLeft(_t)), super({
      ...e,
      // x, y,
      width: Ee,
      height: Ce,
      // view matrix
      viewMatrix: _t,
      longitude: s,
      latitude: i,
      zoom: o,
      // projection matrix parameters
      ...ct,
      fovy: Ke,
      focalDistance: Le
    }), this.latitude = i, this.longitude = s, this.zoom = o, this.pitch = u, this.bearing = d, this.altitude = Le, this.fovy = Ke, this.orthographic = F, this._subViewports = L ? [] : null, this._pseudoMeters = Se, Object.freeze(this);
  }
  /* eslint-enable complexity, max-statements */
  get subViewports() {
    if (this._subViewports && !this._subViewports.length) {
      const e = this.getBounds(), i = Math.floor((e[0] + 180) / 360), s = Math.ceil((e[2] - 180) / 360);
      for (let o = i; o <= s; o++) {
        const u = o ? new Il({
          ...this,
          worldOffset: o
        }) : this;
        this._subViewports.push(u);
      }
    }
    return this._subViewports;
  }
  projectPosition(e) {
    if (this._pseudoMeters)
      return super.projectPosition(e);
    const [i, s] = this.projectFlat(e), o = (e[2] || 0) * ep(e[1]);
    return [i, s, o];
  }
  unprojectPosition(e) {
    if (this._pseudoMeters)
      return super.unprojectPosition(e);
    const [i, s] = this.unprojectFlat(e), o = (e[2] || 0) / ep(s);
    return [i, s, o];
  }
  /**
   * Add a meter delta to a base lnglat coordinate, returning a new lnglat array
   *
   * Note: Uses simple linear approximation around the viewport center
   * Error increases with size of offset (roughly 1% per 100km)
   *
   * @param {[Number,Number]|[Number,Number,Number]) lngLatZ - base coordinate
   * @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas
   * @return {[Number,Number]|[Number,Number,Number]) array of [lng,lat,z] deltas
   */
  addMetersToLngLat(e, i) {
    return AT(e, i);
  }
  panByPosition(e, i) {
    const s = Sy(i, this.pixelUnprojectionMatrix), o = this.projectFlat(e), u = Pv([], o, WP([], s)), d = Pv([], this.center, u), [a, w] = this.unprojectFlat(d);
    return { longitude: a, latitude: w };
  }
  getBounds(e = {}) {
    const i = VB(this, e.z || 0);
    return [
      Math.min(i[0][0], i[1][0], i[2][0], i[3][0]),
      Math.min(i[0][1], i[1][1], i[2][1], i[3][1]),
      Math.max(i[0][0], i[1][0], i[2][0], i[3][0]),
      Math.max(i[0][1], i[1][1], i[2][1], i[3][1])
    ];
  }
  /**
   * Returns a new viewport that fit around the given rectangle.
   * Only supports non-perspective mode.
   */
  fitBounds(e, i = {}) {
    const { width: s, height: o } = this, { longitude: u, latitude: d, zoom: a } = UB({ width: s, height: o, bounds: e, ...i });
    return new Il({ width: s, height: o, longitude: u, latitude: d, zoom: a });
  }
}
Il.displayName = "WebMercatorViewport";
const Zv = [0, 0, 0];
function mg(t, e, i = !1) {
  const s = e.projectPosition(t);
  if (i && e instanceof Il) {
    const [o, u, d = 0] = t, a = e.getDistanceScales([o, u]);
    s[2] = d * a.unitsPerMeter[2];
  }
  return s;
}
function AD(t) {
  const { viewport: e, modelMatrix: i, coordinateOrigin: s } = t;
  let { coordinateSystem: o, fromCoordinateSystem: u, fromCoordinateOrigin: d } = t;
  return o === Xt.DEFAULT && (o = e.isGeospatial ? Xt.LNGLAT : Xt.CARTESIAN), u === void 0 && (u = o), d === void 0 && (d = s), {
    viewport: e,
    coordinateSystem: o,
    coordinateOrigin: s,
    modelMatrix: i,
    fromCoordinateSystem: u,
    fromCoordinateOrigin: d
  };
}
function MT(t, { viewport: e, modelMatrix: i, coordinateSystem: s, coordinateOrigin: o, offsetMode: u }) {
  let [d, a, w = 0] = t;
  switch (i && ([d, a, w] = ad([], [d, a, w, 1], i)), s) {
    case Xt.LNGLAT:
      return mg([d, a, w], e, u);
    case Xt.LNGLAT_OFFSETS:
      return mg([d + o[0], a + o[1], w + (o[2] || 0)], e, u);
    case Xt.METER_OFFSETS:
      return mg(AT(o, [d, a, w]), e, u);
    case Xt.CARTESIAN:
    default:
      return e.isGeospatial ? [d + o[0], a + o[1], w + o[2]] : e.projectPosition([d, a, w]);
  }
}
function ED(t, e) {
  const { viewport: i, coordinateSystem: s, coordinateOrigin: o, modelMatrix: u, fromCoordinateSystem: d, fromCoordinateOrigin: a } = AD(e), { autoOffset: w = !0 } = e, { geospatialOrigin: S = Zv, shaderCoordinateOrigin: M = Zv, offsetMode: F = !1 } = w ? wT(i, s, o) : {}, N = MT(t, {
    viewport: i,
    modelMatrix: u,
    coordinateSystem: d,
    coordinateOrigin: a,
    offsetMode: F
  });
  if (F) {
    const L = i.projectPosition(S || M);
    s3(N, N, L);
  }
  return N;
}
let SD = 1, CD = 1;
class RT {
  time = 0;
  channels = /* @__PURE__ */ new Map();
  animations = /* @__PURE__ */ new Map();
  playing = !1;
  lastEngineTime = -1;
  constructor() {
  }
  addChannel(e) {
    const { delay: i = 0, duration: s = Number.POSITIVE_INFINITY, rate: o = 1, repeat: u = 1 } = e, d = SD++, a = {
      time: 0,
      delay: i,
      duration: s,
      rate: o,
      repeat: u
    };
    return this._setChannelTime(a, this.time), this.channels.set(d, a), d;
  }
  removeChannel(e) {
    this.channels.delete(e);
    for (const [i, s] of this.animations)
      s.channel === e && this.detachAnimation(i);
  }
  isFinished(e) {
    const i = this.channels.get(e);
    return i === void 0 ? !1 : this.time >= i.delay + i.duration * i.repeat;
  }
  getTime(e) {
    if (e === void 0)
      return this.time;
    const i = this.channels.get(e);
    return i === void 0 ? -1 : i.time;
  }
  setTime(e) {
    this.time = Math.max(0, e);
    const i = this.channels.values();
    for (const o of i)
      this._setChannelTime(o, this.time);
    const s = this.animations.values();
    for (const o of s) {
      const { animation: u, channel: d } = o;
      u.setTime(this.getTime(d));
    }
  }
  play() {
    this.playing = !0;
  }
  pause() {
    this.playing = !1, this.lastEngineTime = -1;
  }
  reset() {
    this.setTime(0);
  }
  attachAnimation(e, i) {
    const s = CD++;
    return this.animations.set(s, {
      animation: e,
      channel: i
    }), e.setTime(this.getTime(i)), s;
  }
  detachAnimation(e) {
    this.animations.delete(e);
  }
  update(e) {
    this.playing && (this.lastEngineTime === -1 && (this.lastEngineTime = e), this.setTime(this.time + (e - this.lastEngineTime)), this.lastEngineTime = e);
  }
  _setChannelTime(e, i) {
    const s = i - e.delay, o = e.duration * e.repeat;
    s >= o ? e.time = e.duration * e.rate : (e.time = Math.max(0, s) % e.duration, e.time *= e.rate);
  }
}
let ID = 0;
const MD = {
  device: null,
  onAddHTML: () => "",
  onInitialize: async () => null,
  onRender: () => {
  },
  onFinalize: () => {
  },
  onError: (t) => console.error(t),
  // eslint-disable-line no-console
  stats: Yc.stats.get(`animation-loop-${ID++}`),
  // view parameters
  useDevicePixels: !0,
  autoResizeViewport: !1,
  autoResizeDrawingBuffer: !1
};
class RD {
  device = null;
  canvas = null;
  props;
  animationProps = null;
  timeline = null;
  stats;
  cpuTime;
  gpuTime;
  frameRate;
  display;
  needsRedraw = "initialized";
  _initialized = !1;
  _running = !1;
  _animationFrameId = null;
  _nextFramePromise = null;
  _resolveNextFrame = null;
  _cpuStartTime = 0;
  // _gpuTimeQuery: Query | null = null;
  /*
   * @param {HTMLCanvasElement} canvas - if provided, width and height will be passed to context
   */
  constructor(e) {
    if (this.props = { ...MD, ...e }, e = this.props, !e.device)
      throw new Error("No device provided");
    const { useDevicePixels: i = !0 } = this.props;
    this.stats = e.stats || new _h({ id: "animation-loop-stats" }), this.cpuTime = this.stats.get("CPU Time"), this.gpuTime = this.stats.get("GPU Time"), this.frameRate = this.stats.get("Frame Rate"), this.setProps({
      autoResizeViewport: e.autoResizeViewport,
      autoResizeDrawingBuffer: e.autoResizeDrawingBuffer,
      useDevicePixels: i
    }), this.start = this.start.bind(this), this.stop = this.stop.bind(this), this._onMousemove = this._onMousemove.bind(this), this._onMouseleave = this._onMouseleave.bind(this);
  }
  destroy() {
    this.stop(), this._setDisplay(null);
  }
  /** @deprecated Use .destroy() */
  delete() {
    this.destroy();
  }
  /** Flags this animation loop as needing redraw */
  setNeedsRedraw(e) {
    return this.needsRedraw = this.needsRedraw || e, this;
  }
  /** TODO - move these props to CanvasContext? */
  setProps(e) {
    return "autoResizeViewport" in e && (this.props.autoResizeViewport = e.autoResizeViewport || !1), "autoResizeDrawingBuffer" in e && (this.props.autoResizeDrawingBuffer = e.autoResizeDrawingBuffer || !1), "useDevicePixels" in e && (this.props.useDevicePixels = e.useDevicePixels || !1), this;
  }
  /** Starts a render loop if not already running */
  async start() {
    if (this._running)
      return this;
    this._running = !0;
    try {
      let e;
      return this._initialized || (this._initialized = !0, await this._initDevice(), this._initialize(), await this.props.onInitialize(this._getAnimationProps())), this._running ? (e !== !1 && (this._cancelAnimationFrame(), this._requestAnimationFrame()), this) : null;
    } catch (e) {
      const i = e instanceof Error ? e : new Error("Unknown error");
      throw this.props.onError(i), i;
    }
  }
  /** Stops a render loop if already running, finalizing */
  stop() {
    return this._running && (this.animationProps && this.props.onFinalize(this.animationProps), this._cancelAnimationFrame(), this._nextFramePromise = null, this._resolveNextFrame = null, this._running = !1), this;
  }
  /** Explicitly draw a frame */
  redraw() {
    return this.device?.isLost ? this : (this._beginFrameTimers(), this._setupFrame(), this._updateAnimationProps(), this._renderFrame(this._getAnimationProps()), this._clearNeedsRedraw(), this._resolveNextFrame && (this._resolveNextFrame(this), this._nextFramePromise = null, this._resolveNextFrame = null), this._endFrameTimers(), this);
  }
  /** Add a timeline, it will be automatically updated by the animation loop. */
  attachTimeline(e) {
    return this.timeline = e, this.timeline;
  }
  /** Remove a timeline */
  detachTimeline() {
    this.timeline = null;
  }
  /** Wait until a render completes */
  waitForRender() {
    return this.setNeedsRedraw("waitForRender"), this._nextFramePromise || (this._nextFramePromise = new Promise((e) => {
      this._resolveNextFrame = e;
    })), this._nextFramePromise;
  }
  /** TODO - should use device.deviceContext */
  async toDataURL() {
    if (this.setNeedsRedraw("toDataURL"), await this.waitForRender(), this.canvas instanceof HTMLCanvasElement)
      return this.canvas.toDataURL();
    throw new Error("OffscreenCanvas");
  }
  // PRIVATE METHODS
  _initialize() {
    this._startEventHandling(), this._initializeAnimationProps(), this._updateAnimationProps(), this._resizeCanvasDrawingBuffer(), this._resizeViewport();
  }
  _setDisplay(e) {
    this.display && (this.display.destroy(), this.display.animationLoop = null), e && (e.animationLoop = this), this.display = e;
  }
  _requestAnimationFrame() {
    this._running && (this._animationFrameId = kR(this._animationFrame.bind(this)));
  }
  _cancelAnimationFrame() {
    this._animationFrameId !== null && (NR(this._animationFrameId), this._animationFrameId = null);
  }
  _animationFrame() {
    this._running && (this.redraw(), this._requestAnimationFrame());
  }
  // Called on each frame, can be overridden to call onRender multiple times
  // to support e.g. stereoscopic rendering
  _renderFrame(e) {
    if (this.display) {
      this.display._renderFrame(e);
      return;
    }
    this.props.onRender(this._getAnimationProps()), this.device.submit();
  }
  _clearNeedsRedraw() {
    this.needsRedraw = !1;
  }
  _setupFrame() {
    this._resizeCanvasDrawingBuffer(), this._resizeViewport();
  }
  // Initialize the  object that will be passed to app callbacks
  _initializeAnimationProps() {
    if (!this.device)
      throw new Error("loop");
    this.animationProps = {
      animationLoop: this,
      device: this.device,
      canvas: this.device?.canvasContext?.canvas,
      timeline: this.timeline,
      // Initial values
      useDevicePixels: this.props.useDevicePixels,
      needsRedraw: !1,
      // Placeholders
      width: 1,
      height: 1,
      aspect: 1,
      // Animation props
      time: 0,
      startTime: Date.now(),
      engineTime: 0,
      tick: 0,
      tock: 0,
      // Experimental
      _mousePosition: null
      // Event props
    };
  }
  _getAnimationProps() {
    if (!this.animationProps)
      throw new Error("animationProps");
    return this.animationProps;
  }
  // Update the context object that will be passed to app callbacks
  _updateAnimationProps() {
    if (!this.animationProps)
      return;
    const { width: e, height: i, aspect: s } = this._getSizeAndAspect();
    (e !== this.animationProps.width || i !== this.animationProps.height) && this.setNeedsRedraw("drawing buffer resized"), s !== this.animationProps.aspect && this.setNeedsRedraw("drawing buffer aspect changed"), this.animationProps.width = e, this.animationProps.height = i, this.animationProps.aspect = s, this.animationProps.needsRedraw = this.needsRedraw, this.animationProps.engineTime = Date.now() - this.animationProps.startTime, this.timeline && this.timeline.update(this.animationProps.engineTime), this.animationProps.tick = Math.floor(this.animationProps.time / 1e3 * 60), this.animationProps.tock++, this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime;
  }
  /** Wait for supplied device */
  async _initDevice() {
    if (this.device = await this.props.device, !this.device)
      throw new Error("No device provided");
    this.canvas = this.device.canvasContext?.canvas || null;
  }
  _createInfoDiv() {
    if (this.canvas && this.props.onAddHTML) {
      const e = document.createElement("div");
      document.body.appendChild(e), e.style.position = "relative";
      const i = document.createElement("div");
      i.style.position = "absolute", i.style.left = "10px", i.style.bottom = "10px", i.style.width = "300px", i.style.background = "white", this.canvas instanceof HTMLCanvasElement && e.appendChild(this.canvas), e.appendChild(i);
      const s = this.props.onAddHTML(i);
      s && (i.innerHTML = s);
    }
  }
  _getSizeAndAspect() {
    if (!this.device)
      return { width: 1, height: 1, aspect: 1 };
    const [e, i] = this.device?.canvasContext?.getPixelSize() || [1, 1];
    let s = 1;
    const o = this.device?.canvasContext?.canvas;
    return o && o.clientHeight ? s = o.clientWidth / o.clientHeight : e > 0 && i > 0 && (s = e / i), { width: e, height: i, aspect: s };
  }
  /** Default viewport setup */
  _resizeViewport() {
    this.props.autoResizeViewport && this.device.gl && this.device.gl.viewport(
      0,
      0,
      // @ts-expect-error Expose canvasContext
      this.device.gl.drawingBufferWidth,
      // @ts-expect-error Expose canvasContext
      this.device.gl.drawingBufferHeight
    );
  }
  /**
   * Resize the render buffer of the canvas to match canvas client size
   * Optionally multiplying with devicePixel ratio
   */
  _resizeCanvasDrawingBuffer() {
    this.props.autoResizeDrawingBuffer && this.device?.canvasContext?.resize({ useDevicePixels: this.props.useDevicePixels });
  }
  _beginFrameTimers() {
    this.frameRate.timeEnd(), this.frameRate.timeStart(), this.cpuTime.timeStart();
  }
  _endFrameTimers() {
    this.cpuTime.timeEnd();
  }
  // Event handling
  _startEventHandling() {
    this.canvas && (this.canvas.addEventListener("mousemove", this._onMousemove.bind(this)), this.canvas.addEventListener("mouseleave", this._onMouseleave.bind(this)));
  }
  _onMousemove(e) {
    e instanceof MouseEvent && (this._getAnimationProps()._mousePosition = [e.offsetX, e.offsetY]);
  }
  _onMouseleave(e) {
    this._getAnimationProps()._mousePosition = null;
  }
}
class Kv {
  id;
  userData = {};
  /** Determines how vertices are read from the 'vertex' attributes */
  topology;
  bufferLayout = [];
  vertexCount;
  indices;
  attributes;
  constructor(e) {
    this.id = e.id || Pa("geometry"), this.topology = e.topology, this.indices = e.indices || null, this.attributes = e.attributes, this.vertexCount = e.vertexCount, this.bufferLayout = e.bufferLayout || [], this.indices && si(this.indices.usage === Mi.INDEX);
  }
  destroy() {
    this.indices?.destroy();
    for (const e of Object.values(this.attributes))
      e.destroy();
  }
  getVertexCount() {
    return this.vertexCount;
  }
  getAttributes() {
    return this.attributes;
  }
  getIndexes() {
    return this.indices;
  }
  _calculateVertexCount(e) {
    return e.byteLength / 12;
  }
}
function PD(t, e) {
  if (e instanceof Kv)
    return e;
  const i = BD(t, e), { attributes: s, bufferLayout: o } = DD(t, e);
  return new Kv({
    topology: e.topology || "triangle-list",
    bufferLayout: o,
    vertexCount: e.vertexCount,
    indices: i,
    attributes: s
  });
}
function BD(t, e) {
  if (!e.indices)
    return;
  const i = e.indices.value;
  return t.createBuffer({ usage: Mi.INDEX, data: i });
}
function DD(t, e) {
  const i = [], s = {};
  for (const [u, d] of Object.entries(e.attributes)) {
    let a = u;
    switch (u) {
      case "POSITION":
        a = "positions";
        break;
      case "NORMAL":
        a = "normals";
        break;
      case "TEXCOORD_0":
        a = "texCoords";
        break;
      case "COLOR_0":
        a = "colors";
        break;
    }
    s[a] = t.createBuffer({ data: d.value, id: `${u}-buffer` });
    const { value: w, size: S, normalized: M } = d;
    i.push({ name: a, format: PR(w, S, M) });
  }
  const o = e._calculateVertexCount(e.attributes, e.indices);
  return { attributes: s, bufferLayout: i, vertexCount: o };
}
class OD {
  /**
   * The map of modules
   * @todo should should this include the resolved dependencies?
   */
  modules;
  /** Stores the uniform values for each module */
  moduleUniforms;
  /** Stores the uniform bindings for each module  */
  moduleBindings;
  /** Tracks if uniforms have changed */
  moduleUniformsChanged;
  /**
   * Create a new UniformStore instance
   * @param modules
   */
  constructor(e) {
    const i = Sp(Object.values(e).filter((s) => s.dependencies));
    for (const s of i)
      e[s.name] = s;
    Je.log(1, "Creating ShaderInputs with modules", Object.keys(e))(), this.modules = e, this.moduleUniforms = {}, this.moduleBindings = {};
    for (const [s, o] of Object.entries(e)) {
      const u = s;
      this.moduleUniforms[u] = o.defaultUniforms || {}, this.moduleBindings[u] = {};
    }
  }
  /** Destroy */
  destroy() {
  }
  /**
   * Set module props
   */
  setProps(e) {
    for (const i of Object.keys(e)) {
      const s = i, o = e[s], u = this.modules[s];
      if (!u) {
        Je.warn(`Module ${i} not found`)();
        continue;
      }
      const d = this.moduleUniforms[s], a = this.moduleBindings[s], w = u.getUniforms?.(o, d) || o, { uniforms: S, bindings: M } = dy(w);
      this.moduleUniforms[s] = { ...d, ...S }, this.moduleBindings[s] = { ...a, ...M };
    }
  }
  /** Merges all bindings for the shader (from the various modules) */
  // getUniformBlocks(): Record<string, Texture | Sampler> {
  //   return this.moduleUniforms;
  // }
  /**
   * Return the map of modules
   * @todo should should this include the resolved dependencies?
   */
  getModules() {
    return Object.values(this.modules);
  }
  /** Get all uniform values for all modules */
  getUniformValues() {
    return this.moduleUniforms;
  }
  /** Merges all bindings for the shader (from the various modules) */
  getBindings() {
    const e = {};
    for (const i of Object.values(this.moduleBindings))
      Object.assign(e, i);
    return e;
  }
  getDebugTable() {
    const e = {};
    for (const [i, s] of Object.entries(this.moduleUniforms))
      for (const [o, u] of Object.entries(s))
        e[`${i}.${o}`] = {
          type: this.modules[i].uniformTypes?.[o],
          value: String(u)
        };
    return e;
  }
}
class My {
  static defaultProps = { ...nh.defaultProps };
  device;
  _hashCounter = 0;
  _hashes = {};
  _renderPipelineCache = {};
  _computePipelineCache = {};
  /** Get the singleton default pipeline factory for the specified device */
  static getDefaultPipelineFactory(e) {
    return e._lumaData.defaultPipelineFactory = e._lumaData.defaultPipelineFactory || new My(e), e._lumaData.defaultPipelineFactory;
  }
  constructor(e) {
    this.device = e;
  }
  /** Return a RenderPipeline matching props. Reuses a similar pipeline if already created. */
  createRenderPipeline(e) {
    const i = { ...nh.defaultProps, ...e }, s = this._hashRenderPipeline(i);
    if (!this._renderPipelineCache[s]) {
      const o = this.device.createRenderPipeline({
        ...i,
        id: i.id ? `${i.id}-cached` : void 0
      });
      o.hash = s, this._renderPipelineCache[s] = { pipeline: o, useCount: 0 };
    }
    return this._renderPipelineCache[s].useCount++, this._renderPipelineCache[s].pipeline;
  }
  createComputePipeline(e) {
    const i = { ...cp.defaultProps, ...e }, s = this._hashComputePipeline(i);
    if (!this._computePipelineCache[s]) {
      const o = this.device.createComputePipeline({
        ...i,
        id: i.id ? `${i.id}-cached` : void 0
      });
      o.hash = s, this._computePipelineCache[s] = { pipeline: o, useCount: 0 };
    }
    return this._computePipelineCache[s].useCount++, this._computePipelineCache[s].pipeline;
  }
  release(e) {
    const i = e.hash, s = e instanceof cp ? this._computePipelineCache : this._renderPipelineCache;
    s[i].useCount--, s[i].useCount === 0 && (s[i].pipeline.destroy(), delete s[i]);
  }
  // PRIVATE
  _hashComputePipeline(e) {
    return `${this._getHash(e.shader.source)}`;
  }
  /** Calculate a hash based on all the inputs for a render pipeline */
  _hashRenderPipeline(e) {
    const i = this._getHash(e.vs.source), s = e.fs ? this._getHash(e.fs.source) : 0, o = "-", u = this._getHash(JSON.stringify(e.bufferLayout));
    switch (this.device.type) {
      case "webgl":
        return `${i}/${s}V${o}BL${u}`;
      default:
        const d = this._getHash(JSON.stringify(e.parameters));
        return `${i}/${s}V${o}T${e.topology}P${d}BL${u}`;
    }
  }
  _getHash(e) {
    return this._hashes[e] === void 0 && (this._hashes[e] = this._hashCounter++), this._hashes[e];
  }
}
class Ry {
  static defaultProps = { ...Mp.defaultProps };
  device;
  _cache = {};
  /** Returns the default ShaderFactory for the given {@link Device}, creating one if necessary. */
  static getDefaultShaderFactory(e) {
    return e._lumaData.defaultShaderFactory ||= new Ry(e), e._lumaData.defaultShaderFactory;
  }
  /** @internal */
  constructor(e) {
    this.device = e;
  }
  /** Requests a {@link Shader} from the cache, creating a new Shader only if necessary. */
  createShader(e) {
    const i = this._hashShader(e);
    let s = this._cache[i];
    if (!s) {
      const o = this.device.createShader({
        ...e,
        id: e.id ? `${e.id}-cached` : void 0
      });
      this._cache[i] = s = { shader: o, useCount: 0 };
    }
    return s.useCount++, s.shader;
  }
  /** Releases a previously-requested {@link Shader}, destroying it if no users remain. */
  release(e) {
    const i = this._hashShader(e), s = this._cache[i];
    s && (s.useCount--, s.useCount === 0 && (delete this._cache[i], s.shader.destroy()));
  }
  // PRIVATE
  _hashShader(e) {
    return `${e.stage}:${e.source}`;
  }
}
function FD(t, e) {
  const i = {}, s = "Values";
  if (t.attributes.length === 0 && !t.varyings?.length)
    return { "No attributes or varyings": { [s]: "N/A" } };
  for (const o of t.attributes)
    if (o) {
      const u = `${o.location} ${o.name}: ${o.type}`;
      i[`in ${u}`] = { [s]: o.stepMode || "vertex" };
    }
  for (const o of t.varyings || []) {
    const u = `${o.location} ${o.name}`;
    i[`out ${u}`] = { [s]: JSON.stringify(o.accessor) };
  }
  return i;
}
let Pr = null, yg = null;
function kD(t, { id: e, minimap: i, opaque: s, top: o = "0", left: u = "0", rgbaScale: d = 1 }) {
  Pr || (Pr = document.createElement("canvas"), Pr.id = e, Pr.title = e, Pr.style.zIndex = "100", Pr.style.position = "absolute", Pr.style.top = o, Pr.style.left = u, Pr.style.border = "blue 1px solid", Pr.style.transform = "scaleY(-1)", document.body.appendChild(Pr), yg = Pr.getContext("2d")), (Pr.width !== t.width || Pr.height !== t.height) && (Pr.width = t.width / 2, Pr.height = t.height / 2, Pr.style.width = "400px", Pr.style.height = "400px");
  const a = t.device.readPixelsToArrayWebGL(t), w = yg.createImageData(t.width, t.height), S = 0;
  for (let M = 0; M < a.length; M += 4)
    w.data[S + M + 0] = a[M + 0] * d, w.data[S + M + 1] = a[M + 1] * d, w.data[S + M + 2] = a[M + 2] * d, w.data[S + M + 3] = s ? 255 : a[M + 3] * d;
  yg.putImageData(w, 0, 0);
}
const kc = 2, ND = 1e4;
class Ca {
  static defaultProps = {
    ...nh.defaultProps,
    source: null,
    vs: null,
    fs: null,
    id: "unnamed",
    handle: void 0,
    userData: {},
    defines: {},
    modules: [],
    moduleSettings: void 0,
    geometry: null,
    indexBuffer: null,
    attributes: {},
    constantAttributes: {},
    varyings: [],
    isInstanced: void 0,
    instanceCount: 0,
    vertexCount: 0,
    shaderInputs: void 0,
    pipelineFactory: void 0,
    shaderFactory: void 0,
    transformFeedback: void 0,
    shaderAssembler: wl.getDefaultShaderAssembler(),
    debugShaders: void 0,
    disableWarnings: void 0
  };
  device;
  id;
  source;
  vs;
  fs;
  pipelineFactory;
  shaderFactory;
  userData = {};
  // Fixed properties (change can trigger pipeline rebuild)
  /** The render pipeline GPU parameters, depth testing etc */
  parameters;
  /** The primitive topology */
  topology;
  /** Buffer layout */
  bufferLayout;
  // Dynamic properties
  /** Use instanced rendering */
  isInstanced = void 0;
  /** instance count. `undefined` means not instanced */
  instanceCount = 0;
  /** Vertex count */
  vertexCount;
  /** Index buffer */
  indexBuffer = null;
  /** Buffer-valued attributes */
  bufferAttributes = {};
  /** Constant-valued attributes */
  constantAttributes = {};
  /** Bindings (textures, samplers, uniform buffers) */
  bindings = {};
  /** Sets uniforms @deprecated Use uniform buffers and setBindings() for portability*/
  uniforms = {};
  /**
   * VertexArray
   * @note not implemented: if bufferLayout is updated, vertex array has to be rebuilt!
   * @todo - allow application to define multiple vertex arrays?
   * */
  vertexArray;
  /** TransformFeedback, WebGL 2 only. */
  transformFeedback = null;
  /** The underlying GPU "program". @note May be recreated if parameters change */
  pipeline;
  /** ShaderInputs instance */
  shaderInputs;
  _uniformStore;
  _attributeInfos = {};
  _gpuGeometry = null;
  _getModuleUniforms;
  props;
  _pipelineNeedsUpdate = "newly created";
  _needsRedraw = "initializing";
  _destroyed = !1;
  /** "Time" of last draw. Monotonically increasing timestamp */
  _lastDrawTimestamp = -1;
  constructor(e, i) {
    this.props = { ...Ca.defaultProps, ...i }, i = this.props, this.id = i.id || Pa("model"), this.device = e, Object.assign(this.userData, i.userData);
    const s = Object.fromEntries(this.props.modules?.map((a) => [a.name, a]) || []);
    this.setShaderInputs(i.shaderInputs || new OD(s));
    const o = LD(e), u = (this.props.modules?.length > 0 ? this.props.modules : this.shaderInputs?.getModules()) || [];
    if (this.device.type === "webgpu" && this.props.source) {
      this.props.shaderLayout ||= xP(this.props.source);
      const { source: a, getUniforms: w } = this.props.shaderAssembler.assembleShader({
        platformInfo: o,
        ...this.props,
        modules: u
      });
      this.source = a, this._getModuleUniforms = w;
    } else {
      const { vs: a, fs: w, getUniforms: S } = this.props.shaderAssembler.assembleShaderPair({
        platformInfo: o,
        ...this.props,
        modules: u
      });
      this.vs = a, this.fs = w, this._getModuleUniforms = S;
    }
    this.vertexCount = this.props.vertexCount, this.instanceCount = this.props.instanceCount, this.topology = this.props.topology, this.bufferLayout = this.props.bufferLayout, this.parameters = this.props.parameters, i.geometry && this.setGeometry(i.geometry), this.pipelineFactory = i.pipelineFactory || My.getDefaultPipelineFactory(this.device), this.shaderFactory = i.shaderFactory || Ry.getDefaultShaderFactory(this.device), this.pipeline = this._updatePipeline(), this.vertexArray = e.createVertexArray({
      renderPipeline: this.pipeline
    }), this._gpuGeometry && this._setGeometryAttributes(this._gpuGeometry), "isInstanced" in i && (this.isInstanced = i.isInstanced), i.instanceCount && this.setInstanceCount(i.instanceCount), i.vertexCount && this.setVertexCount(i.vertexCount), i.indexBuffer && this.setIndexBuffer(i.indexBuffer), i.attributes && this.setAttributes(i.attributes), i.constantAttributes && this.setConstantAttributes(i.constantAttributes), i.bindings && this.setBindings(i.bindings), i.uniforms && this.setUniforms(i.uniforms), i.moduleSettings && this.updateModuleSettings(i.moduleSettings), i.transformFeedback && (this.transformFeedback = i.transformFeedback), Object.seal(this);
  }
  destroy() {
    this._destroyed || (this.pipelineFactory.release(this.pipeline), this.shaderFactory.release(this.pipeline.vs), this.pipeline.fs && this.shaderFactory.release(this.pipeline.fs), this._uniformStore.destroy(), this._gpuGeometry?.destroy(), this._destroyed = !0);
  }
  // Draw call
  /** Query redraw status. Clears the status. */
  needsRedraw() {
    this._getBindingsUpdateTimestamp() > this._lastDrawTimestamp && this.setNeedsRedraw("contents of bound textures or buffers updated");
    const e = this._needsRedraw;
    return this._needsRedraw = !1, e;
  }
  /** Mark the model as needing a redraw */
  setNeedsRedraw(e) {
    this._needsRedraw ||= e;
  }
  predraw() {
    this.updateShaderInputs(), this.pipeline = this._updatePipeline();
  }
  draw(e) {
    this.predraw();
    let i;
    try {
      this._logDrawCallStart(), this.pipeline = this._updatePipeline(), this.pipeline.setBindings(this.bindings, { disableWarnings: this.props.disableWarnings }), lp(this.uniforms) || this.pipeline.setUniformsWebGL(this.uniforms);
      const { indexBuffer: s } = this.vertexArray, o = s ? s.byteLength / (s.indexType === "uint32" ? 4 : 2) : void 0;
      i = this.pipeline.draw({
        renderPass: e,
        vertexArray: this.vertexArray,
        isInstanced: this.isInstanced,
        vertexCount: this.vertexCount,
        instanceCount: this.instanceCount,
        indexCount: o,
        transformFeedback: this.transformFeedback || void 0,
        // WebGL shares underlying cached pipelines even for models that have different parameters and topology,
        // so we must provide our unique parameters to each draw
        // (In WebGPU most parameters are encoded in the pipeline and cannot be changed per draw call)
        parameters: this.parameters,
        topology: this.topology
      });
    } finally {
      this._logDrawCallEnd();
    }
    return this._logFramebuffer(e), i ? (this._lastDrawTimestamp = this.device.timestamp, this._needsRedraw = !1) : this._needsRedraw = "waiting for resource initialization", i;
  }
  // Update fixed fields (can trigger pipeline rebuild)
  /**
   * Updates the optional geometry
   * Geometry, set topology and bufferLayout
   * @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU
   */
  setGeometry(e) {
    this._gpuGeometry?.destroy();
    const i = e && PD(this.device, e);
    i && (this.setTopology(i.topology || "triangle-list"), this.bufferLayout = Yv(i.bufferLayout, this.bufferLayout), this.vertexArray && this._setGeometryAttributes(i)), this._gpuGeometry = i;
  }
  /**
   * Updates the primitive topology ('triangle-list', 'triangle-strip' etc).
   * @note Triggers a pipeline rebuild / pipeline cache fetch on WebGPU
   */
  setTopology(e) {
    e !== this.topology && (this.topology = e, this._setPipelineNeedsUpdate("topology"));
  }
  /**
   * Updates the buffer layout.
   * @note Triggers a pipeline rebuild / pipeline cache fetch
   */
  setBufferLayout(e) {
    this.bufferLayout = this._gpuGeometry ? Yv(e, this._gpuGeometry.bufferLayout) : e, this._setPipelineNeedsUpdate("bufferLayout"), this.pipeline = this._updatePipeline(), this.vertexArray = this.device.createVertexArray({
      renderPipeline: this.pipeline
    }), this._gpuGeometry && this._setGeometryAttributes(this._gpuGeometry);
  }
  /**
   * Set GPU parameters.
   * @note Can trigger a pipeline rebuild / pipeline cache fetch.
   * @param parameters
   */
  setParameters(e) {
    dm(e, this.parameters, 2) || (this.parameters = e, this._setPipelineNeedsUpdate("parameters"));
  }
  // Update dynamic fields
  /**
   * Updates the instance count (used in draw calls)
   * @note Any attributes with stepMode=instance need to be at least this big
   */
  setInstanceCount(e) {
    this.instanceCount = e, this.isInstanced === void 0 && e > 0 && (this.isInstanced = !0), this.setNeedsRedraw("instanceCount");
  }
  /**
   * Updates the vertex count (used in draw calls)
   * @note Any attributes with stepMode=vertex need to be at least this big
   */
  setVertexCount(e) {
    this.vertexCount = e, this.setNeedsRedraw("vertexCount");
  }
  /** Set the shader inputs */
  setShaderInputs(e) {
    this.shaderInputs = e, this._uniformStore = new RR(this.shaderInputs.modules);
    for (const i of Object.keys(this.shaderInputs.modules)) {
      const s = this._uniformStore.getManagedUniformBuffer(this.device, i);
      this.bindings[`${i}Uniforms`] = s;
    }
    this.setNeedsRedraw("shaderInputs");
  }
  /** Update uniform buffers from the model's shader inputs */
  updateShaderInputs() {
    this._uniformStore.setUniforms(this.shaderInputs.getUniformValues()), this.setBindings(this.shaderInputs.getBindings()), this.setNeedsRedraw("shaderInputs");
  }
  /**
   * Sets bindings (textures, samplers, uniform buffers)
   */
  setBindings(e) {
    Object.assign(this.bindings, e), this.setNeedsRedraw("bindings");
  }
  /**
   * Updates optional transform feedback. WebGL only.
   */
  setTransformFeedback(e) {
    this.transformFeedback = e, this.setNeedsRedraw("transformFeedback");
  }
  /**
   * Sets the index buffer
   * @todo - how to unset it if we change geometry?
   */
  setIndexBuffer(e) {
    this.vertexArray.setIndexBuffer(e), this.setNeedsRedraw("indexBuffer");
  }
  /**
   * Sets attributes (buffers)
   * @note Overrides any attributes previously set with the same name
   */
  setAttributes(e, i) {
    e.indices && Je.warn(`Model:${this.id} setAttributes() - indexBuffer should be set using setIndexBuffer()`)();
    for (const [s, o] of Object.entries(e)) {
      const u = this.bufferLayout.find((w) => Jv(w).includes(s));
      if (!u) {
        Je.warn(`Model(${this.id}): Missing layout for buffer "${s}".`)();
        continue;
      }
      const d = Jv(u);
      let a = !1;
      for (const w of d) {
        const S = this._attributeInfos[w];
        S && (this.vertexArray.setBuffer(S.location, o), a = !0);
      }
      !a && !(i?.disableWarnings ?? this.props.disableWarnings) && Je.warn(`Model(${this.id}): Ignoring buffer "${o.id}" for unknown attribute "${s}"`)();
    }
    this.setNeedsRedraw("attributes");
  }
  /**
   * Sets constant attributes
   * @note Overrides any attributes previously set with the same name
   * Constant attributes are only supported in WebGL, not in WebGPU
   * Any attribute that is disabled in the current vertex array object
   * is read from the context's global constant value for that attribute location.
   * @param constantAttributes
   */
  setConstantAttributes(e, i) {
    for (const [s, o] of Object.entries(e)) {
      const u = this._attributeInfos[s];
      u ? this.vertexArray.setConstantWebGL(u.location, o) : (i?.disableWarnings ?? this.props.disableWarnings) || Je.warn(`Model "${this.id}: Ignoring constant supplied for unknown attribute "${s}"`)();
    }
    this.setNeedsRedraw("constants");
  }
  // DEPRECATED METHODS
  /**
   * Sets individual uniforms
   * @deprecated WebGL only, use uniform buffers for portability
   * @param uniforms
   */
  setUniforms(e) {
    lp(e) || (this.pipeline.setUniformsWebGL(e), Object.assign(this.uniforms, e)), this.setNeedsRedraw("uniforms");
  }
  /**
   * @deprecated Updates shader module settings (which results in uniforms being set)
   */
  updateModuleSettings(e) {
    const { bindings: i, uniforms: s } = dy(this._getModuleUniforms(e));
    Object.assign(this.bindings, i), Object.assign(this.uniforms, s), this.setNeedsRedraw("moduleSettings");
  }
  // Internal methods
  /** Get the timestamp of the latest updated bound GPU memory resource (buffer/texture). */
  _getBindingsUpdateTimestamp() {
    let e = 0;
    for (const i of Object.values(this.bindings))
      i instanceof Ip ? e = Math.max(e, i.texture.updateTimestamp) : i instanceof Mi || i instanceof qs ? e = Math.max(e, i.updateTimestamp) : i instanceof Rp || (e = Math.max(e, i.buffer.updateTimestamp));
    return e;
  }
  /**
   * Updates the optional geometry attributes
   * Geometry, sets several attributes, indexBuffer, and also vertex count
   * @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU
   */
  _setGeometryAttributes(e) {
    const i = { ...e.attributes };
    for (const [s] of Object.entries(i))
      !this.pipeline.shaderLayout.attributes.find((o) => o.name === s) && s !== "positions" && delete i[s];
    this.vertexCount = e.vertexCount, this.setIndexBuffer(e.indices || null), this.setAttributes(e.attributes, { disableWarnings: !0 }), this.setAttributes(i, { disableWarnings: this.props.disableWarnings }), this.setNeedsRedraw("geometry attributes");
  }
  /** Mark pipeline as needing update */
  _setPipelineNeedsUpdate(e) {
    this._pipelineNeedsUpdate ||= e, this.setNeedsRedraw(e);
  }
  /** Update pipeline if needed */
  _updatePipeline() {
    if (this._pipelineNeedsUpdate) {
      let e = null, i = null;
      this.pipeline && (Je.log(1, `Model ${this.id}: Recreating pipeline because "${this._pipelineNeedsUpdate}".`)(), e = this.pipeline.vs, i = this.pipeline.fs), this._pipelineNeedsUpdate = !1;
      const s = this.shaderFactory.createShader({
        id: `${this.id}-vertex`,
        stage: "vertex",
        source: this.source || this.vs,
        debug: this.props.debugShaders
      });
      let o = null;
      this.source ? o = s : this.fs && (o = this.shaderFactory.createShader({
        id: `${this.id}-fragment`,
        stage: "fragment",
        source: this.source || this.fs,
        debug: this.props.debugShaders
      })), this.pipeline = this.pipelineFactory.createRenderPipeline({
        ...this.props,
        bufferLayout: this.bufferLayout,
        topology: this.topology,
        parameters: this.parameters,
        vs: s,
        fs: o
      }), this._attributeInfos = Lw(this.pipeline.shaderLayout, this.bufferLayout), e && this.shaderFactory.release(e), i && this.shaderFactory.release(i);
    }
    return this.pipeline;
  }
  /** Throttle draw call logging */
  _lastLogTime = 0;
  _logOpen = !1;
  _logDrawCallStart() {
    const e = Je.level > 3 ? 0 : ND;
    Je.level < 2 || Date.now() - this._lastLogTime < e || (this._lastLogTime = Date.now(), this._logOpen = !0, Je.group(kc, `>>> DRAWING MODEL ${this.id}`, { collapsed: Je.level <= 2 })());
  }
  _logDrawCallEnd() {
    if (this._logOpen) {
      const e = FD(this.pipeline.shaderLayout, this.id);
      Je.table(kc, e)();
      const i = this.shaderInputs.getDebugTable();
      for (const [o, u] of Object.entries(this.uniforms))
        i[o] = { value: u };
      Je.table(kc, i)();
      const s = this._getAttributeDebugTable();
      Je.table(kc, this._attributeInfos)(), Je.table(kc, s)(), Je.groupEnd(kc)(), this._logOpen = !1;
    }
  }
  _drawCount = 0;
  _logFramebuffer(e) {
    const i = Je.get("framebuffer");
    if (this._drawCount++, !i || this._drawCount++ > 3 && this._drawCount % 60)
      return;
    const s = e.props.framebuffer;
    s && kD(s, { id: s.id, minimap: !0 });
  }
  _getAttributeDebugTable() {
    const e = {};
    for (const [i, s] of Object.entries(this._attributeInfos))
      e[s.location] = {
        name: i,
        type: s.shaderType,
        values: this._getBufferOrConstantValues(this.vertexArray.attributes[s.location], s.bufferDataType)
      };
    if (this.vertexArray.indexBuffer) {
      const { indexBuffer: i } = this.vertexArray, s = i.indexType === "uint32" ? new Uint32Array(i.debugData) : new Uint16Array(i.debugData);
      e.indices = {
        name: "indices",
        type: i.indexType,
        values: s.toString()
      };
    }
    return e;
  }
  // TODO - fix typing of luma data types
  _getBufferOrConstantValues(e, i) {
    const s = Vw(i);
    return (e instanceof Mi ? new s(e.debugData) : e).toString();
  }
}
function Yv(t, e) {
  const i = [...t];
  for (const s of e) {
    const o = i.findIndex((u) => u.name === s.name);
    o < 0 ? i.push(s) : i[o] = s;
  }
  return i;
}
function LD(t) {
  return {
    type: t.type,
    shaderLanguage: t.info.shadingLanguage,
    shaderLanguageVersion: t.info.shadingLanguageVersion,
    gpu: t.info.gpu,
    // HACK - we pretend that the DeviceFeatures is a Set, it has a similar API
    features: t.features
  };
}
function Jv(t) {
  return t.attributes ? t.attributes?.map((e) => e.attribute) : [t.name];
}
class Yu {
  device;
  model;
  transformFeedback;
  /** @deprecated Use device feature test. */
  static isSupported(e) {
    return e?.info?.type === "webgl";
  }
  constructor(e, i = Ca.defaultProps) {
    si(Yu.isSupported(e), "BufferTransform not yet implemented on WebGPU"), this.device = e, this.model = new Ca(this.device, {
      id: i.id || "buffer-transform-model",
      fs: i.fs || BM(),
      topology: i.topology || "point-list",
      ...i
    }), this.transformFeedback = this.device.createTransformFeedback({
      layout: this.model.pipeline.shaderLayout,
      buffers: i.feedbackBuffers
    }), this.model.setTransformFeedback(this.transformFeedback), Object.seal(this);
  }
  /** Destroy owned resources. */
  destroy() {
    this.model && this.model.destroy();
  }
  /** @deprecated Use {@link destroy}. */
  delete() {
    this.destroy();
  }
  /** Run one transform loop. */
  run(e) {
    const i = this.device.beginRenderPass(e);
    this.model.draw(i), i.end();
  }
  /** @deprecated */
  update(...e) {
    console.warn("TextureTransform#update() not implemented");
  }
  /** Returns the {@link Buffer} or {@link BufferRange} for given varying name. */
  getBuffer(e) {
    return this.transformFeedback.getBuffer(e);
  }
  readAsync(e) {
    const i = this.getBuffer(e);
    if (i instanceof Mi)
      return i.readAsync();
    const { buffer: s, byteOffset: o = 0, byteLength: u = s.byteLength } = i;
    return s.readAsync(o, u);
  }
}
class eh {
  id;
  /** Determines how vertices are read from the 'vertex' attributes */
  topology;
  vertexCount;
  indices;
  attributes;
  userData = {};
  constructor(e) {
    const { attributes: i = {}, indices: s = null, vertexCount: o = null } = e;
    this.id = e.id || Pa("geometry"), this.topology = e.topology, s && (this.indices = ArrayBuffer.isView(s) ? { value: s, size: 1 } : s), this.attributes = {};
    for (const [u, d] of Object.entries(i)) {
      const a = ArrayBuffer.isView(d) ? { value: d } : d;
      si(ArrayBuffer.isView(a.value), `${this._print(u)}: must be typed array or object with value as typed array`), (u === "POSITION" || u === "positions") && !a.size && (a.size = 3), u === "indices" ? (si(!this.indices), this.indices = a) : this.attributes[u] = a;
    }
    this.indices && this.indices.isIndexed !== void 0 && (this.indices = Object.assign({}, this.indices), delete this.indices.isIndexed), this.vertexCount = o || this._calculateVertexCount(this.attributes, this.indices);
  }
  getVertexCount() {
    return this.vertexCount;
  }
  /**
   * Return an object with all attributes plus indices added as a field.
   * TODO Geometry types are a mess
   */
  getAttributes() {
    return this.indices ? { indices: this.indices, ...this.attributes } : this.attributes;
  }
  // PRIVATE
  _print(e) {
    return `Geometry ${this.id} attribute ${e}`;
  }
  /**
   * GeometryAttribute
   * value: typed array
   * type: indices, vertices, uvs
   * size: elements per vertex
   * target: WebGL buffer type (string or constant)
   *
   * @param attributes
   * @param indices
   * @returns
   */
  _setAttributes(e, i) {
    return this;
  }
  _calculateVertexCount(e, i) {
    if (i)
      return i.value.length;
    let s = 1 / 0;
    for (const o of Object.values(e)) {
      const { value: u, size: d, constant: a } = o;
      !a && u && d >= 1 && (s = Math.min(s, u.length / d));
    }
    return si(Number.isFinite(s)), s;
  }
}
class gp {
  id;
  matrix = new Gt();
  display = !0;
  position = new Be();
  rotation = new Be();
  scale = new Be(1, 1, 1);
  userData = {};
  props = {};
  constructor(e = {}) {
    const { id: i } = e;
    this.id = i || Pa(this.constructor.name), this._setScenegraphNodeProps(e);
  }
  getBounds() {
    return null;
  }
  destroy() {
  }
  /** @deprecated use .destroy() */
  delete() {
    this.destroy();
  }
  setProps(e) {
    return this._setScenegraphNodeProps(e), this;
  }
  toString() {
    return `{type: ScenegraphNode, id: ${this.id})}`;
  }
  setPosition(e) {
    return si(e.length === 3, "setPosition requires vector argument"), this.position = e, this;
  }
  setRotation(e) {
    return si(e.length === 3, "setRotation requires vector argument"), this.rotation = e, this;
  }
  setScale(e) {
    return si(e.length === 3, "setScale requires vector argument"), this.scale = e, this;
  }
  setMatrix(e, i = !0) {
    i ? this.matrix.copy(e) : this.matrix = e;
  }
  setMatrixComponents(e) {
    const { position: i, rotation: s, scale: o, update: u = !0 } = e;
    return i && this.setPosition(i), s && this.setRotation(s), o && this.setScale(o), u && this.updateMatrix(), this;
  }
  updateMatrix() {
    const e = this.position, i = this.rotation, s = this.scale;
    return this.matrix.identity(), this.matrix.translate(e), this.matrix.rotateXYZ(i), this.matrix.scale(s), this;
  }
  update(e = {}) {
    const { position: i, rotation: s, scale: o } = e;
    return i && this.setPosition(i), s && this.setRotation(s), o && this.setScale(o), this.updateMatrix(), this;
  }
  getCoordinateUniforms(e, i) {
    si(e), i = i || this.matrix;
    const s = new Gt(e).multiplyRight(i), o = s.invert(), u = o.transpose();
    return {
      viewMatrix: e,
      modelMatrix: i,
      objectMatrix: i,
      worldMatrix: s,
      worldInverseMatrix: o,
      worldInverseTransposeMatrix: u
    };
  }
  // TODO - copied code, not yet vetted
  /*
    transform() {
      if (!this.parent) {
        this.endPosition.set(this.position);
        this.endRotation.set(this.rotation);
        this.endScale.set(this.scale);
      } else {
        const parent = this.parent;
        this.endPosition.set(this.position.add(parent.endPosition));
        this.endRotation.set(this.rotation.add(parent.endRotation));
        this.endScale.set(this.scale.add(parent.endScale));
      }
  
      const ch = this.children;
      for (let i = 0; i < ch.length; ++i) {
        ch[i].transform();
      }
  
      return this;
    }
    */
  _setScenegraphNodeProps(e) {
    "display" in e && (this.display = e.display), "position" in e && this.setPosition(e.position), "rotation" in e && this.setRotation(e.rotation), "scale" in e && this.setScale(e.scale), "matrix" in e && this.setMatrix(e.matrix), Object.assign(this.props, e);
  }
}
class th extends gp {
  children;
  constructor(e = {}) {
    e = Array.isArray(e) ? { children: e } : e;
    const { children: i = [] } = e;
    Je.assert(i.every((s) => s instanceof gp), "every child must an instance of ScenegraphNode"), super(e), this.children = i;
  }
  getBounds() {
    const e = [
      [1 / 0, 1 / 0, 1 / 0],
      [-1 / 0, -1 / 0, -1 / 0]
    ];
    return this.traverse((i, { worldMatrix: s }) => {
      const o = i.getBounds();
      if (!o)
        return;
      const [u, d] = o, a = new Be(u).add(d).divide([2, 2, 2]);
      s.transformAsPoint(a, a);
      const w = new Be(d).subtract(u).divide([2, 2, 2]);
      s.transformAsVector(w, w);
      for (let S = 0; S < 8; S++) {
        const M = new Be(S & 1 ? -1 : 1, S & 2 ? -1 : 1, S & 4 ? -1 : 1).multiply(w).add(a);
        for (let F = 0; F < 3; F++)
          e[0][F] = Math.min(e[0][F], M[F]), e[1][F] = Math.max(e[1][F], M[F]);
      }
    }), Number.isFinite(e[0][0]) ? e : null;
  }
  destroy() {
    this.children.forEach((e) => e.destroy()), this.removeAll(), super.destroy();
  }
  // Unpacks arrays and nested arrays of children
  add(...e) {
    for (const i of e)
      Array.isArray(i) ? this.add(...i) : this.children.push(i);
    return this;
  }
  remove(e) {
    const i = this.children, s = i.indexOf(e);
    return s > -1 && i.splice(s, 1), this;
  }
  removeAll() {
    return this.children = [], this;
  }
  traverse(e, { worldMatrix: i = new Gt() } = {}) {
    const s = new Gt(i).multiplyRight(this.matrix);
    for (const o of this.children)
      o instanceof th ? o.traverse(e, { worldMatrix: s }) : e(o, { worldMatrix: s });
  }
}
class Am extends gp {
  model;
  bounds = null;
  managedResources;
  // TODO - is this used? override callbacks to make sure we call them with this
  // onBeforeRender = null;
  // onAfterRender = null;
  // AfterRender = null;
  constructor(e) {
    super(e), this.model = e.model, this.managedResources = e.managedResources || [], this.bounds = e.bounds || null, this.setProps(e);
  }
  getBounds() {
    return this.bounds;
  }
  destroy() {
    this.model && (this.model.destroy(), this.model = null), this.managedResources.forEach((e) => e.destroy()), this.managedResources = [];
  }
  // Expose model methods
  draw(e) {
    return this.model.draw(e);
  }
}
const UD = {
  blendColorOperation: "add",
  blendColorSrcFactor: "one",
  blendColorDstFactor: "zero",
  blendAlphaOperation: "add",
  blendAlphaSrcFactor: "constant-alpha",
  blendAlphaDstFactor: "zero"
};
class PT extends Iy {
  constructor() {
    super(...arguments), this._colorEncoderState = null;
  }
  render(e) {
    return "pickingFBO" in e ? this._drawPickingBuffer(e) : super.render(e);
  }
  // Private
  // Draws list of layers and viewports into the picking buffer
  // Note: does not sample the buffer, that has to be done by the caller
  _drawPickingBuffer({ layers: e, layerFilter: i, views: s, viewports: o, onViewportActive: u, pickingFBO: d, deviceRect: { x: a, y: w, width: S, height: M }, cullRect: F, effects: N, pass: L = "picking", pickZ: re, moduleParameters: ne }) {
    this.pickZ = re;
    const we = this._resetColorEncoder(re), Se = [a, w, S, M], Ee = super.render({
      target: d,
      layers: e,
      layerFilter: i,
      views: s,
      viewports: o,
      onViewportActive: u,
      cullRect: F,
      effects: N?.filter((Le) => Le.useInPicking),
      pass: L,
      isPicking: !0,
      moduleParameters: ne,
      clearColor: [0, 0, 0, 0],
      colorMask: 15,
      scissorRect: Se
    });
    return this._colorEncoderState = null, { decodePickingColor: we && VD.bind(null, we), stats: Ee };
  }
  shouldDrawLayer(e) {
    const { pickable: i, operation: s } = e.props;
    return i && s.includes("draw") || s.includes("terrain") || s.includes("mask");
  }
  getModuleParameters() {
    return {
      picking: {
        isActive: 1,
        isAttribute: this.pickZ
      },
      // turn off lighting by adding empty light source object
      // lights shader module relies on the `lightSources` to turn on/off lighting
      lightSources: {}
    };
  }
  getLayerParameters(e, i, s) {
    const o = {
      // TODO - When used as a custom layer in older Mapbox versions, context
      // state was dirty. Mapbox fixed that; we should test and remove the workaround.
      // https://github.com/mapbox/mapbox-gl-js/issues/7801
      depthMask: !0,
      depthTest: !0,
      depthRange: [0, 1],
      ...e.props.parameters
    }, { pickable: u, operation: d } = e.props;
    return !this._colorEncoderState || d.includes("terrain") ? o.blend = !1 : u && d.includes("draw") && (Object.assign(o, UD), o.blend = !0, o.blendColor = zD(this._colorEncoderState, e, s)), o;
  }
  _resetColorEncoder(e) {
    return this._colorEncoderState = e ? null : {
      byLayer: /* @__PURE__ */ new Map(),
      byAlpha: []
    }, this._colorEncoderState;
  }
}
function zD(t, e, i) {
  const { byLayer: s, byAlpha: o } = t;
  let u, d = s.get(e);
  return d ? (d.viewports.push(i), u = d.a) : (u = s.size + 1, u <= 255 ? (d = { a: u, layer: e, viewports: [i] }, s.set(e, d), o[u] = d) : (Jt.warn("Too many pickable layers, only picking the first 255")(), u = 0)), [0, 0, 0, u / 255];
}
function VD(t, e) {
  const i = t.byAlpha[e[3]];
  return i && {
    pickedLayer: i.layer,
    pickedViewports: i.viewports,
    pickedObjectIndex: i.layer.decodePickingColor(e)
  };
}
const Vc = {
  NO_STATE: "Awaiting state",
  MATCHED: "Matched. State transferred from previous layer",
  INITIALIZED: "Initialized",
  AWAITING_GC: "Discarded. Awaiting garbage collection",
  AWAITING_FINALIZATION: "No longer matched. Awaiting garbage collection",
  FINALIZED: "Finalized! Awaiting garbage collection"
}, mp = Symbol.for("component"), Ta = Symbol.for("propTypes"), bg = Symbol.for("deprecatedProps"), ih = Symbol.for("asyncPropDefaults"), Ml = Symbol.for("asyncPropOriginal"), va = Symbol.for("asyncPropResolved");
function ch(t, e = () => !0) {
  return Array.isArray(t) ? BT(t, e, []) : e(t) ? [t] : [];
}
function BT(t, e, i) {
  let s = -1;
  for (; ++s < t.length; ) {
    const o = t[s];
    Array.isArray(o) ? BT(o, e, i) : e(o) && i.push(o);
  }
  return i;
}
function jD({ target: t, source: e, start: i = 0, count: s = 1 }) {
  const o = e.length, u = s * o;
  let d = 0;
  for (let a = i; d < o; d++)
    t[a++] = e[d];
  for (; d < u; )
    d < u - d ? (t.copyWithin(i + d, i, i + d), d *= 2) : (t.copyWithin(i + d, i, i + u - d), d = u);
  return t;
}
class HD {
  constructor(e, i, s) {
    this._loadCount = 0, this._subscribers = /* @__PURE__ */ new Set(), this.id = e, this.context = s, this.setData(i);
  }
  // consumer: {onChange: Function}
  subscribe(e) {
    this._subscribers.add(e);
  }
  unsubscribe(e) {
    this._subscribers.delete(e);
  }
  inUse() {
    return this._subscribers.size > 0;
  }
  delete() {
  }
  getData() {
    return this.isLoaded ? this._error ? Promise.reject(this._error) : this._content : this._loader.then(() => this.getData());
  }
  setData(e, i) {
    if (e === this._data && !i)
      return;
    this._data = e;
    const s = ++this._loadCount;
    let o = e;
    typeof e == "string" && (o = Ea(e)), o instanceof Promise ? (this.isLoaded = !1, this._loader = o.then((u) => {
      this._loadCount === s && (this.isLoaded = !0, this._error = void 0, this._content = u);
    }).catch((u) => {
      this._loadCount === s && (this.isLoaded = !0, this._error = u || !0);
    })) : (this.isLoaded = !0, this._error = void 0, this._content = e);
    for (const u of this._subscribers)
      u.onChange(this.getData());
  }
}
class $D {
  constructor(e) {
    this.protocol = e.protocol || "resource://", this._context = {
      device: e.device,
      // @ts-expect-error
      gl: e.device?.gl,
      resourceManager: this
    }, this._resources = {}, this._consumers = {}, this._pruneRequest = null;
  }
  contains(e) {
    return e.startsWith(this.protocol) ? !0 : e in this._resources;
  }
  add({ resourceId: e, data: i, forceUpdate: s = !1, persistent: o = !0 }) {
    let u = this._resources[e];
    u ? u.setData(i, s) : (u = new HD(e, i, this._context), this._resources[e] = u), u.persistent = o;
  }
  remove(e) {
    const i = this._resources[e];
    i && (i.delete(), delete this._resources[e]);
  }
  unsubscribe({ consumerId: e }) {
    const i = this._consumers[e];
    if (i) {
      for (const s in i) {
        const o = i[s], u = this._resources[o.resourceId];
        u && u.unsubscribe(o);
      }
      delete this._consumers[e], this.prune();
    }
  }
  subscribe({ resourceId: e, onChange: i, consumerId: s, requestId: o = "default" }) {
    const { _resources: u, protocol: d } = this;
    e.startsWith(d) && (e = e.replace(d, ""), u[e] || this.add({ resourceId: e, data: null, persistent: !1 }));
    const a = u[e];
    if (this._track(s, o, a, i), a)
      return a.getData();
  }
  prune() {
    this._pruneRequest || (this._pruneRequest = setTimeout(() => this._prune(), 0));
  }
  finalize() {
    for (const e in this._resources)
      this._resources[e].delete();
  }
  _track(e, i, s, o) {
    const u = this._consumers, d = u[e] = u[e] || {};
    let a = d[i];
    const w = a && a.resourceId && this._resources[a.resourceId];
    w && (w.unsubscribe(a), this.prune()), s && (a ? (a.onChange = o, a.resourceId = s.id) : a = {
      onChange: o,
      resourceId: s.id
    }, d[i] = a, s.subscribe(a));
  }
  _prune() {
    this._pruneRequest = null;
    for (const e of Object.keys(this._resources)) {
      const i = this._resources[e];
      !i.persistent && !i.inUse() && (i.delete(), delete this._resources[e]);
    }
  }
}
const GD = "layerManager.setLayers", WD = "layerManager.activateViewport";
class XD {
  /**
   * @param device
   * @param param1
   */
  // eslint-disable-next-line
  constructor(e, i) {
    this._lastRenderedLayers = [], this._needsRedraw = !1, this._needsUpdate = !1, this._nextLayers = null, this._debug = !1, this._defaultShaderModulesChanged = !1, this.activateViewport = (a) => {
      Yr(WD, this, a), a && (this.context.viewport = a);
    };
    const { deck: s, stats: o, viewport: u, timeline: d } = i || {};
    this.layers = [], this.resourceManager = new $D({ device: e, protocol: "deck://" }), this.context = {
      mousePosition: null,
      userData: {},
      layerManager: this,
      device: e,
      // @ts-expect-error
      gl: e?.gl,
      deck: s,
      shaderAssembler: tD(),
      defaultShaderModules: [],
      renderPass: void 0,
      stats: o || new _h({ id: "deck.gl" }),
      // Make sure context.viewport is not empty on the first layer initialization
      viewport: u || new cd({ id: "DEFAULT-INITIAL-VIEWPORT" }),
      // Current viewport, exposed to layers for project* function
      timeline: d || new RT(),
      resourceManager: this.resourceManager,
      onError: void 0
    }, Object.seal(this);
  }
  /** Method to call when the layer manager is not needed anymore. */
  finalize() {
    this.resourceManager.finalize();
    for (const e of this.layers)
      this._finalizeLayer(e);
  }
  /** Check if a redraw is needed */
  needsRedraw(e = { clearRedrawFlags: !1 }) {
    let i = this._needsRedraw;
    e.clearRedrawFlags && (this._needsRedraw = !1);
    for (const s of this.layers) {
      const o = s.getNeedsRedraw(e);
      i = i || o;
    }
    return i;
  }
  /** Check if a deep update of all layers is needed */
  needsUpdate() {
    return this._nextLayers && this._nextLayers !== this._lastRenderedLayers ? "layers changed" : this._defaultShaderModulesChanged ? "shader modules changed" : this._needsUpdate;
  }
  /** Layers will be redrawn (in next animation frame) */
  setNeedsRedraw(e) {
    this._needsRedraw = this._needsRedraw || e;
  }
  /** Layers will be updated deeply (in next animation frame)
    Potentially regenerating attributes and sub layers */
  setNeedsUpdate(e) {
    this._needsUpdate = this._needsUpdate || e;
  }
  /** Gets a list of currently rendered layers. Optionally filter by id. */
  getLayers({ layerIds: e } = {}) {
    return e ? this.layers.filter((i) => e.find((s) => i.id.indexOf(s) === 0)) : this.layers;
  }
  /** Set props needed for layer rendering and picking. */
  setProps(e) {
    "debug" in e && (this._debug = e.debug), "userData" in e && (this.context.userData = e.userData), "layers" in e && (this._nextLayers = e.layers), "onError" in e && (this.context.onError = e.onError);
  }
  /** Supply a new layer list, initiating sublayer generation and layer matching */
  setLayers(e, i) {
    Yr(GD, this, i, e), this._lastRenderedLayers = e;
    const s = ch(e, Boolean);
    for (const o of s)
      o.context = this.context;
    this._updateLayers(this.layers, s);
  }
  /** Update layers from last cycle if `setNeedsUpdate()` has been called */
  updateLayers() {
    const e = this.needsUpdate();
    e && (this.setNeedsRedraw(`updating layers: ${e}`), this.setLayers(this._nextLayers || this._lastRenderedLayers, e)), this._nextLayers = null;
  }
  /** Register a default shader module */
  addDefaultShaderModule(e) {
    const { defaultShaderModules: i } = this.context;
    i.find((s) => s.name === e.name) || (i.push(e), this._defaultShaderModulesChanged = !0);
  }
  /** Deregister a default shader module */
  removeDefaultShaderModule(e) {
    const { defaultShaderModules: i } = this.context, s = i.findIndex((o) => o.name === e.name);
    s >= 0 && (i.splice(s, 1), this._defaultShaderModulesChanged = !0);
  }
  _handleError(e, i, s) {
    s.raiseError(i, `${e} of ${s}`);
  }
  // TODO - mark layers with exceptions as bad and remove from rendering cycle?
  /** Match all layers, checking for caught errors
    to avoid having an exception in one layer disrupt other layers */
  _updateLayers(e, i) {
    const s = {};
    for (const d of e)
      s[d.id] ? Jt.warn(`Multiple old layers with same id ${d.id}`)() : s[d.id] = d;
    if (this._defaultShaderModulesChanged) {
      for (const d of e)
        d.setNeedsUpdate(), d.setChangeFlags({ extensionsChanged: !0 });
      this._defaultShaderModulesChanged = !1;
    }
    const o = [];
    this._updateSublayersRecursively(i, s, o), this._finalizeOldLayers(s);
    let u = !1;
    for (const d of o)
      if (d.hasUniformTransition()) {
        u = `Uniform transition in ${d}`;
        break;
      }
    this._needsUpdate = u, this.layers = o;
  }
  /* eslint-disable complexity,max-statements */
  // Note: adds generated layers to `generatedLayers` array parameter
  _updateSublayersRecursively(e, i, s) {
    for (const o of e) {
      o.context = this.context;
      const u = i[o.id];
      u === null && Jt.warn(`Multiple new layers with same id ${o.id}`)(), i[o.id] = null;
      let d = null;
      try {
        this._debug && u !== o && o.validateProps(), u ? (this._transferLayerState(u, o), this._updateLayer(o)) : this._initializeLayer(o), s.push(o), d = o.isComposite ? o.getSubLayers() : null;
      } catch (a) {
        this._handleError("matching", a, o);
      }
      d && this._updateSublayersRecursively(d, i, s);
    }
  }
  /* eslint-enable complexity,max-statements */
  // Finalize any old layers that were not matched
  _finalizeOldLayers(e) {
    for (const i in e) {
      const s = e[i];
      s && this._finalizeLayer(s);
    }
  }
  // / EXCEPTION SAFE LAYER ACCESS
  /** Safely initializes a single layer, calling layer methods */
  _initializeLayer(e) {
    try {
      e._initialize(), e.lifecycle = Vc.INITIALIZED;
    } catch (i) {
      this._handleError("initialization", i, e);
    }
  }
  /** Transfer state from one layer to a newer version */
  _transferLayerState(e, i) {
    i._transferState(e), i.lifecycle = Vc.MATCHED, i !== e && (e.lifecycle = Vc.AWAITING_GC);
  }
  /** Safely updates a single layer, cleaning all flags */
  _updateLayer(e) {
    try {
      e._update();
    } catch (i) {
      this._handleError("update", i, e);
    }
  }
  /** Safely finalizes a single layer, removing all resources */
  _finalizeLayer(e) {
    this._needsRedraw = this._needsRedraw || `finalized ${e}`, e.lifecycle = Vc.AWAITING_FINALIZATION;
    try {
      e._finalize(), e.lifecycle = Vc.FINALIZED;
    } catch (i) {
      this._handleError("finalization", i, e);
    }
  }
}
function Pn(t, e, i) {
  if (t === e)
    return !0;
  if (!i || !t || !e)
    return !1;
  if (Array.isArray(t)) {
    if (!Array.isArray(e) || t.length !== e.length)
      return !1;
    for (let s = 0; s < t.length; s++)
      if (!Pn(t[s], e[s], i - 1))
        return !1;
    return !0;
  }
  if (Array.isArray(e))
    return !1;
  if (typeof t == "object" && typeof e == "object") {
    const s = Object.keys(t), o = Object.keys(e);
    if (s.length !== o.length)
      return !1;
    for (const u of s)
      if (!e.hasOwnProperty(u) || !Pn(t[u], e[u], i - 1))
        return !1;
    return !0;
  }
  return !1;
}
class qD {
  constructor(e) {
    this.views = [], this.width = 100, this.height = 100, this.viewState = {}, this.controllers = {}, this.timeline = e.timeline, this._viewports = [], this._viewportMap = {}, this._isUpdating = !1, this._needsRedraw = "First render", this._needsUpdate = "Initialize", this._eventManager = e.eventManager, this._eventCallbacks = {
      onViewStateChange: e.onViewStateChange,
      onInteractionStateChange: e.onInteractionStateChange
    }, Object.seal(this), this.setProps(e);
  }
  /** Remove all resources and event listeners */
  finalize() {
    for (const e in this.controllers) {
      const i = this.controllers[e];
      i && i.finalize();
    }
    this.controllers = {};
  }
  /** Check if a redraw is needed */
  needsRedraw(e = { clearRedrawFlags: !1 }) {
    const i = this._needsRedraw;
    return e.clearRedrawFlags && (this._needsRedraw = !1), i;
  }
  /** Mark the manager as dirty. Will rebuild all viewports and update controllers. */
  setNeedsUpdate(e) {
    this._needsUpdate = this._needsUpdate || e, this._needsRedraw = this._needsRedraw || e;
  }
  /** Checks each viewport for transition updates */
  updateViewStates() {
    for (const e in this.controllers) {
      const i = this.controllers[e];
      i && i.updateTransition();
    }
  }
  /** Get a set of viewports for a given width and height
   * TODO - Intention is for deck.gl to autodeduce width and height and drop the need for props
   * @param rect (object, optional) - filter the viewports
   *   + not provided - return all viewports
   *   + {x, y} - only return viewports that contain this pixel
   *   + {x, y, width, height} - only return viewports that overlap with this rectangle
   */
  getViewports(e) {
    return e ? this._viewports.filter((i) => i.containsPixel(e)) : this._viewports;
  }
  /** Get a map of all views */
  getViews() {
    const e = {};
    return this.views.forEach((i) => {
      e[i.id] = i;
    }), e;
  }
  /** Resolves a viewId string to a View */
  getView(e) {
    return this.views.find((i) => i.id === e);
  }
  /** Returns the viewState for a specific viewId. Matches the viewState by
    1. view.viewStateId
    2. view.id
    3. root viewState
    then applies the view's filter if any */
  getViewState(e) {
    const i = typeof e == "string" ? this.getView(e) : e, s = i && this.viewState[i.getViewStateId()] || this.viewState;
    return i ? i.filterViewState(s) : s;
  }
  getViewport(e) {
    return this._viewportMap[e];
  }
  /**
   * Unproject pixel coordinates on screen onto world coordinates,
   * (possibly [lon, lat]) on map.
   * - [x, y] => [lng, lat]
   * - [x, y, z] => [lng, lat, Z]
   * @param {Array} xyz -
   * @param {Object} opts - options
   * @param {Object} opts.topLeft=true - Whether origin is top left
   * @return {Array|null} - [lng, lat, Z] or [X, Y, Z]
   */
  unproject(e, i) {
    const s = this.getViewports(), o = { x: e[0], y: e[1] };
    for (let u = s.length - 1; u >= 0; --u) {
      const d = s[u];
      if (d.containsPixel(o)) {
        const a = e.slice();
        return a[0] -= d.x, a[1] -= d.y, d.unproject(a, i);
      }
    }
    return null;
  }
  /** Update the manager with new Deck props */
  setProps(e) {
    e.views && this._setViews(e.views), e.viewState && this._setViewState(e.viewState), ("width" in e || "height" in e) && this._setSize(e.width, e.height), this._isUpdating || this._update();
  }
  //
  // PRIVATE METHODS
  //
  _update() {
    this._isUpdating = !0, this._needsUpdate && (this._needsUpdate = !1, this._rebuildViewports()), this._needsUpdate && (this._needsUpdate = !1, this._rebuildViewports()), this._isUpdating = !1;
  }
  _setSize(e, i) {
    (e !== this.width || i !== this.height) && (this.width = e, this.height = i, this.setNeedsUpdate("Size changed"));
  }
  // Update the view descriptor list and set change flag if needed
  // Does not actually rebuild the `Viewport`s until `getViewports` is called
  _setViews(e) {
    e = ch(e, Boolean), this._diffViews(e, this.views) && this.setNeedsUpdate("views changed"), this.views = e;
  }
  _setViewState(e) {
    e ? (!Pn(e, this.viewState, 3) && this.setNeedsUpdate("viewState changed"), this.viewState = e) : Jt.warn("missing `viewState` or `initialViewState`")();
  }
  _createController(e, i) {
    const s = i.type;
    return new s({
      timeline: this.timeline,
      eventManager: this._eventManager,
      // Set an internal callback that calls the prop callback if provided
      onViewStateChange: this._eventCallbacks.onViewStateChange,
      onStateChange: this._eventCallbacks.onInteractionStateChange,
      makeViewport: (u) => this.getView(e.id)?.makeViewport({
        viewState: u,
        width: this.width,
        height: this.height
      })
    });
  }
  _updateController(e, i, s, o) {
    const u = e.controller;
    if (u && s) {
      const d = {
        ...i,
        ...u,
        id: e.id,
        x: s.x,
        y: s.y,
        width: s.width,
        height: s.height
      };
      return (!o || o.constructor !== u.type) && (o = this._createController(e, d)), o && o.setProps(d), o;
    }
    return null;
  }
  // Rebuilds viewports from descriptors towards a certain window size
  _rebuildViewports() {
    const { views: e } = this, i = this.controllers;
    this._viewports = [], this.controllers = {};
    let s = !1;
    for (let o = e.length; o--; ) {
      const u = e[o], d = this.getViewState(u), a = u.makeViewport({ viewState: d, width: this.width, height: this.height });
      let w = i[u.id];
      const S = !!u.controller;
      S && !w && (s = !0), (s || !S) && w && (w.finalize(), w = null), this.controllers[u.id] = this._updateController(u, d, a, w), a && this._viewports.unshift(a);
    }
    for (const o in i) {
      const u = i[o];
      u && !this.controllers[o] && u.finalize();
    }
    this._buildViewportMap();
  }
  _buildViewportMap() {
    this._viewportMap = {}, this._viewports.forEach((e) => {
      e.id && (this._viewportMap[e.id] = this._viewportMap[e.id] || e);
    });
  }
  // Check if viewport array has changed, returns true if any change
  // Note that descriptors can be the same
  _diffViews(e, i) {
    return e.length !== i.length ? !0 : e.some((s, o) => !e[o].equals(i[o]));
  }
}
const ZD = /([0-9]+\.?[0-9]*)(%|px)/;
function da(t) {
  switch (typeof t) {
    case "number":
      return {
        position: t,
        relative: !1
      };
    case "string":
      const e = ZD.exec(t);
      if (e && e.length >= 3) {
        const i = e[2] === "%", s = parseFloat(e[1]);
        return {
          position: i ? s / 100 : s,
          relative: i
        };
      }
    // fallthrough
    default:
      throw new Error(`Could not parse position string ${t}`);
  }
}
function fa(t, e) {
  return t.relative ? Math.round(t.position * e) : t.position;
}
class KD {
  constructor(e) {
    const { id: i, x: s = 0, y: o = 0, width: u = "100%", height: d = "100%", padding: a = null } = e;
    this.id = i || this.constructor.displayName || "view", this.props = { ...e, id: this.id }, this._x = da(s), this._y = da(o), this._width = da(u), this._height = da(d), this._padding = a && {
      left: da(a.left || 0),
      right: da(a.right || 0),
      top: da(a.top || 0),
      bottom: da(a.bottom || 0)
    }, this.equals = this.equals.bind(this), Object.seal(this);
  }
  equals(e) {
    return this === e ? !0 : this.ViewportType === e.ViewportType && Pn(this.props, e.props, 2);
  }
  /** Make viewport from canvas dimensions and view state */
  makeViewport({ width: e, height: i, viewState: s }) {
    s = this.filterViewState(s);
    const o = this.getDimensions({ width: e, height: i });
    return !o.height || !o.width ? null : new this.ViewportType({ ...s, ...this.props, ...o });
  }
  getViewStateId() {
    const { viewState: e } = this.props;
    return typeof e == "string" ? e : e?.id || this.id;
  }
  // Allows view to override (or completely define) viewState
  filterViewState(e) {
    if (this.props.viewState && typeof this.props.viewState == "object") {
      if (!this.props.viewState.id)
        return this.props.viewState;
      const i = { ...e };
      for (const s in this.props.viewState)
        s !== "id" && (i[s] = this.props.viewState[s]);
      return i;
    }
    return e;
  }
  /** Resolve the dimensions of the view from overall canvas dimensions */
  getDimensions({ width: e, height: i }) {
    const s = {
      x: fa(this._x, e),
      y: fa(this._y, i),
      width: fa(this._width, e),
      height: fa(this._height, i)
    };
    return this._padding && (s.padding = {
      left: fa(this._padding.left, e),
      top: fa(this._padding.top, i),
      right: fa(this._padding.right, e),
      bottom: fa(this._padding.bottom, i)
    }), s;
  }
  // Used by sub classes to resolve controller props
  get controller() {
    const e = this.props.controller;
    return e ? e === !0 ? { type: this.ControllerType } : typeof e == "function" ? { type: e } : { type: this.ControllerType, ...e } : null;
  }
}
class Bp {
  /**
   * @params timeline {Timeline}
   */
  constructor(e) {
    this._inProgress = !1, this._handle = null, this.time = 0, this.settings = {
      duration: 0
    }, this._timeline = e;
  }
  /* Public API */
  get inProgress() {
    return this._inProgress;
  }
  /**
   * (re)start this transition.
   * @params props {object} - optional overriding props. see constructor
   */
  start(e) {
    this.cancel(), this.settings = e, this._inProgress = !0, this.settings.onStart?.(this);
  }
  /**
   * end this transition if it is in progress.
   */
  end() {
    this._inProgress && (this._timeline.removeChannel(this._handle), this._handle = null, this._inProgress = !1, this.settings.onEnd?.(this));
  }
  /**
   * cancel this transition if it is in progress.
   */
  cancel() {
    this._inProgress && (this.settings.onInterrupt?.(this), this._timeline.removeChannel(this._handle), this._handle = null, this._inProgress = !1);
  }
  /**
   * update this transition. Returns `true` if updated.
   */
  update() {
    if (!this._inProgress)
      return !1;
    if (this._handle === null) {
      const { _timeline: e, settings: i } = this;
      this._handle = e.addChannel({
        delay: e.getTime(),
        duration: i.duration
      });
    }
    return this.time = this._timeline.getTime(this._handle), this._onUpdate(), this.settings.onUpdate?.(this), this._timeline.isFinished(this._handle) && this.end(), !0;
  }
  /* Private API */
  _onUpdate() {
  }
}
const Qv = () => {
}, Em = {
  BREAK: 1,
  SNAP_TO_END: 2,
  IGNORE: 3
}, YD = (t) => t, JD = Em.BREAK;
class QD {
  constructor(e) {
    this._onTransitionUpdate = (i) => {
      const { time: s, settings: { interpolator: o, startProps: u, endProps: d, duration: a, easing: w } } = i, S = w(s / a), M = o.interpolateProps(u, d, S);
      this.propsInTransition = this.getControllerState({
        ...this.props,
        ...M
      }).getViewportProps(), this.onViewStateChange({
        viewState: this.propsInTransition,
        oldViewState: this.props
      });
    }, this.getControllerState = e.getControllerState, this.propsInTransition = null, this.transition = new Bp(e.timeline), this.onViewStateChange = e.onViewStateChange || Qv, this.onStateChange = e.onStateChange || Qv;
  }
  finalize() {
    this.transition.cancel();
  }
  // Returns current transitioned viewport.
  getViewportInTransition() {
    return this.propsInTransition;
  }
  // Process the vewiport change, either ignore or trigger a new transition.
  // Return true if a new transition is triggered, false otherwise.
  processViewStateChange(e) {
    let i = !1;
    const s = this.props;
    if (this.props = e, !s || this._shouldIgnoreViewportChange(s, e))
      return !1;
    if (this._isTransitionEnabled(e)) {
      let o = s;
      if (this.transition.inProgress) {
        const { interruption: u, endProps: d } = this.transition.settings;
        o = {
          ...s,
          ...u === Em.SNAP_TO_END ? d : this.propsInTransition || s
        };
      }
      this._triggerTransition(o, e), i = !0;
    } else
      this.transition.cancel();
    return i;
  }
  updateTransition() {
    this.transition.update();
  }
  // Helper methods
  _isTransitionEnabled(e) {
    const { transitionDuration: i, transitionInterpolator: s } = e;
    return (i > 0 || i === "auto") && !!s;
  }
  _isUpdateDueToCurrentTransition(e) {
    return this.transition.inProgress && this.propsInTransition ? this.transition.settings.interpolator.arePropsEqual(e, this.propsInTransition) : !1;
  }
  _shouldIgnoreViewportChange(e, i) {
    return this.transition.inProgress ? this.transition.settings.interruption === Em.IGNORE || // Ignore update if it is due to current active transition.
    this._isUpdateDueToCurrentTransition(i) : this._isTransitionEnabled(i) ? i.transitionInterpolator.arePropsEqual(e, i) : !0;
  }
  _triggerTransition(e, i) {
    const s = this.getControllerState(e), o = this.getControllerState(i).shortestPathFrom(s), u = i.transitionInterpolator, d = u.getDuration ? u.getDuration(e, i) : i.transitionDuration;
    if (d === 0)
      return;
    const a = u.initializeProps(e, o);
    this.propsInTransition = {};
    const w = {
      duration: d,
      easing: i.transitionEasing || YD,
      interpolator: u,
      interruption: i.transitionInterruption || JD,
      startProps: a.start,
      endProps: a.end,
      onStart: i.onTransitionStart,
      onUpdate: this._onTransitionUpdate,
      onInterrupt: this._onTransitionEnd(i.onTransitionInterrupt),
      onEnd: this._onTransitionEnd(i.onTransitionEnd)
    };
    this.transition.start(w), this.onStateChange({ inTransition: !0 }), this.updateTransition();
  }
  _onTransitionEnd(e) {
    return (i) => {
      this.propsInTransition = null, this.onStateChange({
        inTransition: !1,
        isZooming: !1,
        isPanning: !1,
        isRotating: !1
      }), e?.(i);
    };
  }
}
function Tr(t, e) {
  if (!t)
    throw new Error(e || "deck.gl: assertion failed.");
}
class eO {
  /**
   * @param opts {array|object}
   * @param opts.compare {array} - prop names used in equality check
   * @param opts.extract {array} - prop names needed for interpolation
   * @param opts.required {array} - prop names that must be supplied
   * alternatively, supply one list of prop names as `opts` if all of the above are the same.
   */
  constructor(e) {
    const { compare: i, extract: s, required: o } = e;
    this._propsToCompare = i, this._propsToExtract = s || i, this._requiredProps = o;
  }
  /**
   * Checks if two sets of props need transition in between
   * @param currentProps {object} - a list of viewport props
   * @param nextProps {object} - a list of viewport props
   * @returns {bool} - true if two props are equivalent
   */
  arePropsEqual(e, i) {
    for (const s of this._propsToCompare)
      if (!(s in e) || !(s in i) || !On(e[s], i[s]))
        return !1;
    return !0;
  }
  /**
   * Called before transition starts to validate/pre-process start and end props
   * @param startProps {object} - a list of starting viewport props
   * @param endProps {object} - a list of target viewport props
   * @returns {Object} {start, end} - start and end props to be passed
   *   to `interpolateProps`
   */
  initializeProps(e, i) {
    const s = {}, o = {};
    for (const u of this._propsToExtract)
      (u in e || u in i) && (s[u] = e[u], o[u] = i[u]);
    return this._checkRequiredProps(s), this._checkRequiredProps(o), { start: s, end: o };
  }
  /**
   * Returns transition duration
   * @param startProps {object} - a list of starting viewport props
   * @param endProps {object} - a list of target viewport props
   * @returns {Number} - transition duration in milliseconds
   */
  getDuration(e, i) {
    return i.transitionDuration;
  }
  _checkRequiredProps(e) {
    this._requiredProps && this._requiredProps.forEach((i) => {
      const s = e[i];
      Tr(Number.isFinite(s) || Array.isArray(s), `${i} is required for transition`);
    });
  }
}
const tO = ["longitude", "latitude", "zoom", "bearing", "pitch"], iO = ["longitude", "latitude", "zoom"];
class DT extends eO {
  /**
   * @param {Object} opts
   * @param {Array} opts.transitionProps - list of props to apply linear transition to.
   * @param {Array} opts.around - a screen point to zoom/rotate around.
   * @param {Function} opts.makeViewport - construct a viewport instance with given props.
   */
  constructor(e = {}) {
    const i = Array.isArray(e) ? e : e.transitionProps, s = Array.isArray(e) ? {} : e;
    s.transitionProps = Array.isArray(i) ? {
      compare: i,
      required: i
    } : i || {
      compare: tO,
      required: iO
    }, super(s.transitionProps), this.opts = s;
  }
  initializeProps(e, i) {
    const s = super.initializeProps(e, i), { makeViewport: o, around: u } = this.opts;
    if (o && u) {
      const d = o(e), a = o(i), w = d.unproject(u);
      s.start.around = u, Object.assign(s.end, {
        around: a.project(w),
        aroundPosition: w,
        width: i.width,
        height: i.height
      });
    }
    return s;
  }
  interpolateProps(e, i, s) {
    const o = {};
    for (const u of this._propsToExtract)
      o[u] = dp(e[u] || 0, i[u] || 0, s);
    if (i.aroundPosition && this.opts.makeViewport) {
      const u = this.opts.makeViewport({ ...i, ...o });
      Object.assign(o, u.panByPosition(
        i.aroundPosition,
        // anchor point in current screen coordinates
        dp(e.around, i.around, s)
      ));
    }
    return o;
  }
}
const pa = {
  transitionDuration: 0
}, rO = 300, Bf = (t) => 1 - (1 - t) * (1 - t), Nc = {
  WHEEL: ["wheel"],
  PAN: ["panstart", "panmove", "panend"],
  PINCH: ["pinchstart", "pinchmove", "pinchend"],
  TRIPLE_PAN: ["tripanstart", "tripanmove", "tripanend"],
  DOUBLE_TAP: ["doubletap"],
  KEYBOARD: ["keydown"]
}, _l = {};
class sO {
  constructor(e) {
    this.state = {}, this._events = {}, this._interactionState = {
      isDragging: !1
    }, this._customEvents = [], this._eventStartBlocked = null, this._panMove = !1, this.invertPan = !1, this.dragMode = "rotate", this.inertia = 0, this.scrollZoom = !0, this.dragPan = !0, this.dragRotate = !0, this.doubleClickZoom = !0, this.touchZoom = !0, this.touchRotate = !1, this.keyboard = !0, this.transitionManager = new QD({
      ...e,
      getControllerState: (i) => new this.ControllerState(i),
      onViewStateChange: this._onTransition.bind(this),
      onStateChange: this._setInteractionState.bind(this)
    }), this.handleEvent = this.handleEvent.bind(this), this.eventManager = e.eventManager, this.onViewStateChange = e.onViewStateChange || (() => {
    }), this.onStateChange = e.onStateChange || (() => {
    }), this.makeViewport = e.makeViewport;
  }
  set events(e) {
    this.toggleEvents(this._customEvents, !1), this.toggleEvents(e, !0), this._customEvents = e, this.props && this.setProps(this.props);
  }
  finalize() {
    for (const e in this._events)
      this._events[e] && this.eventManager?.off(e, this.handleEvent);
    this.transitionManager.finalize();
  }
  /**
   * Callback for events
   */
  handleEvent(e) {
    this._controllerState = void 0;
    const i = this._eventStartBlocked;
    switch (e.type) {
      case "panstart":
        return i ? !1 : this._onPanStart(e);
      case "panmove":
        return this._onPan(e);
      case "panend":
        return this._onPanEnd(e);
      case "pinchstart":
        return i ? !1 : this._onPinchStart(e);
      case "pinchmove":
        return this._onPinch(e);
      case "pinchend":
        return this._onPinchEnd(e);
      case "tripanstart":
        return i ? !1 : this._onTriplePanStart(e);
      case "tripanmove":
        return this._onTriplePan(e);
      case "tripanend":
        return this._onTriplePanEnd(e);
      case "doubletap":
        return this._onDoubleTap(e);
      case "wheel":
        return this._onWheel(e);
      case "keydown":
        return this._onKeyDown(e);
      default:
        return !1;
    }
  }
  /* Event utils */
  // Event object: http://hammerjs.github.io/api/#event-object
  get controllerState() {
    return this._controllerState = this._controllerState || new this.ControllerState({
      makeViewport: this.makeViewport,
      ...this.props,
      ...this.state
    }), this._controllerState;
  }
  getCenter(e) {
    const { x: i, y: s } = this.props, { offsetCenter: o } = e;
    return [o.x - i, o.y - s];
  }
  isPointInBounds(e, i) {
    const { width: s, height: o } = this.props;
    if (i && i.handled)
      return !1;
    const u = e[0] >= 0 && e[0] <= s && e[1] >= 0 && e[1] <= o;
    return u && i && i.stopPropagation(), u;
  }
  isFunctionKeyPressed(e) {
    const { srcEvent: i } = e;
    return !!(i.metaKey || i.altKey || i.ctrlKey || i.shiftKey);
  }
  isDragging() {
    return this._interactionState.isDragging || !1;
  }
  // When a multi-touch event ends, e.g. pinch, not all pointers are lifted at the same time.
  // This triggers a brief `pan` event.
  // Calling this method will temporarily disable *start events to avoid conflicting transitions.
  blockEvents(e) {
    const i = setTimeout(() => {
      this._eventStartBlocked === i && (this._eventStartBlocked = null);
    }, e);
    this._eventStartBlocked = i;
  }
  /**
   * Extract interactivity options
   */
  setProps(e) {
    e.dragMode && (this.dragMode = e.dragMode), this.props = e, "transitionInterpolator" in e || (e.transitionInterpolator = this._getTransitionProps().transitionInterpolator), this.transitionManager.processViewStateChange(e);
    const { inertia: i } = e;
    this.inertia = Number.isFinite(i) ? i : i === !0 ? rO : 0;
    const { scrollZoom: s = !0, dragPan: o = !0, dragRotate: u = !0, doubleClickZoom: d = !0, touchZoom: a = !0, touchRotate: w = !1, keyboard: S = !0 } = e, M = !!this.onViewStateChange;
    this.toggleEvents(Nc.WHEEL, M && s), this.toggleEvents(Nc.PAN, M), this.toggleEvents(Nc.PINCH, M && (a || w)), this.toggleEvents(Nc.TRIPLE_PAN, M && w), this.toggleEvents(Nc.DOUBLE_TAP, M && d), this.toggleEvents(Nc.KEYBOARD, M && S), this.scrollZoom = s, this.dragPan = o, this.dragRotate = u, this.doubleClickZoom = d, this.touchZoom = a, this.touchRotate = w, this.keyboard = S;
  }
  updateTransition() {
    this.transitionManager.updateTransition();
  }
  toggleEvents(e, i) {
    this.eventManager && e.forEach((s) => {
      this._events[s] !== i && (this._events[s] = i, i ? this.eventManager.on(s, this.handleEvent) : this.eventManager.off(s, this.handleEvent));
    });
  }
  // Private Methods
  /* Callback util */
  // formats map state and invokes callback function
  updateViewport(e, i = null, s = {}) {
    const o = { ...e.getViewportProps(), ...i }, u = this.controllerState !== e;
    if (this.state = e.getState(), this._setInteractionState(s), u) {
      const d = this.controllerState && this.controllerState.getViewportProps();
      this.onViewStateChange && this.onViewStateChange({ viewState: o, interactionState: this._interactionState, oldViewState: d, viewId: this.props.id });
    }
  }
  _onTransition(e) {
    this.onViewStateChange({ ...e, interactionState: this._interactionState, viewId: this.props.id });
  }
  _setInteractionState(e) {
    Object.assign(this._interactionState, e), this.onStateChange(this._interactionState);
  }
  /* Event handlers */
  // Default handler for the `panstart` event.
  _onPanStart(e) {
    const i = this.getCenter(e);
    if (!this.isPointInBounds(i, e))
      return !1;
    let s = this.isFunctionKeyPressed(e) || e.rightButton || !1;
    (this.invertPan || this.dragMode === "pan") && (s = !s);
    const o = this.controllerState[s ? "panStart" : "rotateStart"]({
      pos: i
    });
    return this._panMove = s, this.updateViewport(o, pa, { isDragging: !0 }), !0;
  }
  // Default handler for the `panmove` and `panend` event.
  _onPan(e) {
    return this.isDragging() ? this._panMove ? this._onPanMove(e) : this._onPanRotate(e) : !1;
  }
  _onPanEnd(e) {
    return this.isDragging() ? this._panMove ? this._onPanMoveEnd(e) : this._onPanRotateEnd(e) : !1;
  }
  // Default handler for panning to move.
  // Called by `_onPan` when panning without function key pressed.
  _onPanMove(e) {
    if (!this.dragPan)
      return !1;
    const i = this.getCenter(e), s = this.controllerState.pan({ pos: i });
    return this.updateViewport(s, pa, {
      isDragging: !0,
      isPanning: !0
    }), !0;
  }
  _onPanMoveEnd(e) {
    const { inertia: i } = this;
    if (this.dragPan && i && e.velocity) {
      const s = this.getCenter(e), o = [
        s[0] + e.velocityX * i / 2,
        s[1] + e.velocityY * i / 2
      ], u = this.controllerState.pan({ pos: o }).panEnd();
      this.updateViewport(u, {
        ...this._getTransitionProps(),
        transitionDuration: i,
        transitionEasing: Bf
      }, {
        isDragging: !1,
        isPanning: !0
      });
    } else {
      const s = this.controllerState.panEnd();
      this.updateViewport(s, null, {
        isDragging: !1,
        isPanning: !1
      });
    }
    return !0;
  }
  // Default handler for panning to rotate.
  // Called by `_onPan` when panning with function key pressed.
  _onPanRotate(e) {
    if (!this.dragRotate)
      return !1;
    const i = this.getCenter(e), s = this.controllerState.rotate({ pos: i });
    return this.updateViewport(s, pa, {
      isDragging: !0,
      isRotating: !0
    }), !0;
  }
  _onPanRotateEnd(e) {
    const { inertia: i } = this;
    if (this.dragRotate && i && e.velocity) {
      const s = this.getCenter(e), o = [
        s[0] + e.velocityX * i / 2,
        s[1] + e.velocityY * i / 2
      ], u = this.controllerState.rotate({ pos: o }).rotateEnd();
      this.updateViewport(u, {
        ...this._getTransitionProps(),
        transitionDuration: i,
        transitionEasing: Bf
      }, {
        isDragging: !1,
        isRotating: !0
      });
    } else {
      const s = this.controllerState.rotateEnd();
      this.updateViewport(s, null, {
        isDragging: !1,
        isRotating: !1
      });
    }
    return !0;
  }
  // Default handler for the `wheel` event.
  _onWheel(e) {
    if (!this.scrollZoom)
      return !1;
    const i = this.getCenter(e);
    if (!this.isPointInBounds(i, e))
      return !1;
    e.srcEvent.preventDefault();
    const { speed: s = 0.01, smooth: o = !1 } = this.scrollZoom === !0 ? {} : this.scrollZoom, { delta: u } = e;
    let d = 2 / (1 + Math.exp(-Math.abs(u * s)));
    u < 0 && d !== 0 && (d = 1 / d);
    const a = this.controllerState.zoom({ pos: i, scale: d });
    return this.updateViewport(a, { ...this._getTransitionProps({ around: i }), transitionDuration: o ? 250 : 1 }, {
      isZooming: !0,
      isPanning: !0
    }), !0;
  }
  _onTriplePanStart(e) {
    const i = this.getCenter(e);
    if (!this.isPointInBounds(i, e))
      return !1;
    const s = this.controllerState.rotateStart({ pos: i });
    return this.updateViewport(s, pa, { isDragging: !0 }), !0;
  }
  _onTriplePan(e) {
    if (!this.touchRotate || !this.isDragging())
      return !1;
    const i = this.getCenter(e);
    i[0] -= e.deltaX;
    const s = this.controllerState.rotate({ pos: i });
    return this.updateViewport(s, pa, {
      isDragging: !0,
      isRotating: !0
    }), !0;
  }
  _onTriplePanEnd(e) {
    if (!this.isDragging())
      return !1;
    const { inertia: i } = this;
    if (this.touchRotate && i && e.velocityY) {
      const s = this.getCenter(e), o = [s[0], s[1] += e.velocityY * i / 2], u = this.controllerState.rotate({ pos: o });
      this.updateViewport(u, {
        ...this._getTransitionProps(),
        transitionDuration: i,
        transitionEasing: Bf
      }, {
        isDragging: !1,
        isRotating: !0
      }), this.blockEvents(i);
    } else {
      const s = this.controllerState.rotateEnd();
      this.updateViewport(s, null, {
        isDragging: !1,
        isRotating: !1
      });
    }
    return !0;
  }
  // Default handler for the `pinchstart` event.
  _onPinchStart(e) {
    const i = this.getCenter(e);
    if (!this.isPointInBounds(i, e))
      return !1;
    const s = this.controllerState.zoomStart({ pos: i }).rotateStart({ pos: i });
    return _l._startPinchRotation = e.rotation, _l._lastPinchEvent = e, this.updateViewport(s, pa, { isDragging: !0 }), !0;
  }
  // Default handler for the `pinchmove` and `pinchend` events.
  _onPinch(e) {
    if (!this.touchZoom && !this.touchRotate || !this.isDragging())
      return !1;
    let i = this.controllerState;
    if (this.touchZoom) {
      const { scale: s } = e, o = this.getCenter(e);
      i = i.zoom({ pos: o, scale: s });
    }
    if (this.touchRotate) {
      const { rotation: s } = e;
      i = i.rotate({
        deltaAngleX: _l._startPinchRotation - s
      });
    }
    return this.updateViewport(i, pa, {
      isDragging: !0,
      isPanning: this.touchZoom,
      isZooming: this.touchZoom,
      isRotating: this.touchRotate
    }), _l._lastPinchEvent = e, !0;
  }
  _onPinchEnd(e) {
    if (!this.isDragging())
      return !1;
    const { inertia: i } = this, { _lastPinchEvent: s } = _l;
    if (this.touchZoom && i && s && e.scale !== s.scale) {
      const o = this.getCenter(e);
      let u = this.controllerState.rotateEnd();
      const d = Math.log2(e.scale), a = (d - Math.log2(s.scale)) / (e.deltaTime - s.deltaTime), w = Math.pow(2, d + a * i / 2);
      u = u.zoom({ pos: o, scale: w }).zoomEnd(), this.updateViewport(u, {
        ...this._getTransitionProps({ around: o }),
        transitionDuration: i,
        transitionEasing: Bf
      }, {
        isDragging: !1,
        isPanning: this.touchZoom,
        isZooming: this.touchZoom,
        isRotating: !1
      }), this.blockEvents(i);
    } else {
      const o = this.controllerState.zoomEnd().rotateEnd();
      this.updateViewport(o, null, {
        isDragging: !1,
        isPanning: !1,
        isZooming: !1,
        isRotating: !1
      });
    }
    return _l._startPinchRotation = null, _l._lastPinchEvent = null, !0;
  }
  // Default handler for the `doubletap` event.
  _onDoubleTap(e) {
    if (!this.doubleClickZoom)
      return !1;
    const i = this.getCenter(e);
    if (!this.isPointInBounds(i, e))
      return !1;
    const s = this.isFunctionKeyPressed(e), o = this.controllerState.zoom({ pos: i, scale: s ? 0.5 : 2 });
    return this.updateViewport(o, this._getTransitionProps({ around: i }), {
      isZooming: !0,
      isPanning: !0
    }), this.blockEvents(100), !0;
  }
  // Default handler for the `keydown` event
  _onKeyDown(e) {
    if (!this.keyboard)
      return !1;
    const i = this.isFunctionKeyPressed(e), { zoomSpeed: s, moveSpeed: o, rotateSpeedX: u, rotateSpeedY: d } = this.keyboard === !0 ? {} : this.keyboard, { controllerState: a } = this;
    let w;
    const S = {};
    switch (e.srcEvent.code) {
      case "Minus":
        w = i ? a.zoomOut(s).zoomOut(s) : a.zoomOut(s), S.isZooming = !0;
        break;
      case "Equal":
        w = i ? a.zoomIn(s).zoomIn(s) : a.zoomIn(s), S.isZooming = !0;
        break;
      case "ArrowLeft":
        i ? (w = a.rotateLeft(u), S.isRotating = !0) : (w = a.moveLeft(o), S.isPanning = !0);
        break;
      case "ArrowRight":
        i ? (w = a.rotateRight(u), S.isRotating = !0) : (w = a.moveRight(o), S.isPanning = !0);
        break;
      case "ArrowUp":
        i ? (w = a.rotateUp(d), S.isRotating = !0) : (w = a.moveUp(o), S.isPanning = !0);
        break;
      case "ArrowDown":
        i ? (w = a.rotateDown(d), S.isRotating = !0) : (w = a.moveDown(o), S.isPanning = !0);
        break;
      default:
        return !1;
    }
    return this.updateViewport(w, this._getTransitionProps(), S), !0;
  }
  _getTransitionProps(e) {
    const { transition: i } = this;
    return !i || !i.transitionInterpolator ? pa : e ? {
      ...i,
      transitionInterpolator: new DT({
        ...e,
        ...i.transitionInterpolator.opts,
        makeViewport: this.controllerState.makeViewport
      })
    } : i;
  }
}
class nO {
  constructor(e, i) {
    this._viewportProps = this.applyConstraints(e), this._state = i;
  }
  getViewportProps() {
    return this._viewportProps;
  }
  getState() {
    return this._state;
  }
}
const ex = 5, oO = 1.2;
class aO extends nO {
  constructor(e) {
    const {
      /** Mapbox viewport properties */
      /** The width of the viewport */
      width: i,
      /** The height of the viewport */
      height: s,
      /** The latitude at the center of the viewport */
      latitude: o,
      /** The longitude at the center of the viewport */
      longitude: u,
      /** The tile zoom level of the map. */
      zoom: d,
      /** The bearing of the viewport in degrees */
      bearing: a = 0,
      /** The pitch of the viewport in degrees */
      pitch: w = 0,
      /**
       * Specify the altitude of the viewport camera
       * Unit: map heights, default 1.5
       * Non-public API, see https://github.com/mapbox/mapbox-gl-js/issues/1137
       */
      altitude: S = 1.5,
      /** Viewport position */
      position: M = [0, 0, 0],
      /** Viewport constraints */
      maxZoom: F = 20,
      minZoom: N = 0,
      maxPitch: L = 60,
      minPitch: re = 0,
      /** Interaction states, required to calculate change during transform */
      /* The point on map being grabbed when the operation first started */
      startPanLngLat: ne,
      /* Center of the zoom when the operation first started */
      startZoomLngLat: we,
      /* Pointer position when rotation started */
      startRotatePos: Se,
      /** Bearing when current perspective rotate operation started */
      startBearing: Ee,
      /** Pitch when current perspective rotate operation started */
      startPitch: Ce,
      /** Zoom when current zoom operation started */
      startZoom: Le,
      /** Normalize viewport props to fit map height into viewport */
      normalize: Ze = !0
    } = e;
    Tr(Number.isFinite(u)), Tr(Number.isFinite(o)), Tr(Number.isFinite(d)), super({
      width: i,
      height: s,
      latitude: o,
      longitude: u,
      zoom: d,
      bearing: a,
      pitch: w,
      altitude: S,
      maxZoom: F,
      minZoom: N,
      maxPitch: L,
      minPitch: re,
      normalize: Ze,
      position: M
    }, {
      startPanLngLat: ne,
      startZoomLngLat: we,
      startRotatePos: Se,
      startBearing: Ee,
      startPitch: Ce,
      startZoom: Le
    }), this.makeViewport = e.makeViewport;
  }
  /**
   * Start panning
   * @param {[Number, Number]} pos - position on screen where the pointer grabs
   */
  panStart({ pos: e }) {
    return this._getUpdatedState({
      startPanLngLat: this._unproject(e)
    });
  }
  /**
   * Pan
   * @param {[Number, Number]} pos - position on screen where the pointer is
   * @param {[Number, Number], optional} startPos - where the pointer grabbed at
   *   the start of the operation. Must be supplied of `panStart()` was not called
   */
  pan({ pos: e, startPos: i }) {
    const s = this.getState().startPanLngLat || this._unproject(i);
    if (!s)
      return this;
    const u = this.makeViewport(this.getViewportProps()).panByPosition(s, e);
    return this._getUpdatedState(u);
  }
  /**
   * End panning
   * Must call if `panStart()` was called
   */
  panEnd() {
    return this._getUpdatedState({
      startPanLngLat: null
    });
  }
  /**
   * Start rotating
   * @param {[Number, Number]} pos - position on screen where the center is
   */
  rotateStart({ pos: e }) {
    return this._getUpdatedState({
      startRotatePos: e,
      startBearing: this.getViewportProps().bearing,
      startPitch: this.getViewportProps().pitch
    });
  }
  /**
   * Rotate
   * @param {[Number, Number]} pos - position on screen where the center is
   */
  rotate({ pos: e, deltaAngleX: i = 0, deltaAngleY: s = 0 }) {
    const { startRotatePos: o, startBearing: u, startPitch: d } = this.getState();
    if (!o || u === void 0 || d === void 0)
      return this;
    let a;
    return e ? a = this._getNewRotation(e, o, d, u) : a = {
      bearing: u + i,
      pitch: d + s
    }, this._getUpdatedState(a);
  }
  /**
   * End rotating
   * Must call if `rotateStart()` was called
   */
  rotateEnd() {
    return this._getUpdatedState({
      startBearing: null,
      startPitch: null
    });
  }
  /**
   * Start zooming
   * @param {[Number, Number]} pos - position on screen where the center is
   */
  zoomStart({ pos: e }) {
    return this._getUpdatedState({
      startZoomLngLat: this._unproject(e),
      startZoom: this.getViewportProps().zoom
    });
  }
  /**
   * Zoom
   * @param {[Number, Number]} pos - position on screen where the current center is
   * @param {[Number, Number]} startPos - the center position at
   *   the start of the operation. Must be supplied of `zoomStart()` was not called
   * @param {Number} scale - a number between [0, 1] specifying the accumulated
   *   relative scale.
   */
  zoom({ pos: e, startPos: i, scale: s }) {
    let { startZoom: o, startZoomLngLat: u } = this.getState();
    if (u || (o = this.getViewportProps().zoom, u = this._unproject(i) || this._unproject(e)), !u)
      return this;
    const { maxZoom: d, minZoom: a } = this.getViewportProps();
    let w = o + Math.log2(s);
    w = Do(w, a, d);
    const S = this.makeViewport({ ...this.getViewportProps(), zoom: w });
    return this._getUpdatedState({
      zoom: w,
      ...S.panByPosition(u, e)
    });
  }
  /**
   * End zooming
   * Must call if `zoomStart()` was called
   */
  zoomEnd() {
    return this._getUpdatedState({
      startZoomLngLat: null,
      startZoom: null
    });
  }
  zoomIn(e = 2) {
    return this._zoomFromCenter(e);
  }
  zoomOut(e = 2) {
    return this._zoomFromCenter(1 / e);
  }
  moveLeft(e = 100) {
    return this._panFromCenter([e, 0]);
  }
  moveRight(e = 100) {
    return this._panFromCenter([-e, 0]);
  }
  moveUp(e = 100) {
    return this._panFromCenter([0, e]);
  }
  moveDown(e = 100) {
    return this._panFromCenter([0, -e]);
  }
  rotateLeft(e = 15) {
    return this._getUpdatedState({
      bearing: this.getViewportProps().bearing - e
    });
  }
  rotateRight(e = 15) {
    return this._getUpdatedState({
      bearing: this.getViewportProps().bearing + e
    });
  }
  rotateUp(e = 10) {
    return this._getUpdatedState({
      pitch: this.getViewportProps().pitch + e
    });
  }
  rotateDown(e = 10) {
    return this._getUpdatedState({
      pitch: this.getViewportProps().pitch - e
    });
  }
  shortestPathFrom(e) {
    const i = e.getViewportProps(), s = { ...this.getViewportProps() }, { bearing: o, longitude: u } = s;
    return Math.abs(o - i.bearing) > 180 && (s.bearing = o < 0 ? o + 360 : o - 360), Math.abs(u - i.longitude) > 180 && (s.longitude = u < 0 ? u + 360 : u - 360), s;
  }
  // Apply any constraints (mathematical or defined by _viewportProps) to map state
  applyConstraints(e) {
    const { maxZoom: i, minZoom: s, zoom: o } = e;
    e.zoom = Do(o, s, i);
    const { maxPitch: u, minPitch: d, pitch: a } = e;
    e.pitch = Do(a, d, u);
    const { normalize: w = !0 } = e;
    return w && Object.assign(e, jB(e)), e;
  }
  /* Private methods */
  _zoomFromCenter(e) {
    const { width: i, height: s } = this.getViewportProps();
    return this.zoom({
      pos: [i / 2, s / 2],
      scale: e
    });
  }
  _panFromCenter(e) {
    const { width: i, height: s } = this.getViewportProps();
    return this.pan({
      startPos: [i / 2, s / 2],
      pos: [i / 2 + e[0], s / 2 + e[1]]
    });
  }
  _getUpdatedState(e) {
    return new this.constructor({
      makeViewport: this.makeViewport,
      ...this.getViewportProps(),
      ...this.getState(),
      ...e
    });
  }
  _unproject(e) {
    const i = this.makeViewport(this.getViewportProps());
    return e && i.unproject(e);
  }
  _getNewRotation(e, i, s, o) {
    const u = e[0] - i[0], d = e[1] - i[1], a = e[1], w = i[1], { width: S, height: M } = this.getViewportProps(), F = u / S;
    let N = 0;
    d > 0 ? Math.abs(M - w) > ex && (N = d / (w - M) * oO) : d < 0 && w > ex && (N = 1 - a / w), N = Do(N, -1, 1);
    const { minPitch: L, maxPitch: re } = this.getViewportProps(), ne = o + 180 * F;
    let we = s;
    return N > 0 ? we = s + N * (re - s) : N < 0 && (we = s - N * (L - s)), {
      pitch: we,
      bearing: ne
    };
  }
}
class lO extends sO {
  constructor() {
    super(...arguments), this.ControllerState = aO, this.transition = {
      transitionDuration: 300,
      transitionInterpolator: new DT({
        transitionProps: {
          compare: ["longitude", "latitude", "zoom", "bearing", "pitch", "position"],
          required: ["longitude", "latitude", "zoom"]
        }
      })
    }, this.dragMode = "pan";
  }
  setProps(e) {
    e.position = e.position || [0, 0, 0];
    const i = this.props;
    super.setProps(e), (!i || i.height !== e.height) && this.updateViewport(new this.ControllerState({
      makeViewport: this.makeViewport,
      ...e,
      ...this.state
    }));
  }
}
class Py extends KD {
  constructor(e = {}) {
    super(e);
  }
  get ViewportType() {
    return Il;
  }
  get ControllerType() {
    return lO;
  }
}
Py.displayName = "MapView";
const cO = new IT();
function hO(t, e) {
  const i = t.order ?? 1 / 0, s = e.order ?? 1 / 0;
  return i - s;
}
class uO {
  constructor(e) {
    this._resolvedEffects = [], this._defaultEffects = [], this.effects = [], this._context = e, this._needsRedraw = "Initial render", this._setEffects([]);
  }
  /**
   * Register a new default effect, i.e. an effect presents regardless of user supplied props.effects
   */
  addDefaultEffect(e) {
    const i = this._defaultEffects;
    if (!i.find((s) => s.id === e.id)) {
      const s = i.findIndex((o) => hO(o, e) > 0);
      s < 0 ? i.push(e) : i.splice(s, 0, e), e.setup(this._context), this._setEffects(this.effects);
    }
  }
  setProps(e) {
    "effects" in e && (Pn(e.effects, this.effects, 1) || this._setEffects(e.effects));
  }
  needsRedraw(e = { clearRedrawFlags: !1 }) {
    const i = this._needsRedraw;
    return e.clearRedrawFlags && (this._needsRedraw = !1), i;
  }
  getEffects() {
    return this._resolvedEffects;
  }
  _setEffects(e) {
    const i = {};
    for (const o of this.effects)
      i[o.id] = o;
    const s = [];
    for (const o of e) {
      const u = i[o.id];
      let d = o;
      u && u !== o ? u.setProps ? (u.setProps(o.props), d = u) : u.cleanup(this._context) : u || o.setup(this._context), s.push(d), delete i[o.id];
    }
    for (const o in i)
      i[o].cleanup(this._context);
    this.effects = s, this._resolvedEffects = s.concat(this._defaultEffects), e.some((o) => o instanceof IT) || this._resolvedEffects.push(cO), this._needsRedraw = "effects changed";
  }
  finalize() {
    for (const e of this._resolvedEffects)
      e.cleanup(this._context);
    this.effects.length = 0, this._resolvedEffects.length = 0, this._defaultEffects.length = 0;
  }
}
class dO extends Iy {
  shouldDrawLayer(e) {
    const { operation: i } = e.props;
    return i.includes("draw") || i.includes("terrain");
  }
}
const fO = "deckRenderer.renderLayers";
class pO {
  constructor(e) {
    this.device = e, this.layerFilter = null, this.drawPickingColors = !1, this.drawLayersPass = new dO(e), this.pickLayersPass = new PT(e), this.renderCount = 0, this._needsRedraw = "Initial render", this.renderBuffers = [], this.lastPostProcessEffect = null;
  }
  setProps(e) {
    this.layerFilter !== e.layerFilter && (this.layerFilter = e.layerFilter, this._needsRedraw = "layerFilter changed"), this.drawPickingColors !== e.drawPickingColors && (this.drawPickingColors = e.drawPickingColors, this._needsRedraw = "drawPickingColors changed");
  }
  renderLayers(e) {
    if (!e.viewports.length)
      return;
    const i = this.drawPickingColors ? this.pickLayersPass : this.drawLayersPass, s = {
      layerFilter: this.layerFilter,
      isPicking: this.drawPickingColors,
      ...e
    };
    s.effects && this._preRender(s.effects, s);
    const o = this.lastPostProcessEffect ? this.renderBuffers[0] : s.target;
    this.lastPostProcessEffect && (s.clearColor = [0, 0, 0, 0], s.clearCanvas = !0);
    const u = i.render({ ...s, target: o });
    s.effects && this._postRender(s.effects, s), this.renderCount++, Yr(fO, this, u, e);
  }
  needsRedraw(e = { clearRedrawFlags: !1 }) {
    const i = this._needsRedraw;
    return e.clearRedrawFlags && (this._needsRedraw = !1), i;
  }
  finalize() {
    const { renderBuffers: e } = this;
    for (const i of e)
      i.delete();
    e.length = 0;
  }
  _preRender(e, i) {
    this.lastPostProcessEffect = null, i.preRenderStats = i.preRenderStats || {};
    for (const s of e)
      i.preRenderStats[s.id] = s.preRender(i), s.postRender && (this.lastPostProcessEffect = s.id);
    this.lastPostProcessEffect && this._resizeRenderBuffers();
  }
  _resizeRenderBuffers() {
    const { renderBuffers: e } = this, i = this.device.canvasContext.getDrawingBufferSize();
    e.length === 0 && [0, 1].map((s) => {
      const o = this.device.createTexture({
        sampler: { minFilter: "linear", magFilter: "linear" }
      });
      e.push(this.device.createFramebuffer({
        id: `deck-renderbuffer-${s}`,
        colorAttachments: [o]
      }));
    });
    for (const s of e)
      s.resize(i);
  }
  _postRender(e, i) {
    const { renderBuffers: s } = this, o = {
      ...i,
      inputBuffer: s[0],
      swapBuffer: s[1]
    };
    for (const u of e)
      if (u.postRender) {
        o.target = u.id === this.lastPostProcessEffect ? i.target : void 0;
        const d = u.postRender(o);
        o.inputBuffer = d, o.swapBuffer = d === s[0] ? s[1] : s[0];
      }
  }
}
const _O = {
  pickedColor: null,
  pickedObjectIndex: -1
};
function gO({ pickedColors: t, decodePickingColor: e, deviceX: i, deviceY: s, deviceRadius: o, deviceRect: u }) {
  const { x: d, y: a, width: w, height: S } = u;
  let M = o * o, F = -1, N = 0;
  for (let L = 0; L < S; L++) {
    const re = L + a - s, ne = re * re;
    if (ne > M)
      N += 4 * w;
    else
      for (let we = 0; we < w; we++) {
        if (t[N + 3] - 1 >= 0) {
          const Ee = we + d - i, Ce = Ee * Ee + ne;
          Ce <= M && (M = Ce, F = N);
        }
        N += 4;
      }
  }
  if (F >= 0) {
    const L = t.slice(F, F + 4), re = e(L);
    if (re) {
      const ne = Math.floor(F / 4 / w), we = F / 4 - ne * w;
      return {
        ...re,
        pickedColor: L,
        pickedX: d + we,
        pickedY: a + ne
      };
    }
    Jt.error("Picked non-existent layer. Is picking buffer corrupt?")();
  }
  return _O;
}
function mO({ pickedColors: t, decodePickingColor: e }) {
  const i = /* @__PURE__ */ new Map();
  if (t) {
    for (let s = 0; s < t.length; s += 4)
      if (t[s + 3] - 1 >= 0) {
        const u = t.slice(s, s + 4), d = u.join(",");
        if (!i.has(d)) {
          const a = e(u);
          a ? i.set(d, {
            ...a,
            color: u
          }) : Jt.error("Picked non-existent layer. Is picking buffer corrupt?")();
        }
      }
  }
  return Array.from(i.values());
}
function OT({ pickInfo: t, viewports: e, pixelRatio: i, x: s, y: o, z: u }) {
  let d = e[0];
  e.length > 1 && (d = bO(t?.pickedViewports || e, { x: s, y: o }));
  let a;
  if (d) {
    const w = [s - d.x, o - d.y];
    u !== void 0 && (w[2] = u), a = d.unproject(w);
  }
  return {
    color: null,
    layer: null,
    viewport: d,
    index: -1,
    picked: !1,
    x: s,
    y: o,
    pixel: [s, o],
    coordinate: a,
    devicePixel: t && "pickedX" in t ? [t.pickedX, t.pickedY] : void 0,
    pixelRatio: i
  };
}
function yO(t) {
  const { pickInfo: e, lastPickedInfo: i, mode: s, layers: o } = t, { pickedColor: u, pickedLayer: d, pickedObjectIndex: a } = e, w = d ? [d] : [];
  if (s === "hover") {
    const F = i.index, N = i.layerId, L = d ? d.props.id : null;
    if (L !== N || a !== F) {
      if (L !== N) {
        const re = o.find((ne) => ne.props.id === N);
        re && w.unshift(re);
      }
      i.layerId = L, i.index = a, i.info = null;
    }
  }
  const S = OT(t), M = /* @__PURE__ */ new Map();
  return M.set(null, S), w.forEach((F) => {
    let N = { ...S };
    F === d && (N.color = u, N.index = a, N.picked = !0), N = FT({ layer: F, info: N, mode: s });
    const L = N.layer;
    F === d && s === "hover" && (i.info = N), M.set(L.id, N), s === "hover" && L.updateAutoHighlight(N);
  }), M;
}
function FT({ layer: t, info: e, mode: i }) {
  for (; t && e; ) {
    const s = e.layer || null;
    e.sourceLayer = s, e.layer = t, e = t.getPickingInfo({ info: e, mode: i, sourceLayer: s }), t = t.parent;
  }
  return e;
}
function bO(t, e) {
  for (let i = t.length - 1; i >= 0; i--) {
    const s = t[i];
    if (s.containsPixel(e))
      return s;
  }
  return t[0];
}
class vO {
  constructor(e) {
    this._pickable = !0, this.device = e, this.pickLayersPass = new PT(e), this.lastPickedInfo = {
      index: -1,
      layerId: null,
      info: null
    };
  }
  setProps(e) {
    "layerFilter" in e && (this.layerFilter = e.layerFilter), "_pickable" in e && (this._pickable = e._pickable);
  }
  finalize() {
    this.pickingFBO && this.pickingFBO.destroy(), this.depthFBO && this.depthFBO.destroy();
  }
  /** Pick the closest info at given coordinate */
  pickObject(e) {
    return this._pickClosestObject(e);
  }
  /** Get all unique infos within a bounding box */
  pickObjects(e) {
    return this._pickVisibleObjects(e);
  }
  // Returns a new picking info object by assuming the last picked object is still picked
  getLastPickedObject({ x: e, y: i, layers: s, viewports: o }, u = this.lastPickedInfo.info) {
    const d = u && u.layer && u.layer.id, a = u && u.viewport && u.viewport.id, w = d ? s.find((N) => N.id === d) : null, S = a && o.find((N) => N.id === a) || o[0], M = S && S.unproject([e - S.x, i - S.y]);
    return { ...u, ...{
      x: e,
      y: i,
      viewport: S,
      coordinate: M,
      layer: w
    } };
  }
  // Private
  /** Ensures that picking framebuffer exists and matches the canvas size */
  _resizeBuffer() {
    if (!this.pickingFBO && (this.pickingFBO = this.device.createFramebuffer({
      colorAttachments: ["rgba8unorm"],
      depthStencilAttachment: "depth16unorm"
    }), this.device.isTextureFormatRenderable("rgba32float"))) {
      const i = this.device.createFramebuffer({
        colorAttachments: ["rgba32float"],
        depthStencilAttachment: "depth16unorm"
      });
      this.depthFBO = i;
    }
    const { canvas: e } = this.device.getCanvasContext();
    this.pickingFBO?.resize({ width: e.width, height: e.height }), this.depthFBO?.resize({ width: e.width, height: e.height });
  }
  /** Preliminary filtering of the layers list. Skid picking pass if no layer is pickable. */
  _getPickable(e) {
    if (this._pickable === !1)
      return null;
    const i = e.filter((s) => this.pickLayersPass.shouldDrawLayer(s) && !s.isComposite);
    return i.length ? i : null;
  }
  /** Pick the closest object at the given coordinate */
  // eslint-disable-next-line max-statements,complexity
  _pickClosestObject({ layers: e, views: i, viewports: s, x: o, y: u, radius: d = 0, depth: a = 1, mode: w = "query", unproject3D: S, onViewportActive: M, effects: F }) {
    const N = this.device.canvasContext.cssToDeviceRatio(), L = this._getPickable(e);
    if (!L || s.length === 0)
      return {
        result: [],
        emptyInfo: OT({ viewports: s, x: o, y: u, pixelRatio: N })
      };
    this._resizeBuffer();
    const re = this.device.canvasContext.cssToDevicePixels([o, u], !0), ne = [
      re.x + Math.floor(re.width / 2),
      re.y + Math.floor(re.height / 2)
    ], we = Math.round(d * N), { width: Se, height: Ee } = this.pickingFBO, Ce = this._getPickingRect({
      deviceX: ne[0],
      deviceY: ne[1],
      deviceRadius: we,
      deviceWidth: Se,
      deviceHeight: Ee
    }), Le = {
      x: o - d,
      y: u - d,
      width: d * 2 + 1,
      height: d * 2 + 1
    };
    let Ze;
    const Ke = [], ct = /* @__PURE__ */ new Set();
    for (let _t = 0; _t < a; _t++) {
      let st;
      if (Ce) {
        const bt = this._drawAndSample({
          layers: L,
          views: i,
          viewports: s,
          onViewportActive: M,
          deviceRect: Ce,
          cullRect: Le,
          effects: F,
          pass: `picking:${w}`
        });
        st = gO({
          ...bt,
          deviceX: ne[0],
          deviceY: ne[1],
          deviceRadius: we,
          deviceRect: Ce
        });
      } else
        st = {
          pickedColor: null,
          pickedObjectIndex: -1
        };
      let ot;
      if (st.pickedLayer && S && this.depthFBO) {
        const { pickedColors: bt } = this._drawAndSample({
          layers: [st.pickedLayer],
          views: i,
          viewports: s,
          onViewportActive: M,
          deviceRect: {
            x: st.pickedX,
            y: st.pickedY,
            width: 1,
            height: 1
          },
          cullRect: Le,
          effects: F,
          pass: `picking:${w}:z`
        }, !0);
        bt[3] && (ot = bt[0]);
      }
      st.pickedLayer && _t + 1 < a && (ct.add(st.pickedLayer), st.pickedLayer.disablePickingIndex(st.pickedObjectIndex)), Ze = yO({
        pickInfo: st,
        lastPickedInfo: this.lastPickedInfo,
        mode: w,
        layers: L,
        viewports: s,
        x: o,
        y: u,
        z: ot,
        pixelRatio: N
      });
      for (const bt of Ze.values())
        bt.layer && Ke.push(bt);
      if (!st.pickedColor)
        break;
    }
    for (const _t of ct)
      _t.restorePickingColors();
    return { result: Ke, emptyInfo: Ze.get(null) };
  }
  /** Pick all objects within the given bounding box */
  _pickVisibleObjects({ layers: e, views: i, viewports: s, x: o, y: u, width: d = 1, height: a = 1, mode: w = "query", maxObjects: S = null, onViewportActive: M, effects: F }) {
    const N = this._getPickable(e);
    if (!N || s.length === 0)
      return [];
    this._resizeBuffer();
    const L = this.device.canvasContext.cssToDeviceRatio(), re = this.device.canvasContext.cssToDevicePixels([o, u], !0), ne = re.x, we = re.y + re.height, Se = this.device.canvasContext.cssToDevicePixels([o + d, u + a], !0), Ee = Se.x + Se.width, Ce = Se.y, Le = {
      x: ne,
      y: Ce,
      // deviceTop and deviceRight represent the first pixel outside the desired rect
      width: Ee - ne,
      height: we - Ce
    }, Ze = this._drawAndSample({
      layers: N,
      views: i,
      viewports: s,
      onViewportActive: M,
      deviceRect: Le,
      cullRect: { x: o, y: u, width: d, height: a },
      effects: F,
      pass: `picking:${w}`
    }), Ke = mO(Ze), ct = /* @__PURE__ */ new Map(), _t = [], st = Number.isFinite(S);
    for (let ot = 0; ot < Ke.length && !(st && _t.length >= S); ot++) {
      const bt = Ke[ot];
      let Ft = {
        color: bt.pickedColor,
        layer: null,
        index: bt.pickedObjectIndex,
        picked: !0,
        x: o,
        y: u,
        pixelRatio: L
      };
      Ft = FT({ layer: bt.pickedLayer, info: Ft, mode: w });
      const jt = Ft.layer.id;
      ct.has(jt) || ct.set(jt, /* @__PURE__ */ new Set());
      const Et = ct.get(jt), bi = Ft.object ?? Ft.index;
      Et.has(bi) || (Et.add(bi), _t.push(Ft));
    }
    return _t;
  }
  _drawAndSample({ layers: e, views: i, viewports: s, onViewportActive: o, deviceRect: u, cullRect: d, effects: a, pass: w }, S = !1) {
    const M = S ? this.depthFBO : this.pickingFBO, F = {
      layers: e,
      layerFilter: this.layerFilter,
      views: i,
      viewports: s,
      onViewportActive: o,
      pickingFBO: M,
      deviceRect: u,
      cullRect: d,
      effects: a,
      pass: w,
      pickZ: S,
      preRenderStats: {}
    };
    for (const Ee of a)
      Ee.useInPicking && (F.preRenderStats[Ee.id] = Ee.preRender(F));
    const { decodePickingColor: N } = this.pickLayersPass.render(F), { x: L, y: re, width: ne, height: we } = u, Se = new (S ? Float32Array : Uint8Array)(ne * we * 4);
    return this.device.readPixelsToArrayWebGL(M, {
      sourceX: L,
      sourceY: re,
      sourceWidth: ne,
      sourceHeight: we,
      target: Se
    }), { pickedColors: Se, decodePickingColor: N };
  }
  // Calculate a picking rect centered on deviceX and deviceY and clipped to device
  // Returns null if pixel is outside of device
  _getPickingRect({ deviceX: e, deviceY: i, deviceRadius: s, deviceWidth: o, deviceHeight: u }) {
    const d = Math.max(0, e - s), a = Math.max(0, i - s), w = Math.min(o, e + s + 1) - d, S = Math.min(u, i + s + 1) - a;
    return w <= 0 || S <= 0 ? null : { x: d, y: a, width: w, height: S };
  }
}
const xO = {
  "top-left": { top: 0, left: 0 },
  "top-right": { top: 0, right: 0 },
  "bottom-left": { bottom: 0, left: 0 },
  "bottom-right": { bottom: 0, right: 0 },
  fill: { top: 0, left: 0, bottom: 0, right: 0 }
}, wO = "top-left", tx = "__root";
class TO {
  constructor({ deck: e, parentElement: i }) {
    this.defaultWidgets = [], this.widgets = [], this.resolvedWidgets = [], this.containers = {}, this.lastViewports = {}, this.deck = e, this.parentElement = i;
  }
  getWidgets() {
    return this.resolvedWidgets;
  }
  /** Declarative API to configure widgets */
  setProps(e) {
    e.widgets && !Pn(e.widgets, this.widgets, 1) && this._setWidgets(e.widgets);
  }
  finalize() {
    for (const e of this.getWidgets())
      this._remove(e);
    this.defaultWidgets.length = 0, this.resolvedWidgets.length = 0;
    for (const e in this.containers)
      this.containers[e].remove();
  }
  /** Imperative API. Widgets added this way are not affected by the declarative prop. */
  addDefault(e) {
    this.defaultWidgets.find((i) => i.id === e.id) || (this._add(e), this.defaultWidgets.push(e), this._setWidgets(this.widgets));
  }
  /** Resolve widgets from the declarative prop */
  _setWidgets(e) {
    const i = {};
    for (const s of this.resolvedWidgets)
      i[s.id] = s;
    this.resolvedWidgets.length = 0;
    for (const s of this.defaultWidgets)
      i[s.id] = null, this.resolvedWidgets.push(s);
    for (let s of e) {
      const o = i[s.id];
      o ? /* Widget placement changed */ o.viewId !== s.viewId || o.placement !== s.placement ? (this._remove(o), this._add(s)) : s !== o && (o.setProps(s.props), s = o) : this._add(s), i[s.id] = null, this.resolvedWidgets.push(s);
    }
    for (const s in i) {
      const o = i[s];
      o && this._remove(o);
    }
    this.widgets = e;
  }
  _add(e) {
    const { viewId: i = null, placement: s = wO } = e, o = e.onAdd({ deck: this.deck, viewId: i });
    o && this._getContainer(i, s).append(o), e._element = o;
  }
  _remove(e) {
    e.onRemove(), e._element && e._element.remove(), e._element = void 0;
  }
  /* global document */
  _getContainer(e, i) {
    const s = e || tx;
    let o = this.containers[s];
    o || (o = document.createElement("div"), o.style.pointerEvents = "none", o.style.position = "absolute", o.style.overflow = "hidden", this.parentElement?.append(o), this.containers[s] = o);
    let u = o.querySelector(`.${i}`);
    return u || (u = document.createElement("div"), u.className = i, u.style.position = "absolute", u.style.zIndex = "2", Object.assign(u.style, xO[i]), o.append(u)), u;
  }
  _updateContainers() {
    const e = this.deck.width, i = this.deck.height;
    for (const s in this.containers) {
      const o = this.lastViewports[s] || null, u = s === tx || o, d = this.containers[s];
      u ? (d.style.display = "block", d.style.left = `${o ? o.x : 0}px`, d.style.top = `${o ? o.y : 0}px`, d.style.width = `${o ? o.width : e}px`, d.style.height = `${o ? o.height : i}px`) : d.style.display = "none";
    }
  }
  onRedraw({ viewports: e, layers: i }) {
    const s = e.reduce((u, d) => (u[d.id] = d, u), {}), { lastViewports: o } = this;
    for (const u of this.getWidgets()) {
      const { viewId: d } = u;
      if (d) {
        const a = s[d];
        a && (u.onViewportChange && !a.equals(o[d]) && u.onViewportChange(a), u.onRedraw?.({ viewports: [a], layers: i }));
      } else {
        if (u.onViewportChange)
          for (const a of e)
            a.equals(o[a.id]) || u.onViewportChange(a);
        u.onRedraw?.({ viewports: e, layers: i });
      }
    }
    this.lastViewports = s, this._updateContainers();
  }
  onHover(e, i) {
    for (const s of this.getWidgets()) {
      const { viewId: o } = s;
      (!o || o === e.viewport?.id) && s.onHover?.(e, i);
    }
  }
  onEvent(e, i) {
    const s = vm[i.type];
    if (s)
      for (const o of this.getWidgets()) {
        const { viewId: u } = o;
        (!u || u === e.viewport?.id) && o[s.handler]?.(e, i);
      }
  }
}
const AO = {
  zIndex: "1",
  position: "absolute",
  pointerEvents: "none",
  color: "#a0a7b4",
  backgroundColor: "#29323c",
  padding: "10px",
  top: "0",
  left: "0",
  display: "none"
};
class EO {
  constructor() {
    this.id = "default-tooltip", this.placement = "fill", this.props = {}, this.isVisible = !1;
  }
  onAdd({ deck: e }) {
    const i = document.createElement("div");
    return i.className = "deck-tooltip", Object.assign(i.style, AO), this.deck = e, this.element = i, i;
  }
  onRemove() {
    this.deck = void 0, this.element = void 0;
  }
  setProps() {
  }
  onViewportChange(e) {
    this.isVisible && e.id === this.lastViewport?.id && e !== this.lastViewport && this.setTooltip(null);
  }
  onHover(e) {
    const { deck: i } = this, s = i && i.props.getTooltip;
    if (!s)
      return;
    const o = s(e);
    this.lastViewport = e.viewport, this.setTooltip(o, e.x, e.y);
  }
  setTooltip(e, i, s) {
    const o = this.element;
    if (o) {
      if (typeof e == "string")
        o.innerText = e;
      else if (e)
        e.text && (o.innerText = e.text), e.html && (o.innerHTML = e.html), e.className && (o.className = e.className);
      else {
        this.isVisible = !1, o.style.display = "none";
        return;
      }
      this.isVisible = !0, o.style.display = "block", o.style.transform = `translate(${i}px, ${s}px)`, e && typeof e == "object" && "style" in e && Object.assign(o.style, e.style);
    }
  }
}
var $c;
(function(t) {
  t[t.DEPTH_BUFFER_BIT = 256] = "DEPTH_BUFFER_BIT", t[t.STENCIL_BUFFER_BIT = 1024] = "STENCIL_BUFFER_BIT", t[t.COLOR_BUFFER_BIT = 16384] = "COLOR_BUFFER_BIT", t[t.POINTS = 0] = "POINTS", t[t.LINES = 1] = "LINES", t[t.LINE_LOOP = 2] = "LINE_LOOP", t[t.LINE_STRIP = 3] = "LINE_STRIP", t[t.TRIANGLES = 4] = "TRIANGLES", t[t.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", t[t.TRIANGLE_FAN = 6] = "TRIANGLE_FAN", t[t.ZERO = 0] = "ZERO", t[t.ONE = 1] = "ONE", t[t.SRC_COLOR = 768] = "SRC_COLOR", t[t.ONE_MINUS_SRC_COLOR = 769] = "ONE_MINUS_SRC_COLOR", t[t.SRC_ALPHA = 770] = "SRC_ALPHA", t[t.ONE_MINUS_SRC_ALPHA = 771] = "ONE_MINUS_SRC_ALPHA", t[t.DST_ALPHA = 772] = "DST_ALPHA", t[t.ONE_MINUS_DST_ALPHA = 773] = "ONE_MINUS_DST_ALPHA", t[t.DST_COLOR = 774] = "DST_COLOR", t[t.ONE_MINUS_DST_COLOR = 775] = "ONE_MINUS_DST_COLOR", t[t.SRC_ALPHA_SATURATE = 776] = "SRC_ALPHA_SATURATE", t[t.CONSTANT_COLOR = 32769] = "CONSTANT_COLOR", t[t.ONE_MINUS_CONSTANT_COLOR = 32770] = "ONE_MINUS_CONSTANT_COLOR", t[t.CONSTANT_ALPHA = 32771] = "CONSTANT_ALPHA", t[t.ONE_MINUS_CONSTANT_ALPHA = 32772] = "ONE_MINUS_CONSTANT_ALPHA", t[t.FUNC_ADD = 32774] = "FUNC_ADD", t[t.FUNC_SUBTRACT = 32778] = "FUNC_SUBTRACT", t[t.FUNC_REVERSE_SUBTRACT = 32779] = "FUNC_REVERSE_SUBTRACT", t[t.BLEND_EQUATION = 32777] = "BLEND_EQUATION", t[t.BLEND_EQUATION_RGB = 32777] = "BLEND_EQUATION_RGB", t[t.BLEND_EQUATION_ALPHA = 34877] = "BLEND_EQUATION_ALPHA", t[t.BLEND_DST_RGB = 32968] = "BLEND_DST_RGB", t[t.BLEND_SRC_RGB = 32969] = "BLEND_SRC_RGB", t[t.BLEND_DST_ALPHA = 32970] = "BLEND_DST_ALPHA", t[t.BLEND_SRC_ALPHA = 32971] = "BLEND_SRC_ALPHA", t[t.BLEND_COLOR = 32773] = "BLEND_COLOR", t[t.ARRAY_BUFFER_BINDING = 34964] = "ARRAY_BUFFER_BINDING", t[t.ELEMENT_ARRAY_BUFFER_BINDING = 34965] = "ELEMENT_ARRAY_BUFFER_BINDING", t[t.LINE_WIDTH = 2849] = "LINE_WIDTH", t[t.ALIASED_POINT_SIZE_RANGE = 33901] = "ALIASED_POINT_SIZE_RANGE", t[t.ALIASED_LINE_WIDTH_RANGE = 33902] = "ALIASED_LINE_WIDTH_RANGE", t[t.CULL_FACE_MODE = 2885] = "CULL_FACE_MODE", t[t.FRONT_FACE = 2886] = "FRONT_FACE", t[t.DEPTH_RANGE = 2928] = "DEPTH_RANGE", t[t.DEPTH_WRITEMASK = 2930] = "DEPTH_WRITEMASK", t[t.DEPTH_CLEAR_VALUE = 2931] = "DEPTH_CLEAR_VALUE", t[t.DEPTH_FUNC = 2932] = "DEPTH_FUNC", t[t.STENCIL_CLEAR_VALUE = 2961] = "STENCIL_CLEAR_VALUE", t[t.STENCIL_FUNC = 2962] = "STENCIL_FUNC", t[t.STENCIL_FAIL = 2964] = "STENCIL_FAIL", t[t.STENCIL_PASS_DEPTH_FAIL = 2965] = "STENCIL_PASS_DEPTH_FAIL", t[t.STENCIL_PASS_DEPTH_PASS = 2966] = "STENCIL_PASS_DEPTH_PASS", t[t.STENCIL_REF = 2967] = "STENCIL_REF", t[t.STENCIL_VALUE_MASK = 2963] = "STENCIL_VALUE_MASK", t[t.STENCIL_WRITEMASK = 2968] = "STENCIL_WRITEMASK", t[t.STENCIL_BACK_FUNC = 34816] = "STENCIL_BACK_FUNC", t[t.STENCIL_BACK_FAIL = 34817] = "STENCIL_BACK_FAIL", t[t.STENCIL_BACK_PASS_DEPTH_FAIL = 34818] = "STENCIL_BACK_PASS_DEPTH_FAIL", t[t.STENCIL_BACK_PASS_DEPTH_PASS = 34819] = "STENCIL_BACK_PASS_DEPTH_PASS", t[t.STENCIL_BACK_REF = 36003] = "STENCIL_BACK_REF", t[t.STENCIL_BACK_VALUE_MASK = 36004] = "STENCIL_BACK_VALUE_MASK", t[t.STENCIL_BACK_WRITEMASK = 36005] = "STENCIL_BACK_WRITEMASK", t[t.VIEWPORT = 2978] = "VIEWPORT", t[t.SCISSOR_BOX = 3088] = "SCISSOR_BOX", t[t.COLOR_CLEAR_VALUE = 3106] = "COLOR_CLEAR_VALUE", t[t.COLOR_WRITEMASK = 3107] = "COLOR_WRITEMASK", t[t.UNPACK_ALIGNMENT = 3317] = "UNPACK_ALIGNMENT", t[t.PACK_ALIGNMENT = 3333] = "PACK_ALIGNMENT", t[t.MAX_TEXTURE_SIZE = 3379] = "MAX_TEXTURE_SIZE", t[t.MAX_VIEWPORT_DIMS = 3386] = "MAX_VIEWPORT_DIMS", t[t.SUBPIXEL_BITS = 3408] = "SUBPIXEL_BITS", t[t.RED_BITS = 3410] = "RED_BITS", t[t.GREEN_BITS = 3411] = "GREEN_BITS", t[t.BLUE_BITS = 3412] = "BLUE_BITS", t[t.ALPHA_BITS = 3413] = "ALPHA_BITS", t[t.DEPTH_BITS = 3414] = "DEPTH_BITS", t[t.STENCIL_BITS = 3415] = "STENCIL_BITS", t[t.POLYGON_OFFSET_UNITS = 10752] = "POLYGON_OFFSET_UNITS", t[t.POLYGON_OFFSET_FACTOR = 32824] = "POLYGON_OFFSET_FACTOR", t[t.TEXTURE_BINDING_2D = 32873] = "TEXTURE_BINDING_2D", t[t.SAMPLE_BUFFERS = 32936] = "SAMPLE_BUFFERS", t[t.SAMPLES = 32937] = "SAMPLES", t[t.SAMPLE_COVERAGE_VALUE = 32938] = "SAMPLE_COVERAGE_VALUE", t[t.SAMPLE_COVERAGE_INVERT = 32939] = "SAMPLE_COVERAGE_INVERT", t[t.COMPRESSED_TEXTURE_FORMATS = 34467] = "COMPRESSED_TEXTURE_FORMATS", t[t.VENDOR = 7936] = "VENDOR", t[t.RENDERER = 7937] = "RENDERER", t[t.VERSION = 7938] = "VERSION", t[t.IMPLEMENTATION_COLOR_READ_TYPE = 35738] = "IMPLEMENTATION_COLOR_READ_TYPE", t[t.IMPLEMENTATION_COLOR_READ_FORMAT = 35739] = "IMPLEMENTATION_COLOR_READ_FORMAT", t[t.BROWSER_DEFAULT_WEBGL = 37444] = "BROWSER_DEFAULT_WEBGL", t[t.STATIC_DRAW = 35044] = "STATIC_DRAW", t[t.STREAM_DRAW = 35040] = "STREAM_DRAW", t[t.DYNAMIC_DRAW = 35048] = "DYNAMIC_DRAW", t[t.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", t[t.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", t[t.BUFFER_SIZE = 34660] = "BUFFER_SIZE", t[t.BUFFER_USAGE = 34661] = "BUFFER_USAGE", t[t.CURRENT_VERTEX_ATTRIB = 34342] = "CURRENT_VERTEX_ATTRIB", t[t.VERTEX_ATTRIB_ARRAY_ENABLED = 34338] = "VERTEX_ATTRIB_ARRAY_ENABLED", t[t.VERTEX_ATTRIB_ARRAY_SIZE = 34339] = "VERTEX_ATTRIB_ARRAY_SIZE", t[t.VERTEX_ATTRIB_ARRAY_STRIDE = 34340] = "VERTEX_ATTRIB_ARRAY_STRIDE", t[t.VERTEX_ATTRIB_ARRAY_TYPE = 34341] = "VERTEX_ATTRIB_ARRAY_TYPE", t[t.VERTEX_ATTRIB_ARRAY_NORMALIZED = 34922] = "VERTEX_ATTRIB_ARRAY_NORMALIZED", t[t.VERTEX_ATTRIB_ARRAY_POINTER = 34373] = "VERTEX_ATTRIB_ARRAY_POINTER", t[t.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 34975] = "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING", t[t.CULL_FACE = 2884] = "CULL_FACE", t[t.FRONT = 1028] = "FRONT", t[t.BACK = 1029] = "BACK", t[t.FRONT_AND_BACK = 1032] = "FRONT_AND_BACK", t[t.BLEND = 3042] = "BLEND", t[t.DEPTH_TEST = 2929] = "DEPTH_TEST", t[t.DITHER = 3024] = "DITHER", t[t.POLYGON_OFFSET_FILL = 32823] = "POLYGON_OFFSET_FILL", t[t.SAMPLE_ALPHA_TO_COVERAGE = 32926] = "SAMPLE_ALPHA_TO_COVERAGE", t[t.SAMPLE_COVERAGE = 32928] = "SAMPLE_COVERAGE", t[t.SCISSOR_TEST = 3089] = "SCISSOR_TEST", t[t.STENCIL_TEST = 2960] = "STENCIL_TEST", t[t.NO_ERROR = 0] = "NO_ERROR", t[t.INVALID_ENUM = 1280] = "INVALID_ENUM", t[t.INVALID_VALUE = 1281] = "INVALID_VALUE", t[t.INVALID_OPERATION = 1282] = "INVALID_OPERATION", t[t.OUT_OF_MEMORY = 1285] = "OUT_OF_MEMORY", t[t.CONTEXT_LOST_WEBGL = 37442] = "CONTEXT_LOST_WEBGL", t[t.CW = 2304] = "CW", t[t.CCW = 2305] = "CCW", t[t.DONT_CARE = 4352] = "DONT_CARE", t[t.FASTEST = 4353] = "FASTEST", t[t.NICEST = 4354] = "NICEST", t[t.GENERATE_MIPMAP_HINT = 33170] = "GENERATE_MIPMAP_HINT", t[t.BYTE = 5120] = "BYTE", t[t.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", t[t.SHORT = 5122] = "SHORT", t[t.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", t[t.INT = 5124] = "INT", t[t.UNSIGNED_INT = 5125] = "UNSIGNED_INT", t[t.FLOAT = 5126] = "FLOAT", t[t.DOUBLE = 5130] = "DOUBLE", t[t.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", t[t.ALPHA = 6406] = "ALPHA", t[t.RGB = 6407] = "RGB", t[t.RGBA = 6408] = "RGBA", t[t.LUMINANCE = 6409] = "LUMINANCE", t[t.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", t[t.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", t[t.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", t[t.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", t[t.FRAGMENT_SHADER = 35632] = "FRAGMENT_SHADER", t[t.VERTEX_SHADER = 35633] = "VERTEX_SHADER", t[t.COMPILE_STATUS = 35713] = "COMPILE_STATUS", t[t.DELETE_STATUS = 35712] = "DELETE_STATUS", t[t.LINK_STATUS = 35714] = "LINK_STATUS", t[t.VALIDATE_STATUS = 35715] = "VALIDATE_STATUS", t[t.ATTACHED_SHADERS = 35717] = "ATTACHED_SHADERS", t[t.ACTIVE_ATTRIBUTES = 35721] = "ACTIVE_ATTRIBUTES", t[t.ACTIVE_UNIFORMS = 35718] = "ACTIVE_UNIFORMS", t[t.MAX_VERTEX_ATTRIBS = 34921] = "MAX_VERTEX_ATTRIBS", t[t.MAX_VERTEX_UNIFORM_VECTORS = 36347] = "MAX_VERTEX_UNIFORM_VECTORS", t[t.MAX_VARYING_VECTORS = 36348] = "MAX_VARYING_VECTORS", t[t.MAX_COMBINED_TEXTURE_IMAGE_UNITS = 35661] = "MAX_COMBINED_TEXTURE_IMAGE_UNITS", t[t.MAX_VERTEX_TEXTURE_IMAGE_UNITS = 35660] = "MAX_VERTEX_TEXTURE_IMAGE_UNITS", t[t.MAX_TEXTURE_IMAGE_UNITS = 34930] = "MAX_TEXTURE_IMAGE_UNITS", t[t.MAX_FRAGMENT_UNIFORM_VECTORS = 36349] = "MAX_FRAGMENT_UNIFORM_VECTORS", t[t.SHADER_TYPE = 35663] = "SHADER_TYPE", t[t.SHADING_LANGUAGE_VERSION = 35724] = "SHADING_LANGUAGE_VERSION", t[t.CURRENT_PROGRAM = 35725] = "CURRENT_PROGRAM", t[t.NEVER = 512] = "NEVER", t[t.LESS = 513] = "LESS", t[t.EQUAL = 514] = "EQUAL", t[t.LEQUAL = 515] = "LEQUAL", t[t.GREATER = 516] = "GREATER", t[t.NOTEQUAL = 517] = "NOTEQUAL", t[t.GEQUAL = 518] = "GEQUAL", t[t.ALWAYS = 519] = "ALWAYS", t[t.KEEP = 7680] = "KEEP", t[t.REPLACE = 7681] = "REPLACE", t[t.INCR = 7682] = "INCR", t[t.DECR = 7683] = "DECR", t[t.INVERT = 5386] = "INVERT", t[t.INCR_WRAP = 34055] = "INCR_WRAP", t[t.DECR_WRAP = 34056] = "DECR_WRAP", t[t.NEAREST = 9728] = "NEAREST", t[t.LINEAR = 9729] = "LINEAR", t[t.NEAREST_MIPMAP_NEAREST = 9984] = "NEAREST_MIPMAP_NEAREST", t[t.LINEAR_MIPMAP_NEAREST = 9985] = "LINEAR_MIPMAP_NEAREST", t[t.NEAREST_MIPMAP_LINEAR = 9986] = "NEAREST_MIPMAP_LINEAR", t[t.LINEAR_MIPMAP_LINEAR = 9987] = "LINEAR_MIPMAP_LINEAR", t[t.TEXTURE_MAG_FILTER = 10240] = "TEXTURE_MAG_FILTER", t[t.TEXTURE_MIN_FILTER = 10241] = "TEXTURE_MIN_FILTER", t[t.TEXTURE_WRAP_S = 10242] = "TEXTURE_WRAP_S", t[t.TEXTURE_WRAP_T = 10243] = "TEXTURE_WRAP_T", t[t.TEXTURE_2D = 3553] = "TEXTURE_2D", t[t.TEXTURE = 5890] = "TEXTURE", t[t.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", t[t.TEXTURE_BINDING_CUBE_MAP = 34068] = "TEXTURE_BINDING_CUBE_MAP", t[t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", t[t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", t[t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", t[t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", t[t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", t[t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z", t[t.MAX_CUBE_MAP_TEXTURE_SIZE = 34076] = "MAX_CUBE_MAP_TEXTURE_SIZE", t[t.TEXTURE0 = 33984] = "TEXTURE0", t[t.ACTIVE_TEXTURE = 34016] = "ACTIVE_TEXTURE", t[t.REPEAT = 10497] = "REPEAT", t[t.CLAMP_TO_EDGE = 33071] = "CLAMP_TO_EDGE", t[t.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT", t[t.TEXTURE_WIDTH = 4096] = "TEXTURE_WIDTH", t[t.TEXTURE_HEIGHT = 4097] = "TEXTURE_HEIGHT", t[t.FLOAT_VEC2 = 35664] = "FLOAT_VEC2", t[t.FLOAT_VEC3 = 35665] = "FLOAT_VEC3", t[t.FLOAT_VEC4 = 35666] = "FLOAT_VEC4", t[t.INT_VEC2 = 35667] = "INT_VEC2", t[t.INT_VEC3 = 35668] = "INT_VEC3", t[t.INT_VEC4 = 35669] = "INT_VEC4", t[t.BOOL = 35670] = "BOOL", t[t.BOOL_VEC2 = 35671] = "BOOL_VEC2", t[t.BOOL_VEC3 = 35672] = "BOOL_VEC3", t[t.BOOL_VEC4 = 35673] = "BOOL_VEC4", t[t.FLOAT_MAT2 = 35674] = "FLOAT_MAT2", t[t.FLOAT_MAT3 = 35675] = "FLOAT_MAT3", t[t.FLOAT_MAT4 = 35676] = "FLOAT_MAT4", t[t.SAMPLER_2D = 35678] = "SAMPLER_2D", t[t.SAMPLER_CUBE = 35680] = "SAMPLER_CUBE", t[t.LOW_FLOAT = 36336] = "LOW_FLOAT", t[t.MEDIUM_FLOAT = 36337] = "MEDIUM_FLOAT", t[t.HIGH_FLOAT = 36338] = "HIGH_FLOAT", t[t.LOW_INT = 36339] = "LOW_INT", t[t.MEDIUM_INT = 36340] = "MEDIUM_INT", t[t.HIGH_INT = 36341] = "HIGH_INT", t[t.FRAMEBUFFER = 36160] = "FRAMEBUFFER", t[t.RENDERBUFFER = 36161] = "RENDERBUFFER", t[t.RGBA4 = 32854] = "RGBA4", t[t.RGB5_A1 = 32855] = "RGB5_A1", t[t.RGB565 = 36194] = "RGB565", t[t.DEPTH_COMPONENT16 = 33189] = "DEPTH_COMPONENT16", t[t.STENCIL_INDEX = 6401] = "STENCIL_INDEX", t[t.STENCIL_INDEX8 = 36168] = "STENCIL_INDEX8", t[t.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL", t[t.RENDERBUFFER_WIDTH = 36162] = "RENDERBUFFER_WIDTH", t[t.RENDERBUFFER_HEIGHT = 36163] = "RENDERBUFFER_HEIGHT", t[t.RENDERBUFFER_INTERNAL_FORMAT = 36164] = "RENDERBUFFER_INTERNAL_FORMAT", t[t.RENDERBUFFER_RED_SIZE = 36176] = "RENDERBUFFER_RED_SIZE", t[t.RENDERBUFFER_GREEN_SIZE = 36177] = "RENDERBUFFER_GREEN_SIZE", t[t.RENDERBUFFER_BLUE_SIZE = 36178] = "RENDERBUFFER_BLUE_SIZE", t[t.RENDERBUFFER_ALPHA_SIZE = 36179] = "RENDERBUFFER_ALPHA_SIZE", t[t.RENDERBUFFER_DEPTH_SIZE = 36180] = "RENDERBUFFER_DEPTH_SIZE", t[t.RENDERBUFFER_STENCIL_SIZE = 36181] = "RENDERBUFFER_STENCIL_SIZE", t[t.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 36048] = "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE", t[t.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 36049] = "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME", t[t.FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 36050] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL", t[t.FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 36051] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE", t[t.COLOR_ATTACHMENT0 = 36064] = "COLOR_ATTACHMENT0", t[t.DEPTH_ATTACHMENT = 36096] = "DEPTH_ATTACHMENT", t[t.STENCIL_ATTACHMENT = 36128] = "STENCIL_ATTACHMENT", t[t.DEPTH_STENCIL_ATTACHMENT = 33306] = "DEPTH_STENCIL_ATTACHMENT", t[t.NONE = 0] = "NONE", t[t.FRAMEBUFFER_COMPLETE = 36053] = "FRAMEBUFFER_COMPLETE", t[t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 36054] = "FRAMEBUFFER_INCOMPLETE_ATTACHMENT", t[t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 36055] = "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT", t[t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 36057] = "FRAMEBUFFER_INCOMPLETE_DIMENSIONS", t[t.FRAMEBUFFER_UNSUPPORTED = 36061] = "FRAMEBUFFER_UNSUPPORTED", t[t.FRAMEBUFFER_BINDING = 36006] = "FRAMEBUFFER_BINDING", t[t.RENDERBUFFER_BINDING = 36007] = "RENDERBUFFER_BINDING", t[t.READ_FRAMEBUFFER = 36008] = "READ_FRAMEBUFFER", t[t.DRAW_FRAMEBUFFER = 36009] = "DRAW_FRAMEBUFFER", t[t.MAX_RENDERBUFFER_SIZE = 34024] = "MAX_RENDERBUFFER_SIZE", t[t.INVALID_FRAMEBUFFER_OPERATION = 1286] = "INVALID_FRAMEBUFFER_OPERATION", t[t.UNPACK_FLIP_Y_WEBGL = 37440] = "UNPACK_FLIP_Y_WEBGL", t[t.UNPACK_PREMULTIPLY_ALPHA_WEBGL = 37441] = "UNPACK_PREMULTIPLY_ALPHA_WEBGL", t[t.UNPACK_COLORSPACE_CONVERSION_WEBGL = 37443] = "UNPACK_COLORSPACE_CONVERSION_WEBGL", t[t.READ_BUFFER = 3074] = "READ_BUFFER", t[t.UNPACK_ROW_LENGTH = 3314] = "UNPACK_ROW_LENGTH", t[t.UNPACK_SKIP_ROWS = 3315] = "UNPACK_SKIP_ROWS", t[t.UNPACK_SKIP_PIXELS = 3316] = "UNPACK_SKIP_PIXELS", t[t.PACK_ROW_LENGTH = 3330] = "PACK_ROW_LENGTH", t[t.PACK_SKIP_ROWS = 3331] = "PACK_SKIP_ROWS", t[t.PACK_SKIP_PIXELS = 3332] = "PACK_SKIP_PIXELS", t[t.TEXTURE_BINDING_3D = 32874] = "TEXTURE_BINDING_3D", t[t.UNPACK_SKIP_IMAGES = 32877] = "UNPACK_SKIP_IMAGES", t[t.UNPACK_IMAGE_HEIGHT = 32878] = "UNPACK_IMAGE_HEIGHT", t[t.MAX_3D_TEXTURE_SIZE = 32883] = "MAX_3D_TEXTURE_SIZE", t[t.MAX_ELEMENTS_VERTICES = 33e3] = "MAX_ELEMENTS_VERTICES", t[t.MAX_ELEMENTS_INDICES = 33001] = "MAX_ELEMENTS_INDICES", t[t.MAX_TEXTURE_LOD_BIAS = 34045] = "MAX_TEXTURE_LOD_BIAS", t[t.MAX_FRAGMENT_UNIFORM_COMPONENTS = 35657] = "MAX_FRAGMENT_UNIFORM_COMPONENTS", t[t.MAX_VERTEX_UNIFORM_COMPONENTS = 35658] = "MAX_VERTEX_UNIFORM_COMPONENTS", t[t.MAX_ARRAY_TEXTURE_LAYERS = 35071] = "MAX_ARRAY_TEXTURE_LAYERS", t[t.MIN_PROGRAM_TEXEL_OFFSET = 35076] = "MIN_PROGRAM_TEXEL_OFFSET", t[t.MAX_PROGRAM_TEXEL_OFFSET = 35077] = "MAX_PROGRAM_TEXEL_OFFSET", t[t.MAX_VARYING_COMPONENTS = 35659] = "MAX_VARYING_COMPONENTS", t[t.FRAGMENT_SHADER_DERIVATIVE_HINT = 35723] = "FRAGMENT_SHADER_DERIVATIVE_HINT", t[t.RASTERIZER_DISCARD = 35977] = "RASTERIZER_DISCARD", t[t.VERTEX_ARRAY_BINDING = 34229] = "VERTEX_ARRAY_BINDING", t[t.MAX_VERTEX_OUTPUT_COMPONENTS = 37154] = "MAX_VERTEX_OUTPUT_COMPONENTS", t[t.MAX_FRAGMENT_INPUT_COMPONENTS = 37157] = "MAX_FRAGMENT_INPUT_COMPONENTS", t[t.MAX_SERVER_WAIT_TIMEOUT = 37137] = "MAX_SERVER_WAIT_TIMEOUT", t[t.MAX_ELEMENT_INDEX = 36203] = "MAX_ELEMENT_INDEX", t[t.RED = 6403] = "RED", t[t.RGB8 = 32849] = "RGB8", t[t.RGBA8 = 32856] = "RGBA8", t[t.RGB10_A2 = 32857] = "RGB10_A2", t[t.TEXTURE_3D = 32879] = "TEXTURE_3D", t[t.TEXTURE_WRAP_R = 32882] = "TEXTURE_WRAP_R", t[t.TEXTURE_MIN_LOD = 33082] = "TEXTURE_MIN_LOD", t[t.TEXTURE_MAX_LOD = 33083] = "TEXTURE_MAX_LOD", t[t.TEXTURE_BASE_LEVEL = 33084] = "TEXTURE_BASE_LEVEL", t[t.TEXTURE_MAX_LEVEL = 33085] = "TEXTURE_MAX_LEVEL", t[t.TEXTURE_COMPARE_MODE = 34892] = "TEXTURE_COMPARE_MODE", t[t.TEXTURE_COMPARE_FUNC = 34893] = "TEXTURE_COMPARE_FUNC", t[t.SRGB = 35904] = "SRGB", t[t.SRGB8 = 35905] = "SRGB8", t[t.SRGB8_ALPHA8 = 35907] = "SRGB8_ALPHA8", t[t.COMPARE_REF_TO_TEXTURE = 34894] = "COMPARE_REF_TO_TEXTURE", t[t.RGBA32F = 34836] = "RGBA32F", t[t.RGB32F = 34837] = "RGB32F", t[t.RGBA16F = 34842] = "RGBA16F", t[t.RGB16F = 34843] = "RGB16F", t[t.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", t[t.TEXTURE_BINDING_2D_ARRAY = 35869] = "TEXTURE_BINDING_2D_ARRAY", t[t.R11F_G11F_B10F = 35898] = "R11F_G11F_B10F", t[t.RGB9_E5 = 35901] = "RGB9_E5", t[t.RGBA32UI = 36208] = "RGBA32UI", t[t.RGB32UI = 36209] = "RGB32UI", t[t.RGBA16UI = 36214] = "RGBA16UI", t[t.RGB16UI = 36215] = "RGB16UI", t[t.RGBA8UI = 36220] = "RGBA8UI", t[t.RGB8UI = 36221] = "RGB8UI", t[t.RGBA32I = 36226] = "RGBA32I", t[t.RGB32I = 36227] = "RGB32I", t[t.RGBA16I = 36232] = "RGBA16I", t[t.RGB16I = 36233] = "RGB16I", t[t.RGBA8I = 36238] = "RGBA8I", t[t.RGB8I = 36239] = "RGB8I", t[t.RED_INTEGER = 36244] = "RED_INTEGER", t[t.RGB_INTEGER = 36248] = "RGB_INTEGER", t[t.RGBA_INTEGER = 36249] = "RGBA_INTEGER", t[t.R8 = 33321] = "R8", t[t.RG8 = 33323] = "RG8", t[t.R16F = 33325] = "R16F", t[t.R32F = 33326] = "R32F", t[t.RG16F = 33327] = "RG16F", t[t.RG32F = 33328] = "RG32F", t[t.R8I = 33329] = "R8I", t[t.R8UI = 33330] = "R8UI", t[t.R16I = 33331] = "R16I", t[t.R16UI = 33332] = "R16UI", t[t.R32I = 33333] = "R32I", t[t.R32UI = 33334] = "R32UI", t[t.RG8I = 33335] = "RG8I", t[t.RG8UI = 33336] = "RG8UI", t[t.RG16I = 33337] = "RG16I", t[t.RG16UI = 33338] = "RG16UI", t[t.RG32I = 33339] = "RG32I", t[t.RG32UI = 33340] = "RG32UI", t[t.R8_SNORM = 36756] = "R8_SNORM", t[t.RG8_SNORM = 36757] = "RG8_SNORM", t[t.RGB8_SNORM = 36758] = "RGB8_SNORM", t[t.RGBA8_SNORM = 36759] = "RGBA8_SNORM", t[t.RGB10_A2UI = 36975] = "RGB10_A2UI", t[t.TEXTURE_IMMUTABLE_FORMAT = 37167] = "TEXTURE_IMMUTABLE_FORMAT", t[t.TEXTURE_IMMUTABLE_LEVELS = 33503] = "TEXTURE_IMMUTABLE_LEVELS", t[t.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", t[t.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", t[t.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", t[t.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", t[t.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", t[t.HALF_FLOAT = 5131] = "HALF_FLOAT", t[t.RG = 33319] = "RG", t[t.RG_INTEGER = 33320] = "RG_INTEGER", t[t.INT_2_10_10_10_REV = 36255] = "INT_2_10_10_10_REV", t[t.CURRENT_QUERY = 34917] = "CURRENT_QUERY", t[t.QUERY_RESULT = 34918] = "QUERY_RESULT", t[t.QUERY_RESULT_AVAILABLE = 34919] = "QUERY_RESULT_AVAILABLE", t[t.ANY_SAMPLES_PASSED = 35887] = "ANY_SAMPLES_PASSED", t[t.ANY_SAMPLES_PASSED_CONSERVATIVE = 36202] = "ANY_SAMPLES_PASSED_CONSERVATIVE", t[t.MAX_DRAW_BUFFERS = 34852] = "MAX_DRAW_BUFFERS", t[t.DRAW_BUFFER0 = 34853] = "DRAW_BUFFER0", t[t.DRAW_BUFFER1 = 34854] = "DRAW_BUFFER1", t[t.DRAW_BUFFER2 = 34855] = "DRAW_BUFFER2", t[t.DRAW_BUFFER3 = 34856] = "DRAW_BUFFER3", t[t.DRAW_BUFFER4 = 34857] = "DRAW_BUFFER4", t[t.DRAW_BUFFER5 = 34858] = "DRAW_BUFFER5", t[t.DRAW_BUFFER6 = 34859] = "DRAW_BUFFER6", t[t.DRAW_BUFFER7 = 34860] = "DRAW_BUFFER7", t[t.DRAW_BUFFER8 = 34861] = "DRAW_BUFFER8", t[t.DRAW_BUFFER9 = 34862] = "DRAW_BUFFER9", t[t.DRAW_BUFFER10 = 34863] = "DRAW_BUFFER10", t[t.DRAW_BUFFER11 = 34864] = "DRAW_BUFFER11", t[t.DRAW_BUFFER12 = 34865] = "DRAW_BUFFER12", t[t.DRAW_BUFFER13 = 34866] = "DRAW_BUFFER13", t[t.DRAW_BUFFER14 = 34867] = "DRAW_BUFFER14", t[t.DRAW_BUFFER15 = 34868] = "DRAW_BUFFER15", t[t.MAX_COLOR_ATTACHMENTS = 36063] = "MAX_COLOR_ATTACHMENTS", t[t.COLOR_ATTACHMENT1 = 36065] = "COLOR_ATTACHMENT1", t[t.COLOR_ATTACHMENT2 = 36066] = "COLOR_ATTACHMENT2", t[t.COLOR_ATTACHMENT3 = 36067] = "COLOR_ATTACHMENT3", t[t.COLOR_ATTACHMENT4 = 36068] = "COLOR_ATTACHMENT4", t[t.COLOR_ATTACHMENT5 = 36069] = "COLOR_ATTACHMENT5", t[t.COLOR_ATTACHMENT6 = 36070] = "COLOR_ATTACHMENT6", t[t.COLOR_ATTACHMENT7 = 36071] = "COLOR_ATTACHMENT7", t[t.COLOR_ATTACHMENT8 = 36072] = "COLOR_ATTACHMENT8", t[t.COLOR_ATTACHMENT9 = 36073] = "COLOR_ATTACHMENT9", t[t.COLOR_ATTACHMENT10 = 36074] = "COLOR_ATTACHMENT10", t[t.COLOR_ATTACHMENT11 = 36075] = "COLOR_ATTACHMENT11", t[t.COLOR_ATTACHMENT12 = 36076] = "COLOR_ATTACHMENT12", t[t.COLOR_ATTACHMENT13 = 36077] = "COLOR_ATTACHMENT13", t[t.COLOR_ATTACHMENT14 = 36078] = "COLOR_ATTACHMENT14", t[t.COLOR_ATTACHMENT15 = 36079] = "COLOR_ATTACHMENT15", t[t.SAMPLER_3D = 35679] = "SAMPLER_3D", t[t.SAMPLER_2D_SHADOW = 35682] = "SAMPLER_2D_SHADOW", t[t.SAMPLER_2D_ARRAY = 36289] = "SAMPLER_2D_ARRAY", t[t.SAMPLER_2D_ARRAY_SHADOW = 36292] = "SAMPLER_2D_ARRAY_SHADOW", t[t.SAMPLER_CUBE_SHADOW = 36293] = "SAMPLER_CUBE_SHADOW", t[t.INT_SAMPLER_2D = 36298] = "INT_SAMPLER_2D", t[t.INT_SAMPLER_3D = 36299] = "INT_SAMPLER_3D", t[t.INT_SAMPLER_CUBE = 36300] = "INT_SAMPLER_CUBE", t[t.INT_SAMPLER_2D_ARRAY = 36303] = "INT_SAMPLER_2D_ARRAY", t[t.UNSIGNED_INT_SAMPLER_2D = 36306] = "UNSIGNED_INT_SAMPLER_2D", t[t.UNSIGNED_INT_SAMPLER_3D = 36307] = "UNSIGNED_INT_SAMPLER_3D", t[t.UNSIGNED_INT_SAMPLER_CUBE = 36308] = "UNSIGNED_INT_SAMPLER_CUBE", t[t.UNSIGNED_INT_SAMPLER_2D_ARRAY = 36311] = "UNSIGNED_INT_SAMPLER_2D_ARRAY", t[t.MAX_SAMPLES = 36183] = "MAX_SAMPLES", t[t.SAMPLER_BINDING = 35097] = "SAMPLER_BINDING", t[t.PIXEL_PACK_BUFFER = 35051] = "PIXEL_PACK_BUFFER", t[t.PIXEL_UNPACK_BUFFER = 35052] = "PIXEL_UNPACK_BUFFER", t[t.PIXEL_PACK_BUFFER_BINDING = 35053] = "PIXEL_PACK_BUFFER_BINDING", t[t.PIXEL_UNPACK_BUFFER_BINDING = 35055] = "PIXEL_UNPACK_BUFFER_BINDING", t[t.COPY_READ_BUFFER = 36662] = "COPY_READ_BUFFER", t[t.COPY_WRITE_BUFFER = 36663] = "COPY_WRITE_BUFFER", t[t.COPY_READ_BUFFER_BINDING = 36662] = "COPY_READ_BUFFER_BINDING", t[t.COPY_WRITE_BUFFER_BINDING = 36663] = "COPY_WRITE_BUFFER_BINDING", t[t.FLOAT_MAT2x3 = 35685] = "FLOAT_MAT2x3", t[t.FLOAT_MAT2x4 = 35686] = "FLOAT_MAT2x4", t[t.FLOAT_MAT3x2 = 35687] = "FLOAT_MAT3x2", t[t.FLOAT_MAT3x4 = 35688] = "FLOAT_MAT3x4", t[t.FLOAT_MAT4x2 = 35689] = "FLOAT_MAT4x2", t[t.FLOAT_MAT4x3 = 35690] = "FLOAT_MAT4x3", t[t.UNSIGNED_INT_VEC2 = 36294] = "UNSIGNED_INT_VEC2", t[t.UNSIGNED_INT_VEC3 = 36295] = "UNSIGNED_INT_VEC3", t[t.UNSIGNED_INT_VEC4 = 36296] = "UNSIGNED_INT_VEC4", t[t.UNSIGNED_NORMALIZED = 35863] = "UNSIGNED_NORMALIZED", t[t.SIGNED_NORMALIZED = 36764] = "SIGNED_NORMALIZED", t[t.VERTEX_ATTRIB_ARRAY_INTEGER = 35069] = "VERTEX_ATTRIB_ARRAY_INTEGER", t[t.VERTEX_ATTRIB_ARRAY_DIVISOR = 35070] = "VERTEX_ATTRIB_ARRAY_DIVISOR", t[t.TRANSFORM_FEEDBACK_BUFFER_MODE = 35967] = "TRANSFORM_FEEDBACK_BUFFER_MODE", t[t.MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS = 35968] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS", t[t.TRANSFORM_FEEDBACK_VARYINGS = 35971] = "TRANSFORM_FEEDBACK_VARYINGS", t[t.TRANSFORM_FEEDBACK_BUFFER_START = 35972] = "TRANSFORM_FEEDBACK_BUFFER_START", t[t.TRANSFORM_FEEDBACK_BUFFER_SIZE = 35973] = "TRANSFORM_FEEDBACK_BUFFER_SIZE", t[t.TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 35976] = "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN", t[t.MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS = 35978] = "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS", t[t.MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS = 35979] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS", t[t.INTERLEAVED_ATTRIBS = 35980] = "INTERLEAVED_ATTRIBS", t[t.SEPARATE_ATTRIBS = 35981] = "SEPARATE_ATTRIBS", t[t.TRANSFORM_FEEDBACK_BUFFER = 35982] = "TRANSFORM_FEEDBACK_BUFFER", t[t.TRANSFORM_FEEDBACK_BUFFER_BINDING = 35983] = "TRANSFORM_FEEDBACK_BUFFER_BINDING", t[t.TRANSFORM_FEEDBACK = 36386] = "TRANSFORM_FEEDBACK", t[t.TRANSFORM_FEEDBACK_PAUSED = 36387] = "TRANSFORM_FEEDBACK_PAUSED", t[t.TRANSFORM_FEEDBACK_ACTIVE = 36388] = "TRANSFORM_FEEDBACK_ACTIVE", t[t.TRANSFORM_FEEDBACK_BINDING = 36389] = "TRANSFORM_FEEDBACK_BINDING", t[t.FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING = 33296] = "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING", t[t.FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE = 33297] = "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE", t[t.FRAMEBUFFER_ATTACHMENT_RED_SIZE = 33298] = "FRAMEBUFFER_ATTACHMENT_RED_SIZE", t[t.FRAMEBUFFER_ATTACHMENT_GREEN_SIZE = 33299] = "FRAMEBUFFER_ATTACHMENT_GREEN_SIZE", t[t.FRAMEBUFFER_ATTACHMENT_BLUE_SIZE = 33300] = "FRAMEBUFFER_ATTACHMENT_BLUE_SIZE", t[t.FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE = 33301] = "FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE", t[t.FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE = 33302] = "FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE", t[t.FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE = 33303] = "FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE", t[t.FRAMEBUFFER_DEFAULT = 33304] = "FRAMEBUFFER_DEFAULT", t[t.DEPTH24_STENCIL8 = 35056] = "DEPTH24_STENCIL8", t[t.DRAW_FRAMEBUFFER_BINDING = 36006] = "DRAW_FRAMEBUFFER_BINDING", t[t.READ_FRAMEBUFFER_BINDING = 36010] = "READ_FRAMEBUFFER_BINDING", t[t.RENDERBUFFER_SAMPLES = 36011] = "RENDERBUFFER_SAMPLES", t[t.FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER = 36052] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER", t[t.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE = 36182] = "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE", t[t.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER", t[t.UNIFORM_BUFFER_BINDING = 35368] = "UNIFORM_BUFFER_BINDING", t[t.UNIFORM_BUFFER_START = 35369] = "UNIFORM_BUFFER_START", t[t.UNIFORM_BUFFER_SIZE = 35370] = "UNIFORM_BUFFER_SIZE", t[t.MAX_VERTEX_UNIFORM_BLOCKS = 35371] = "MAX_VERTEX_UNIFORM_BLOCKS", t[t.MAX_FRAGMENT_UNIFORM_BLOCKS = 35373] = "MAX_FRAGMENT_UNIFORM_BLOCKS", t[t.MAX_COMBINED_UNIFORM_BLOCKS = 35374] = "MAX_COMBINED_UNIFORM_BLOCKS", t[t.MAX_UNIFORM_BUFFER_BINDINGS = 35375] = "MAX_UNIFORM_BUFFER_BINDINGS", t[t.MAX_UNIFORM_BLOCK_SIZE = 35376] = "MAX_UNIFORM_BLOCK_SIZE", t[t.MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS = 35377] = "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS", t[t.MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS = 35379] = "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS", t[t.UNIFORM_BUFFER_OFFSET_ALIGNMENT = 35380] = "UNIFORM_BUFFER_OFFSET_ALIGNMENT", t[t.ACTIVE_UNIFORM_BLOCKS = 35382] = "ACTIVE_UNIFORM_BLOCKS", t[t.UNIFORM_TYPE = 35383] = "UNIFORM_TYPE", t[t.UNIFORM_SIZE = 35384] = "UNIFORM_SIZE", t[t.UNIFORM_BLOCK_INDEX = 35386] = "UNIFORM_BLOCK_INDEX", t[t.UNIFORM_OFFSET = 35387] = "UNIFORM_OFFSET", t[t.UNIFORM_ARRAY_STRIDE = 35388] = "UNIFORM_ARRAY_STRIDE", t[t.UNIFORM_MATRIX_STRIDE = 35389] = "UNIFORM_MATRIX_STRIDE", t[t.UNIFORM_IS_ROW_MAJOR = 35390] = "UNIFORM_IS_ROW_MAJOR", t[t.UNIFORM_BLOCK_BINDING = 35391] = "UNIFORM_BLOCK_BINDING", t[t.UNIFORM_BLOCK_DATA_SIZE = 35392] = "UNIFORM_BLOCK_DATA_SIZE", t[t.UNIFORM_BLOCK_ACTIVE_UNIFORMS = 35394] = "UNIFORM_BLOCK_ACTIVE_UNIFORMS", t[t.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES = 35395] = "UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES", t[t.UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER = 35396] = "UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER", t[t.UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER = 35398] = "UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER", t[t.OBJECT_TYPE = 37138] = "OBJECT_TYPE", t[t.SYNC_CONDITION = 37139] = "SYNC_CONDITION", t[t.SYNC_STATUS = 37140] = "SYNC_STATUS", t[t.SYNC_FLAGS = 37141] = "SYNC_FLAGS", t[t.SYNC_FENCE = 37142] = "SYNC_FENCE", t[t.SYNC_GPU_COMMANDS_COMPLETE = 37143] = "SYNC_GPU_COMMANDS_COMPLETE", t[t.UNSIGNALED = 37144] = "UNSIGNALED", t[t.SIGNALED = 37145] = "SIGNALED", t[t.ALREADY_SIGNALED = 37146] = "ALREADY_SIGNALED", t[t.TIMEOUT_EXPIRED = 37147] = "TIMEOUT_EXPIRED", t[t.CONDITION_SATISFIED = 37148] = "CONDITION_SATISFIED", t[t.WAIT_FAILED = 37149] = "WAIT_FAILED", t[t.SYNC_FLUSH_COMMANDS_BIT = 1] = "SYNC_FLUSH_COMMANDS_BIT", t[t.COLOR = 6144] = "COLOR", t[t.DEPTH = 6145] = "DEPTH", t[t.STENCIL = 6146] = "STENCIL", t[t.MIN = 32775] = "MIN", t[t.MAX = 32776] = "MAX", t[t.DEPTH_COMPONENT24 = 33190] = "DEPTH_COMPONENT24", t[t.STREAM_READ = 35041] = "STREAM_READ", t[t.STREAM_COPY = 35042] = "STREAM_COPY", t[t.STATIC_READ = 35045] = "STATIC_READ", t[t.STATIC_COPY = 35046] = "STATIC_COPY", t[t.DYNAMIC_READ = 35049] = "DYNAMIC_READ", t[t.DYNAMIC_COPY = 35050] = "DYNAMIC_COPY", t[t.DEPTH_COMPONENT32F = 36012] = "DEPTH_COMPONENT32F", t[t.DEPTH32F_STENCIL8 = 36013] = "DEPTH32F_STENCIL8", t[t.INVALID_INDEX = 4294967295] = "INVALID_INDEX", t[t.TIMEOUT_IGNORED = -1] = "TIMEOUT_IGNORED", t[t.MAX_CLIENT_WAIT_TIMEOUT_WEBGL = 37447] = "MAX_CLIENT_WAIT_TIMEOUT_WEBGL", t[t.UNMASKED_VENDOR_WEBGL = 37445] = "UNMASKED_VENDOR_WEBGL", t[t.UNMASKED_RENDERER_WEBGL = 37446] = "UNMASKED_RENDERER_WEBGL", t[t.MAX_TEXTURE_MAX_ANISOTROPY_EXT = 34047] = "MAX_TEXTURE_MAX_ANISOTROPY_EXT", t[t.TEXTURE_MAX_ANISOTROPY_EXT = 34046] = "TEXTURE_MAX_ANISOTROPY_EXT", t[t.R16_EXT = 33322] = "R16_EXT", t[t.RG16_EXT = 33324] = "RG16_EXT", t[t.RGB16_EXT = 32852] = "RGB16_EXT", t[t.RGBA16_EXT = 32859] = "RGBA16_EXT", t[t.R16_SNORM_EXT = 36760] = "R16_SNORM_EXT", t[t.RG16_SNORM_EXT = 36761] = "RG16_SNORM_EXT", t[t.RGB16_SNORM_EXT = 36762] = "RGB16_SNORM_EXT", t[t.RGBA16_SNORM_EXT = 36763] = "RGBA16_SNORM_EXT", t[t.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT", t[t.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT", t[t.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT", t[t.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT", t[t.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT", t[t.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", t[t.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", t[t.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", t[t.COMPRESSED_RED_RGTC1_EXT = 36283] = "COMPRESSED_RED_RGTC1_EXT", t[t.COMPRESSED_SIGNED_RED_RGTC1_EXT = 36284] = "COMPRESSED_SIGNED_RED_RGTC1_EXT", t[t.COMPRESSED_RED_GREEN_RGTC2_EXT = 36285] = "COMPRESSED_RED_GREEN_RGTC2_EXT", t[t.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT = 36286] = "COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT", t[t.COMPRESSED_RGBA_BPTC_UNORM_EXT = 36492] = "COMPRESSED_RGBA_BPTC_UNORM_EXT", t[t.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = 36493] = "COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT", t[t.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT = 36494] = "COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT", t[t.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT = 36495] = "COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT", t[t.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC", t[t.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC", t[t.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC", t[t.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC", t[t.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2", t[t.COMPRESSED_RGBA8_ETC2_EAC = 37493] = "COMPRESSED_RGBA8_ETC2_EAC", t[t.COMPRESSED_SRGB8_ETC2 = 37494] = "COMPRESSED_SRGB8_ETC2", t[t.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37495] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", t[t.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37496] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", t[t.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37497] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", t[t.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", t[t.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", t[t.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", t[t.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", t[t.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL", t[t.COMPRESSED_RGB_ATC_WEBGL = 35986] = "COMPRESSED_RGB_ATC_WEBGL", t[t.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL", t[t.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL", t[t.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR", t[t.COMPRESSED_RGBA_ASTC_5x4_KHR = 37809] = "COMPRESSED_RGBA_ASTC_5x4_KHR", t[t.COMPRESSED_RGBA_ASTC_5x5_KHR = 37810] = "COMPRESSED_RGBA_ASTC_5x5_KHR", t[t.COMPRESSED_RGBA_ASTC_6x5_KHR = 37811] = "COMPRESSED_RGBA_ASTC_6x5_KHR", t[t.COMPRESSED_RGBA_ASTC_6x6_KHR = 37812] = "COMPRESSED_RGBA_ASTC_6x6_KHR", t[t.COMPRESSED_RGBA_ASTC_8x5_KHR = 37813] = "COMPRESSED_RGBA_ASTC_8x5_KHR", t[t.COMPRESSED_RGBA_ASTC_8x6_KHR = 37814] = "COMPRESSED_RGBA_ASTC_8x6_KHR", t[t.COMPRESSED_RGBA_ASTC_8x8_KHR = 37815] = "COMPRESSED_RGBA_ASTC_8x8_KHR", t[t.COMPRESSED_RGBA_ASTC_10x5_KHR = 37816] = "COMPRESSED_RGBA_ASTC_10x5_KHR", t[t.COMPRESSED_RGBA_ASTC_10x6_KHR = 37817] = "COMPRESSED_RGBA_ASTC_10x6_KHR", t[t.COMPRESSED_RGBA_ASTC_10x8_KHR = 37818] = "COMPRESSED_RGBA_ASTC_10x8_KHR", t[t.COMPRESSED_RGBA_ASTC_10x10_KHR = 37819] = "COMPRESSED_RGBA_ASTC_10x10_KHR", t[t.COMPRESSED_RGBA_ASTC_12x10_KHR = 37820] = "COMPRESSED_RGBA_ASTC_12x10_KHR", t[t.COMPRESSED_RGBA_ASTC_12x12_KHR = 37821] = "COMPRESSED_RGBA_ASTC_12x12_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = 37840] = "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR = 37841] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR = 37842] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR = 37843] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR = 37844] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR = 37845] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR = 37846] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR = 37847] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR = 37848] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR = 37849] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR = 37850] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR = 37851] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR = 37852] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR = 37853] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR", t[t.QUERY_COUNTER_BITS_EXT = 34916] = "QUERY_COUNTER_BITS_EXT", t[t.CURRENT_QUERY_EXT = 34917] = "CURRENT_QUERY_EXT", t[t.QUERY_RESULT_EXT = 34918] = "QUERY_RESULT_EXT", t[t.QUERY_RESULT_AVAILABLE_EXT = 34919] = "QUERY_RESULT_AVAILABLE_EXT", t[t.TIME_ELAPSED_EXT = 35007] = "TIME_ELAPSED_EXT", t[t.TIMESTAMP_EXT = 36392] = "TIMESTAMP_EXT", t[t.GPU_DISJOINT_EXT = 36795] = "GPU_DISJOINT_EXT", t[t.COMPLETION_STATUS_KHR = 37297] = "COMPLETION_STATUS_KHR", t[t.DEPTH_CLAMP_EXT = 34383] = "DEPTH_CLAMP_EXT", t[t.FIRST_VERTEX_CONVENTION_WEBGL = 36429] = "FIRST_VERTEX_CONVENTION_WEBGL", t[t.LAST_VERTEX_CONVENTION_WEBGL = 36430] = "LAST_VERTEX_CONVENTION_WEBGL", t[t.PROVOKING_VERTEX_WEBL = 36431] = "PROVOKING_VERTEX_WEBL", t[t.POLYGON_MODE_WEBGL = 2880] = "POLYGON_MODE_WEBGL", t[t.POLYGON_OFFSET_LINE_WEBGL = 10754] = "POLYGON_OFFSET_LINE_WEBGL", t[t.LINE_WEBGL = 6913] = "LINE_WEBGL", t[t.FILL_WEBGL = 6914] = "FILL_WEBGL", t[t.MAX_CLIP_DISTANCES_WEBGL = 3378] = "MAX_CLIP_DISTANCES_WEBGL", t[t.MAX_CULL_DISTANCES_WEBGL = 33529] = "MAX_CULL_DISTANCES_WEBGL", t[t.MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL = 33530] = "MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL", t[t.CLIP_DISTANCE0_WEBGL = 12288] = "CLIP_DISTANCE0_WEBGL", t[t.CLIP_DISTANCE1_WEBGL = 12289] = "CLIP_DISTANCE1_WEBGL", t[t.CLIP_DISTANCE2_WEBGL = 12290] = "CLIP_DISTANCE2_WEBGL", t[t.CLIP_DISTANCE3_WEBGL = 12291] = "CLIP_DISTANCE3_WEBGL", t[t.CLIP_DISTANCE4_WEBGL = 12292] = "CLIP_DISTANCE4_WEBGL", t[t.CLIP_DISTANCE5_WEBGL = 12293] = "CLIP_DISTANCE5_WEBGL", t[t.CLIP_DISTANCE6_WEBGL = 12294] = "CLIP_DISTANCE6_WEBGL", t[t.CLIP_DISTANCE7_WEBGL = 12295] = "CLIP_DISTANCE7_WEBGL", t[t.POLYGON_OFFSET_CLAMP_EXT = 36379] = "POLYGON_OFFSET_CLAMP_EXT", t[t.LOWER_LEFT_EXT = 36001] = "LOWER_LEFT_EXT", t[t.UPPER_LEFT_EXT = 36002] = "UPPER_LEFT_EXT", t[t.NEGATIVE_ONE_TO_ONE_EXT = 37726] = "NEGATIVE_ONE_TO_ONE_EXT", t[t.ZERO_TO_ONE_EXT = 37727] = "ZERO_TO_ONE_EXT", t[t.CLIP_ORIGIN_EXT = 37724] = "CLIP_ORIGIN_EXT", t[t.CLIP_DEPTH_MODE_EXT = 37725] = "CLIP_DEPTH_MODE_EXT", t[t.SRC1_COLOR_WEBGL = 35065] = "SRC1_COLOR_WEBGL", t[t.SRC1_ALPHA_WEBGL = 34185] = "SRC1_ALPHA_WEBGL", t[t.ONE_MINUS_SRC1_COLOR_WEBGL = 35066] = "ONE_MINUS_SRC1_COLOR_WEBGL", t[t.ONE_MINUS_SRC1_ALPHA_WEBGL = 35067] = "ONE_MINUS_SRC1_ALPHA_WEBGL", t[t.MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL = 35068] = "MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL", t[t.MIRROR_CLAMP_TO_EDGE_EXT = 34627] = "MIRROR_CLAMP_TO_EDGE_EXT";
})($c || ($c = {}));
const By = {
  3042: !1,
  32773: new Float32Array([0, 0, 0, 0]),
  32777: 32774,
  34877: 32774,
  32969: 1,
  32968: 0,
  32971: 1,
  32970: 0,
  3106: new Float32Array([0, 0, 0, 0]),
  // TBD
  3107: [!0, !0, !0, !0],
  2884: !1,
  2885: 1029,
  2929: !1,
  2931: 1,
  2932: 513,
  2928: new Float32Array([0, 1]),
  // TBD
  2930: !0,
  3024: !0,
  35725: null,
  // FRAMEBUFFER_BINDING and DRAW_FRAMEBUFFER_BINDING(WebGL2) refer same state.
  36006: null,
  36007: null,
  34229: null,
  34964: null,
  2886: 2305,
  33170: 4352,
  2849: 1,
  32823: !1,
  32824: 0,
  10752: 0,
  32926: !1,
  32928: !1,
  32938: 1,
  32939: !1,
  3089: !1,
  // Note: Dynamic value. If scissor test enabled we expect users to set correct scissor box
  3088: new Int32Array([0, 0, 1024, 1024]),
  2960: !1,
  2961: 0,
  2968: 4294967295,
  36005: 4294967295,
  2962: 519,
  2967: 0,
  2963: 4294967295,
  34816: 519,
  36003: 0,
  36004: 4294967295,
  2964: 7680,
  2965: 7680,
  2966: 7680,
  34817: 7680,
  34818: 7680,
  34819: 7680,
  // Dynamic value: We use [0, 0, 1024, 1024] as default, but usually this is updated in each frame.
  2978: [0, 0, 1024, 1024],
  36389: null,
  36662: null,
  36663: null,
  35053: null,
  35055: null,
  35723: 4352,
  36010: null,
  35977: !1,
  3333: 4,
  3317: 4,
  37440: !1,
  37441: !1,
  37443: 37444,
  3330: 0,
  3332: 0,
  3331: 0,
  3314: 0,
  32878: 0,
  3316: 0,
  3315: 0,
  32877: 0
}, pr = (t, e, i) => e ? t.enable(i) : t.disable(i), ix = (t, e, i) => t.hint(i, e), $s = (t, e, i) => t.pixelStorei(i, e), rx = (t, e, i) => {
  const s = i === 36006 ? 36009 : 36008;
  return t.bindFramebuffer(s, e);
}, Au = (t, e, i) => {
  const o = {
    34964: 34962,
    36662: 36662,
    36663: 36663,
    35053: 35051,
    35055: 35052
  }[i];
  t.bindBuffer(o, e);
};
function vg(t) {
  return Array.isArray(t) || ArrayBuffer.isView(t) && !(t instanceof DataView);
}
const SO = {
  3042: pr,
  32773: (t, e) => t.blendColor(...e),
  32777: "blendEquation",
  34877: "blendEquation",
  32969: "blendFunc",
  32968: "blendFunc",
  32971: "blendFunc",
  32970: "blendFunc",
  3106: (t, e) => t.clearColor(...e),
  3107: (t, e) => t.colorMask(...e),
  2884: pr,
  2885: (t, e) => t.cullFace(e),
  2929: pr,
  2931: (t, e) => t.clearDepth(e),
  2932: (t, e) => t.depthFunc(e),
  2928: (t, e) => t.depthRange(...e),
  2930: (t, e) => t.depthMask(e),
  3024: pr,
  35723: ix,
  35725: (t, e) => t.useProgram(e),
  36007: (t, e) => t.bindRenderbuffer(36161, e),
  36389: (t, e) => t.bindTransformFeedback?.(36386, e),
  34229: (t, e) => t.bindVertexArray(e),
  // NOTE: FRAMEBUFFER_BINDING and DRAW_FRAMEBUFFER_BINDING(WebGL2) refer same state.
  36006: rx,
  36010: rx,
  // Buffers
  34964: Au,
  36662: Au,
  36663: Au,
  35053: Au,
  35055: Au,
  2886: (t, e) => t.frontFace(e),
  33170: ix,
  2849: (t, e) => t.lineWidth(e),
  32823: pr,
  32824: "polygonOffset",
  10752: "polygonOffset",
  35977: pr,
  32926: pr,
  32928: pr,
  32938: "sampleCoverage",
  32939: "sampleCoverage",
  3089: pr,
  3088: (t, e) => t.scissor(...e),
  2960: pr,
  2961: (t, e) => t.clearStencil(e),
  2968: (t, e) => t.stencilMaskSeparate(1028, e),
  36005: (t, e) => t.stencilMaskSeparate(1029, e),
  2962: "stencilFuncFront",
  2967: "stencilFuncFront",
  2963: "stencilFuncFront",
  34816: "stencilFuncBack",
  36003: "stencilFuncBack",
  36004: "stencilFuncBack",
  2964: "stencilOpFront",
  2965: "stencilOpFront",
  2966: "stencilOpFront",
  34817: "stencilOpBack",
  34818: "stencilOpBack",
  34819: "stencilOpBack",
  2978: (t, e) => t.viewport(...e),
  // WEBGL2 EXTENSIONS
  // EXT_depth_clamp https://registry.khronos.org/webgl/extensions/EXT_depth_clamp/
  34383: pr,
  // WEBGL_provoking_vertex https://registry.khronos.org/webgl/extensions/WEBGL_provoking_vertex/
  // [GL.PROVOKING_VERTEX_WEBL]: TODO - extension function needed
  // WEBGL_polygon_mode https://registry.khronos.org/webgl/extensions/WEBGL_polygon_mode/
  // POLYGON_MODE_WEBGL  TODO - extension function needed
  10754: pr,
  // WEBGL_clip_cull_distance https://registry.khronos.org/webgl/extensions/WEBGL_clip_cull_distance/
  12288: pr,
  12289: pr,
  12290: pr,
  12291: pr,
  12292: pr,
  12293: pr,
  12294: pr,
  12295: pr,
  // PIXEL PACK/UNPACK MODES
  3333: $s,
  3317: $s,
  37440: $s,
  37441: $s,
  37443: $s,
  3330: $s,
  3332: $s,
  3331: $s,
  3314: $s,
  32878: $s,
  3316: $s,
  3315: $s,
  32877: $s,
  // Function-style setters
  framebuffer: (t, e) => {
    const i = e && "handle" in e ? e.handle : e;
    return t.bindFramebuffer(36160, i);
  },
  blend: (t, e) => e ? t.enable(3042) : t.disable(3042),
  blendColor: (t, e) => t.blendColor(...e),
  blendEquation: (t, e) => {
    const i = typeof e == "number" ? [e, e] : e;
    t.blendEquationSeparate(...i);
  },
  blendFunc: (t, e) => {
    const i = e?.length === 2 ? [...e, ...e] : e;
    t.blendFuncSeparate(...i);
  },
  clearColor: (t, e) => t.clearColor(...e),
  clearDepth: (t, e) => t.clearDepth(e),
  clearStencil: (t, e) => t.clearStencil(e),
  colorMask: (t, e) => t.colorMask(...e),
  cull: (t, e) => e ? t.enable(2884) : t.disable(2884),
  cullFace: (t, e) => t.cullFace(e),
  depthTest: (t, e) => e ? t.enable(2929) : t.disable(2929),
  depthFunc: (t, e) => t.depthFunc(e),
  depthMask: (t, e) => t.depthMask(e),
  depthRange: (t, e) => t.depthRange(...e),
  dither: (t, e) => e ? t.enable(3024) : t.disable(3024),
  derivativeHint: (t, e) => {
    t.hint(35723, e);
  },
  frontFace: (t, e) => t.frontFace(e),
  mipmapHint: (t, e) => t.hint(33170, e),
  lineWidth: (t, e) => t.lineWidth(e),
  polygonOffsetFill: (t, e) => e ? t.enable(32823) : t.disable(32823),
  polygonOffset: (t, e) => t.polygonOffset(...e),
  sampleCoverage: (t, e) => t.sampleCoverage(...e),
  scissorTest: (t, e) => e ? t.enable(3089) : t.disable(3089),
  scissor: (t, e) => t.scissor(...e),
  stencilTest: (t, e) => e ? t.enable(2960) : t.disable(2960),
  stencilMask: (t, e) => {
    e = vg(e) ? e : [e, e];
    const [i, s] = e;
    t.stencilMaskSeparate(1028, i), t.stencilMaskSeparate(1029, s);
  },
  stencilFunc: (t, e) => {
    e = vg(e) && e.length === 3 ? [...e, ...e] : e;
    const [i, s, o, u, d, a] = e;
    t.stencilFuncSeparate(1028, i, s, o), t.stencilFuncSeparate(1029, u, d, a);
  },
  stencilOp: (t, e) => {
    e = vg(e) && e.length === 3 ? [...e, ...e] : e;
    const [i, s, o, u, d, a] = e;
    t.stencilOpSeparate(1028, i, s, o), t.stencilOpSeparate(1029, u, d, a);
  },
  viewport: (t, e) => t.viewport(...e)
};
function Ki(t, e, i) {
  return e[t] !== void 0 ? e[t] : i[t];
}
const CO = {
  blendEquation: (t, e, i) => t.blendEquationSeparate(Ki(32777, e, i), Ki(34877, e, i)),
  blendFunc: (t, e, i) => t.blendFuncSeparate(Ki(32969, e, i), Ki(32968, e, i), Ki(32971, e, i), Ki(32970, e, i)),
  polygonOffset: (t, e, i) => t.polygonOffset(Ki(32824, e, i), Ki(10752, e, i)),
  sampleCoverage: (t, e, i) => t.sampleCoverage(Ki(32938, e, i), Ki(32939, e, i)),
  stencilFuncFront: (t, e, i) => t.stencilFuncSeparate(1028, Ki(2962, e, i), Ki(2967, e, i), Ki(2963, e, i)),
  stencilFuncBack: (t, e, i) => t.stencilFuncSeparate(1029, Ki(34816, e, i), Ki(36003, e, i), Ki(36004, e, i)),
  stencilOpFront: (t, e, i) => t.stencilOpSeparate(1028, Ki(2964, e, i), Ki(2965, e, i), Ki(2966, e, i)),
  stencilOpBack: (t, e, i) => t.stencilOpSeparate(1029, Ki(34817, e, i), Ki(34818, e, i), Ki(34819, e, i))
}, sx = {
  // GENERIC SETTERS
  enable: (t, e) => t({
    [e]: !0
  }),
  disable: (t, e) => t({
    [e]: !1
  }),
  pixelStorei: (t, e, i) => t({
    [e]: i
  }),
  hint: (t, e, i) => t({
    [e]: i
  }),
  // SPECIFIC SETTERS
  useProgram: (t, e) => t({
    35725: e
  }),
  bindRenderbuffer: (t, e, i) => t({
    36007: i
  }),
  bindTransformFeedback: (t, e, i) => t({
    36389: i
  }),
  bindVertexArray: (t, e) => t({
    34229: e
  }),
  bindFramebuffer: (t, e, i) => {
    switch (e) {
      case 36160:
        return t({
          36006: i,
          36010: i
        });
      case 36009:
        return t({ 36006: i });
      case 36008:
        return t({ 36010: i });
      default:
        return null;
    }
  },
  bindBuffer: (t, e, i) => {
    const s = {
      34962: [34964],
      36662: [36662],
      36663: [36663],
      35051: [35053],
      35052: [35055]
    }[e];
    return s ? t({ [s]: i }) : { valueChanged: !0 };
  },
  blendColor: (t, e, i, s, o) => t({
    32773: new Float32Array([e, i, s, o])
  }),
  blendEquation: (t, e) => t({
    32777: e,
    34877: e
  }),
  blendEquationSeparate: (t, e, i) => t({
    32777: e,
    34877: i
  }),
  blendFunc: (t, e, i) => t({
    32969: e,
    32968: i,
    32971: e,
    32970: i
  }),
  blendFuncSeparate: (t, e, i, s, o) => t({
    32969: e,
    32968: i,
    32971: s,
    32970: o
  }),
  clearColor: (t, e, i, s, o) => t({
    3106: new Float32Array([e, i, s, o])
  }),
  clearDepth: (t, e) => t({
    2931: e
  }),
  clearStencil: (t, e) => t({
    2961: e
  }),
  colorMask: (t, e, i, s, o) => t({
    3107: [e, i, s, o]
  }),
  cullFace: (t, e) => t({
    2885: e
  }),
  depthFunc: (t, e) => t({
    2932: e
  }),
  depthRange: (t, e, i) => t({
    2928: new Float32Array([e, i])
  }),
  depthMask: (t, e) => t({
    2930: e
  }),
  frontFace: (t, e) => t({
    2886: e
  }),
  lineWidth: (t, e) => t({
    2849: e
  }),
  polygonOffset: (t, e, i) => t({
    32824: e,
    10752: i
  }),
  sampleCoverage: (t, e, i) => t({
    32938: e,
    32939: i
  }),
  scissor: (t, e, i, s, o) => t({
    3088: new Int32Array([e, i, s, o])
  }),
  stencilMask: (t, e) => t({
    2968: e,
    36005: e
  }),
  stencilMaskSeparate: (t, e, i) => t({
    [e === 1028 ? 2968 : 36005]: i
  }),
  stencilFunc: (t, e, i, s) => t({
    2962: e,
    2967: i,
    2963: s,
    34816: e,
    36003: i,
    36004: s
  }),
  stencilFuncSeparate: (t, e, i, s, o) => t({
    [e === 1028 ? 2962 : 34816]: i,
    [e === 1028 ? 2967 : 36003]: s,
    [e === 1028 ? 2963 : 36004]: o
  }),
  stencilOp: (t, e, i, s) => t({
    2964: e,
    2965: i,
    2966: s,
    34817: e,
    34818: i,
    34819: s
  }),
  stencilOpSeparate: (t, e, i, s, o) => t({
    [e === 1028 ? 2964 : 34817]: i,
    [e === 1028 ? 2965 : 34818]: s,
    [e === 1028 ? 2966 : 34819]: o
  }),
  viewport: (t, e, i, s, o) => t({
    2978: [e, i, s, o]
  })
}, Qn = (t, e) => t.isEnabled(e), nx = {
  3042: Qn,
  2884: Qn,
  2929: Qn,
  3024: Qn,
  32823: Qn,
  32926: Qn,
  32928: Qn,
  3089: Qn,
  2960: Qn,
  35977: Qn
}, IO = /* @__PURE__ */ new Set([
  34016,
  36388,
  36387,
  35983,
  35368,
  34965,
  35739,
  35738,
  3074,
  34853,
  34854,
  34855,
  34856,
  34857,
  34858,
  34859,
  34860,
  34861,
  34862,
  34863,
  34864,
  34865,
  34866,
  34867,
  34868,
  35097,
  32873,
  35869,
  32874,
  34068
]);
function gh(t, e) {
  if (RO(e))
    return;
  const i = {};
  for (const o in e) {
    const u = Number(o), d = SO[o];
    d && (typeof d == "string" ? i[d] = !0 : d(t, e[o], u));
  }
  const s = t.state && t.state.cache;
  if (s)
    for (const o in i) {
      const u = CO[o];
      u(t, e, s);
    }
}
function kT(t, e = By) {
  if (typeof e == "number") {
    const o = e, u = nx[o];
    return u ? u(t, o) : t.getParameter(o);
  }
  const i = Array.isArray(e) ? e : Object.keys(e), s = {};
  for (const o of i) {
    const u = nx[o];
    s[o] = u ? u(t, Number(o)) : t.getParameter(Number(o));
  }
  return s;
}
function MO(t) {
  gh(t, By);
}
function RO(t) {
  for (const e in t)
    return !1;
  return !0;
}
function PO(t, e) {
  if (t === e)
    return !0;
  const i = Array.isArray(t) || ArrayBuffer.isView(t), s = Array.isArray(e) || ArrayBuffer.isView(e);
  if (i && s && t.length === e.length) {
    for (let o = 0; o < t.length; ++o)
      if (t[o] !== e[o])
        return !1;
    return !0;
  }
  return !1;
}
class BO {
  gl;
  program = null;
  stateStack = [];
  enable = !0;
  cache;
  log;
  constructor(e, {
    copyState: i = !1,
    // Copy cache from params (slow) or initialize from WebGL defaults (fast)
    log: s = () => {
    }
    // Logging function, called when gl parameter change calls are actually issued
  } = {}) {
    this.gl = e, this.cache = i ? kT(e) : Object.assign({}, By), this.log = s, this._updateCache = this._updateCache.bind(this), Object.seal(this);
  }
  push(e = {}) {
    this.stateStack.push({});
  }
  pop() {
    si(this.stateStack.length > 0);
    const e = this.stateStack[this.stateStack.length - 1];
    gh(this.gl, e), this.stateStack.pop();
  }
  /**
  // interceptor for context set functions - update our cache and our stack
  // values (Object) - the key values for this setter
   * @param values
   * @returns
   */
  _updateCache(e) {
    let i = !1, s;
    const o = this.stateStack.length > 0 ? this.stateStack[this.stateStack.length - 1] : null;
    for (const u in e) {
      si(u !== void 0);
      const d = e[u], a = this.cache[u];
      PO(d, a) || (i = !0, s = a, o && !(u in o) && (o[u] = a), this.cache[u] = d);
    }
    return { valueChanged: i, oldValue: s };
  }
}
function Rl(t) {
  return t.state;
}
function NT(t, e) {
  const { enable: i = !0, copyState: s } = e;
  if (si(s !== void 0), !t.state) {
    t.state = new BO(t, { copyState: s }), OO(t);
    for (const u in sx) {
      const d = sx[u];
      DO(t, u, d);
    }
    ox(t, "getParameter"), ox(t, "isEnabled");
  }
  const o = Rl(t);
  return o.enable = i, t;
}
function Dp(t) {
  let e = Rl(t);
  e || (NT(t, { copyState: !1 }), e = Rl(t)), e.push();
}
function Ju(t) {
  const e = Rl(t);
  si(e), e.pop();
}
function ox(t, e) {
  const i = t[e].bind(t);
  t[e] = function(o) {
    if (o === void 0 || IO.has(o))
      return i(o);
    const u = Rl(t);
    return o in u.cache || (u.cache[o] = i(o)), u.enable ? (
      // Call the getter the params so that it can e.g. serve from a cache
      u.cache[o]
    ) : (
      // Optionally call the original function to do a "hard" query from the WebGL2RenderingContext
      i(o)
    );
  }, Object.defineProperty(t[e], "name", {
    value: `${e}-from-cache`,
    configurable: !1
  });
}
function DO(t, e, i) {
  if (!t[e])
    return;
  const s = t[e].bind(t);
  t[e] = function(...u) {
    const d = Rl(t), { valueChanged: a, oldValue: w } = i(d._updateCache, ...u);
    return a && s(...u), w;
  }, Object.defineProperty(t[e], "name", {
    value: `${e}-to-cache`,
    configurable: !1
  });
}
function OO(t) {
  const e = t.useProgram.bind(t);
  t.useProgram = function(s) {
    const o = Rl(t);
    o.program !== s && (e(s), o.program = s);
  };
}
const FO = {
  powerPreference: "high-performance",
  // After all, most apps are using WebGL for performance reasons
  // eslint-disable-next-line no-console
  onContextLost: () => console.error("WebGL context lost"),
  // eslint-disable-next-line no-console
  onContextRestored: () => console.info("WebGL context restored")
};
function kO(t, e) {
  e = { ...FO, ...e };
  let i = null;
  const s = (u) => i = u.statusMessage || i;
  t.addEventListener("webglcontextcreationerror", s, !1);
  let o = null;
  if (o ||= t.getContext("webgl2", e), t.removeEventListener("webglcontextcreationerror", s, !1), !o)
    throw new Error(`Failed to create WebGL context: ${i || "Unknown error"}`);
  if (e.onContextLost) {
    const { onContextLost: u } = e;
    t.addEventListener("webglcontextlost", (d) => u(d), !1);
  }
  if (e.onContextRestored) {
    const { onContextRestored: u } = e;
    t.addEventListener("webglcontextrestored", (d) => u(d), !1);
  }
  return o;
}
function Ia(t, e, i) {
  return i[e] === void 0 && (i[e] = t.getExtension(e) || null), i[e];
}
function NO(t, e) {
  const i = t.getParameter(7936), s = t.getParameter(7937);
  Ia(t, "WEBGL_debug_renderer_info", e);
  const o = e.WEBGL_debug_renderer_info, u = t.getParameter(o ? o.UNMASKED_VENDOR_WEBGL : 7936), d = t.getParameter(o ? o.UNMASKED_RENDERER_WEBGL : 7937), a = u || i, w = d || s, S = t.getParameter(7938), M = LT(a, w), F = LO(a, w), N = UO(a, w);
  return {
    type: "webgl",
    gpu: M,
    gpuType: N,
    gpuBackend: F,
    vendor: a,
    renderer: w,
    version: S,
    shadingLanguage: "glsl",
    shadingLanguageVersion: 300
  };
}
function LT(t, e) {
  return /NVIDIA/i.exec(t) || /NVIDIA/i.exec(e) ? "nvidia" : /INTEL/i.exec(t) || /INTEL/i.exec(e) ? "intel" : /Apple/i.exec(t) || /Apple/i.exec(e) ? "apple" : /AMD/i.exec(t) || /AMD/i.exec(e) || /ATI/i.exec(t) || /ATI/i.exec(e) ? "amd" : /SwiftShader/i.exec(t) || /SwiftShader/i.exec(e) ? "software" : "unknown";
}
function LO(t, e) {
  return /Metal/i.exec(t) || /Metal/i.exec(e) ? "metal" : /ANGLE/i.exec(t) || /ANGLE/i.exec(e) ? "opengl" : "unknown";
}
function UO(t, e) {
  if (/SwiftShader/i.exec(t) || /SwiftShader/i.exec(e))
    return "cpu";
  switch (LT(t, e)) {
    case "intel":
      return "integrated";
    case "software":
      return "cpu";
    case "unknown":
      return "unknown";
    default:
      return "discrete";
  }
}
function UT(t) {
  switch (t) {
    case "uint8":
      return 5121;
    case "sint8":
      return 5120;
    case "unorm8":
      return 5121;
    case "snorm8":
      return 5120;
    case "uint16":
      return 5123;
    case "sint16":
      return 5122;
    case "unorm16":
      return 5123;
    case "snorm16":
      return 5122;
    case "uint32":
      return 5125;
    case "sint32":
      return 5124;
    // WebGPU does not support normalized 32 bit integer attributes
    // case 'unorm32': return GL.UNSIGNED_INT;
    // case 'snorm32': return GL.INT;
    case "float16":
      return 5131;
    case "float32":
      return 5126;
  }
  throw new Error(String(t));
}
const Kr = "texture-compression-bc", fi = "texture-compression-astc", eo = "texture-compression-etc2", zO = "texture-compression-etc1-webgl", Df = "texture-compression-pvrtc-webgl", xg = "texture-compression-atc-webgl", Eu = "float32-renderable-webgl", wg = "float16-renderable-webgl", VO = "rgb9e5ufloat_renderable-webgl", Tg = "snorm8-renderable-webgl", Su = "norm16-renderable-webgl", Ag = "snorm16-renderable-webgl", Of = "float32-filterable", ax = "float16-filterable-webgl", ku = "WEBGL_compressed_texture_s3tc", Nu = "WEBGL_compressed_texture_s3tc_srgb", Gc = "EXT_texture_compression_rgtc", Wc = "EXT_texture_compression_bptc", jO = "WEBGL_compressed_texture_etc", HO = "WEBGL_compressed_texture_astc", $O = "WEBGL_compressed_texture_etc1", GO = "WEBGL_compressed_texture_pvrtc", WO = "WEBGL_compressed_texture_atc", lx = "EXT_texture_norm16", cx = "EXT_render_snorm", XO = "EXT_color_buffer_float", Dy = {
  "float32-renderable-webgl": ["EXT_color_buffer_float"],
  "float16-renderable-webgl": ["EXT_color_buffer_half_float"],
  "rgb9e5ufloat_renderable-webgl": ["WEBGL_render_shared_exponent"],
  "snorm8-renderable-webgl": [cx],
  "norm16-renderable-webgl": [lx],
  "snorm16-renderable-webgl": [lx, cx],
  "float32-filterable": ["OES_texture_float_linear"],
  "float16-filterable-webgl": ["OES_texture_half_float_linear"],
  "texture-filterable-anisotropic-webgl": ["EXT_texture_filter_anisotropic"],
  "texture-blend-float-webgl": ["EXT_float_blend"],
  "texture-compression-bc": [ku, Nu, Gc, Wc],
  // 'texture-compression-bc3-srgb-webgl': [X_S3TC_SRGB],
  // 'texture-compression-bc3-webgl': [X_S3TC],
  "texture-compression-bc5-webgl": [Gc],
  "texture-compression-bc7-webgl": [Wc],
  "texture-compression-etc2": [jO],
  "texture-compression-astc": [HO],
  "texture-compression-etc1-webgl": [$O],
  "texture-compression-pvrtc-webgl": [GO],
  "texture-compression-atc-webgl": [WO]
};
function qO(t) {
  return t in Dy;
}
function ZO(t, e, i) {
  return (Dy[e] || []).every((o) => Ia(t, o, i));
}
const Op = {
  // Unsized formats that leave the precision up to the driver. TODO - Fix bpp constants
  "rgb8unorm-unsized": {
    gl: 6407,
    b: 4,
    c: 2,
    bpp: 4,
    dataFormat: 6407,
    types: [5121, 33635]
  },
  "rgba8unorm-unsized": {
    gl: 6408,
    b: 4,
    c: 2,
    bpp: 4,
    dataFormat: 6408,
    types: [5121, 32819, 32820]
  },
  // 'r8unorm-unsized': {gl: GL.LUMINANCE, b: 4, c: 2, bpp: 4},
  // 'rgb8unorm-srgb-unsized': {gl: GL.SRGB_EXT, b: 4, c: 2, bpp: 4, gl1Ext: SRGB},
  // 'rgba8unorm-srgb-unsized': {gl: GL.SRGB_ALPHA_EXT, b: 4, c: 2, bpp: 4, gl1Ext: SRGB},
  // 8-bit formats
  r8unorm: { gl: 33321, b: 1, c: 1, rb: !0 },
  r8snorm: { gl: 36756, b: 1, c: 1, render: Tg },
  r8uint: { gl: 33330, b: 1, c: 1, rb: !0 },
  r8sint: { gl: 33329, b: 1, c: 1, rb: !0 },
  // 16-bit formats
  rg8unorm: { gl: 33323, b: 2, c: 2, rb: !0 },
  rg8snorm: { gl: 36757, b: 2, c: 2, render: Tg },
  rg8uint: { gl: 33336, b: 2, c: 2, rb: !0 },
  rg8sint: { gl: 33335, b: 2, c: 2, rb: !0 },
  r16uint: { gl: 33332, b: 2, c: 1, rb: !0 },
  r16sint: { gl: 33331, b: 2, c: 1, rb: !0 },
  r16float: { gl: 33325, b: 2, c: 1, render: wg, filter: "float16-filterable-webgl", rb: !0 },
  "r16unorm-webgl": { gl: 33322, b: 2, c: 1, f: Su, rb: !0 },
  "r16snorm-webgl": { gl: 36760, b: 2, c: 1, f: Ag },
  // Packed 16-bit formats
  "rgba4unorm-webgl": { gl: 32854, b: 2, c: 4, wgpu: !1, rb: !0 },
  "rgb565unorm-webgl": { gl: 36194, b: 2, c: 4, wgpu: !1, rb: !0 },
  "rgb5a1unorm-webgl": { gl: 32855, b: 2, c: 4, wgpu: !1, rb: !0 },
  // 24-bit formats
  "rgb8unorm-webgl": { gl: 32849, b: 3, c: 3, wgpu: !1 },
  "rgb8snorm-webgl": { gl: 36758, b: 3, c: 3, wgpu: !1 },
  // 32-bit formats  
  rgba8unorm: { gl: 32856, b: 4, c: 2, bpp: 4 },
  "rgba8unorm-srgb": { gl: 35907, b: 4, c: 4, bpp: 4 },
  rgba8snorm: { gl: 36759, b: 4, c: 4, render: Tg },
  rgba8uint: { gl: 36220, b: 4, c: 4, bpp: 4 },
  rgba8sint: { gl: 36238, b: 4, c: 4, bpp: 4 },
  // reverse colors, webgpu only
  bgra8unorm: { b: 4, c: 4 },
  "bgra8unorm-srgb": { b: 4, c: 4 },
  rg16uint: { gl: 33338, b: 4, c: 1, bpp: 4 },
  rg16sint: { gl: 33337, b: 4, c: 2, bpp: 4 },
  // When using a WebGL 2 context and the EXT_color_buffer_float WebGL2 extension
  rg16float: { gl: 33327, bpp: 4, b: 4, c: 2, render: wg, filter: ax, rb: !0 },
  "rg16unorm-webgl": { gl: 33324, b: 2, c: 2, render: Su },
  "rg16snorm-webgl": { gl: 36761, b: 2, c: 2, render: Ag },
  r32uint: { gl: 33334, b: 4, c: 1, bpp: 4, rb: !0 },
  r32sint: { gl: 33333, b: 4, c: 1, bpp: 4, rb: !0 },
  r32float: { gl: 33326, bpp: 4, b: 4, c: 1, render: Eu, filter: Of },
  // Packed 32-bit formats
  rgb9e5ufloat: { gl: 35901, b: 4, c: 3, p: 1, render: VO },
  // , filter: true},
  rg11b10ufloat: { gl: 35898, b: 4, c: 3, p: 1, render: Eu, rb: !0 },
  rgb10a2unorm: { gl: 32857, b: 4, c: 4, p: 1, rb: !0 },
  "rgb10a2uint-webgl": { b: 4, c: 4, gl: 36975, p: 1, wgpu: !1, bpp: 4, rb: !0 },
  // 48-bit formats
  "rgb16unorm-webgl": { gl: 32852, b: 2, c: 3, f: Su },
  // rgb not renderable
  "rgb16snorm-webgl": { gl: 36762, b: 2, c: 3, f: Su },
  // rgb not renderable
  // 64-bit formats
  rg32uint: { gl: 33340, b: 8, c: 2, rb: !0 },
  rg32sint: { gl: 33339, b: 8, c: 2, rb: !0 },
  rg32float: { gl: 33328, b: 8, c: 2, render: Eu, filter: Of, rb: !0 },
  rgba16uint: { gl: 36214, b: 8, c: 4, rb: !0 },
  rgba16sint: { gl: 36232, b: 8, c: 4, rb: !0 },
  rgba16float: { gl: 34842, b: 8, c: 4, render: wg, filter: ax },
  "rgba16unorm-webgl": { gl: 32859, b: 2, c: 4, render: Su, rb: !0 },
  "rgba16snorm-webgl": { gl: 36763, b: 2, c: 4, render: Ag },
  // 96-bit formats (deprecated!)
  "rgb32float-webgl": {
    gl: 34837,
    render: Eu,
    filter: Of,
    gl2ext: XO,
    dataFormat: 6407,
    types: [5126]
  },
  // 128-bit formats
  rgba32uint: { gl: 36208, b: 16, c: 4, rb: !0 },
  rgba32sint: { gl: 36226, b: 16, c: 4, rb: !0 },
  rgba32float: { gl: 34836, b: 16, c: 4, render: Eu, filter: Of, rb: !0 },
  // Depth and stencil formats
  stencil8: { gl: 36168, b: 1, c: 1, attachment: 36128, rb: !0 },
  // 8 stencil bits
  depth16unorm: {
    gl: 33189,
    b: 2,
    c: 1,
    attachment: 36096,
    dataFormat: 6402,
    types: [5123],
    rb: !0
  },
  // 16 depth bits
  depth24plus: {
    gl: 33190,
    b: 3,
    c: 1,
    attachment: 36096,
    dataFormat: 6402,
    types: [5125]
  },
  depth32float: {
    gl: 36012,
    b: 4,
    c: 1,
    attachment: 36096,
    dataFormat: 6402,
    types: [5126],
    rb: !0
  },
  // The depth component of the "depth24plus" and "depth24plus-stencil8" formats may be implemented as either a 24-bit depth value or a "depth32float" value.
  "depth24plus-stencil8": {
    gl: 35056,
    b: 4,
    c: 2,
    p: 1,
    attachment: 33306,
    rb: !0,
    depthTexture: !0,
    dataFormat: 34041,
    types: [34042]
  },
  // "depth24unorm-stencil8" feature
  "depth24unorm-stencil8": {
    gl: 35056,
    b: 4,
    c: 2,
    p: 1,
    attachment: 33306,
    dataFormat: 34041,
    types: [34042],
    rb: !0
  },
  // "depth32float-stencil8" feature - TODO below is render buffer only?
  "depth32float-stencil8": {
    gl: 36013,
    b: 5,
    c: 2,
    p: 1,
    attachment: 33306,
    dataFormat: 34041,
    types: [36269],
    rb: !0
  },
  // BC compressed formats: check device.features.has("texture-compression-bc");
  "bc1-rgb-unorm-webgl": { gl: 33776, x: ku, f: Kr },
  "bc1-rgb-unorm-srgb-webgl": { gl: 35916, x: Nu, f: Kr },
  "bc1-rgba-unorm": { gl: 33777, x: ku, f: Kr },
  "bc1-rgba-unorm-srgb": { gl: 35916, x: Nu, f: Kr },
  "bc2-rgba-unorm": { gl: 33778, x: ku, f: Kr },
  "bc2-rgba-unorm-srgb": { gl: 35918, x: Nu, f: Kr },
  "bc3-rgba-unorm": { gl: 33779, x: ku, f: Kr },
  "bc3-rgba-unorm-srgb": { gl: 35919, x: Nu, f: Kr },
  "bc4-r-unorm": { gl: 36283, x: Gc, f: Kr },
  "bc4-r-snorm": { gl: 36284, x: Gc, f: Kr },
  "bc5-rg-unorm": { gl: 36285, x: Gc, f: Kr },
  "bc5-rg-snorm": { gl: 36286, x: Gc, f: Kr },
  "bc6h-rgb-ufloat": { gl: 36495, x: Wc, f: Kr },
  "bc6h-rgb-float": { gl: 36494, x: Wc, f: Kr },
  "bc7-rgba-unorm": { gl: 36492, x: Wc, f: Kr },
  "bc7-rgba-unorm-srgb": { gl: 36493, x: Wc, f: Kr },
  // WEBGL_compressed_texture_etc: device.features.has("texture-compression-etc2")
  // Note: Supposedly guaranteed availability compressed formats in WebGL2, but through CPU decompression
  "etc2-rgb8unorm": { gl: 37492, f: eo },
  "etc2-rgb8unorm-srgb": { gl: 37494, f: eo },
  "etc2-rgb8a1unorm": { gl: 37496, f: eo },
  "etc2-rgb8a1unorm-srgb": { gl: 37497, f: eo },
  "etc2-rgba8unorm": { gl: 37493, f: eo },
  "etc2-rgba8unorm-srgb": { gl: 37495, f: eo },
  "eac-r11unorm": { gl: 37488, f: eo },
  "eac-r11snorm": { gl: 37489, f: eo },
  "eac-rg11unorm": { gl: 37490, f: eo },
  "eac-rg11snorm": { gl: 37491, f: eo },
  // X_ASTC compressed formats: device.features.has("texture-compression-astc")
  "astc-4x4-unorm": { gl: 37808, f: fi },
  "astc-4x4-unorm-srgb": { gl: 37840, f: fi },
  "astc-5x4-unorm": { gl: 37809, f: fi },
  "astc-5x4-unorm-srgb": { gl: 37841, f: fi },
  "astc-5x5-unorm": { gl: 37810, f: fi },
  "astc-5x5-unorm-srgb": { gl: 37842, f: fi },
  "astc-6x5-unorm": { gl: 37811, f: fi },
  "astc-6x5-unorm-srgb": { gl: 37843, f: fi },
  "astc-6x6-unorm": { gl: 37812, f: fi },
  "astc-6x6-unorm-srgb": { gl: 37844, f: fi },
  "astc-8x5-unorm": { gl: 37813, f: fi },
  "astc-8x5-unorm-srgb": { gl: 37845, f: fi },
  "astc-8x6-unorm": { gl: 37814, f: fi },
  "astc-8x6-unorm-srgb": { gl: 37846, f: fi },
  "astc-8x8-unorm": { gl: 37815, f: fi },
  "astc-8x8-unorm-srgb": { gl: 37847, f: fi },
  "astc-10x5-unorm": { gl: 37819, f: fi },
  "astc-10x5-unorm-srgb": { gl: 37851, f: fi },
  "astc-10x6-unorm": { gl: 37817, f: fi },
  "astc-10x6-unorm-srgb": { gl: 37849, f: fi },
  "astc-10x8-unorm": { gl: 37818, f: fi },
  "astc-10x8-unorm-srgb": { gl: 37850, f: fi },
  "astc-10x10-unorm": { gl: 37819, f: fi },
  "astc-10x10-unorm-srgb": { gl: 37851, f: fi },
  "astc-12x10-unorm": { gl: 37820, f: fi },
  "astc-12x10-unorm-srgb": { gl: 37852, f: fi },
  "astc-12x12-unorm": { gl: 37821, f: fi },
  "astc-12x12-unorm-srgb": { gl: 37853, f: fi },
  // WEBGL_compressed_texture_pvrtc
  "pvrtc-rgb4unorm-webgl": { gl: 35840, f: Df },
  "pvrtc-rgba4unorm-webgl": { gl: 35842, f: Df },
  "pvrtc-rbg2unorm-webgl": { gl: 35841, f: Df },
  "pvrtc-rgba2unorm-webgl": { gl: 35843, f: Df },
  // WEBGL_compressed_texture_etc1
  "etc1-rbg-unorm-webgl": { gl: 36196, f: zO },
  // WEBGL_compressed_texture_atc
  "atc-rgb-unorm-webgl": { gl: 35986, f: xg },
  "atc-rgba-unorm-webgl": { gl: 35986, f: xg },
  "atc-rgbai-unorm-webgl": { gl: 34798, f: xg }
}, KO = {
  6403: 1,
  36244: 1,
  33319: 2,
  33320: 2,
  6407: 3,
  36248: 3,
  6408: 4,
  36249: 4,
  6402: 1,
  34041: 1,
  6406: 1,
  6409: 1,
  6410: 2
}, YO = {
  5126: 4,
  5125: 4,
  5124: 4,
  5123: 2,
  5122: 2,
  5131: 2,
  5120: 1,
  5121: 1
};
function Oy(t, e, i) {
  const s = Op[e];
  if (!s || s.gl === void 0)
    return !1;
  const o = s.x || s.gl2ext;
  return o ? !!Ia(t, o, i) : !0;
}
function zT(t) {
  const i = Op[t]?.gl;
  if (i === void 0)
    throw new Error(`Unsupported texture format ${t}`);
  return i;
}
function JO(t, e, i) {
  if (!Oy(t, e, i) || e.startsWith("depth") || e.startsWith("stencil"))
    return !1;
  try {
    if (Dw(e).signed)
      return !1;
  } catch {
    return !1;
  }
  return e.endsWith("32float") ? !!Ia(t, "OES_texture_float_linear, extensions", i) : e.endsWith("16float") ? !!Ia(t, "OES_texture_half_float_linear, extensions", i) : !0;
}
function QO(t, e, i) {
  return !(!Oy(t, e, i) || typeof e == "number");
}
function yp(t) {
  const e = Op[t], i = zT(t), s = Dw(t);
  return {
    format: i,
    dataFormat: e?.dataFormat || tF(s.format, s.integer, s.normalized, i),
    // depth formats don't have a type
    type: s.dataType ? UT(s.dataType) : e?.types?.[0] || 5121,
    // @ts-expect-error
    compressed: s.compressed
  };
}
function eF(t) {
  const e = Op[t];
  if (!e?.attachment)
    throw new Error(`${t} is not a depth stencil format`);
  return e.attachment;
}
function hx(t) {
  const e = yp(t), i = KO[e.dataFormat] || 4, s = YO[e.type] || 1;
  return i * s;
}
function tF(t, e, i, s) {
  if (s === 6408 || s === 6407)
    return s;
  switch (t) {
    case "r":
      return e && !i ? 36244 : 6403;
    case "rg":
      return e && !i ? 33320 : 33319;
    case "rgb":
      return e && !i ? 36248 : 6407;
    case "rgba":
      return e && !i ? 36249 : 6408;
    default:
      return 6408;
  }
}
const ux = {
  // optional WebGPU features
  "depth-clip-control": "EXT_depth_clamp",
  // TODO these seem subtly different
  // 'timestamp-query' // GPUQueryType "timestamp-query"
  // "indirect-first-instance"
  // Textures are handled by getTextureFeatures()
  // 'depth24unorm-stencil8' // GPUTextureFormat 'depth24unorm-stencil8'
  // 'depth32float-stencil8' // GPUTextureFormat 'depth32float-stencil8'
  // optional WebGL features
  "timer-query-webgl": "EXT_disjoint_timer_query_webgl2",
  "compilation-status-async-webgl": "KHR_parallel_shader_compile",
  "polygon-mode-webgl": "WEBGL_polygon_mode",
  "provoking-vertex-webgl": "WEBGL_provoking_vertex",
  "shader-clip-cull-distance-webgl": "WEBGL_clip_cull_distance",
  "shader-noperspective-interpolation-webgl": "NV_shader_noperspective_interpolation",
  "shader-conservative-depth-webgl": "EXT_conservative_depth"
  // Textures are handled by getTextureFeatures()
};
class iF extends qM {
  gl;
  extensions;
  testedFeatures = /* @__PURE__ */ new Set();
  constructor(e, i, s) {
    super([], s), this.gl = e, this.extensions = i, Ia(e, "EXT_color_buffer_float", i);
  }
  *[Symbol.iterator]() {
    const e = this.getFeatures();
    for (const i of e)
      this.has(i) && (yield i);
    return [];
  }
  has(e) {
    return this.disabledFeatures[e] ? !1 : (this.testedFeatures.has(e) || (this.testedFeatures.add(e), qO(e) && ZO(this.gl, e, this.extensions) && this.features.add(e), this.getWebGLFeature(e) && this.features.add(e)), this.features.has(e));
  }
  // FOR DEVICE
  initializeFeatures() {
    const e = this.getFeatures().filter((i) => i !== "polygon-mode-webgl");
    for (const i of e)
      this.has(i);
  }
  // IMPLEMENTATION
  getFeatures() {
    return [...Object.keys(ux), ...Object.keys(Dy)];
  }
  /** Extract all WebGL features */
  getWebGLFeature(e) {
    const i = ux[e];
    return typeof i == "string" ? !!Ia(this.gl, i, this.extensions) : !!i;
  }
}
class rF extends XM {
  get maxTextureDimension1D() {
    return 0;
  }
  // WebGL does not support 1D textures
  get maxTextureDimension2D() {
    return this.getParameter(3379);
  }
  get maxTextureDimension3D() {
    return this.getParameter(32883);
  }
  get maxTextureArrayLayers() {
    return this.getParameter(35071);
  }
  get maxBindGroups() {
    return 0;
  }
  get maxDynamicUniformBuffersPerPipelineLayout() {
    return 0;
  }
  // TBD
  get maxDynamicStorageBuffersPerPipelineLayout() {
    return 0;
  }
  // TBD
  get maxSampledTexturesPerShaderStage() {
    return this.getParameter(35660);
  }
  // ) TBD
  get maxSamplersPerShaderStage() {
    return this.getParameter(35661);
  }
  get maxStorageBuffersPerShaderStage() {
    return 0;
  }
  // TBD
  get maxStorageTexturesPerShaderStage() {
    return 0;
  }
  // TBD
  get maxUniformBuffersPerShaderStage() {
    return this.getParameter(35375);
  }
  get maxUniformBufferBindingSize() {
    return this.getParameter(35376);
  }
  get maxStorageBufferBindingSize() {
    return 0;
  }
  get minUniformBufferOffsetAlignment() {
    return this.getParameter(35380);
  }
  get minStorageBufferOffsetAlignment() {
    return 0;
  }
  get maxVertexBuffers() {
    return 16;
  }
  // WebGL 2 supports 16 buffers, see https://github.com/gpuweb/gpuweb/issues/4284
  get maxVertexAttributes() {
    return this.getParameter(34921);
  }
  get maxVertexBufferArrayStride() {
    return 2048;
  }
  // TBD, this is just the default value from WebGPU
  get maxInterStageShaderComponents() {
    return this.getParameter(35659);
  }
  get maxComputeWorkgroupStorageSize() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeInvocationsPerWorkgroup() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeWorkgroupSizeX() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeWorkgroupSizeY() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeWorkgroupSizeZ() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeWorkgroupsPerDimension() {
    return 0;
  }
  // WebGL does not support compute shaders
  // PRIVATE
  gl;
  limits = {};
  constructor(e) {
    super(), this.gl = e;
  }
  getParameter(e) {
    return this.limits[e] === void 0 && (this.limits[e] = this.gl.getParameter(e)), this.limits[e];
  }
}
function xa(t, e, i) {
  if (sF(e))
    return i(t);
  const { nocatch: s = !0 } = e;
  Dp(t), gh(t, e);
  let o;
  if (s)
    o = i(t), Ju(t);
  else
    try {
      o = i(t);
    } finally {
      Ju(t);
    }
  return o;
}
function sF(t) {
  for (const e in t)
    return !1;
  return !0;
}
function nF(t, e, i, s) {
  if (lp(e))
    return s(t);
  const o = t;
  Dp(o.gl);
  try {
    return oF(t, e), gh(o.gl, i), s(t);
  } finally {
    Ju(o.gl);
  }
}
function oF(t, e) {
  const i = t, { gl: s } = i;
  if (e.cullMode)
    switch (e.cullMode) {
      case "none":
        s.disable(2884);
        break;
      case "front":
        s.enable(2884), s.cullFace(1028);
        break;
      case "back":
        s.enable(2884), s.cullFace(1029);
        break;
    }
  if (e.frontFace && s.frontFace(Cl("frontFace", e.frontFace, {
    ccw: 2305,
    cw: 2304
  })), e.unclippedDepth && t.features.has("depth-clip-control") && s.enable(34383), e.depthBias !== void 0 && (s.enable(32823), s.polygonOffset(e.depthBias, e.depthBiasSlopeScale || 0)), e.provokingVertex && t.features.has("provoking-vertex-webgl")) {
    const u = i.getExtension("WEBGL_provoking_vertex").WEBGL_provoking_vertex, d = Cl("provokingVertex", e.provokingVertex, {
      first: 36429,
      last: 36430
    });
    u?.provokingVertexWEBGL(d);
  }
  if ((e.polygonMode || e.polygonOffsetLine) && t.features.has("polygon-mode-webgl")) {
    if (e.polygonMode) {
      const u = i.getExtension("WEBGL_polygon_mode").WEBGL_polygon_mode, d = Cl("polygonMode", e.polygonMode, {
        fill: 6914,
        line: 6913
      });
      u?.polygonModeWEBGL(1028, d), u?.polygonModeWEBGL(1029, d);
    }
    e.polygonOffsetLine && s.enable(10754);
  }
  if (t.features.has("shader-clip-cull-distance-webgl") && (e.clipDistance0 && s.enable(12288), e.clipDistance1 && s.enable(12289), e.clipDistance2 && s.enable(12290), e.clipDistance3 && s.enable(12291), e.clipDistance4 && s.enable(12292), e.clipDistance5 && s.enable(12293), e.clipDistance6 && s.enable(12294), e.clipDistance7 && s.enable(12295)), e.depthWriteEnabled !== void 0 && s.depthMask(lF("depthWriteEnabled", e.depthWriteEnabled)), e.depthCompare && (e.depthCompare !== "always" ? s.enable(2929) : s.disable(2929), s.depthFunc(Sm("depthCompare", e.depthCompare))), e.stencilWriteMask) {
    const o = e.stencilWriteMask;
    s.stencilMaskSeparate(1028, o), s.stencilMaskSeparate(1029, o);
  }
  if (e.stencilReadMask && Je.warn("stencilReadMask not supported under WebGL"), e.stencilCompare) {
    const o = e.stencilReadMask || 4294967295, u = Sm("depthCompare", e.stencilCompare);
    e.stencilCompare !== "always" ? s.enable(2960) : s.disable(2960), s.stencilFuncSeparate(1028, u, 0, o), s.stencilFuncSeparate(1029, u, 0, o);
  }
  if (e.stencilPassOperation && e.stencilFailOperation && e.stencilDepthFailOperation) {
    const o = Eg("stencilPassOperation", e.stencilPassOperation), u = Eg("stencilFailOperation", e.stencilFailOperation), d = Eg("stencilDepthFailOperation", e.stencilDepthFailOperation);
    s.stencilOpSeparate(1028, u, d, o), s.stencilOpSeparate(1029, u, d, o);
  }
  if (e.blendColorOperation || e.blendAlphaOperation) {
    s.enable(3042);
    const o = dx("blendColorOperation", e.blendColorOperation || "add"), u = dx("blendAlphaOperation", e.blendAlphaOperation || "add");
    s.blendEquationSeparate(o, u);
    const d = Ff("blendColorSrcFactor", e.blendColorSrcFactor || "one"), a = Ff("blendColorDstFactor", e.blendColorDstFactor || "zero"), w = Ff("blendAlphaSrcFactor", e.blendAlphaSrcFactor || "one"), S = Ff("blendAlphaDstFactor", e.blendAlphaDstFactor || "zero");
    s.blendFuncSeparate(d, a, w, S);
  }
}
function Sm(t, e) {
  return Cl(t, e, {
    never: 512,
    less: 513,
    equal: 514,
    "less-equal": 515,
    greater: 516,
    "not-equal": 517,
    "greater-equal": 518,
    always: 519
  });
}
function Eg(t, e) {
  return Cl(t, e, {
    keep: 7680,
    zero: 0,
    replace: 7681,
    invert: 5386,
    "increment-clamp": 7682,
    "decrement-clamp": 7683,
    "increment-wrap": 34055,
    "decrement-wrap": 34056
  });
}
function dx(t, e) {
  return Cl(t, e, {
    add: 32774,
    subtract: 32778,
    "reverse-subtract": 32779,
    min: 32775,
    max: 32776
  });
}
function Ff(t, e) {
  return Cl(t, e, {
    one: 1,
    zero: 0,
    "src-color": 768,
    "one-minus-src-color": 769,
    "dst-color": 774,
    "one-minus-dst-color": 775,
    "src-alpha": 770,
    "one-minus-src-alpha": 771,
    "dst-alpha": 772,
    "one-minus-dst-alpha": 773,
    "src-alpha-saturated": 776,
    "constant-color": 32769,
    "one-minus-constant-color": 32770,
    "constant-alpha": 32771,
    "one-minus-constant-alpha": 32772
  });
}
function aF(t, e) {
  return `Illegal parameter ${e} for ${t}`;
}
function Cl(t, e, i) {
  if (!(e in i))
    throw new Error(aF(t, e));
  return i[e];
}
function lF(t, e) {
  return e;
}
function VT(t) {
  const e = {};
  return t.addressModeU && (e[10242] = Sg(t.addressModeU)), t.addressModeV && (e[10243] = Sg(t.addressModeV)), t.addressModeW && (e[32882] = Sg(t.addressModeW)), t.magFilter && (e[10240] = jT(t.magFilter)), (t.minFilter || t.mipmapFilter) && (e[10241] = cF(t.minFilter || "linear", t.mipmapFilter)), t.lodMinClamp !== void 0 && (e[33082] = t.lodMinClamp), t.lodMaxClamp !== void 0 && (e[33083] = t.lodMaxClamp), t.type === "comparison-sampler" && (e[34892] = 34894), t.compare && (e[34893] = Sm("compare", t.compare)), t.maxAnisotropy && (e[34046] = t.maxAnisotropy), e;
}
function Sg(t) {
  switch (t) {
    case "clamp-to-edge":
      return 33071;
    case "repeat":
      return 10497;
    case "mirror-repeat":
      return 33648;
  }
}
function jT(t) {
  switch (t) {
    case "nearest":
      return 9728;
    case "linear":
      return 9729;
  }
}
function cF(t, e) {
  if (!e)
    return jT(t);
  switch (t) {
    case "nearest":
      return e === "nearest" ? 9984 : 9986;
    case "linear":
      return e === "nearest" ? 9985 : 9987;
  }
}
class Aa extends Mi {
  device;
  gl;
  handle;
  /** Target in OpenGL defines the type of buffer */
  glTarget;
  /** Usage is a hint on how frequently the buffer will be updates */
  glUsage;
  /** Index type is needed when issuing draw calls, so we pre-compute it */
  glIndexType = 5123;
  /** Number of bytes allocated on the GPU for this buffer */
  byteLength;
  /** Number of bytes used */
  bytesUsed;
  constructor(e, i = {}) {
    super(e, i), this.device = e, this.gl = this.device.gl;
    const s = typeof i == "object" ? i.handle : void 0;
    this.handle = s || this.gl.createBuffer(), e.setSpectorMetadata(this.handle, { ...this.props, data: typeof this.props.data }), this.glTarget = hF(this.props.usage), this.glUsage = uF(this.props.usage), this.glIndexType = this.props.indexType === "uint32" ? 5125 : 5123, i.data ? this._initWithData(i.data, i.byteOffset, i.byteLength) : this._initWithByteLength(i.byteLength || 0);
  }
  // PRIVATE METHODS
  /** Allocate a new buffer and initialize to contents of typed array */
  _initWithData(e, i = 0, s = e.byteLength + i) {
    const o = this.glTarget;
    this.gl.bindBuffer(o, this.handle), this.gl.bufferData(o, s, this.glUsage), this.gl.bufferSubData(o, i, e), this.gl.bindBuffer(o, null), this.bytesUsed = s, this.byteLength = s, this._setDebugData(e, i, s), this.trackAllocatedMemory(s);
  }
  // Allocate a GPU buffer of specified size.
  _initWithByteLength(e) {
    si(e >= 0);
    let i = e;
    e === 0 && (i = new Float32Array(0));
    const s = this.glTarget;
    return this.gl.bindBuffer(s, this.handle), this.gl.bufferData(s, i, this.glUsage), this.gl.bindBuffer(s, null), this.bytesUsed = e, this.byteLength = e, this._setDebugData(null, 0, e), this.trackAllocatedMemory(e), this;
  }
  destroy() {
    !this.destroyed && this.handle && (this.removeStats(), this.trackDeallocatedMemory(), this.gl.deleteBuffer(this.handle), this.destroyed = !0, this.handle = null);
  }
  write(e, i = 0) {
    this.gl.bindBuffer(36663, this.handle), this.gl.bufferSubData(36663, i, e), this.gl.bindBuffer(36663, null), this._setDebugData(e, i, e.byteLength);
  }
  /** Asynchronously read data from the buffer */
  async readAsync(e = 0, i) {
    return this.readSyncWebGL(e, i);
  }
  /** Synchronously read data from the buffer. WebGL only. */
  readSyncWebGL(e = 0, i) {
    i = i ?? this.byteLength - e;
    const s = new Uint8Array(i), o = 0;
    return this.gl.bindBuffer(36662, this.handle), this.gl.getBufferSubData(36662, e, s, o, i), this.gl.bindBuffer(36662, null), this._setDebugData(s, e, i), s;
  }
}
function hF(t) {
  return t & Mi.INDEX ? 34963 : t & Mi.VERTEX ? 34962 : t & Mi.UNIFORM ? 35345 : 34962;
}
function uF(t) {
  return t & Mi.INDEX || t & Mi.VERTEX ? 35044 : t & Mi.UNIFORM ? 35048 : 35044;
}
class Cm extends Rp {
  device;
  handle;
  parameters;
  constructor(e, i) {
    super(e, i), this.device = e, this.parameters = VT(i), this.handle = this.handle || this.device.gl.createSampler(), this._setSamplerParameters(this.parameters);
  }
  destroy() {
    this.handle && (this.device.gl.deleteSampler(this.handle), this.handle = void 0);
  }
  toString() {
    return `Sampler(${this.id},${JSON.stringify(this.props)})`;
  }
  /** Set sampler parameters on the sampler */
  _setSamplerParameters(e) {
    for (const [i, s] of Object.entries(e)) {
      const o = Number(i);
      switch (o) {
        case 33082:
        case 33083:
          this.device.gl.samplerParameterf(this.handle, o, s);
          break;
        default:
          this.device.gl.samplerParameteri(this.handle, o, s);
          break;
      }
    }
  }
}
class Xc extends Ip {
  device;
  gl;
  handle;
  texture;
  constructor(e, i) {
    super(e, { ...qs.defaultProps, ...i }), this.device = e, this.gl = this.device.gl, this.handle = null, this.texture = i.texture;
  }
}
const dF = {
  // deprecated
  parameters: {},
  pixelStore: {},
  pixels: null,
  border: 0,
  dataFormat: void 0,
  textureUnit: void 0,
  target: void 0
};
class Bn extends qs {
  // TODO - remove?
  static FACES = [
    34069,
    34070,
    34071,
    34072,
    34073,
    34074
  ];
  MAX_ATTRIBUTES;
  device;
  gl;
  handle;
  // (TODO - currently unused in WebGL, but WebGL 2 does support sampler objects) */
  sampler = void 0;
  view = void 0;
  // data;
  glFormat = void 0;
  type = void 0;
  dataFormat = void 0;
  mipmaps = void 0;
  /**
   * @note `target` cannot be modified by bind:
   * textures are special because when you first bind them to a target,
   * they get special information. When you first bind a texture as a
   * GL_TEXTURE_2D, you are saying that this texture is a 2D texture.
   * And it will always be a 2D texture; this state cannot be changed ever.
   * A texture that was first bound as a GL_TEXTURE_2D, must always be bound as a GL_TEXTURE_2D;
   * attempting to bind it as GL_TEXTURE_3D will give rise to a run-time error
   * */
  target;
  textureUnit = void 0;
  /**
   * Program.draw() checks the loaded flag of all textures to avoid
   * Textures that are still loading from promises
   * Set to true as soon as texture has been initialized with valid data
   */
  loaded = !1;
  _video;
  constructor(e, i) {
    super(e, { ...dF, format: "rgba8unorm", ...i }), this.device = e, this.gl = this.device.gl, this.handle = this.props.handle || this.gl.createTexture(), this.device.setSpectorMetadata(this.handle, { ...this.props, data: typeof this.props.data }), this.glFormat = 6408, this.target = fF(this.props), this.loaded = !1, typeof this.props?.data == "string" && Object.assign(this.props, { data: FR(this.props.data) }), this.initialize(this.props), Object.seal(this);
  }
  destroy() {
    this.handle && (this.gl.deleteTexture(this.handle), this.removeStats(), this.trackDeallocatedMemory("Texture"), this.destroyed = !0);
  }
  toString() {
    return `Texture(${this.id},${this.width}x${this.height})`;
  }
  createView(e) {
    return new Xc(this.device, { ...e, texture: this });
  }
  // eslint-disable-next-line max-statements
  initialize(e = {}) {
    if (this.props.dimension === "cube")
      return this.initializeCube(e);
    let i = e.data;
    if (i instanceof Promise)
      return i.then((we) => this.initialize(Object.assign({}, e, {
        pixels: we,
        data: we
      }))), this;
    const s = typeof HTMLVideoElement < "u" && i instanceof HTMLVideoElement;
    if (s && i.readyState < HTMLVideoElement.HAVE_METADATA)
      return this._video = null, i.addEventListener("loadeddata", () => this.initialize(e)), this;
    const { parameters: o = {} } = e, { pixels: u = null, pixelStore: d = {}, textureUnit: a = void 0, mipmaps: w = !0 } = e;
    i || (i = u);
    let { width: S, height: M, dataFormat: F, type: N, compressed: L = !1 } = e;
    const { depth: re = 0 } = e, ne = zT(e.format);
    return { width: S, height: M, compressed: L, dataFormat: F, type: N } = this._deduceParameters({
      format: e.format,
      type: N,
      dataFormat: F,
      compressed: L,
      data: i,
      width: S,
      height: M
    }), this.width = S, this.height = M, this.glFormat = ne, this.type = N, this.dataFormat = F, this.textureUnit = a, Number.isFinite(this.textureUnit) && (this.gl.activeTexture(33984 + this.textureUnit), this.gl.bindTexture(this.target, this.handle)), this.mipmaps = w, this.setImageData({
      data: i,
      width: S,
      height: M,
      depth: re,
      format: e.format,
      type: N,
      dataFormat: F,
      // @ts-expect-error
      parameters: d,
      compressed: L
    }), this.setSampler(e.sampler), this._setSamplerParameters(o), this.view = this.createView({ ...this.props, mipLevelCount: 1, arrayLayerCount: 1 }), w && this.device.isTextureFormatFilterable(e.format) && this.generateMipmap(), s && (this._video = {
      video: i,
      parameters: o,
      // @ts-expect-error
      lastTime: i.readyState >= HTMLVideoElement.HAVE_CURRENT_DATA ? i.currentTime : -1
    }), this;
  }
  initializeCube(e) {
    const { mipmaps: i = !0, parameters: s = {} } = e;
    return this.setCubeMapImageData(e).then(() => {
      this.loaded = !0, i && this.generateMipmap(e), this.setSampler(e.sampler), this._setSamplerParameters(s);
    }), this;
  }
  setSampler(e = {}) {
    let i;
    e instanceof Cm ? (this.sampler = e, i = e.props) : (this.sampler = new Cm(this.device, e), i = e);
    const s = VT(i);
    return this._setSamplerParameters(s), this;
  }
  /**
   * If size has changed, reinitializes with current format
   * @note note clears image and mipmaps
   */
  resize(e) {
    const { height: i, width: s, mipmaps: o = !1 } = e;
    return s !== this.width || i !== this.height ? this.initialize({
      width: s,
      height: i,
      format: this.format,
      type: this.type,
      dataFormat: this.dataFormat,
      mipmaps: o
    }) : this;
  }
  /** Update external texture (video frame) */
  update() {
    if (this._video) {
      const { video: e, parameters: i, lastTime: s } = this._video;
      if (s === e.currentTime || e.readyState < HTMLVideoElement.HAVE_CURRENT_DATA)
        return;
      this.setSubImageData({
        data: e,
        parameters: i
      }), this.mipmaps && this.generateMipmap(), this._video.lastTime = e.currentTime;
    }
  }
  // Call to regenerate mipmaps after modifying texture(s)
  generateMipmap(e = {}) {
    return this.mipmaps = !0, this.gl.bindTexture(this.target, this.handle), xa(this.gl, e, () => {
      this.gl.generateMipmap(this.target);
    }), this.gl.bindTexture(this.target, null), this;
  }
  /*
   * Allocates storage
   * @param {*} pixels -
   *  null - create empty texture of specified format
   *  Typed array - init from image data in typed array
   *  Buffer|WebGLBuffer - (WEBGL2) init from image data in WebGLBuffer
   *  HTMLImageElement|Image - Inits with content of image. Auto width/height
   *  HTMLCanvasElement - Inits with contents of canvas. Auto width/height
   *  HTMLVideoElement - Creates video texture. Auto width/height
   *
   * @param  width -
   * @param  height -
   * @param  mipMapLevel -
   * @param {GLenum} format - format of image data.
   * @param {GLenum} type
   *  - format of array (autodetect from type) or
   *  - (WEBGL2) format of buffer
   * @param {Number} offset - (WEBGL2) offset from start of buffer
   * @parameters - temporary settings to be applied, can be used to supply pixel store settings.
   */
  // eslint-disable-next-line max-statements, complexity
  setImageData(e) {
    if (this.props.dimension === "3d" || this.props.dimension === "2d-array")
      return this.setImageData3D(e);
    this.trackDeallocatedMemory("Texture");
    const { target: i = this.target, pixels: s = null, level: o = 0, glFormat: u = this.glFormat, offset: d = 0, parameters: a = {} } = e;
    let { data: w = null, type: S = this.type, width: M = this.width, height: F = this.height, dataFormat: N = this.dataFormat, compressed: L = !1 } = e;
    w || (w = s), { type: S, dataFormat: N, compressed: L, width: M, height: F } = this._deduceParameters({
      format: this.props.format,
      type: S,
      dataFormat: N,
      compressed: L,
      data: w,
      width: M,
      height: F
    });
    const { gl: re } = this;
    re.bindTexture(this.target, this.handle);
    let ne = null;
    if ({ data: w, dataType: ne } = this._getDataType({ data: w, compressed: L }), xa(this.gl, a, () => {
      switch (ne) {
        case "null":
          re.texImage2D(i, o, u, M, F, 0, N, S, w);
          break;
        case "typed-array":
          re.texImage2D(
            i,
            o,
            u,
            M,
            F,
            0,
            // border (must be 0)
            N,
            S,
            w,
            d
          );
          break;
        case "buffer":
          this.device.gl.bindBuffer(35052, w.handle || w), this.device.gl.texImage2D(i, o, u, M, F, 0, N, S, d), this.device.gl.bindBuffer(35052, null);
          break;
        case "browser-object":
          re.texImage2D(i, o, u, M, F, 0, N, S, w);
          break;
        case "compressed":
          for (const [we, Se] of w.entries())
            re.compressedTexImage2D(i, we, Se.format, Se.width, Se.height, 0, Se.data);
          break;
        default:
          si(!1, "Unknown image data type");
      }
    }), w && w.byteLength)
      this.trackAllocatedMemory(w.byteLength, "Texture");
    else {
      const we = hx(this.props.format);
      this.trackAllocatedMemory(this.width * this.height * we, "Texture");
    }
    return this.loaded = !0, this;
  }
  /**
   * Redefines an area of an existing texture
   * Note: does not allocate storage
   * Redefines an area of an existing texture
   */
  setSubImageData({ target: e = this.target, pixels: i = null, data: s = null, x: o = 0, y: u = 0, width: d = this.width, height: a = this.height, level: w = 0, glFormat: S = this.glFormat, type: M = this.type, dataFormat: F = this.dataFormat, compressed: N = !1, offset: L = 0, parameters: re = {} }) {
    if ({ type: M, dataFormat: F, compressed: N, width: d, height: a } = this._deduceParameters({
      format: this.props.format,
      type: M,
      dataFormat: F,
      compressed: N,
      data: s,
      width: d,
      height: a
    }), si(this.depth === 1, "texSubImage not supported for 3D textures"), s || (s = i), s && s.data) {
      const ne = s;
      s = ne.data, d = ne.shape[0], a = ne.shape[1];
    }
    s instanceof Aa && (s = s.handle), this.gl.bindTexture(this.target, this.handle), xa(this.gl, re, () => {
      N ? this.gl.compressedTexSubImage2D(e, w, o, u, d, a, S, s) : s === null ? this.gl.texSubImage2D(e, w, o, u, d, a, F, M, null) : ArrayBuffer.isView(s) ? this.gl.texSubImage2D(e, w, o, u, d, a, F, M, s, L) : typeof WebGLBuffer < "u" && s instanceof WebGLBuffer ? (this.device.gl.bindBuffer(35052, s), this.device.gl.texSubImage2D(e, w, o, u, d, a, F, M, L), this.device.gl.bindBuffer(35052, null)) : this.device.gl.texSubImage2D(e, w, o, u, d, a, F, M, s);
    }), this.gl.bindTexture(this.target, null);
  }
  /**
   * Defines a two-dimensional texture image or cube-map texture image with
   * pixels from the current framebuffer (rather than from client memory).
   * (gl.copyTexImage2D wrapper)
   *
   * Note that binding a texture into a Framebuffer's color buffer and
   * rendering can be faster.
   */
  copyFramebuffer(e = {}) {
    return Je.error("Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})")(), null;
  }
  getActiveUnit() {
    return this.gl.getParameter(34016) - 33984;
  }
  bind(e = this.textureUnit) {
    const { gl: i } = this;
    return e !== void 0 && (this.textureUnit = e, i.activeTexture(33984 + e)), i.bindTexture(this.target, this.handle), e;
  }
  unbind(e = this.textureUnit) {
    const { gl: i } = this;
    return e !== void 0 && (this.textureUnit = e, i.activeTexture(33984 + e)), i.bindTexture(this.target, null), e;
  }
  // PRIVATE METHODS
  _getDataType({ data: e, compressed: i = !1 }) {
    return i ? { data: e, dataType: "compressed" } : e === null ? { data: e, dataType: "null" } : ArrayBuffer.isView(e) ? { data: e, dataType: "typed-array" } : e instanceof Aa ? { data: e.handle, dataType: "buffer" } : typeof WebGLBuffer < "u" && e instanceof WebGLBuffer ? { data: e, dataType: "buffer" } : { data: e, dataType: "browser-object" };
  }
  // HELPER METHODS
  _deduceParameters(e) {
    const { format: i, data: s } = e;
    let { width: o, height: u, dataFormat: d, type: a, compressed: w } = e;
    const S = yp(i);
    return d = d || S.dataFormat, a = a || S.type, w = w || S.compressed, { width: o, height: u } = this._deduceImageSize(s, o, u), { dataFormat: d, type: a, compressed: w, width: o, height: u, format: i, data: s };
  }
  // eslint-disable-next-line complexity
  _deduceImageSize(e, i, s) {
    let o;
    return typeof ImageData < "u" && e instanceof ImageData ? o = { width: e.width, height: e.height } : typeof HTMLImageElement < "u" && e instanceof HTMLImageElement ? o = { width: e.naturalWidth, height: e.naturalHeight } : typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement ? o = { width: e.width, height: e.height } : typeof ImageBitmap < "u" && e instanceof ImageBitmap ? o = { width: e.width, height: e.height } : typeof HTMLVideoElement < "u" && e instanceof HTMLVideoElement ? o = { width: e.videoWidth, height: e.videoHeight } : e ? o = { width: i, height: s } : o = { width: i >= 0 ? i : 1, height: s >= 0 ? s : 1 }, si(o, "Could not deduced texture size"), si(i === void 0 || o.width === i, "Deduced texture width does not match supplied width"), si(s === void 0 || o.height === s, "Deduced texture height does not match supplied height"), o;
  }
  // CUBE MAP METHODS
  /* eslint-disable max-statements, max-len */
  async setCubeMapImageData(e) {
    const { gl: i } = this, { width: s, height: o, pixels: u, data: d, format: a = 6408, type: w = 5121 } = e, S = u || d, M = await Promise.all(Bn.FACES.map((F) => {
      const N = S[F];
      return Promise.all(Array.isArray(N) ? N : [N]);
    }));
    this.bind(), Bn.FACES.forEach((F, N) => {
      M[N].length > 1 && this.props.mipmaps !== !1 && Je.warn(`${this.id} has mipmap and multiple LODs.`)(), M[N].forEach((L, re) => {
        s && o ? i.texImage2D(F, re, a, s, o, 0, a, w, L) : i.texImage2D(F, re, a, a, w, L);
      });
    }), this.unbind();
  }
  /** @todo update this method to accept LODs */
  setImageDataForFace(e) {
    const {
      face: i,
      width: s,
      height: o,
      pixels: u,
      data: d,
      format: a = 6408,
      type: w = 5121
      // generateMipmap = false // TODO
    } = e, { gl: S } = this, M = u || d;
    return this.bind(), M instanceof Promise ? M.then((F) => this.setImageDataForFace(Object.assign({}, e, {
      face: i,
      data: F,
      pixels: F
    }))) : this.width || this.height ? S.texImage2D(i, 0, a, s, o, 0, a, w, M) : S.texImage2D(i, 0, a, a, w, M), this;
  }
  /** Image 3D copies from Typed Array or WebGLBuffer */
  setImageData3D(e) {
    const {
      level: i = 0,
      dataFormat: s,
      format: o,
      type: u,
      // = GL.UNSIGNED_BYTE,
      width: d,
      height: a,
      depth: w = 1,
      offset: S = 0,
      data: M,
      parameters: F = {}
    } = e;
    this.trackDeallocatedMemory("Texture"), this.gl.bindTexture(this.target, this.handle);
    const N = yp(o);
    if (xa(this.gl, F, () => {
      ArrayBuffer.isView(M) && this.gl.texImage3D(
        this.target,
        i,
        N.format,
        d,
        a,
        w,
        0,
        N.dataFormat,
        N.type,
        // dataType: getWebGL,
        M
      ), M instanceof Aa && (this.gl.bindBuffer(35052, M.handle), this.gl.texImage3D(this.target, i, s, d, a, w, 0, o, u, S));
    }), M && M.byteLength)
      this.trackAllocatedMemory(M.byteLength, "Texture");
    else {
      const L = hx(this.props.format);
      this.trackAllocatedMemory(this.width * this.height * this.depth * L, "Texture");
    }
    return this.loaded = !0, this;
  }
  // RESOURCE METHODS
  /**
   * Sets sampler parameters on texture
   */
  _setSamplerParameters(e) {
    if (!lp(e)) {
      pF(e), this.gl.bindTexture(this.target, this.handle);
      for (const [i, s] of Object.entries(e)) {
        const o = Number(i), u = s;
        switch (o) {
          case 33082:
          case 33083:
            this.gl.texParameterf(this.target, o, u);
            break;
          default:
            this.gl.texParameteri(this.target, o, u);
            break;
        }
      }
      this.gl.bindTexture(this.target, null);
    }
  }
}
function fF(t) {
  switch (t.dimension) {
    // supported in WebGL
    case "2d":
      return 3553;
    case "cube":
      return 34067;
    // supported in WebGL2
    case "2d-array":
      return 35866;
    case "3d":
      return 32879;
    // not supported in any WebGL version
    case "1d":
    case "cube-array":
    default:
      throw new Error(t.dimension);
  }
}
function pF(t) {
  Je.log(1, "texture sampler parameters", t)();
}
class Hu extends Pp {
  device;
  gl;
  handle;
  get texture() {
    return this.colorAttachments[0];
  }
  constructor(e, i) {
    super(e, i);
    const s = i.handle === null;
    if (this.device = e, this.gl = e.gl, this.handle = this.props.handle || s ? this.props.handle : this.gl.createFramebuffer(), !s) {
      e.setSpectorMetadata(this.handle, { id: this.props.id, props: this.props }), this.autoCreateAttachmentTextures();
      const o = this.gl.bindFramebuffer(36160, this.handle);
      for (let u = 0; u < this.colorAttachments.length; ++u) {
        const d = this.colorAttachments[u], a = 36064 + u;
        d && this._attachOne(a, d);
      }
      if (this.depthStencilAttachment && this._attachOne(eF(this.depthStencilAttachment.props.format), this.depthStencilAttachment), i.check !== !1) {
        const u = this.gl.checkFramebufferStatus(36160);
        if (u !== 36053)
          throw new Error(`Framebuffer ${gF(u)}`);
      }
      this.gl.bindFramebuffer(36160, o);
    }
  }
  /** destroys any auto created resources etc. */
  destroy() {
    super.destroy(), !this.destroyed && this.handle !== null && this.gl.deleteFramebuffer(this.handle);
  }
  // PRIVATE
  /** In WebGL we must use renderbuffers for depth/stencil attachments (unless we have extensions) */
  createDepthStencilTexture(e) {
    return new Bn(this.device, {
      id: `${this.id}-depth-stencil`,
      format: e,
      width: this.width,
      height: this.height,
      mipmaps: !1
    });
  }
  /**
   * Attachment resize is expected to be a noop if size is same
   */
  resizeAttachments(e, i) {
    if (this.handle === null)
      return this.width = this.gl.drawingBufferWidth, this.height = this.gl.drawingBufferHeight, this;
    e === void 0 && (e = this.gl.drawingBufferWidth), i === void 0 && (i = this.gl.drawingBufferHeight);
    for (const s of this.colorAttachments)
      s.texture.resize({ width: e, height: i });
    return this.depthStencilAttachment && this.depthStencilAttachment.texture.resize({ width: e, height: i }), this;
  }
  /** Attach one attachment */
  _attachOne(e, i) {
    if (Array.isArray(i)) {
      const [s, o = 0, u = 0] = i;
      return this._attachTexture(e, s, o, u), s;
    }
    if (i instanceof Bn)
      return this._attachTexture(e, i, 0, 0), i;
    if (i instanceof Xc) {
      const s = i;
      return this._attachTexture(e, s.texture, s.props.baseMipLevel, s.props.baseArrayLayer), i.texture;
    }
    throw new Error("attach");
  }
  // TODO - we do not seem to need render buffers in WebGL 2
  // protected _attachWEBGLRenderbuffer(attachment: GL, renderbuffer: WEBGLRenderbuffer): void {
  //   this.gl.framebufferRenderbuffer(
  //     GL.FRAMEBUFFER,
  //     attachment,
  //     GL.RENDERBUFFER,
  //     renderbuffer.handle
  //   );
  // }
  /**
   * @param attachment
   * @param texture
   * @param layer = 0 - index into WEBGLTextureArray and Texture3D or face for `TextureCubeMap`
   * @param level = 0 - mipmapLevel
   */
  _attachTexture(e, i, s, o) {
    const { gl: u } = this.device;
    switch (u.bindTexture(i.target, i.handle), i.target) {
      case 35866:
      case 32879:
        u.framebufferTextureLayer(36160, e, i.target, o, s);
        break;
      case 34067:
        const d = _F(s);
        u.framebufferTexture2D(36160, e, d, i.handle, o);
        break;
      case 3553:
        u.framebufferTexture2D(36160, e, 3553, i.handle, o);
        break;
      default:
        si(!1, "Illegal texture type");
    }
    u.bindTexture(i.target, null);
  }
}
function _F(t) {
  return t < 34069 ? t + 34069 : t;
}
function gF(t) {
  switch (t) {
    case 36053:
      return "success";
    case 36054:
      return "Mismatched attachments";
    case 36055:
      return "No attachments";
    case 36057:
      return "Height/width mismatch";
    case 36061:
      return "Unsupported or split attachments";
    // WebGL2
    case 36182:
      return "Samples mismatch";
    // OVR_multiview2 extension
    // case GL.FRAMEBUFFER_INCOMPLETE_VIEW_TARGETS_OVR: return 'baseViewIndex mismatch';
    default:
      return `${t}`;
  }
}
class mF extends Ow {
  device;
  presentationSize;
  _framebuffer = null;
  constructor(e, i) {
    super(i), this.device = e, this.presentationSize = [-1, -1], this._setAutoCreatedCanvasId(`${this.device.id}-canvas`), this.update();
  }
  getCurrentFramebuffer() {
    return this.update(), this._framebuffer = this._framebuffer || new Hu(this.device, { handle: null }), this._framebuffer;
  }
  /** Resizes and updates render targets if necessary */
  update() {
    const e = this.getPixelSize();
    (e[0] !== this.presentationSize[0] || e[1] !== this.presentationSize[1]) && (this.presentationSize = e, this.resize());
  }
  /**
   * Resize the canvas' drawing buffer.
   *
   * Can match the canvas CSS size, and optionally also consider devicePixelRatio
   * Can be called every frame
   *
   * Regardless of size, the drawing buffer will always be scaled to the viewport, but
   * for best visual results, usually set to either:
   *  canvas CSS width x canvas CSS height
   *  canvas CSS width * devicePixelRatio x canvas CSS height * devicePixelRatio
   * See http://webgl2fundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
   */
  resize(e) {
    if (this.device.gl && this.canvas) {
      const i = this.getDevicePixelRatio(e?.useDevicePixels);
      this.setDevicePixelRatio(i, e);
      return;
    }
  }
  commit() {
  }
}
const yF = {
  spector: Je.get("spector") || Je.get("spectorjs")
}, bF = "https://cdn.jsdelivr.net/npm/spectorjs@0.9.30/dist/spector.bundle.js", vF = 1;
let ms = null, fx = !1;
async function xF(t) {
  if (!globalThis.SPECTOR)
    try {
      await jw(bF);
    } catch (e) {
      Je.warn(String(e));
    }
}
function wF(t) {
  if (t = { ...yF, ...t }, !t?.spector || (!ms && globalThis.SPECTOR && (Je.probe(vF, "SPECTOR found and initialized")(), ms = new globalThis.SPECTOR.Spector(), globalThis.luma && (globalThis.luma.spector = ms)), !ms))
    return null;
  if (fx || (fx = !0, ms.spyCanvases(), ms?.onCaptureStarted.add((e) => Je.info("Spector capture started:", e)()), ms?.onCapture.add((e) => {
    Je.info("Spector capture complete:", e)(), ms?.getResultUI(), ms?.resultView.display(), ms?.resultView.addCapture(e);
  })), t?.canvas) {
    if (typeof t.spector == "string" && t.spector !== t.canvas.id)
      return ms;
    ms?.startCapture(t?.canvas, 500), new Promise((e) => setTimeout(e, 2e3)).then((e) => {
      Je.info("Spector capture stopped after 2 seconds")(), ms?.stopCapture();
    });
  }
  return ms;
}
const TF = "https://unpkg.com/webgl-debug@2.0.1/index.js";
function HT(t) {
  return t.luma = t.luma || {}, t.luma;
}
async function AF() {
  Ra() && !globalThis.WebGLDebugUtils && (globalThis.global = globalThis.global || globalThis, globalThis.global.module = {}, await jw(TF));
}
function EF(t, e = {}) {
  return t ? e.debug ? CF(t, e) : SF(t) : null;
}
function SF(t) {
  const e = HT(t);
  return e.realContext ? e.realContext : t;
}
function CF(t, e) {
  if (!globalThis.WebGLDebugUtils)
    return Je.warn("webgl-debug not loaded")(), t;
  const i = HT(t);
  if (i.debugContext)
    return i.debugContext;
  globalThis.WebGLDebugUtils.init({ ...$c, ...t });
  const s = globalThis.WebGLDebugUtils.makeDebugContext(t, IF.bind(null, e), MF.bind(null, e));
  for (const d in $c)
    !(d in s) && typeof $c[d] == "number" && (s[d] = $c[d]);
  class o {
  }
  Object.setPrototypeOf(s, Object.getPrototypeOf(t)), Object.setPrototypeOf(o, s);
  const u = Object.create(o);
  return i.realContext = t, i.debugContext = u, u.debug = !0, u;
}
function Cg(t, e) {
  e = Array.from(e).map((s) => s === void 0 ? "undefined" : s);
  let i = globalThis.WebGLDebugUtils.glFunctionArgsToString(t, e);
  return i = `${i.slice(0, 100)}${i.length > 100 ? "..." : ""}`, `gl.${t}(${i})`;
}
function IF(t, e, i, s) {
  s = Array.from(s).map((a) => a === void 0 ? "undefined" : a);
  const o = globalThis.WebGLDebugUtils.glEnumToString(e), u = globalThis.WebGLDebugUtils.glFunctionArgsToString(i, s), d = `${o} in gl.${i}(${u})`;
  Je.error(d)();
  debugger;
  if (t.throwOnError)
    throw new Error(d);
}
function MF(t, e, i) {
  let s = "";
  if (Je.level >= 1 && (s = Cg(e, i), Je.log(1, s)()), t.break && t.break.length > 0 && (s = s || Cg(e, i), t.break.every((u) => s.indexOf(u) !== -1)))
    debugger;
  for (const o of i)
    if (o === void 0) {
      if (s = s || Cg(e, i), t.throwOnError)
        throw new Error(`Undefined argument: ${s}`);
      Je.error(`Undefined argument: ${s}`)();
      debugger;
    }
}
function RF(t) {
  const e = t.split(/\r?\n/), i = [];
  for (const s of e) {
    if (s.length <= 1)
      continue;
    const o = s.split(":");
    if (o.length === 2) {
      const [F, N] = o;
      i.push({
        message: N.trim(),
        type: px(F),
        lineNum: 0,
        linePos: 0
      });
      continue;
    }
    const [u, d, a, ...w] = o;
    let S = parseInt(a, 10);
    isNaN(S) && (S = 0);
    let M = parseInt(d, 10);
    isNaN(M) && (M = 0), i.push({
      message: w.join(":").trim(),
      type: px(u),
      lineNum: S,
      linePos: M
      // TODO
    });
  }
  return i;
}
function px(t) {
  const e = ["warning", "error", "info"], i = t.toLowerCase();
  return e.includes(i) ? i : "info";
}
class PF extends Mp {
  device;
  handle;
  constructor(e, i) {
    switch (super(e, i), this.device = e, this.props.stage) {
      case "vertex":
        this.handle = this.props.handle || this.device.gl.createShader(35633);
        break;
      case "fragment":
        this.handle = this.props.handle || this.device.gl.createShader(35632);
        break;
      default:
        throw new Error(this.props.stage);
    }
    this._compile(this.source);
  }
  destroy() {
    this.handle && (this.removeStats(), this.device.gl.deleteShader(this.handle), this.destroyed = !0);
  }
  async getCompilationInfo() {
    return await this._waitForCompilationComplete(), this.getCompilationInfoSync();
  }
  getCompilationInfoSync() {
    const e = this.device.gl.getShaderInfoLog(this.handle);
    return RF(e);
  }
  getTranslatedSource() {
    return this.device.getExtension("WEBGL_debug_shaders").WEBGL_debug_shaders?.getTranslatedShaderSource(this.handle);
  }
  // PRIVATE METHODS
  /** Compile a shader and get compilation status */
  async _compile(e) {
    e = ((o) => o.startsWith("#version ") ? o : `#version 100
${o}`)(e);
    const { gl: s } = this.device;
    if (s.shaderSource(this.handle, e), s.compileShader(this.handle), Je.level === 0) {
      this.compilationStatus = "pending";
      return;
    }
    if (!this.device.features.has("compilation-status-async-webgl")) {
      if (this._getCompilationStatus(), this.debugShader(), this.compilationStatus === "error")
        throw new Error(`GLSL compilation errors in ${this.props.stage} shader ${this.props.id}`);
      return;
    }
    Je.once(1, "Shader compilation is asynchronous")(), await this._waitForCompilationComplete(), Je.info(2, `Shader ${this.id} - async compilation complete: ${this.compilationStatus}`)(), this._getCompilationStatus(), this.debugShader();
  }
  /** Use KHR_parallel_shader_compile extension if available */
  async _waitForCompilationComplete() {
    const e = async (o) => await new Promise((u) => setTimeout(u, o));
    if (!this.device.features.has("compilation-status-async-webgl")) {
      await e(10);
      return;
    }
    const { gl: s } = this.device;
    for (; ; ) {
      if (s.getShaderParameter(this.handle, 37297))
        return;
      await e(10);
    }
  }
  /**
   * Get the shader compilation status
   * TODO - Load log even when no error reported, to catch warnings?
   * https://gamedev.stackexchange.com/questions/30429/how-to-detect-glsl-warnings
   */
  _getCompilationStatus() {
    this.compilationStatus = this.device.gl.getShaderParameter(this.handle, 35713) ? "success" : "error";
  }
}
const BF = 256, DF = 1024, OF = 16384, Ig = 6144, FF = [1, 2, 4, 8];
class kF extends oy {
  device;
  /** Parameters that should be applied before each draw call */
  glParameters;
  constructor(e, i) {
    super(e, i), this.device = e, Dp(this.device.gl), this.setParameters(this.props.parameters), this.clear();
  }
  end() {
    Ju(this.device.gl);
  }
  pushDebugGroup(e) {
  }
  popDebugGroup() {
  }
  insertDebugMarker(e) {
  }
  // beginOcclusionQuery(queryIndex: number): void;
  // endOcclusionQuery(): void;
  // executeBundles(bundles: Iterable<GPURenderBundle>): void;
  /**
   * Maps RenderPass parameters to GL parameters
   */
  setParameters(e = {}) {
    const i = { ...this.glParameters };
    this.props.framebuffer && (i.framebuffer = this.props.framebuffer), this.props.depthReadOnly && (i.depthMask = !this.props.depthReadOnly), i.stencilMask = this.props.stencilReadOnly ? 0 : 1, i[35977] = this.props.discard, e.viewport && (e.viewport.length >= 6 ? (i.viewport = e.viewport.slice(0, 4), i.depthRange = [e.viewport[4], e.viewport[5]]) : i.viewport = e.viewport), e.scissorRect && (i.scissorTest = !0, i.scissor = e.scissorRect), e.blendConstant && (i.blendColor = e.blendConstant), e.stencilReference && (console.warn("RenderPassParameters.stencilReference not yet implemented in WebGL"), e[2967] = e.stencilReference), e.colorMask && (i.colorMask = FF.map((s) => !!(s & e.colorMask))), this.glParameters = i, gh(this.device.gl, i);
  }
  beginOcclusionQuery(e) {
    this.props.occlusionQuerySet?.beginOcclusionQuery();
  }
  endOcclusionQuery() {
    this.props.occlusionQuerySet?.endOcclusionQuery();
  }
  // PRIVATE
  /**
   * Optionally clears depth, color and stencil buffers based on parameters
   */
  clear() {
    const e = { ...this.glParameters };
    let i = 0;
    this.props.clearColor !== !1 && (i |= OF, e.clearColor = this.props.clearColor), this.props.clearDepth !== !1 && (i |= BF, e.clearDepth = this.props.clearDepth), this.props.clearStencil !== !1 && (i |= DF, e.clearStencil = this.props.clearStencil), i !== 0 && xa(this.device.gl, e, () => {
      this.device.gl.clear(i);
    });
  }
  /**
   * WebGL2 - clear a specific color buffer
   */
  clearColorBuffer(e = 0, i = [0, 0, 0, 0]) {
    xa(this.device.gl, { framebuffer: this.props.framebuffer }, () => {
      switch (i.constructor) {
        case Int32Array:
          this.device.gl.clearBufferiv(Ig, e, i);
          break;
        case Uint32Array:
          this.device.gl.clearBufferuiv(Ig, e, i);
          break;
        case Float32Array:
        default:
          this.device.gl.clearBufferfv(Ig, e, i);
          break;
      }
    });
  }
}
const NF = "Failed to deduce GL constant from typed array";
function LF(t) {
  switch (ArrayBuffer.isView(t) ? t.constructor : t) {
    case Float32Array:
      return 5126;
    case Uint16Array:
      return 5123;
    case Uint32Array:
      return 5125;
    case Uint8Array:
      return 5121;
    case Uint8ClampedArray:
      return 5121;
    case Int8Array:
      return 5120;
    case Int16Array:
      return 5122;
    case Int32Array:
      return 5124;
    default:
      throw new Error(NF);
  }
}
function Im(t, e) {
  const { clamped: i = !0 } = e || {};
  switch (t) {
    case 5126:
      return Float32Array;
    case 5123:
    case 33635:
    case 32819:
    case 32820:
      return Uint16Array;
    case 5125:
      return Uint32Array;
    case 5121:
      return i ? Uint8ClampedArray : Uint8Array;
    case 5120:
      return Int8Array;
    case 5122:
      return Int16Array;
    case 5124:
      return Int32Array;
    default:
      throw new Error("Failed to deduce typed array type from GL constant");
  }
}
const UF = {
  offset: 0,
  stride: 0,
  type: 5126,
  size: 1,
  divisor: 0,
  normalized: !1,
  integer: !1
}, zF = {
  deprecatedProps: {
    instanced: "divisor",
    isInstanced: "divisor"
  }
};
class $u {
  offset;
  stride;
  type;
  size;
  divisor;
  normalized;
  integer;
  buffer;
  index;
  static getBytesPerElement(e) {
    return Im(e.type || 5126).BYTES_PER_ELEMENT;
  }
  static getBytesPerVertex(e) {
    return si(e.size), Im(e.type || 5126).BYTES_PER_ELEMENT * e.size;
  }
  // Combines (merges) a list of accessors. On top of default values
  // Usually [programAccessor, bufferAccessor, appAccessor]
  // All props will be set in the returned object.
  // TODO check for conflicts between values in the supplied accessors
  static resolve(...e) {
    return new $u(UF, ...e);
  }
  constructor(...e) {
    e.forEach((i) => this._assign(i)), Object.freeze(this);
  }
  toString() {
    return JSON.stringify(this);
  }
  // ACCESSORS
  // TODO - remove>
  get BYTES_PER_ELEMENT() {
    return $u.getBytesPerElement(this);
  }
  get BYTES_PER_VERTEX() {
    return $u.getBytesPerVertex(this);
  }
  // PRIVATE
  // eslint-disable-next-line complexity, max-statements
  _assign(e = {}) {
    return e = DR("Accessor", e, zF), e.type !== void 0 && (this.type = e.type, (e.type === 5124 || e.type === 5125) && (this.integer = !0)), e.size !== void 0 && (this.size = e.size), e.offset !== void 0 && (this.offset = e.offset), e.stride !== void 0 && (this.stride = e.stride), e.normalize !== void 0 && (this.normalized = e.normalize), e.normalized !== void 0 && (this.normalized = e.normalized), e.integer !== void 0 && (this.integer = e.integer), e.divisor !== void 0 && (this.divisor = e.divisor), e.buffer !== void 0 && (this.buffer = e.buffer), e.index !== void 0 && (typeof e.index == "boolean" ? this.index = e.index ? 1 : 0 : this.index = e.index), e.instanced !== void 0 && (this.divisor = e.instanced ? 1 : 0), e.isInstanced !== void 0 && (this.divisor = e.isInstanced ? 1 : 0), this.offset === void 0 && delete this.offset, this.stride === void 0 && delete this.stride, this.type === void 0 && delete this.type, this.size === void 0 && delete this.size, this.divisor === void 0 && delete this.divisor, this.normalized === void 0 && delete this.normalized, this.integer === void 0 && delete this.integer, this.buffer === void 0 && delete this.buffer, this.index === void 0 && delete this.index, this;
  }
}
function VF(t) {
  return jF.includes(t);
}
const jF = [
  35678,
  35680,
  35679,
  35682,
  36289,
  36292,
  36293,
  36298,
  36299,
  36300,
  36303,
  36306,
  36307,
  36308,
  36311
], $T = {
  5126: [5126, 1, "float", "f32", "float32"],
  35664: [5126, 2, "vec2", "vec2<f32>", "float32x2"],
  35665: [5126, 3, "vec3", "vec3<f32>", "float32x3"],
  35666: [5126, 4, "vec4", "vec4<f32>", "float32x4"],
  5124: [5124, 1, "int", "i32", "sint32"],
  35667: [5124, 2, "ivec2", "vec2<i32>", "sint32x2"],
  35668: [5124, 3, "ivec3", "vec3<i32>", "sint32x3"],
  35669: [5124, 4, "ivec4", "vec4<i32>", "sint32x4"],
  5125: [5125, 1, "uint", "u32", "uint32"],
  36294: [5125, 2, "uvec2", "vec2<u32>", "uint32x2"],
  36295: [5125, 3, "uvec3", "vec3<u32>", "uint32x3"],
  36296: [5125, 4, "uvec4", "vec4<u32>", "uint32x4"],
  35670: [5126, 1, "bool", "f32", "float32"],
  35671: [5126, 2, "bvec2", "vec2<f32>", "float32x2"],
  35672: [5126, 3, "bvec3", "vec3<f32>", "float32x3"],
  35673: [5126, 4, "bvec4", "vec4<f32>", "float32x4"],
  // TODO - are sizes/components below correct?
  35674: [5126, 8, "mat2", "mat2x2<f32>"],
  // 4
  35685: [5126, 8, "mat2x3", "mat2x3<f32>"],
  // 6
  35686: [5126, 8, "mat2x4", "mat2x4<f32>"],
  // 8
  35687: [5126, 12, "mat3x2", "mat3x2<f32>"],
  // 6
  35675: [5126, 12, "mat3", "mat3x3<f32>"],
  // 9
  35688: [5126, 12, "mat3x4", "mat3x4<f32>"],
  // 12
  35689: [5126, 16, "mat4x2", "mat4x2<f32>"],
  // 8
  35690: [5126, 16, "mat4x3", "mat4x3<f32>"],
  // 12
  35676: [5126, 16, "mat4", "mat4x4<f32>"]
  // 16
};
function GT(t) {
  const e = $T[t];
  if (!e)
    throw new Error("uniform");
  const [i, s, , o] = e;
  return { format: o, components: s, glType: i };
}
function HF(t) {
  const e = $T[t];
  if (!e)
    throw new Error("attribute");
  const [, i, , s, o] = e;
  return { attributeType: s, vertexFormat: o, components: i };
}
function $F(t, e) {
  const i = {
    attributes: [],
    bindings: []
  };
  i.attributes = GF(t, e);
  const s = qF(t, e);
  for (const a of s) {
    const w = a.uniforms.map((S) => ({
      name: S.name,
      format: S.format,
      byteOffset: S.byteOffset,
      byteStride: S.byteStride,
      arrayLength: S.arrayLength
    }));
    i.bindings.push({
      type: "uniform",
      name: a.name,
      location: a.location,
      visibility: (a.vertex ? 1 : 0) & (a.fragment ? 2 : 0),
      minBindingSize: a.byteLength,
      uniforms: w
    });
  }
  const o = XF(t, e);
  let u = 0;
  for (const a of o)
    if (VF(a.type)) {
      const { viewDimension: w, sampleType: S } = KF(a.type);
      i.bindings.push({
        type: "texture",
        name: a.name,
        location: u,
        viewDimension: w,
        sampleType: S
      }), a.textureUnit = u, u += 1;
    }
  o.length && (i.uniforms = o);
  const d = WF(t, e);
  return d?.length && (i.varyings = d), i;
}
function GF(t, e) {
  const i = [], s = t.getProgramParameter(e, 35721);
  for (let o = 0; o < s; o++) {
    const u = t.getActiveAttrib(e, o);
    if (!u)
      throw new Error("activeInfo");
    const {
      name: d,
      type: a
      /* , size*/
    } = u, w = t.getAttribLocation(e, d);
    if (w >= 0) {
      const { attributeType: S } = HF(a), M = /instance/i.test(d) ? "instance" : "vertex";
      i.push({
        name: d,
        location: w,
        stepMode: M,
        type: S
        // size - for arrays, size is the number of elements in the array
      });
    }
  }
  return i.sort((o, u) => o.location - u.location), i;
}
function WF(t, e) {
  const i = [], s = t.getProgramParameter(e, 35971);
  for (let o = 0; o < s; o++) {
    const u = t.getTransformFeedbackVarying(e, o);
    if (!u)
      throw new Error("activeInfo");
    const { name: d, type: a, size: w } = u, { glType: S, components: M } = GT(a), F = new $u({ type: S, size: w * M }), N = { location: o, name: d, accessor: F };
    i.push(N);
  }
  return i.sort((o, u) => o.location - u.location), i;
}
function XF(t, e) {
  const i = [], s = t.getProgramParameter(e, 35718);
  for (let o = 0; o < s; o++) {
    const u = t.getActiveUniform(e, o);
    if (!u)
      throw new Error("activeInfo");
    const { name: d, size: a, type: w } = u, { name: S, isArray: M } = YF(d);
    let F = t.getUniformLocation(e, S);
    const N = {
      // WebGL locations are uniquely typed but just numbers
      location: F,
      name: S,
      size: a,
      type: w,
      isArray: M
    };
    if (i.push(N), N.size > 1)
      for (let L = 0; L < N.size; L++) {
        const re = `${S}[${L}]`;
        F = t.getUniformLocation(e, re);
        const ne = {
          ...N,
          name: re,
          location: F
        };
        i.push(ne);
      }
  }
  return i;
}
function qF(t, e) {
  const i = (u, d) => t.getActiveUniformBlockParameter(e, u, d), s = [], o = t.getProgramParameter(e, 35382);
  for (let u = 0; u < o; u++) {
    const d = {
      name: t.getActiveUniformBlockName(e, u) || "",
      location: i(u, 35391),
      byteLength: i(u, 35392),
      vertex: i(u, 35396),
      fragment: i(u, 35398),
      uniformCount: i(u, 35394),
      uniforms: []
    }, a = i(u, 35395) || [], w = t.getActiveUniforms(e, a, 35383), S = t.getActiveUniforms(e, a, 35384), M = t.getActiveUniforms(e, a, 35387), F = t.getActiveUniforms(e, a, 35388);
    for (let N = 0; N < d.uniformCount; ++N) {
      const L = t.getActiveUniform(e, a[N]);
      if (!L)
        throw new Error("activeInfo");
      d.uniforms.push({
        name: L.name,
        format: GT(w[N]).format,
        type: w[N],
        arrayLength: S[N],
        byteOffset: M[N],
        byteStride: F[N]
        // matrixStride: uniformStride[i],
        // rowMajor: uniformRowMajor[i]
      });
    }
    s.push(d);
  }
  return s.sort((u, d) => u.location - d.location), s;
}
const ZF = {
  35678: ["2d", "float"],
  35680: ["cube", "float"],
  35679: ["3d", "float"],
  35682: ["3d", "depth"],
  36289: ["2d-array", "float"],
  36292: ["2d-array", "depth"],
  36293: ["cube", "float"],
  36298: ["2d", "sint"],
  36299: ["3d", "sint"],
  36300: ["cube", "sint"],
  36303: ["2d-array", "uint"],
  36306: ["2d", "uint"],
  36307: ["3d", "uint"],
  36308: ["cube", "uint"],
  36311: ["2d-array", "uint"]
};
function KF(t) {
  const e = ZF[t];
  if (!e)
    throw new Error("sampler");
  const [i, s] = e;
  return { viewDimension: i, sampleType: s };
}
function YF(t) {
  if (t[t.length - 1] !== "]")
    return {
      name: t,
      length: 1,
      isArray: !1
    };
  const i = /([^[]*)(\[[0-9]+\])?/.exec(t);
  if (!i || i.length < 2)
    throw new Error(`Failed to parse GLSL uniform name ${t}`);
  return {
    name: i[1],
    length: i[2] ? 1 : 0,
    isArray: !!i[2]
  };
}
function JF(t, e, i, s) {
  const o = t;
  let u = s;
  u === !0 && (u = 1), u === !1 && (u = 0);
  const d = typeof u == "number" ? [u] : u;
  switch (i) {
    case 35678:
    case 35680:
    case 35679:
    case 35682:
    case 36289:
    case 36292:
    case 36293:
    case 36298:
    case 36299:
    case 36300:
    case 36303:
    case 36306:
    case 36307:
    case 36308:
    case 36311:
      if (typeof s != "number")
        throw new Error("samplers must be set to integers");
      return t.uniform1i(e, s);
    case 5126:
      return t.uniform1fv(e, d);
    case 35664:
      return t.uniform2fv(e, d);
    case 35665:
      return t.uniform3fv(e, d);
    case 35666:
      return t.uniform4fv(e, d);
    case 5124:
      return t.uniform1iv(e, d);
    case 35667:
      return t.uniform2iv(e, d);
    case 35668:
      return t.uniform3iv(e, d);
    case 35669:
      return t.uniform4iv(e, d);
    case 35670:
      return t.uniform1iv(e, d);
    case 35671:
      return t.uniform2iv(e, d);
    case 35672:
      return t.uniform3iv(e, d);
    case 35673:
      return t.uniform4iv(e, d);
    // WEBGL2 - unsigned integers
    case 5125:
      return o.uniform1uiv(e, d, 1);
    case 36294:
      return o.uniform2uiv(e, d, 2);
    case 36295:
      return o.uniform3uiv(e, d, 3);
    case 36296:
      return o.uniform4uiv(e, d, 4);
    // WebGL2 - quadratic matrices
    // false: don't transpose the matrix
    case 35674:
      return t.uniformMatrix2fv(e, !1, d);
    case 35675:
      return t.uniformMatrix3fv(e, !1, d);
    case 35676:
      return t.uniformMatrix4fv(e, !1, d);
    // WebGL2 - rectangular matrices
    case 35685:
      return o.uniformMatrix2x3fv(e, !1, d);
    case 35686:
      return o.uniformMatrix2x4fv(e, !1, d);
    case 35687:
      return o.uniformMatrix3x2fv(e, !1, d);
    case 35688:
      return o.uniformMatrix3x4fv(e, !1, d);
    case 35689:
      return o.uniformMatrix4x2fv(e, !1, d);
    case 35690:
      return o.uniformMatrix4x3fv(e, !1, d);
  }
  throw new Error("Illegal uniform");
}
function QF(t) {
  switch (t) {
    case "point-list":
      return 0;
    case "line-list":
      return 1;
    case "line-strip":
      return 3;
    case "line-loop-webgl":
      return 2;
    case "triangle-list":
      return 4;
    case "triangle-strip":
      return 5;
    case "triangle-fan-webgl":
      return 6;
    default:
      throw new Error(t);
  }
}
function ek(t) {
  switch (t) {
    case "point-list":
      return 0;
    case "line-list":
      return 1;
    case "line-strip":
      return 1;
    case "line-loop-webgl":
      return 1;
    case "triangle-list":
      return 4;
    case "triangle-strip":
      return 4;
    case "triangle-fan-webgl":
      return 4;
    default:
      throw new Error(t);
  }
}
const _x = 4;
class tk extends nh {
  /** The WebGL device that created this render pipeline */
  device;
  /** Handle to underlying WebGL program */
  handle;
  /** vertex shader */
  vs;
  /** fragment shader */
  fs;
  /** The layout extracted from shader by WebGL introspection APIs */
  introspectedLayout;
  /** Uniforms set on this model */
  uniforms = {};
  /** Bindings set on this model */
  bindings = {};
  /** WebGL varyings */
  varyings = null;
  _uniformCount = 0;
  _uniformSetters = {};
  // TODO are these used?
  constructor(e, i) {
    super(e, i), this.device = e, this.handle = this.props.handle || this.device.gl.createProgram(), this.device.setSpectorMetadata(this.handle, { id: this.props.id }), this.vs = i.vs, this.fs = i.fs;
    const { varyings: s, bufferMode: o = 35981 } = i;
    switch (s && s.length > 0 && (this.varyings = s, this.device.gl.transformFeedbackVaryings(this.handle, s, o)), this._linkShaders(), Je.time(1, `RenderPipeline ${this.id} - shaderLayout introspection`)(), this.introspectedLayout = $F(this.device.gl, this.handle), Je.timeEnd(1, `RenderPipeline ${this.id} - shaderLayout introspection`)(), this.shaderLayout = vR(this.introspectedLayout, i.shaderLayout), this.props.topology) {
      case "triangle-fan-webgl":
      case "line-loop-webgl":
        Je.warn(`Primitive topology ${this.props.topology} is deprecated and will be removed in v9.1`);
        break;
    }
  }
  destroy() {
    this.handle && (this.device.gl.deleteProgram(this.handle), this.destroyed = !0);
  }
  /**
   * Bindings include: textures, samplers and uniform buffers
   * @todo needed for portable model
   */
  setBindings(e, i) {
    for (const [s, o] of Object.entries(e)) {
      const u = this.shaderLayout.bindings.find((d) => d.name === s) || this.shaderLayout.bindings.find((d) => d.name === `${s}Uniforms`);
      if (!u) {
        const d = this.shaderLayout.bindings.map((a) => `"${a.name}"`).join(", ");
        i?.disableWarnings || Je.warn(`Unknown binding "${s}" in render pipeline "${this.id}", expected one of ${d}`)();
        continue;
      }
      switch (o || Je.warn(`Unsetting binding "${s}" in render pipeline "${this.id}"`)(), u.type) {
        case "uniform":
          if (!(o instanceof Aa) && !(o.buffer instanceof Aa))
            throw new Error("buffer value");
          break;
        case "texture":
          if (!(o instanceof Xc || o instanceof Bn || o instanceof Hu))
            throw new Error("texture value");
          break;
        case "sampler":
          Je.warn(`Ignoring sampler ${s}`)();
          break;
        default:
          throw new Error(u.type);
      }
      this.bindings[s] = o;
    }
  }
  /** @todo needed for portable model
   * @note The WebGL API is offers many ways to draw things
   * This function unifies those ways into a single call using common parameters with sane defaults
   */
  draw(e) {
    const {
      renderPass: i,
      parameters: s = this.props.parameters,
      topology: o = this.props.topology,
      vertexArray: u,
      vertexCount: d,
      // indexCount,
      instanceCount: a,
      isInstanced: w = !1,
      firstVertex: S = 0,
      // firstIndex,
      // firstInstance,
      // baseVertex,
      transformFeedback: M
    } = e, F = QF(o), N = !!u.indexBuffer, L = u.indexBuffer?.glIndexType;
    if (this.linkStatus !== "success")
      return Je.info(2, `RenderPipeline:${this.id}.draw() aborted - waiting for shader linking`)(), !1;
    if (!this._areTexturesRenderable() || d === 0)
      return Je.info(2, `RenderPipeline:${this.id}.draw() aborted - textures not yet loaded`)(), !1;
    if (d === 0)
      return Je.info(2, `RenderPipeline:${this.id}.draw() aborted - no vertices to draw`)(), !0;
    this.device.gl.useProgram(this.handle), u.bindBeforeRender(i), M && M.begin(this.props.topology), this._applyBindings(), this._applyUniforms();
    const re = i;
    return nF(this.device, s, re.glParameters, () => {
      N && w ? this.device.gl.drawElementsInstanced(
        F,
        d || 0,
        // indexCount?
        L,
        S,
        a || 0
      ) : N ? this.device.gl.drawElements(F, d || 0, L, S) : w ? this.device.gl.drawArraysInstanced(F, S, d || 0, a || 0) : this.device.gl.drawArrays(F, S, d || 0), M && M.end();
    }), u.unbindAfterRender(i), !0;
  }
  // DEPRECATED METHODS
  setUniformsWebGL(e) {
    const { bindings: i } = dy(e);
    Object.keys(i).forEach((s) => {
      Je.warn(`Unsupported value "${JSON.stringify(i[s])}" used in setUniforms() for key ${s}. Use setBindings() instead?`)();
    }), Object.assign(this.uniforms, e);
  }
  // PRIVATE METHODS
  // setAttributes(attributes: Record<string, Buffer>): void {}
  // setBindings(bindings: Record<string, Binding>): void {}
  async _linkShaders() {
    const { gl: e } = this.device;
    if (e.attachShader(this.handle, this.vs.handle), e.attachShader(this.handle, this.fs.handle), Je.time(_x, `linkProgram for ${this.id}`)(), e.linkProgram(this.handle), Je.timeEnd(_x, `linkProgram for ${this.id}`)(), Je.level, !this.device.features.has("compilation-status-async-webgl")) {
      const s = this._getLinkStatus();
      this._reportLinkStatus(s);
      return;
    }
    Je.once(1, "RenderPipeline linking is asynchronous")(), await this._waitForLinkComplete(), Je.info(2, `RenderPipeline ${this.id} - async linking complete: ${this.linkStatus}`)();
    const i = this._getLinkStatus();
    this._reportLinkStatus(i);
  }
  /** Report link status. First, check for shader compilation failures if linking fails */
  _reportLinkStatus(e) {
    switch (e) {
      case "success":
        return;
      default:
        throw this.vs.compilationStatus === "error" ? (this.vs.debugShader(), new Error(`Error during compilation of shader ${this.vs.id}`)) : this.fs?.compilationStatus === "error" ? (this.fs.debugShader(), new Error(`Error during compilation of shader ${this.fs.id}`)) : new Error(`Error during ${e}: ${this.device.gl.getProgramInfoLog(this.handle)}`);
    }
  }
  /**
   * Get the shader compilation status
   * TODO - Load log even when no error reported, to catch warnings?
   * https://gamedev.stackexchange.com/questions/30429/how-to-detect-glsl-warnings
   */
  _getLinkStatus() {
    const { gl: e } = this.device;
    return e.getProgramParameter(this.handle, 35714) ? (e.validateProgram(this.handle), e.getProgramParameter(this.handle, 35715) ? (this.linkStatus = "success", "success") : (this.linkStatus = "error", "validation")) : (this.linkStatus = "error", "linking");
  }
  /** Use KHR_parallel_shader_compile extension if available */
  async _waitForLinkComplete() {
    const e = async (o) => await new Promise((u) => setTimeout(u, o));
    if (!this.device.features.has("compilation-status-async-webgl")) {
      await e(10);
      return;
    }
    const { gl: s } = this.device;
    for (; ; ) {
      if (s.getProgramParameter(this.handle, 37297))
        return;
      await e(10);
    }
  }
  /**
   * Checks if all texture-values uniforms are renderable (i.e. loaded)
   * Update a texture if needed (e.g. from video)
   * Note: This is currently done before every draw call
   */
  _areTexturesRenderable() {
    let e = !0;
    for (const [, i] of Object.entries(this.bindings))
      i instanceof Bn && (i.update(), e = e && i.loaded);
    return e;
  }
  /** Apply any bindings (before each draw call) */
  _applyBindings() {
    if (this.linkStatus !== "success")
      return;
    const { gl: e } = this.device;
    e.useProgram(this.handle);
    let i = 0, s = 0;
    for (const o of this.shaderLayout.bindings) {
      const u = this.bindings[o.name] || this.bindings[o.name.replace(/Uniforms$/, "")];
      if (!u)
        throw new Error(`No value for binding ${o.name} in ${this.id}`);
      switch (o.type) {
        case "uniform":
          const { name: d } = o, a = e.getUniformBlockIndex(this.handle, d);
          if (a === 4294967295)
            throw new Error(`Invalid uniform block name ${d}`);
          e.uniformBlockBinding(this.handle, s, a), u instanceof Aa ? e.bindBufferBase(35345, s, u.handle) : e.bindBufferRange(
            35345,
            s,
            // @ts-expect-error
            u.buffer.handle,
            // @ts-expect-error
            u.offset || 0,
            // @ts-expect-error
            u.size || u.buffer.byteLength - u.offset
          ), s += 1;
          break;
        case "texture":
          if (!(u instanceof Xc || u instanceof Bn || u instanceof Hu))
            throw new Error("texture");
          let w;
          if (u instanceof Xc)
            w = u.texture;
          else if (u instanceof Bn)
            w = u;
          else if (u instanceof Hu && u.colorAttachments[0] instanceof Xc)
            Je.warn("Passing framebuffer in texture binding may be deprecated. Use fbo.colorAttachments[0] instead")(), w = u.colorAttachments[0].texture;
          else
            throw new Error("No texture");
          e.activeTexture(33984 + i), e.bindTexture(w.target, w.handle), i += 1;
          break;
        case "sampler":
          break;
        case "storage":
        case "read-only-storage":
          throw new Error(`binding type '${o.type}' not supported in WebGL`);
      }
    }
  }
  /**
   * Due to program sharing, uniforms need to be reset before every draw call
   * (though caching will avoid redundant WebGL calls)
   */
  _applyUniforms() {
    for (const e of this.shaderLayout.uniforms || []) {
      const { name: i, location: s, type: o, textureUnit: u } = e, d = this.uniforms[i] ?? u;
      d !== void 0 && JF(this.device.gl, s, o, d);
    }
  }
}
class ik extends ly {
  device;
  commands = [];
  constructor(e) {
    super(e, {}), this.device = e;
  }
  submitCommands(e = this.commands) {
    for (const i of e)
      switch (i.name) {
        case "copy-buffer-to-buffer":
          rk(this.device, i.options);
          break;
        case "copy-buffer-to-texture":
          sk(this.device, i.options);
          break;
        case "copy-texture-to-buffer":
          nk(this.device, i.options);
          break;
        case "copy-texture-to-texture":
          ok(this.device, i.options);
          break;
      }
  }
}
function rk(t, e) {
  const i = e.source, s = e.destination;
  t.gl.bindBuffer(36662, i.handle), t.gl.bindBuffer(36663, s.handle), t.gl.copyBufferSubData(36662, 36663, e.sourceOffset ?? 0, e.destinationOffset ?? 0, e.size), t.gl.bindBuffer(36662, null), t.gl.bindBuffer(36663, null);
}
function sk(t, e) {
  throw new Error("Not implemented");
}
function nk(t, e) {
  const {
    /** Texture to copy to/from. */
    source: i,
    /**  Mip-map level of the texture to copy to/from. (Default 0) */
    mipLevel: s = 0,
    /** Defines which aspects of the texture to copy to/from. */
    aspect: o = "all",
    /** Width to copy */
    width: u = e.source.width,
    /** Height to copy */
    height: d = e.source.height,
    depthOrArrayLayers: a = 0,
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from. */
    origin: w = [0, 0],
    /** Destination buffer */
    destination: S,
    /** Offset, in bytes, from the beginning of the buffer to the start of the image data (default 0) */
    byteOffset: M = 0,
    /**
     * The stride, in bytes, between the beginning of each block row and the subsequent block row.
     * Required if there are multiple block rows (i.e. the copy height or depth is more than one block).
     */
    bytesPerRow: F,
    /**
     * Number of block rows per single image of the texture.
     * rowsPerImage &times; bytesPerRow is the stride, in bytes, between the beginning of each image of data and the subsequent image.
     * Required if there are multiple images (i.e. the copy depth is more than one).
     */
    rowsPerImage: N
  } = e;
  if (o !== "all")
    throw new Error("not supported");
  if (s !== 0 || a !== 0 || F || N)
    throw new Error("not implemented");
  const { framebuffer: L, destroyFramebuffer: re } = WT(i);
  let ne;
  try {
    const we = S, Se = u || L.width, Ee = d || L.height, Ce = yp(L.texture.props.format), Le = Ce.dataFormat, Ze = Ce.type;
    t.gl.bindBuffer(35051, we.handle), ne = t.gl.bindFramebuffer(36160, L.handle), t.gl.readPixels(w[0], w[1], Se, Ee, Le, Ze, M);
  } finally {
    t.gl.bindBuffer(35051, null), ne !== void 0 && t.gl.bindFramebuffer(36160, ne), re && L.destroy();
  }
}
function ok(t, e) {
  const {
    /** Texture to copy to/from. */
    source: i,
    /**  Mip-map level of the texture to copy to (Default 0) */
    destinationMipLevel: s = 0,
    /** Defines which aspects of the texture to copy to/from. */
    // aspect = 'all',
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy from. */
    origin: o = [0, 0],
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to. */
    destinationOrigin: u = [0, 0],
    /** Texture to copy to/from. */
    destination: d
    /**  Mip-map level of the texture to copy to/from. (Default 0) */
    // destinationMipLevel = options.mipLevel,
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from. */
    // destinationOrigin = [0, 0],
    /** Defines which aspects of the texture to copy to/from. */
    // destinationAspect = options.aspect,
  } = e;
  let {
    width: a = e.destination.width,
    height: w = e.destination.height
    // depthOrArrayLayers = 0
  } = e;
  const { framebuffer: S, destroyFramebuffer: M } = WT(i), [F, N] = o, [L, re, ne] = u, we = t.gl.bindFramebuffer(36160, S.handle);
  let Se = null, Ee;
  if (d instanceof Bn)
    Se = d, a = Number.isFinite(a) ? a : Se.width, w = Number.isFinite(w) ? w : Se.height, Se.bind(0), Ee = Se.target;
  else
    throw new Error("invalid destination");
  switch (Ee) {
    case 3553:
    case 34067:
      t.gl.copyTexSubImage2D(Ee, s, L, re, F, N, a, w);
      break;
    case 35866:
    case 32879:
      t.gl.copyTexSubImage3D(Ee, s, L, re, ne, F, N, a, w);
      break;
  }
  Se && Se.unbind(), t.gl.bindFramebuffer(36160, we), M && S.destroy();
}
function WT(t) {
  if (t instanceof qs) {
    const { width: e, height: i, id: s } = t;
    return { framebuffer: t.device.createFramebuffer({
      id: `framebuffer-for-${s}`,
      width: e,
      height: i,
      colorAttachments: [t]
    }), destroyFramebuffer: !0 };
  }
  return { framebuffer: t, destroyFramebuffer: !1 };
}
class ak extends ay {
  device;
  commandBuffer;
  constructor(e, i) {
    super(e, i), this.device = e, this.commandBuffer = new ik(e);
  }
  destroy() {
  }
  finish() {
    this.commandBuffer.submitCommands();
  }
  // beginRenderPass(GPURenderPassDescriptor descriptor): GPURenderPassEncoder;
  // beginComputePass(optional GPUComputePassDescriptor descriptor = {}): GPUComputePassEncoder;
  // finish(options?: {id?: string}): GPUCommandBuffer;
  copyBufferToBuffer(e) {
    this.commandBuffer.commands.push({ name: "copy-buffer-to-buffer", options: e });
  }
  copyBufferToTexture(e) {
    this.commandBuffer.commands.push({ name: "copy-buffer-to-texture", options: e });
  }
  copyTextureToBuffer(e) {
    this.commandBuffer.commands.push({ name: "copy-texture-to-buffer", options: e });
  }
  copyTextureToTexture(e) {
    this.commandBuffer.commands.push({ name: "copy-texture-to-texture", options: e });
  }
  pushDebugGroup(e) {
  }
  popDebugGroup() {
  }
  insertDebugMarker(e) {
  }
  resolveQuerySet(e, i, s) {
  }
}
class Fy extends cy {
  get [Symbol.toStringTag]() {
    return "VertexArray";
  }
  device;
  handle;
  /** Attribute 0 buffer constant */
  buffer = null;
  bufferValue = null;
  /** * Attribute 0 can not be disable on most desktop OpenGL based browsers */
  static isConstantAttributeZeroSupported(e) {
    return gC() === "Chrome";
  }
  // Create a VertexArray
  constructor(e, i) {
    super(e, i), this.device = e, this.handle = this.device.gl.createVertexArray();
  }
  destroy() {
    super.destroy(), this.buffer && this.buffer?.destroy(), this.handle && (this.device.gl.deleteVertexArray(this.handle), this.handle = void 0);
  }
  /**
  // Set (bind/unbind) an elements buffer, for indexed rendering.
  // Must be a Buffer bound to GL.ELEMENT_ARRAY_BUFFER or null. Constants not supported
   *
   * @param elementBuffer
   */
  setIndexBuffer(e) {
    const i = e;
    if (i && i.glTarget !== 34963)
      throw new Error("Use .setBuffer()");
    this.device.gl.bindVertexArray(this.handle), this.device.gl.bindBuffer(34963, i ? i.handle : null), this.indexBuffer = i, this.device.gl.bindVertexArray(null);
  }
  /** Set a location in vertex attributes array to a buffer, enables the location, sets divisor */
  setBuffer(e, i) {
    const s = i;
    if (s.glTarget === 34963)
      throw new Error("Use .setIndexBuffer()");
    const { size: o, type: u, stride: d, offset: a, normalized: w, integer: S, divisor: M } = this._getAccessor(e);
    this.device.gl.bindVertexArray(this.handle), this.device.gl.bindBuffer(34962, s.handle), S ? this.device.gl.vertexAttribIPointer(e, o, u, d, a) : this.device.gl.vertexAttribPointer(e, o, u, w, d, a), this.device.gl.bindBuffer(34962, null), this.device.gl.enableVertexAttribArray(e), this.device.gl.vertexAttribDivisor(e, M || 0), this.attributes[e] = s, this.device.gl.bindVertexArray(null);
  }
  /** Set a location in vertex attributes array to a constant value, disables the location */
  setConstantWebGL(e, i) {
    this._enable(e, !1), this.attributes[e] = i;
  }
  bindBeforeRender() {
    this.device.gl.bindVertexArray(this.handle), this._applyConstantAttributes();
  }
  unbindAfterRender() {
    this.device.gl.bindVertexArray(null);
  }
  // Internal methods
  /**
   * Constant attributes need to be reset before every draw call
   * Any attribute that is disabled in the current vertex array object
   * is read from the context's global constant value for that attribute location.
   * @note Constant attributes are only supported in WebGL, not in WebGPU
   */
  _applyConstantAttributes() {
    for (let e = 0; e < this.maxVertexAttributes; ++e) {
      const i = this.attributes[e];
      ArrayBuffer.isView(i) && this.device.setConstantAttributeWebGL(e, i);
    }
  }
  /**
   * Set a location in vertex attributes array to a buffer, enables the location, sets divisor
   * @note requires vertex array to be bound
   */
  // protected _setAttributeLayout(location: number): void {
  //   const {size, type, stride, offset, normalized, integer, divisor} = this._getAccessor(location);
  //   // WebGL2 supports *integer* data formats, i.e. GPU will see integer values
  //   if (integer) {
  //     this.device.gl.vertexAttribIPointer(location, size, type, stride, offset);
  //   } else {
  //     // Attaches ARRAY_BUFFER with specified buffer format to location
  //     this.device.gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
  //   }
  //   this.device.gl.vertexAttribDivisor(location, divisor || 0);
  // }
  /** Get an accessor from the  */
  _getAccessor(e) {
    const i = this.attributeInfos[e];
    if (!i)
      throw new Error(`Unknown attribute location ${e}`);
    const s = UT(i.bufferDataType);
    return {
      size: i.bufferComponents,
      type: s,
      stride: i.byteStride,
      offset: i.byteOffset,
      normalized: i.normalized,
      // it is the shader attribute declaration, not the vertex memory format,
      // that determines if the data in the buffer will be treated as integers.
      //
      // Also note that WebGL supports assigning non-normalized integer data to floating point attributes,
      // but as far as we can tell, WebGPU does not.
      integer: i.integer,
      divisor: i.stepMode === "instance" ? 1 : 0
    };
  }
  /**
   * Enabling an attribute location makes it reference the currently bound buffer
   * Disabling an attribute location makes it reference the global constant value
   * TODO - handle single values for size 1 attributes?
   * TODO - convert classic arrays based on known type?
   */
  _enable(e, i = !0) {
    const o = Fy.isConstantAttributeZeroSupported(this.device) || e !== 0;
    (i || o) && (e = Number(e), this.device.gl.bindVertexArray(this.handle), i ? this.device.gl.enableVertexAttribArray(e) : this.device.gl.disableVertexAttribArray(e), this.device.gl.bindVertexArray(null));
  }
  /**
   * Provide a means to create a buffer that is equivalent to a constant.
   * NOTE: Desktop OpenGL cannot disable attribute 0.
   * https://stackoverflow.com/questions/20305231/webgl-warning-attribute-0-is-disabled-
   * this-has-significant-performance-penalty
   */
  getConstantBuffer(e, i) {
    const s = lk(i), o = s.byteLength * e, u = s.length * e;
    if (this.buffer && o !== this.buffer.byteLength)
      throw new Error(`Buffer size is immutable, byte length ${o} !== ${this.buffer.byteLength}.`);
    let d = !this.buffer;
    if (this.buffer = this.buffer || this.device.createBuffer({ byteLength: o }), d = d || !ck(s, this.bufferValue), d) {
      const a = AR(i.constructor, u);
      ER({ target: a, source: s, start: 0, count: u }), this.buffer.write(a), this.bufferValue = i;
    }
    return this.buffer;
  }
}
function lk(t) {
  return Array.isArray(t) ? new Float32Array(t) : t;
}
function ck(t, e) {
  if (!t || !e || t.length !== e.length || t.constructor !== e.constructor)
    return !1;
  for (let i = 0; i < t.length; ++i)
    if (t[i] !== e[i])
      return !1;
  return !0;
}
class hk extends hy {
  device;
  gl;
  handle;
  /**
   * NOTE: The Model already has this information while drawing, but
   * TransformFeedback currently needs it internally, to look up
   * varying information outside of a draw() call.
   */
  layout;
  buffers = {};
  unusedBuffers = {};
  /**
   * Allows us to avoid a Chrome bug where a buffer that is already bound to a
   * different target cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.
   * This a major workaround, see: https://github.com/KhronosGroup/WebGL/issues/2346
   */
  bindOnUse = !0;
  _bound = !1;
  constructor(e, i) {
    super(e, i), this.device = e, this.gl = e.gl, this.handle = this.props.handle || this.gl.createTransformFeedback(), this.layout = this.props.layout, i.buffers && this.setBuffers(i.buffers), Object.seal(this);
  }
  destroy() {
    this.gl.deleteTransformFeedback(this.handle), super.destroy();
  }
  begin(e = "point-list") {
    this.gl.bindTransformFeedback(36386, this.handle), this.bindOnUse && this._bindBuffers(), this.gl.beginTransformFeedback(ek(e));
  }
  end() {
    this.gl.endTransformFeedback(), this.bindOnUse && this._unbindBuffers(), this.gl.bindTransformFeedback(36386, null);
  }
  // SUBCLASS
  setBuffers(e) {
    this.buffers = {}, this.unusedBuffers = {}, this.bind(() => {
      for (const i in e)
        this.setBuffer(i, e[i]);
    });
  }
  setBuffer(e, i) {
    const s = this._getVaryingIndex(e), { buffer: o, byteLength: u, byteOffset: d } = this._getBufferRange(i);
    if (s < 0) {
      this.unusedBuffers[e] = o, Je.warn(`${this.id} unusedBuffers varying buffer ${e}`)();
      return;
    }
    this.buffers[s] = { buffer: o, byteLength: u, byteOffset: d }, this.bindOnUse || this._bindBuffer(s, o, d, u);
  }
  getBuffer(e) {
    if (gx(e))
      return this.buffers[e] || null;
    const i = this._getVaryingIndex(e);
    return i >= 0 ? this.buffers[i] : null;
  }
  bind(e = this.handle) {
    if (typeof e != "function")
      return this.gl.bindTransformFeedback(36386, e), this;
    let i;
    return this._bound ? i = e() : (this.gl.bindTransformFeedback(36386, this.handle), this._bound = !0, i = e(), this._bound = !1, this.gl.bindTransformFeedback(36386, null)), i;
  }
  unbind() {
    this.bind(null);
  }
  // PRIVATE METHODS
  /** Extract offsets for bindBufferRange */
  _getBufferRange(e) {
    if (e instanceof Aa)
      return { buffer: e, byteOffset: 0, byteLength: e.byteLength };
    const { buffer: i, byteOffset: s = 0, byteLength: o = e.buffer.byteLength } = e;
    return { buffer: i, byteOffset: s, byteLength: o };
  }
  _getVaryingIndex(e) {
    if (gx(e))
      return Number(e);
    for (const i of this.layout.varyings)
      if (e === i.name)
        return i.location;
    return -1;
  }
  /**
   * Need to avoid chrome bug where buffer that is already bound to a different target
   * cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.
   */
  _bindBuffers() {
    for (const e in this.buffers) {
      const { buffer: i, byteLength: s, byteOffset: o } = this._getBufferRange(this.buffers[e]);
      this._bindBuffer(Number(e), i, o, s);
    }
  }
  _unbindBuffers() {
    for (const e in this.buffers)
      this.gl.bindBufferBase(35982, Number(e), null);
  }
  _bindBuffer(e, i, s = 0, o) {
    const u = i && i.handle;
    !u || o === void 0 ? this.gl.bindBufferBase(35982, e, u) : this.gl.bindBufferRange(35982, e, u, s, o);
  }
}
function gx(t) {
  return typeof t == "number" ? Number.isInteger(t) : /^\d+$/.test(t);
}
class uk extends uy {
  device;
  handle;
  target = null;
  _queryPending = !1;
  _pollingPromise = null;
  get [Symbol.toStringTag]() {
    return "Query";
  }
  // Create a query class
  constructor(e, i) {
    if (super(e, i), this.device = e, i.count > 1)
      throw new Error("WebGL QuerySet can only have one value");
    this.handle = this.device.gl.createQuery(), Object.seal(this);
  }
  destroy() {
    this.device.gl.deleteQuery(this.handle);
  }
  // FOR RENDER PASS AND COMMAND ENCODER
  /**
   * Shortcut for timer query (dependent on extension in both WebGL1 and 2)
   * Measures GPU time delta between this call and a matching `end` call in the
   * GPU instruction stream.
   */
  beginTimestampQuery() {
    return this._begin(35007);
  }
  endTimestampQuery() {
    this._end();
  }
  // Shortcut for occlusion queries
  beginOcclusionQuery(e) {
    return this._begin(e?.conservative ? 36202 : 35887);
  }
  endOcclusionQuery() {
    this._end();
  }
  // Shortcut for transformFeedbackQuery
  beginTransformFeedbackQuery() {
    return this._begin(35976);
  }
  endTransformFeedbackQuery() {
    this._end();
  }
  async resolveQuery() {
    return [await this.pollQuery()];
  }
  // PRIVATE METHODS
  /**
   * Due to OpenGL API limitations, after calling `begin()` on one Query
   * instance, `end()` must be called on that same instance before
   * calling `begin()` on another query. While there can be multiple
   * outstanding queries representing disjoint `begin()`/`end()` intervals.
   * It is not possible to interleave or overlap `begin` and `end` calls.
   */
  _begin(e) {
    this._queryPending || (this.target = e, this.device.gl.beginQuery(this.target, this.handle));
  }
  // ends the current query
  _end() {
    this._queryPending || this.target && (this.device.gl.endQuery(this.target), this.target = null, this._queryPending = !0);
  }
  // Returns true if the query result is available
  isResultAvailable() {
    if (!this._queryPending)
      return !1;
    const e = this.device.gl.getQueryParameter(this.handle, 34919);
    return e && (this._queryPending = !1), e;
  }
  // Timing query is disjoint, i.e. results are invalid
  isTimerDisjoint() {
    return this.device.gl.getParameter(36795);
  }
  // Returns query result.
  getResult() {
    return this.device.gl.getQueryParameter(this.handle, 34918);
  }
  // Returns the query result, converted to milliseconds to match JavaScript conventions.
  getTimerMilliseconds() {
    return this.getResult() / 1e6;
  }
  // Polls the query
  pollQuery(e = Number.POSITIVE_INFINITY) {
    if (this._pollingPromise)
      return this._pollingPromise;
    let i = 0;
    return this._pollingPromise = new Promise((s, o) => {
      const u = () => {
        this.isResultAvailable() ? (s(this.getResult()), this._pollingPromise = null) : i++ > e ? (o("Timed out"), this._pollingPromise = null) : requestAnimationFrame(u);
      };
      requestAnimationFrame(u);
    }), this._pollingPromise;
  }
}
function XT(t) {
  switch (t) {
    case 6406:
    case 33326:
    case 6403:
      return 1;
    case 33328:
    case 33319:
      return 2;
    case 6407:
    case 34837:
      return 3;
    case 6408:
    case 34836:
      return 4;
    // TODO: Add support for additional WebGL2 formats
    default:
      return si(!1), 0;
  }
}
function dk(t) {
  switch (t) {
    case 5121:
      return 1;
    case 33635:
    case 32819:
    case 32820:
      return 2;
    case 5126:
      return 4;
    // TODO: Add support for additional WebGL2 types
    default:
      return si(!1), 0;
  }
}
function fk(t, e) {
  const {
    sourceX: i = 0,
    sourceY: s = 0,
    sourceFormat: o = 6408,
    sourceAttachment: u = 36064
    // TODO - support gl.readBuffer
  } = e || {};
  let {
    target: d = null,
    // following parameters are auto deduced if not provided
    sourceWidth: a,
    sourceHeight: w,
    sourceType: S
  } = e || {};
  const { framebuffer: M, deleteFramebuffer: F } = qT(t);
  si(M);
  const { gl: N, handle: L } = M;
  a = a || M.width, w = w || M.height;
  const re = u - 36064;
  S = S || M.colorAttachments[re]?.texture?.type || 5121, d = gk(d, S, o, a, w), S = S || LF(d);
  const ne = N.bindFramebuffer(36160, L);
  return N.readPixels(i, s, a, w, o, S, d), N.bindFramebuffer(36160, ne || null), F && M.destroy(), d;
}
function pk(t, e) {
  const { target: i, sourceX: s = 0, sourceY: o = 0, sourceFormat: u = 6408, targetByteOffset: d = 0 } = e || {};
  let { sourceWidth: a, sourceHeight: w, sourceType: S } = e || {};
  const { framebuffer: M, deleteFramebuffer: F } = qT(t);
  si(M), a = a || M.width, w = w || M.height;
  const N = M;
  S = S || 5121;
  let L = i;
  if (!L) {
    const ne = XT(u), we = dk(S), Se = d + a * w * ne * we;
    L = N.device.createBuffer({ byteLength: Se });
  }
  const re = t.device.createCommandEncoder();
  return re.copyTextureToBuffer({
    source: t,
    width: a,
    height: w,
    origin: [s, o],
    destination: L,
    byteOffset: d
  }), re.destroy(), F && M.destroy(), L;
}
function qT(t) {
  return t instanceof Pp ? { framebuffer: t, deleteFramebuffer: !1 } : { framebuffer: _k(t), deleteFramebuffer: !0 };
}
function _k(t, e) {
  const { device: i, width: s, height: o, id: u } = t;
  return i.createFramebuffer({
    ...e,
    id: `framebuffer-for-${u}`,
    width: s,
    height: o,
    colorAttachments: [t]
  });
}
function gk(t, e, i, s, o) {
  if (t)
    return t;
  e = e || 5121;
  const u = Im(e, { clamped: !1 }), d = XT(i);
  return new u(s * o * d);
}
const mk = 256, yk = 1024, bk = 16384, vk = "clear: bad arguments";
function xk(t, e) {
  const { framebuffer: i = null, color: s = null, depth: o = null, stencil: u = null } = e || {}, d = {};
  i && (d.framebuffer = i);
  let a = 0;
  s && (a |= bk, s !== !0 && (d.clearColor = s)), o && (a |= mk, o !== !0 && (d.clearDepth = o)), u && (a |= yk, o !== !0 && (d.clearStencil = o)), si(a !== 0, vk);
  const w = t.gl;
  xa(w, d, () => {
    w.clear(a);
  });
}
const Cu = 1;
class wa extends sh {
  //
  // Public `Device` API
  //
  /** type of this device */
  static type = "webgl";
  /** type of this device */
  type = "webgl";
  /** The underlying WebGL context */
  handle;
  features;
  limits;
  info;
  canvasContext;
  lost;
  _resolveContextLost;
  //
  // Static methods, expected to be present by `luma.createDevice()`
  //
  /** Check if WebGL 2 is available */
  static isSupported() {
    return typeof WebGL2RenderingContext < "u";
  }
  /**
   * Get a device instance from a GL context
   * Creates and instruments the device if not already created
   * @param gl
   * @returns
   */
  static attach(e) {
    if (e instanceof wa)
      return e;
    if (e?.device instanceof sh)
      return e.device;
    if (!wk(e))
      throw new Error("Invalid WebGL2RenderingContext");
    return new wa({ gl: e });
  }
  static async create(e = {}) {
    Je.groupCollapsed(Cu, "WebGLDevice created")();
    const i = [];
    e.debug && i.push(AF()), e.spector && i.push(xF()), typeof e.canvas == "string" && i.push(Ow.pageLoaded);
    const s = await Promise.allSettled(i);
    for (const d of s)
      d.status === "rejected" && Je.error(`Failed to initialize debug libraries ${d.reason}`)();
    if (Je.probe(Cu + 1, "DOM is loaded")(), e.gl?.device)
      return Je.warn("reattaching existing device")(), wa.attach(e.gl);
    const o = new wa(e), u = `Created ${o.type}${o.debug ? " debug" : ""} context: ${o.info.vendor}, ${o.info.renderer} for canvas: ${o.canvasContext.id}`;
    return Je.probe(Cu, u)(), Je.table(Cu, o.info)(), Je.groupEnd(Cu)(), o;
  }
  //
  // Public API
  //
  constructor(e) {
    super({ ...e, id: e.id || Pa("webgl-device") });
    const i = e.gl?.device;
    if (i)
      throw new Error(`WebGL context already attached to device ${i.id}`);
    const s = e.gl?.canvas || e.canvas;
    this.canvasContext = new mF(this, { ...e, canvas: s }), this.lost = new Promise((a) => {
      this._resolveContextLost = a;
    });
    let o = e.gl || null;
    if (o ||= kO(this.canvasContext.canvas, {
      ...e,
      onContextLost: (a) => this._resolveContextLost?.({
        reason: "destroyed",
        message: "Entered sleep mode, or too many apps or browser tabs are using the GPU."
      })
    }), !o)
      throw new Error("WebGL context creation failed");
    this.handle = o, this.gl = o, this.gl.device = this, this.gl._version = 2, e.spector && (this.spectorJS = wF({ ...this.props, canvas: this.handle.canvas })), this.info = NO(this.gl, this._extensions), this.limits = new rF(this.gl), this.features = new iF(this.gl, this._extensions, this.props.disabledFeatures), this.props.initalizeFeatures && this.features.initializeFeatures(), this.canvasContext.resize();
    const { enable: u = !0, copyState: d = !1 } = e;
    NT(this.gl, {
      enable: u,
      copyState: d
    }), e.debug && (this.gl = EF(this.gl, { ...e, throwOnError: !0 }), this.debug = !0, Je.level = Math.max(Je.level, 1), Je.warn("WebGL debug mode activated. Performance reduced.")());
  }
  /**
   * Destroys the context
   * @note Has no effect for WebGL browser contexts, there is no browser API for destroying contexts
   */
  destroy() {
  }
  get isLost() {
    return this.gl.isContextLost();
  }
  getSize() {
    return [this.gl.drawingBufferWidth, this.gl.drawingBufferHeight];
  }
  isTextureFormatSupported(e) {
    return Oy(this.gl, e, this._extensions);
  }
  isTextureFormatFilterable(e) {
    return JO(this.gl, e, this._extensions);
  }
  isTextureFormatRenderable(e) {
    return QO(this.gl, e, this._extensions);
  }
  // IMPLEMENTATION OF ABSTRACT DEVICE
  createCanvasContext(e) {
    throw new Error("WebGL only supports a single canvas");
  }
  createBuffer(e) {
    const i = this._getBufferProps(e);
    return new Aa(this, i);
  }
  _createTexture(e) {
    return new Bn(this, e);
  }
  createExternalTexture(e) {
    throw new Error("createExternalTexture() not implemented");
  }
  createSampler(e) {
    return new Cm(this, e);
  }
  createShader(e) {
    return new PF(this, e);
  }
  createFramebuffer(e) {
    return new Hu(this, e);
  }
  createVertexArray(e) {
    return new Fy(this, e);
  }
  createTransformFeedback(e) {
    return new hk(this, e);
  }
  createQuerySet(e) {
    return new uk(this, e);
  }
  createRenderPipeline(e) {
    return new tk(this, e);
  }
  beginRenderPass(e) {
    return new kF(this, e);
  }
  createComputePipeline(e) {
    throw new Error("ComputePipeline not supported in WebGL");
  }
  beginComputePass(e) {
    throw new Error("ComputePass not supported in WebGL");
  }
  renderPass = null;
  createCommandEncoder(e) {
    return new ak(this, e);
  }
  /**
   * Offscreen Canvas Support: Commit the frame
   * https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/commit
   * Chrome's offscreen canvas does not require gl.commit
   */
  submit() {
    this.renderPass?.end(), this.renderPass = null;
  }
  //
  // TEMPORARY HACKS - will be removed in v9.1
  //
  /** @deprecated - should use command encoder */
  readPixelsToArrayWebGL(e, i) {
    return fk(e, i);
  }
  /** @deprecated - should use command encoder */
  readPixelsToBufferWebGL(e, i) {
    return pk(e, i);
  }
  setParametersWebGL(e) {
    gh(this.gl, e);
  }
  getParametersWebGL(e) {
    return kT(this.gl, e);
  }
  withParametersWebGL(e, i) {
    return xa(this.gl, e, i);
  }
  clearWebGL(e) {
    xk(this, e);
  }
  resetWebGL() {
    Je.warn("WebGLDevice.resetWebGL is deprecated, use only for debugging")(), MO(this.gl);
  }
  //
  // WebGL-only API (not part of `Device` API)
  //
  /** WebGL2 context. */
  gl;
  debug = !1;
  /** State used by luma.gl classes: TODO - move to canvasContext*/
  _canvasSizeInfo = { clientWidth: 0, clientHeight: 0, devicePixelRatio: 1 };
  /** State used by luma.gl classes - TODO - not used? */
  _extensions = {};
  _polyfilled = !1;
  /** Instance of Spector.js (if initialized) */
  spectorJS;
  /**
   * Triggers device (or WebGL context) loss.
   * @note primarily intended for testing how application reacts to device loss
   */
  loseDevice() {
    let e = !1;
    const s = this.getExtension("WEBGL_lose_context").WEBGL_lose_context;
    return s && (e = !0, s.loseContext()), this._resolveContextLost?.({
      reason: "destroyed",
      message: "Application triggered context loss"
    }), e;
  }
  /** Save current WebGL context state onto an internal stack */
  pushState() {
    Dp(this.gl);
  }
  /** Restores previously saved context state */
  popState() {
    Ju(this.gl);
  }
  /**
   * Storing data on a special field on WebGLObjects makes that data visible in SPECTOR chrome debug extension
   * luma.gl ids and props can be inspected
   */
  setSpectorMetadata(e, i) {
    e.__SPECTOR_Metadata = i;
  }
  /**
   * Returns the GL.<KEY> constant that corresponds to a numeric value of a GL constant
   * Be aware that there are some duplicates especially for constants that are 0,
   * so this isn't guaranteed to return the right key in all cases.
   */
  getGLKey(e, i) {
    i = i || this.gl2 || this.gl;
    const s = Number(e);
    for (const o in i)
      if (i[o] === s)
        return `GL.${o}`;
    return String(e);
  }
  /** Store constants */
  _constants;
  /**
   * Set a constant value for a location. Disabled attributes at that location will read from this value
   * @note WebGL constants are stored globally on the WebGL context, not the VertexArray
   * so they need to be updated before every render
   * @todo - remember/cache values to avoid setting them unnecessarily?
   */
  setConstantAttributeWebGL(e, i) {
    const s = this.limits.maxVertexAttributes;
    this._constants = this._constants || new Array(s).fill(null);
    const o = this._constants[e];
    switch (o && Sk(o, i) && Je.info(1, `setConstantAttributeWebGL(${e}) could have been skipped, value unchanged`)(), this._constants[e] = i, i.constructor) {
      case Float32Array:
        Tk(this, e, i);
        break;
      case Int32Array:
        Ak(this, e, i);
        break;
      case Uint32Array:
        Ek(this, e, i);
        break;
      default:
        si(!1);
    }
  }
  /** Ensure extensions are only requested once */
  getExtension(e) {
    return Ia(this.gl, e, this._extensions), this._extensions;
  }
}
function wk(t) {
  return typeof WebGL2RenderingContext < "u" && t instanceof WebGL2RenderingContext ? !0 : !!(t && Number.isFinite(t._version));
}
function Tk(t, e, i) {
  switch (i.length) {
    case 1:
      t.gl.vertexAttrib1fv(e, i);
      break;
    case 2:
      t.gl.vertexAttrib2fv(e, i);
      break;
    case 3:
      t.gl.vertexAttrib3fv(e, i);
      break;
    case 4:
      t.gl.vertexAttrib4fv(e, i);
      break;
    default:
      si(!1);
  }
}
function Ak(t, e, i) {
  t.gl.vertexAttribI4iv(e, i);
}
function Ek(t, e, i) {
  t.gl.vertexAttribI4uiv(e, i);
}
function Sk(t, e) {
  if (!t || !e || t.length !== e.length || t.constructor !== e.constructor)
    return !1;
  for (let i = 0; i < t.length; ++i)
    if (t[i] !== e[i])
      return !1;
  return !0;
}
var Mg = { exports: {} };
/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
var mx;
function Ck() {
  return mx || (mx = 1, (function(t) {
    (function(e, i, s, o) {
      var u = ["", "webkit", "Moz", "MS", "ms", "o"], d = i.createElement("div"), a = "function", w = Math.round, S = Math.abs, M = Date.now;
      function F(X, Q, ue) {
        return setTimeout(Ce(X, ue), Q);
      }
      function N(X, Q, ue) {
        return Array.isArray(X) ? (L(X, ue[Q], ue), !0) : !1;
      }
      function L(X, Q, ue) {
        var xe;
        if (X)
          if (X.forEach)
            X.forEach(Q, ue);
          else if (X.length !== o)
            for (xe = 0; xe < X.length; )
              Q.call(ue, X[xe], xe, X), xe++;
          else
            for (xe in X)
              X.hasOwnProperty(xe) && Q.call(ue, X[xe], xe, X);
      }
      function re(X, Q, ue) {
        var xe = "DEPRECATED METHOD: " + Q + `
` + ue + ` AT 
`;
        return function() {
          var $e = new Error("get-stack-trace"), at = $e && $e.stack ? $e.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace", It = e.console && (e.console.warn || e.console.log);
          return It && It.call(e.console, xe, at), X.apply(this, arguments);
        };
      }
      var ne;
      typeof Object.assign != "function" ? ne = function(Q) {
        if (Q === o || Q === null)
          throw new TypeError("Cannot convert undefined or null to object");
        for (var ue = Object(Q), xe = 1; xe < arguments.length; xe++) {
          var $e = arguments[xe];
          if ($e !== o && $e !== null)
            for (var at in $e)
              $e.hasOwnProperty(at) && (ue[at] = $e[at]);
        }
        return ue;
      } : ne = Object.assign;
      var we = re(function(Q, ue, xe) {
        for (var $e = Object.keys(ue), at = 0; at < $e.length; )
          (!xe || xe && Q[$e[at]] === o) && (Q[$e[at]] = ue[$e[at]]), at++;
        return Q;
      }, "extend", "Use `assign`."), Se = re(function(Q, ue) {
        return we(Q, ue, !0);
      }, "merge", "Use `assign`.");
      function Ee(X, Q, ue) {
        var xe = Q.prototype, $e;
        $e = X.prototype = Object.create(xe), $e.constructor = X, $e._super = xe, ue && ne($e, ue);
      }
      function Ce(X, Q) {
        return function() {
          return X.apply(Q, arguments);
        };
      }
      function Le(X, Q) {
        return typeof X == a ? X.apply(Q && Q[0] || o, Q) : X;
      }
      function Ze(X, Q) {
        return X === o ? Q : X;
      }
      function Ke(X, Q, ue) {
        L(ot(Q), function(xe) {
          X.addEventListener(xe, ue, !1);
        });
      }
      function ct(X, Q, ue) {
        L(ot(Q), function(xe) {
          X.removeEventListener(xe, ue, !1);
        });
      }
      function _t(X, Q) {
        for (; X; ) {
          if (X == Q)
            return !0;
          X = X.parentNode;
        }
        return !1;
      }
      function st(X, Q) {
        return X.indexOf(Q) > -1;
      }
      function ot(X) {
        return X.trim().split(/\s+/g);
      }
      function bt(X, Q, ue) {
        if (X.indexOf && !ue)
          return X.indexOf(Q);
        for (var xe = 0; xe < X.length; ) {
          if (ue && X[xe][ue] == Q || !ue && X[xe] === Q)
            return xe;
          xe++;
        }
        return -1;
      }
      function Ft(X) {
        return Array.prototype.slice.call(X, 0);
      }
      function jt(X, Q, ue) {
        for (var xe = [], $e = [], at = 0; at < X.length; ) {
          var It = X[at][Q];
          bt($e, It) < 0 && xe.push(X[at]), $e[at] = It, at++;
        }
        return xe = xe.sort(function(mt, Ai) {
          return mt[Q] > Ai[Q];
        }), xe;
      }
      function Et(X, Q) {
        for (var ue, xe, $e = Q[0].toUpperCase() + Q.slice(1), at = 0; at < u.length; ) {
          if (ue = u[at], xe = ue ? ue + $e : Q, xe in X)
            return xe;
          at++;
        }
        return o;
      }
      var bi = 1;
      function Dr() {
        return bi++;
      }
      function gr(X) {
        var Q = X.ownerDocument || X;
        return Q.defaultView || Q.parentWindow || e;
      }
      var Ln = /mobile|tablet|ip(ad|hone|od)|android/i, Ht = "ontouchstart" in e, rr = Et(e, "PointerEvent") !== o, wi = Ht && Ln.test(navigator.userAgent), sr = "touch", cs = "pen", hs = "mouse", pn = "kinect", Er = 25, Ri = 1, ji = 2, qt = 4, Fi = 8, ws = 1, Ji = 2, ni = 4, ai = 8, mr = 16, ki = Ji | ni, Or = ai | mr, es = ki | Or, ts = ["x", "y"], Ts = ["clientX", "clientY"];
      function Ni(X, Q) {
        var ue = this;
        this.manager = X, this.callback = Q, this.element = X.element, this.target = X.options.inputTarget, this.domHandler = function(xe) {
          Le(X.options.enable, [X]) && ue.handler(xe);
        }, this.init();
      }
      Ni.prototype = {
        /**
         * should handle the inputEvent data and trigger the callback
         * @virtual
         */
        handler: function() {
        },
        /**
         * bind the events
         */
        init: function() {
          this.evEl && Ke(this.element, this.evEl, this.domHandler), this.evTarget && Ke(this.target, this.evTarget, this.domHandler), this.evWin && Ke(gr(this.element), this.evWin, this.domHandler);
        },
        /**
         * unbind the events
         */
        destroy: function() {
          this.evEl && ct(this.element, this.evEl, this.domHandler), this.evTarget && ct(this.target, this.evTarget, this.domHandler), this.evWin && ct(gr(this.element), this.evWin, this.domHandler);
        }
      };
      function Ks(X) {
        var Q, ue = X.options.inputClass;
        return ue ? Q = ue : rr ? Q = wt : wi ? Q = Pt : Ht ? Q = Hi : Q = Ne, new Q(X, Ys);
      }
      function Ys(X, Q, ue) {
        var xe = ue.pointers.length, $e = ue.changedPointers.length, at = Q & Ri && xe - $e === 0, It = Q & (qt | Fi) && xe - $e === 0;
        ue.isFirst = !!at, ue.isFinal = !!It, at && (X.session = {}), ue.eventType = Q, _n(X, ue), X.emit("hammer.input", ue), X.recognize(ue), X.session.prevInput = ue;
      }
      function _n(X, Q) {
        var ue = X.session, xe = Q.pointers, $e = xe.length;
        ue.firstInput || (ue.firstInput = As(Q)), $e > 1 && !ue.firstMultiple ? ue.firstMultiple = As(Q) : $e === 1 && (ue.firstMultiple = !1);
        var at = ue.firstInput, It = ue.firstMultiple, hi = It ? It.center : at.center, mt = Q.center = gn(xe);
        Q.timeStamp = M(), Q.deltaTime = Q.timeStamp - at.timeStamp, Q.angle = q(hi, mt), Q.distance = W(hi, mt), Js(ue, Q), Q.offsetDirection = $(Q.deltaX, Q.deltaY);
        var Ai = _e(Q.deltaTime, Q.deltaX, Q.deltaY);
        Q.overallVelocityX = Ai.x, Q.overallVelocityY = Ai.y, Q.overallVelocity = S(Ai.x) > S(Ai.y) ? Ai.x : Ai.y, Q.scale = It ? pe(It.pointers, xe) : 1, Q.rotation = It ? ae(It.pointers, xe) : 0, Q.maxPointers = ue.prevInput ? Q.pointers.length > ue.prevInput.maxPointers ? Q.pointers.length : ue.prevInput.maxPointers : Q.pointers.length, Qs(ue, Q);
        var kr = X.element;
        _t(Q.srcEvent.target, kr) && (kr = Q.srcEvent.target), Q.target = kr;
      }
      function Js(X, Q) {
        var ue = Q.center, xe = X.offsetDelta || {}, $e = X.prevDelta || {}, at = X.prevInput || {};
        (Q.eventType === Ri || at.eventType === qt) && ($e = X.prevDelta = {
          x: at.deltaX || 0,
          y: at.deltaY || 0
        }, xe = X.offsetDelta = {
          x: ue.x,
          y: ue.y
        }), Q.deltaX = $e.x + (ue.x - xe.x), Q.deltaY = $e.y + (ue.y - xe.y);
      }
      function Qs(X, Q) {
        var ue = X.lastInterval || Q, xe = Q.timeStamp - ue.timeStamp, $e, at, It, hi;
        if (Q.eventType != Fi && (xe > Er || ue.velocity === o)) {
          var mt = Q.deltaX - ue.deltaX, Ai = Q.deltaY - ue.deltaY, kr = _e(xe, mt, Ai);
          at = kr.x, It = kr.y, $e = S(kr.x) > S(kr.y) ? kr.x : kr.y, hi = $(mt, Ai), X.lastInterval = Q;
        } else
          $e = ue.velocity, at = ue.velocityX, It = ue.velocityY, hi = ue.direction;
        Q.velocity = $e, Q.velocityX = at, Q.velocityY = It, Q.direction = hi;
      }
      function As(X) {
        for (var Q = [], ue = 0; ue < X.pointers.length; )
          Q[ue] = {
            clientX: w(X.pointers[ue].clientX),
            clientY: w(X.pointers[ue].clientY)
          }, ue++;
        return {
          timeStamp: M(),
          pointers: Q,
          center: gn(Q),
          deltaX: X.deltaX,
          deltaY: X.deltaY
        };
      }
      function gn(X) {
        var Q = X.length;
        if (Q === 1)
          return {
            x: w(X[0].clientX),
            y: w(X[0].clientY)
          };
        for (var ue = 0, xe = 0, $e = 0; $e < Q; )
          ue += X[$e].clientX, xe += X[$e].clientY, $e++;
        return {
          x: w(ue / Q),
          y: w(xe / Q)
        };
      }
      function _e(X, Q, ue) {
        return {
          x: Q / X || 0,
          y: ue / X || 0
        };
      }
      function $(X, Q) {
        return X === Q ? ws : S(X) >= S(Q) ? X < 0 ? Ji : ni : Q < 0 ? ai : mr;
      }
      function W(X, Q, ue) {
        ue || (ue = ts);
        var xe = Q[ue[0]] - X[ue[0]], $e = Q[ue[1]] - X[ue[1]];
        return Math.sqrt(xe * xe + $e * $e);
      }
      function q(X, Q, ue) {
        ue || (ue = ts);
        var xe = Q[ue[0]] - X[ue[0]], $e = Q[ue[1]] - X[ue[1]];
        return Math.atan2($e, xe) * 180 / Math.PI;
      }
      function ae(X, Q) {
        return q(Q[1], Q[0], Ts) + q(X[1], X[0], Ts);
      }
      function pe(X, Q) {
        return W(Q[0], Q[1], Ts) / W(X[0], X[1], Ts);
      }
      var ge = {
        mousedown: Ri,
        mousemove: ji,
        mouseup: qt
      }, Pe = "mousedown", ye = "mousemove mouseup";
      function Ne() {
        this.evEl = Pe, this.evWin = ye, this.pressed = !1, Ni.apply(this, arguments);
      }
      Ee(Ne, Ni, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function(Q) {
          var ue = ge[Q.type];
          ue & Ri && Q.button === 0 && (this.pressed = !0), ue & ji && Q.which !== 1 && (ue = qt), this.pressed && (ue & qt && (this.pressed = !1), this.callback(this.manager, ue, {
            pointers: [Q],
            changedPointers: [Q],
            pointerType: hs,
            srcEvent: Q
          }));
        }
      });
      var He = {
        pointerdown: Ri,
        pointermove: ji,
        pointerup: qt,
        pointercancel: Fi,
        pointerout: Fi
      }, ze = {
        2: sr,
        3: cs,
        4: hs,
        5: pn
        // see https://twitter.com/jacobrossi/status/480596438489890816
      }, lt = "pointerdown", ve = "pointermove pointerup pointercancel";
      e.MSPointerEvent && !e.PointerEvent && (lt = "MSPointerDown", ve = "MSPointerMove MSPointerUp MSPointerCancel");
      function wt() {
        this.evEl = lt, this.evWin = ve, Ni.apply(this, arguments), this.store = this.manager.session.pointerEvents = [];
      }
      Ee(wt, Ni, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function(Q) {
          var ue = this.store, xe = !1, $e = Q.type.toLowerCase().replace("ms", ""), at = He[$e], It = ze[Q.pointerType] || Q.pointerType, hi = It == sr, mt = bt(ue, Q.pointerId, "pointerId");
          at & Ri && (Q.button === 0 || hi) ? mt < 0 && (ue.push(Q), mt = ue.length - 1) : at & (qt | Fi) && (xe = !0), !(mt < 0) && (ue[mt] = Q, this.callback(this.manager, at, {
            pointers: ue,
            changedPointers: [Q],
            pointerType: It,
            srcEvent: Q
          }), xe && ue.splice(mt, 1));
        }
      });
      var Ot = {
        touchstart: Ri,
        touchmove: ji,
        touchend: qt,
        touchcancel: Fi
      }, ft = "touchstart", St = "touchstart touchmove touchend touchcancel";
      function Kt() {
        this.evTarget = ft, this.evWin = St, this.started = !1, Ni.apply(this, arguments);
      }
      Ee(Kt, Ni, {
        handler: function(Q) {
          var ue = Ot[Q.type];
          if (ue === Ri && (this.started = !0), !!this.started) {
            var xe = Li.call(this, Q, ue);
            ue & (qt | Fi) && xe[0].length - xe[1].length === 0 && (this.started = !1), this.callback(this.manager, ue, {
              pointers: xe[0],
              changedPointers: xe[1],
              pointerType: sr,
              srcEvent: Q
            });
          }
        }
      });
      function Li(X, Q) {
        var ue = Ft(X.touches), xe = Ft(X.changedTouches);
        return Q & (qt | Fi) && (ue = jt(ue.concat(xe), "identifier")), [ue, xe];
      }
      var Ui = {
        touchstart: Ri,
        touchmove: ji,
        touchend: qt,
        touchcancel: Fi
      }, Ti = "touchstart touchmove touchend touchcancel";
      function Pt() {
        this.evTarget = Ti, this.targetIds = {}, Ni.apply(this, arguments);
      }
      Ee(Pt, Ni, {
        handler: function(Q) {
          var ue = Ui[Q.type], xe = Nt.call(this, Q, ue);
          xe && this.callback(this.manager, ue, {
            pointers: xe[0],
            changedPointers: xe[1],
            pointerType: sr,
            srcEvent: Q
          });
        }
      });
      function Nt(X, Q) {
        var ue = Ft(X.touches), xe = this.targetIds;
        if (Q & (Ri | ji) && ue.length === 1)
          return xe[ue[0].identifier] = !0, [ue, ue];
        var $e, at, It = Ft(X.changedTouches), hi = [], mt = this.target;
        if (at = ue.filter(function(Ai) {
          return _t(Ai.target, mt);
        }), Q === Ri)
          for ($e = 0; $e < at.length; )
            xe[at[$e].identifier] = !0, $e++;
        for ($e = 0; $e < It.length; )
          xe[It[$e].identifier] && hi.push(It[$e]), Q & (qt | Fi) && delete xe[It[$e].identifier], $e++;
        if (hi.length)
          return [
            // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
            jt(at.concat(hi), "identifier"),
            hi
          ];
      }
      var Pi = 2500, Ge = 25;
      function Hi() {
        Ni.apply(this, arguments);
        var X = Ce(this.handler, this);
        this.touch = new Pt(this.manager, X), this.mouse = new Ne(this.manager, X), this.primaryTouch = null, this.lastTouches = [];
      }
      Ee(Hi, Ni, {
        /**
         * handle mouse and touch events
         * @param {Hammer} manager
         * @param {String} inputEvent
         * @param {Object} inputData
         */
        handler: function(Q, ue, xe) {
          var $e = xe.pointerType == sr, at = xe.pointerType == hs;
          if (!(at && xe.sourceCapabilities && xe.sourceCapabilities.firesTouchEvents)) {
            if ($e)
              _i.call(this, ue, xe);
            else if (at && Un.call(this, xe))
              return;
            this.callback(Q, ue, xe);
          }
        },
        /**
         * remove the event listeners
         */
        destroy: function() {
          this.touch.destroy(), this.mouse.destroy();
        }
      });
      function _i(X, Q) {
        X & Ri ? (this.primaryTouch = Q.changedPointers[0].identifier, Es.call(this, Q)) : X & (qt | Fi) && Es.call(this, Q);
      }
      function Es(X) {
        var Q = X.changedPointers[0];
        if (Q.identifier === this.primaryTouch) {
          var ue = { x: Q.clientX, y: Q.clientY };
          this.lastTouches.push(ue);
          var xe = this.lastTouches, $e = function() {
            var at = xe.indexOf(ue);
            at > -1 && xe.splice(at, 1);
          };
          setTimeout($e, Pi);
        }
      }
      function Un(X) {
        for (var Q = X.srcEvent.clientX, ue = X.srcEvent.clientY, xe = 0; xe < this.lastTouches.length; xe++) {
          var $e = this.lastTouches[xe], at = Math.abs(Q - $e.x), It = Math.abs(ue - $e.y);
          if (at <= Ge && It <= Ge)
            return !0;
        }
        return !1;
      }
      var tt = Et(d.style, "touchAction"), Dt = tt !== o, Ct = "compute", $i = "auto", Ss = "manipulation", Sr = "none", Tt = "pan-x", en = "pan-y", is = Vn();
      function zn(X, Q) {
        this.manager = X, this.set(Q);
      }
      zn.prototype = {
        /**
         * set the touchAction value on the element or enable the polyfill
         * @param {String} value
         */
        set: function(X) {
          X == Ct && (X = this.compute()), Dt && this.manager.element.style && is[X] && (this.manager.element.style[tt] = X), this.actions = X.toLowerCase().trim();
        },
        /**
         * just re-set the touchAction value
         */
        update: function() {
          this.set(this.manager.options.touchAction);
        },
        /**
         * compute the value for the touchAction property based on the recognizer's settings
         * @returns {String} value
         */
        compute: function() {
          var X = [];
          return L(this.manager.recognizers, function(Q) {
            Le(Q.options.enable, [Q]) && (X = X.concat(Q.getTouchAction()));
          }), us(X.join(" "));
        },
        /**
         * this method is called on each input cycle and provides the preventing of the browser behavior
         * @param {Object} input
         */
        preventDefaults: function(X) {
          var Q = X.srcEvent, ue = X.offsetDirection;
          if (this.manager.session.prevented) {
            Q.preventDefault();
            return;
          }
          var xe = this.actions, $e = st(xe, Sr) && !is[Sr], at = st(xe, en) && !is[en], It = st(xe, Tt) && !is[Tt];
          if ($e) {
            var hi = X.pointers.length === 1, mt = X.distance < 2, Ai = X.deltaTime < 250;
            if (hi && mt && Ai)
              return;
          }
          if (!(It && at) && ($e || at && ue & ki || It && ue & Or))
            return this.preventSrc(Q);
        },
        /**
         * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
         * @param {Object} srcEvent
         */
        preventSrc: function(X) {
          this.manager.session.prevented = !0, X.preventDefault();
        }
      };
      function us(X) {
        if (st(X, Sr))
          return Sr;
        var Q = st(X, Tt), ue = st(X, en);
        return Q && ue ? Sr : Q || ue ? Q ? Tt : en : st(X, Ss) ? Ss : $i;
      }
      function Vn() {
        if (!Dt)
          return !1;
        var X = {}, Q = e.CSS && e.CSS.supports;
        return ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(ue) {
          X[ue] = Q ? e.CSS.supports("touch-action", ue) : !0;
        }), X;
      }
      var li = 1, yr = 2, zi = 4, zt = 8, ds = zt, Cs = 16, $r = 32;
      function nr(X) {
        this.options = ne({}, this.defaults, X || {}), this.id = Dr(), this.manager = null, this.options.enable = Ze(this.options.enable, !0), this.state = li, this.simultaneous = {}, this.requireFail = [];
      }
      nr.prototype = {
        /**
         * @virtual
         * @type {Object}
         */
        defaults: {},
        /**
         * set options
         * @param {Object} options
         * @return {Recognizer}
         */
        set: function(X) {
          return ne(this.options, X), this.manager && this.manager.touchAction.update(), this;
        },
        /**
         * recognize simultaneous with an other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        recognizeWith: function(X) {
          if (N(X, "recognizeWith", this))
            return this;
          var Q = this.simultaneous;
          return X = ho(X, this), Q[X.id] || (Q[X.id] = X, X.recognizeWith(this)), this;
        },
        /**
         * drop the simultaneous link. it doesnt remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRecognizeWith: function(X) {
          return N(X, "dropRecognizeWith", this) ? this : (X = ho(X, this), delete this.simultaneous[X.id], this);
        },
        /**
         * recognizer can only run when an other is failing
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        requireFailure: function(X) {
          if (N(X, "requireFailure", this))
            return this;
          var Q = this.requireFail;
          return X = ho(X, this), bt(Q, X) === -1 && (Q.push(X), X.requireFailure(this)), this;
        },
        /**
         * drop the requireFailure link. it does not remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRequireFailure: function(X) {
          if (N(X, "dropRequireFailure", this))
            return this;
          X = ho(X, this);
          var Q = bt(this.requireFail, X);
          return Q > -1 && this.requireFail.splice(Q, 1), this;
        },
        /**
         * has require failures boolean
         * @returns {boolean}
         */
        hasRequireFailures: function() {
          return this.requireFail.length > 0;
        },
        /**
         * if the recognizer can recognize simultaneous with an other recognizer
         * @param {Recognizer} otherRecognizer
         * @returns {Boolean}
         */
        canRecognizeWith: function(X) {
          return !!this.simultaneous[X.id];
        },
        /**
         * You should use `tryEmit` instead of `emit` directly to check
         * that all the needed recognizers has failed before emitting.
         * @param {Object} input
         */
        emit: function(X) {
          var Q = this, ue = this.state;
          function xe($e) {
            Q.manager.emit($e, X);
          }
          ue < zt && xe(Q.options.event + Is(ue)), xe(Q.options.event), X.additionalEvent && xe(X.additionalEvent), ue >= zt && xe(Q.options.event + Is(ue));
        },
        /**
         * Check that all the require failure recognizers has failed,
         * if true, it emits a gesture event,
         * otherwise, setup the state to FAILED.
         * @param {Object} input
         */
        tryEmit: function(X) {
          if (this.canEmit())
            return this.emit(X);
          this.state = $r;
        },
        /**
         * can we emit?
         * @returns {boolean}
         */
        canEmit: function() {
          for (var X = 0; X < this.requireFail.length; ) {
            if (!(this.requireFail[X].state & ($r | li)))
              return !1;
            X++;
          }
          return !0;
        },
        /**
         * update the recognizer
         * @param {Object} inputData
         */
        recognize: function(X) {
          var Q = ne({}, X);
          if (!Le(this.options.enable, [this, Q])) {
            this.reset(), this.state = $r;
            return;
          }
          this.state & (ds | Cs | $r) && (this.state = li), this.state = this.process(Q), this.state & (yr | zi | zt | Cs) && this.tryEmit(Q);
        },
        /**
         * return the state of the recognizer
         * the actual recognizing happens in this method
         * @virtual
         * @param {Object} inputData
         * @returns {Const} STATE
         */
        process: function(X) {
        },
        // jshint ignore:line
        /**
         * return the preferred touch-action
         * @virtual
         * @returns {Array}
         */
        getTouchAction: function() {
        },
        /**
         * called when the gesture isn't allowed to recognize
         * like when another is being recognized or it is disabled
         * @virtual
         */
        reset: function() {
        }
      };
      function Is(X) {
        return X & Cs ? "cancel" : X & zt ? "end" : X & zi ? "move" : X & yr ? "start" : "";
      }
      function Uo(X) {
        return X == mr ? "down" : X == ai ? "up" : X == Ji ? "left" : X == ni ? "right" : "";
      }
      function ho(X, Q) {
        var ue = Q.manager;
        return ue ? ue.get(X) : X;
      }
      function Gr() {
        nr.apply(this, arguments);
      }
      Ee(Gr, nr, {
        /**
         * @namespace
         * @memberof AttrRecognizer
         */
        defaults: {
          /**
           * @type {Number}
           * @default 1
           */
          pointers: 1
        },
        /**
         * Used to check if it the recognizer receives valid input, like input.distance > 10.
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {Boolean} recognized
         */
        attrTest: function(X) {
          var Q = this.options.pointers;
          return Q === 0 || X.pointers.length === Q;
        },
        /**
         * Process the input and return the state for the recognizer
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {*} State
         */
        process: function(X) {
          var Q = this.state, ue = X.eventType, xe = Q & (yr | zi), $e = this.attrTest(X);
          return xe && (ue & Fi || !$e) ? Q | Cs : xe || $e ? ue & qt ? Q | zt : Q & yr ? Q | zi : yr : $r;
        }
      });
      function Ms() {
        Gr.apply(this, arguments), this.pX = null, this.pY = null;
      }
      Ee(Ms, Gr, {
        /**
         * @namespace
         * @memberof PanRecognizer
         */
        defaults: {
          event: "pan",
          threshold: 10,
          pointers: 1,
          direction: es
        },
        getTouchAction: function() {
          var X = this.options.direction, Q = [];
          return X & ki && Q.push(en), X & Or && Q.push(Tt), Q;
        },
        directionTest: function(X) {
          var Q = this.options, ue = !0, xe = X.distance, $e = X.direction, at = X.deltaX, It = X.deltaY;
          return $e & Q.direction || (Q.direction & ki ? ($e = at === 0 ? ws : at < 0 ? Ji : ni, ue = at != this.pX, xe = Math.abs(X.deltaX)) : ($e = It === 0 ? ws : It < 0 ? ai : mr, ue = It != this.pY, xe = Math.abs(X.deltaY))), X.direction = $e, ue && xe > Q.threshold && $e & Q.direction;
        },
        attrTest: function(X) {
          return Gr.prototype.attrTest.call(this, X) && (this.state & yr || !(this.state & yr) && this.directionTest(X));
        },
        emit: function(X) {
          this.pX = X.deltaX, this.pY = X.deltaY;
          var Q = Uo(X.direction);
          Q && (X.additionalEvent = this.options.event + Q), this._super.emit.call(this, X);
        }
      });
      function zo() {
        Gr.apply(this, arguments);
      }
      Ee(zo, Gr, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
          event: "pinch",
          threshold: 0,
          pointers: 2
        },
        getTouchAction: function() {
          return [Sr];
        },
        attrTest: function(X) {
          return this._super.attrTest.call(this, X) && (Math.abs(X.scale - 1) > this.options.threshold || this.state & yr);
        },
        emit: function(X) {
          if (X.scale !== 1) {
            var Q = X.scale < 1 ? "in" : "out";
            X.additionalEvent = this.options.event + Q;
          }
          this._super.emit.call(this, X);
        }
      });
      function Ba() {
        nr.apply(this, arguments), this._timer = null, this._input = null;
      }
      Ee(Ba, nr, {
        /**
         * @namespace
         * @memberof PressRecognizer
         */
        defaults: {
          event: "press",
          pointers: 1,
          time: 251,
          // minimal time of the pointer to be pressed
          threshold: 9
          // a minimal movement is ok, but keep it low
        },
        getTouchAction: function() {
          return [$i];
        },
        process: function(X) {
          var Q = this.options, ue = X.pointers.length === Q.pointers, xe = X.distance < Q.threshold, $e = X.deltaTime > Q.time;
          if (this._input = X, !xe || !ue || X.eventType & (qt | Fi) && !$e)
            this.reset();
          else if (X.eventType & Ri)
            this.reset(), this._timer = F(function() {
              this.state = ds, this.tryEmit();
            }, Q.time, this);
          else if (X.eventType & qt)
            return ds;
          return $r;
        },
        reset: function() {
          clearTimeout(this._timer);
        },
        emit: function(X) {
          this.state === ds && (X && X.eventType & qt ? this.manager.emit(this.options.event + "up", X) : (this._input.timeStamp = M(), this.manager.emit(this.options.event, this._input)));
        }
      });
      function Da() {
        Gr.apply(this, arguments);
      }
      Ee(Da, Gr, {
        /**
         * @namespace
         * @memberof RotateRecognizer
         */
        defaults: {
          event: "rotate",
          threshold: 0,
          pointers: 2
        },
        getTouchAction: function() {
          return [Sr];
        },
        attrTest: function(X) {
          return this._super.attrTest.call(this, X) && (Math.abs(X.rotation) > this.options.threshold || this.state & yr);
        }
      });
      function Oa() {
        Gr.apply(this, arguments);
      }
      Ee(Oa, Gr, {
        /**
         * @namespace
         * @memberof SwipeRecognizer
         */
        defaults: {
          event: "swipe",
          threshold: 10,
          velocity: 0.3,
          direction: ki | Or,
          pointers: 1
        },
        getTouchAction: function() {
          return Ms.prototype.getTouchAction.call(this);
        },
        attrTest: function(X) {
          var Q = this.options.direction, ue;
          return Q & (ki | Or) ? ue = X.overallVelocity : Q & ki ? ue = X.overallVelocityX : Q & Or && (ue = X.overallVelocityY), this._super.attrTest.call(this, X) && Q & X.offsetDirection && X.distance > this.options.threshold && X.maxPointers == this.options.pointers && S(ue) > this.options.velocity && X.eventType & qt;
        },
        emit: function(X) {
          var Q = Uo(X.offsetDirection);
          Q && this.manager.emit(this.options.event + Q, X), this.manager.emit(this.options.event, X);
        }
      });
      function jn() {
        nr.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0;
      }
      Ee(jn, nr, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
          event: "tap",
          pointers: 1,
          taps: 1,
          interval: 300,
          // max time between the multi-tap taps
          time: 250,
          // max time of the pointer to be down (like finger on the screen)
          threshold: 9,
          // a minimal movement is ok, but keep it low
          posThreshold: 10
          // a multi-tap can be a bit off the initial position
        },
        getTouchAction: function() {
          return [Ss];
        },
        process: function(X) {
          var Q = this.options, ue = X.pointers.length === Q.pointers, xe = X.distance < Q.threshold, $e = X.deltaTime < Q.time;
          if (this.reset(), X.eventType & Ri && this.count === 0)
            return this.failTimeout();
          if (xe && $e && ue) {
            if (X.eventType != qt)
              return this.failTimeout();
            var at = this.pTime ? X.timeStamp - this.pTime < Q.interval : !0, It = !this.pCenter || W(this.pCenter, X.center) < Q.posThreshold;
            this.pTime = X.timeStamp, this.pCenter = X.center, !It || !at ? this.count = 1 : this.count += 1, this._input = X;
            var hi = this.count % Q.taps;
            if (hi === 0)
              return this.hasRequireFailures() ? (this._timer = F(function() {
                this.state = ds, this.tryEmit();
              }, Q.interval, this), yr) : ds;
          }
          return $r;
        },
        failTimeout: function() {
          return this._timer = F(function() {
            this.state = $r;
          }, this.options.interval, this), $r;
        },
        reset: function() {
          clearTimeout(this._timer);
        },
        emit: function() {
          this.state == ds && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input));
        }
      });
      function Fr(X, Q) {
        return Q = Q || {}, Q.recognizers = Ze(Q.recognizers, Fr.defaults.preset), new tn(X, Q);
      }
      Fr.VERSION = "2.0.7", Fr.defaults = {
        /**
         * set if DOM events are being triggered.
         * But this is slower and unused by simple implementations, so disabled by default.
         * @type {Boolean}
         * @default false
         */
        domEvents: !1,
        /**
         * The value for the touchAction property/fallback.
         * When set to `compute` it will magically set the correct value based on the added recognizers.
         * @type {String}
         * @default compute
         */
        touchAction: Ct,
        /**
         * @type {Boolean}
         * @default true
         */
        enable: !0,
        /**
         * EXPERIMENTAL FEATURE -- can be removed/changed
         * Change the parent input target element.
         * If Null, then it is being set the to main element.
         * @type {Null|EventTarget}
         * @default null
         */
        inputTarget: null,
        /**
         * force an input class
         * @type {Null|Function}
         * @default null
         */
        inputClass: null,
        /**
         * Default recognizer setup when calling `Hammer()`
         * When creating a new Manager these will be skipped.
         * @type {Array}
         */
        preset: [
          // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
          [Da, { enable: !1 }],
          [zo, { enable: !1 }, ["rotate"]],
          [Oa, { direction: ki }],
          [Ms, { direction: ki }, ["swipe"]],
          [jn],
          [jn, { event: "doubletap", taps: 2 }, ["tap"]],
          [Ba]
        ],
        /**
         * Some CSS properties can be used to improve the working of Hammer.
         * Add them to this method and they will be set when creating a new Manager.
         * @namespace
         */
        cssProps: {
          /**
           * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */
          userSelect: "none",
          /**
           * Disable the Windows Phone grippers when pressing an element.
           * @type {String}
           * @default 'none'
           */
          touchSelect: "none",
          /**
           * Disables the default callout shown when you touch and hold a touch target.
           * On iOS, when you touch and hold a touch target such as a link, Safari displays
           * a callout containing information about the link. This property allows you to disable that callout.
           * @type {String}
           * @default 'none'
           */
          touchCallout: "none",
          /**
           * Specifies whether zooming is enabled. Used by IE10>
           * @type {String}
           * @default 'none'
           */
          contentZooming: "none",
          /**
           * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */
          userDrag: "none",
          /**
           * Overrides the highlight color shown when the user taps a link or a JavaScript
           * clickable element in iOS. This property obeys the alpha value, if specified.
           * @type {String}
           * @default 'rgba(0,0,0,0)'
           */
          tapHighlightColor: "rgba(0,0,0,0)"
        }
      };
      var Fa = 1, Vo = 2;
      function tn(X, Q) {
        this.options = ne({}, Fr.defaults, Q || {}), this.options.inputTarget = this.options.inputTarget || X, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = X, this.input = Ks(this), this.touchAction = new zn(this, this.options.touchAction), jo(this, !0), L(this.options.recognizers, function(ue) {
          var xe = this.add(new ue[0](ue[1]));
          ue[2] && xe.recognizeWith(ue[2]), ue[3] && xe.requireFailure(ue[3]);
        }, this);
      }
      tn.prototype = {
        /**
         * set options
         * @param {Object} options
         * @returns {Manager}
         */
        set: function(X) {
          return ne(this.options, X), X.touchAction && this.touchAction.update(), X.inputTarget && (this.input.destroy(), this.input.target = X.inputTarget, this.input.init()), this;
        },
        /**
         * stop recognizing for this session.
         * This session will be discarded, when a new [input]start event is fired.
         * When forced, the recognizer cycle is stopped immediately.
         * @param {Boolean} [force]
         */
        stop: function(X) {
          this.session.stopped = X ? Vo : Fa;
        },
        /**
         * run the recognizers!
         * called by the inputHandler function on every movement of the pointers (touches)
         * it walks through all the recognizers and tries to detect the gesture that is being made
         * @param {Object} inputData
         */
        recognize: function(X) {
          var Q = this.session;
          if (!Q.stopped) {
            this.touchAction.preventDefaults(X);
            var ue, xe = this.recognizers, $e = Q.curRecognizer;
            (!$e || $e && $e.state & ds) && ($e = Q.curRecognizer = null);
            for (var at = 0; at < xe.length; )
              ue = xe[at], Q.stopped !== Vo && // 1
              (!$e || ue == $e || // 2
              ue.canRecognizeWith($e)) ? ue.recognize(X) : ue.reset(), !$e && ue.state & (yr | zi | zt) && ($e = Q.curRecognizer = ue), at++;
          }
        },
        /**
         * get a recognizer by its event name.
         * @param {Recognizer|String} recognizer
         * @returns {Recognizer|Null}
         */
        get: function(X) {
          if (X instanceof nr)
            return X;
          for (var Q = this.recognizers, ue = 0; ue < Q.length; ue++)
            if (Q[ue].options.event == X)
              return Q[ue];
          return null;
        },
        /**
         * add a recognizer to the manager
         * existing recognizers with the same event name will be removed
         * @param {Recognizer} recognizer
         * @returns {Recognizer|Manager}
         */
        add: function(X) {
          if (N(X, "add", this))
            return this;
          var Q = this.get(X.options.event);
          return Q && this.remove(Q), this.recognizers.push(X), X.manager = this, this.touchAction.update(), X;
        },
        /**
         * remove a recognizer by name or instance
         * @param {Recognizer|String} recognizer
         * @returns {Manager}
         */
        remove: function(X) {
          if (N(X, "remove", this))
            return this;
          if (X = this.get(X), X) {
            var Q = this.recognizers, ue = bt(Q, X);
            ue !== -1 && (Q.splice(ue, 1), this.touchAction.update());
          }
          return this;
        },
        /**
         * bind event
         * @param {String} events
         * @param {Function} handler
         * @returns {EventEmitter} this
         */
        on: function(X, Q) {
          if (X !== o && Q !== o) {
            var ue = this.handlers;
            return L(ot(X), function(xe) {
              ue[xe] = ue[xe] || [], ue[xe].push(Q);
            }), this;
          }
        },
        /**
         * unbind event, leave emit blank to remove all handlers
         * @param {String} events
         * @param {Function} [handler]
         * @returns {EventEmitter} this
         */
        off: function(X, Q) {
          if (X !== o) {
            var ue = this.handlers;
            return L(ot(X), function(xe) {
              Q ? ue[xe] && ue[xe].splice(bt(ue[xe], Q), 1) : delete ue[xe];
            }), this;
          }
        },
        /**
         * emit event to the listeners
         * @param {String} event
         * @param {Object} data
         */
        emit: function(X, Q) {
          this.options.domEvents && ka(X, Q);
          var ue = this.handlers[X] && this.handlers[X].slice();
          if (!(!ue || !ue.length)) {
            Q.type = X, Q.preventDefault = function() {
              Q.srcEvent.preventDefault();
            };
            for (var xe = 0; xe < ue.length; )
              ue[xe](Q), xe++;
          }
        },
        /**
         * destroy the manager and unbinds all events
         * it doesn't unbind dom events, that is the user own responsibility
         */
        destroy: function() {
          this.element && jo(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null;
        }
      };
      function jo(X, Q) {
        var ue = X.element;
        if (ue.style) {
          var xe;
          L(X.options.cssProps, function($e, at) {
            xe = Et(ue.style, at), Q ? (X.oldCssProps[xe] = ue.style[xe], ue.style[xe] = $e) : ue.style[xe] = X.oldCssProps[xe] || "";
          }), Q || (X.oldCssProps = {});
        }
      }
      function ka(X, Q) {
        var ue = i.createEvent("Event");
        ue.initEvent(X, !0, !0), ue.gesture = Q, Q.target.dispatchEvent(ue);
      }
      ne(Fr, {
        INPUT_START: Ri,
        INPUT_MOVE: ji,
        INPUT_END: qt,
        INPUT_CANCEL: Fi,
        STATE_POSSIBLE: li,
        STATE_BEGAN: yr,
        STATE_CHANGED: zi,
        STATE_ENDED: zt,
        STATE_RECOGNIZED: ds,
        STATE_CANCELLED: Cs,
        STATE_FAILED: $r,
        DIRECTION_NONE: ws,
        DIRECTION_LEFT: Ji,
        DIRECTION_RIGHT: ni,
        DIRECTION_UP: ai,
        DIRECTION_DOWN: mr,
        DIRECTION_HORIZONTAL: ki,
        DIRECTION_VERTICAL: Or,
        DIRECTION_ALL: es,
        Manager: tn,
        Input: Ni,
        TouchAction: zn,
        TouchInput: Pt,
        MouseInput: Ne,
        PointerEventInput: wt,
        TouchMouseInput: Hi,
        SingleTouchInput: Kt,
        Recognizer: nr,
        AttrRecognizer: Gr,
        Tap: jn,
        Pan: Ms,
        Swipe: Oa,
        Pinch: zo,
        Rotate: Da,
        Press: Ba,
        on: Ke,
        off: ct,
        each: L,
        merge: Se,
        extend: we,
        assign: ne,
        inherit: Ee,
        bindFn: Ce,
        prefixed: Et
      });
      var yh = typeof e < "u" ? e : typeof self < "u" ? self : {};
      yh.Hammer = Fr, t.exports ? t.exports = Fr : e[s] = Fr;
    })(window, document, "Hammer");
  })(Mg)), Mg.exports;
}
var hd = Ck();
const Ik = /* @__PURE__ */ J1(hd), to = /* @__PURE__ */ Y1({
  __proto__: null,
  default: Ik
}, [hd]), ZT = 1, KT = 2, Mm = 4, Mk = {
  mousedown: ZT,
  mousemove: KT,
  mouseup: Mm
};
function Rk(t, e) {
  for (let i = 0; i < t.length; i++)
    if (e(t[i]))
      return !0;
  return !1;
}
function Pk(t) {
  const e = t.prototype.handler;
  t.prototype.handler = function(s) {
    const o = this.store;
    s.button > 0 && s.type === "pointerdown" && (Rk(o, (u) => u.pointerId === s.pointerId) || o.push(s)), e.call(this, s);
  };
}
function Bk(t) {
  t.prototype.handler = function(i) {
    let s = Mk[i.type];
    s & ZT && i.button >= 0 && (this.pressed = !0), s & KT && i.buttons === 0 && (s = Mm), this.pressed && (s & Mm && (this.pressed = !1), this.callback(this.manager, s, {
      pointers: [i],
      changedPointers: [i],
      pointerType: "mouse",
      srcEvent: i
    }));
  };
}
Pk(hd.PointerEventInput);
Bk(hd.MouseInput);
const Dk = hd.Manager;
class Fp {
  constructor(e, i, s) {
    this.element = e, this.callback = i, this.options = { enable: !0, ...s };
  }
}
const Ok = to ? [
  [to.Pan, { event: "tripan", pointers: 3, threshold: 0, enable: !1 }],
  [to.Rotate, { enable: !1 }],
  [to.Pinch, { enable: !1 }],
  [to.Swipe, { enable: !1 }],
  [to.Pan, { threshold: 0, enable: !1 }],
  [to.Press, { enable: !1 }],
  [to.Tap, { event: "doubletap", taps: 2, enable: !1 }],
  // TODO - rename to 'tap' and 'singletap' in the next major release
  [to.Tap, { event: "anytap", enable: !1 }],
  [to.Tap, { enable: !1 }]
] : null, yx = {
  tripan: ["rotate", "pinch", "pan"],
  rotate: ["pinch"],
  pinch: ["pan"],
  pan: ["press", "doubletap", "anytap", "tap"],
  doubletap: ["anytap"],
  anytap: ["tap"]
}, Fk = {
  doubletap: ["tap"]
}, kk = {
  pointerdown: "pointerdown",
  pointermove: "pointermove",
  pointerup: "pointerup",
  touchstart: "pointerdown",
  touchmove: "pointermove",
  touchend: "pointerup",
  mousedown: "pointerdown",
  mousemove: "pointermove",
  mouseup: "pointerup"
}, ky = {
  KEY_EVENTS: ["keydown", "keyup"],
  MOUSE_EVENTS: ["mousedown", "mousemove", "mouseup", "mouseover", "mouseout", "mouseleave"],
  WHEEL_EVENTS: [
    // Chrome, Safari
    "wheel",
    // IE
    "mousewheel"
  ]
}, Nk = {
  tap: "tap",
  anytap: "anytap",
  doubletap: "doubletap",
  press: "press",
  pinch: "pinch",
  pinchin: "pinch",
  pinchout: "pinch",
  pinchstart: "pinch",
  pinchmove: "pinch",
  pinchend: "pinch",
  pinchcancel: "pinch",
  rotate: "rotate",
  rotatestart: "rotate",
  rotatemove: "rotate",
  rotateend: "rotate",
  rotatecancel: "rotate",
  tripan: "tripan",
  tripanstart: "tripan",
  tripanmove: "tripan",
  tripanup: "tripan",
  tripandown: "tripan",
  tripanleft: "tripan",
  tripanright: "tripan",
  tripanend: "tripan",
  tripancancel: "tripan",
  pan: "pan",
  panstart: "pan",
  panmove: "pan",
  panup: "pan",
  pandown: "pan",
  panleft: "pan",
  panright: "pan",
  panend: "pan",
  pancancel: "pan",
  swipe: "swipe",
  swipeleft: "swipe",
  swiperight: "swipe",
  swipeup: "swipe",
  swipedown: "swipe"
}, bx = {
  click: "tap",
  anyclick: "anytap",
  dblclick: "doubletap",
  mousedown: "pointerdown",
  mousemove: "pointermove",
  mouseup: "pointerup",
  mouseover: "pointerover",
  mouseout: "pointerout",
  mouseleave: "pointerleave"
}, Lk = typeof navigator < "u" && navigator.userAgent ? navigator.userAgent.toLowerCase() : "", qc = typeof window < "u" ? window : global;
let Rm = !1;
try {
  const t = {
    // This function will be called when the browser
    // attempts to access the passive property.
    get passive() {
      return Rm = !0, !0;
    }
  };
  qc.addEventListener("test", null, t), qc.removeEventListener("test", null);
} catch {
  Rm = !1;
}
const Uk = Lk.indexOf("firefox") !== -1, { WHEEL_EVENTS: zk } = ky, vx = "wheel", xx = 4.000244140625, Vk = 40, jk = 0.25;
class Hk extends Fp {
  constructor(e, i, s) {
    super(e, i, s), this.handleEvent = (o) => {
      if (!this.options.enable)
        return;
      let u = o.deltaY;
      qc.WheelEvent && (Uk && o.deltaMode === qc.WheelEvent.DOM_DELTA_PIXEL && (u /= qc.devicePixelRatio), o.deltaMode === qc.WheelEvent.DOM_DELTA_LINE && (u *= Vk)), u !== 0 && u % xx === 0 && (u = Math.floor(u / xx)), o.shiftKey && u && (u = u * jk), this.callback({
        type: vx,
        center: {
          x: o.clientX,
          y: o.clientY
        },
        delta: -u,
        srcEvent: o,
        pointerType: "mouse",
        target: o.target
      });
    }, this.events = (this.options.events || []).concat(zk), this.events.forEach((o) => e.addEventListener(o, this.handleEvent, Rm ? { passive: !1 } : !1));
  }
  destroy() {
    this.events.forEach((e) => this.element.removeEventListener(e, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(e, i) {
    e === vx && (this.options.enable = i);
  }
}
const { MOUSE_EVENTS: $k } = ky, wx = "pointermove", Tx = "pointerover", Ax = "pointerout", Ex = "pointerenter", Sx = "pointerleave";
class Gk extends Fp {
  constructor(e, i, s) {
    super(e, i, s), this.handleEvent = (u) => {
      this.handleOverEvent(u), this.handleOutEvent(u), this.handleEnterEvent(u), this.handleLeaveEvent(u), this.handleMoveEvent(u);
    }, this.pressed = !1;
    const { enable: o } = this.options;
    this.enableMoveEvent = o, this.enableLeaveEvent = o, this.enableEnterEvent = o, this.enableOutEvent = o, this.enableOverEvent = o, this.events = (this.options.events || []).concat($k), this.events.forEach((u) => e.addEventListener(u, this.handleEvent));
  }
  destroy() {
    this.events.forEach((e) => this.element.removeEventListener(e, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(e, i) {
    e === wx && (this.enableMoveEvent = i), e === Tx && (this.enableOverEvent = i), e === Ax && (this.enableOutEvent = i), e === Ex && (this.enableEnterEvent = i), e === Sx && (this.enableLeaveEvent = i);
  }
  handleOverEvent(e) {
    this.enableOverEvent && e.type === "mouseover" && this._emit(Tx, e);
  }
  handleOutEvent(e) {
    this.enableOutEvent && e.type === "mouseout" && this._emit(Ax, e);
  }
  handleEnterEvent(e) {
    this.enableEnterEvent && e.type === "mouseenter" && this._emit(Ex, e);
  }
  handleLeaveEvent(e) {
    this.enableLeaveEvent && e.type === "mouseleave" && this._emit(Sx, e);
  }
  handleMoveEvent(e) {
    if (this.enableMoveEvent)
      switch (e.type) {
        case "mousedown":
          e.button >= 0 && (this.pressed = !0);
          break;
        case "mousemove":
          e.buttons === 0 && (this.pressed = !1), this.pressed || this._emit(wx, e);
          break;
        case "mouseup":
          this.pressed = !1;
          break;
      }
  }
  _emit(e, i) {
    this.callback({
      type: e,
      center: {
        x: i.clientX,
        y: i.clientY
      },
      srcEvent: i,
      pointerType: "mouse",
      target: i.target
    });
  }
}
const { KEY_EVENTS: Wk } = ky, Cx = "keydown", Ix = "keyup";
class Xk extends Fp {
  constructor(e, i, s) {
    super(e, i, s), this.handleEvent = (o) => {
      const u = o.target || o.srcElement;
      u.tagName === "INPUT" && u.type === "text" || u.tagName === "TEXTAREA" || (this.enableDownEvent && o.type === "keydown" && this.callback({
        type: Cx,
        srcEvent: o,
        key: o.key,
        target: o.target
      }), this.enableUpEvent && o.type === "keyup" && this.callback({
        type: Ix,
        srcEvent: o,
        key: o.key,
        target: o.target
      }));
    }, this.enableDownEvent = this.options.enable, this.enableUpEvent = this.options.enable, this.events = (this.options.events || []).concat(Wk), e.tabIndex = this.options.tabIndex || 0, e.style.outline = "none", this.events.forEach((o) => e.addEventListener(o, this.handleEvent));
  }
  destroy() {
    this.events.forEach((e) => this.element.removeEventListener(e, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(e, i) {
    e === Cx && (this.enableDownEvent = i), e === Ix && (this.enableUpEvent = i);
  }
}
const Mx = "contextmenu";
class qk extends Fp {
  constructor(e, i, s) {
    super(e, i, s), this.handleEvent = (o) => {
      this.options.enable && this.callback({
        type: Mx,
        center: {
          x: o.clientX,
          y: o.clientY
        },
        srcEvent: o,
        pointerType: "mouse",
        target: o.target
      });
    }, e.addEventListener("contextmenu", this.handleEvent);
  }
  destroy() {
    this.element.removeEventListener("contextmenu", this.handleEvent);
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(e, i) {
    e === Mx && (this.options.enable = i);
  }
}
const Rx = 1, Pm = 2, Px = 4, Zk = {
  pointerdown: Rx,
  pointermove: Pm,
  pointerup: Px,
  mousedown: Rx,
  mousemove: Pm,
  mouseup: Px
}, Kk = 0, Yk = 1, Jk = 2, Qk = 1, eN = 2, tN = 4;
function iN(t) {
  const e = Zk[t.srcEvent.type];
  if (!e)
    return null;
  const { buttons: i, button: s } = t.srcEvent;
  let o = !1, u = !1, d = !1;
  return e === Pm ? (o = !!(i & Qk), u = !!(i & tN), d = !!(i & eN)) : (o = s === Kk, u = s === Yk, d = s === Jk), { leftButton: o, middleButton: u, rightButton: d };
}
function rN(t, e) {
  const i = t.center;
  if (!i)
    return null;
  const s = e.getBoundingClientRect(), o = s.width / e.offsetWidth || 1, u = s.height / e.offsetHeight || 1, d = {
    x: (i.x - s.left - e.clientLeft) / o,
    y: (i.y - s.top - e.clientTop) / u
  };
  return { center: i, offsetCenter: d };
}
const Rg = {
  srcElement: "root",
  priority: 0
};
class sN {
  constructor(e) {
    this.handleEvent = (i) => {
      if (this.isEmpty())
        return;
      const s = this._normalizeEvent(i);
      let o = i.srcEvent.target;
      for (; o && o !== s.rootElement; ) {
        if (this._emit(s, o), s.handled)
          return;
        o = o.parentNode;
      }
      this._emit(s, "root");
    }, this.eventManager = e, this.handlers = [], this.handlersByElement = /* @__PURE__ */ new Map(), this._active = !1;
  }
  // Returns true if there are no non-passive handlers
  isEmpty() {
    return !this._active;
  }
  add(e, i, s, o = !1, u = !1) {
    const { handlers: d, handlersByElement: a } = this;
    let w = Rg;
    typeof s == "string" || s && s.addEventListener ? w = { ...Rg, srcElement: s } : s && (w = { ...Rg, ...s });
    let S = a.get(w.srcElement);
    S || (S = [], a.set(w.srcElement, S));
    const M = {
      type: e,
      handler: i,
      srcElement: w.srcElement,
      priority: w.priority
    };
    o && (M.once = !0), u && (M.passive = !0), d.push(M), this._active = this._active || !M.passive;
    let F = S.length - 1;
    for (; F >= 0 && !(S[F].priority >= M.priority); )
      F--;
    S.splice(F + 1, 0, M);
  }
  remove(e, i) {
    const { handlers: s, handlersByElement: o } = this;
    for (let u = s.length - 1; u >= 0; u--) {
      const d = s[u];
      if (d.type === e && d.handler === i) {
        s.splice(u, 1);
        const a = o.get(d.srcElement);
        a.splice(a.indexOf(d), 1), a.length === 0 && o.delete(d.srcElement);
      }
    }
    this._active = s.some((u) => !u.passive);
  }
  /**
   * Invoke handlers on a particular element
   */
  _emit(e, i) {
    const s = this.handlersByElement.get(i);
    if (s) {
      let o = !1;
      const u = () => {
        e.handled = !0;
      }, d = () => {
        e.handled = !0, o = !0;
      }, a = [];
      for (let w = 0; w < s.length; w++) {
        const { type: S, handler: M, once: F } = s[w];
        if (M({
          ...e,
          // @ts-ignore
          type: S,
          stopPropagation: u,
          stopImmediatePropagation: d
        }), F && a.push(s[w]), o)
          break;
      }
      for (let w = 0; w < a.length; w++) {
        const { type: S, handler: M } = a[w];
        this.remove(S, M);
      }
    }
  }
  /**
   * Normalizes hammerjs and custom events to have predictable fields.
   */
  _normalizeEvent(e) {
    const i = this.eventManager.getElement();
    return {
      ...e,
      ...iN(e),
      ...rN(e, i),
      preventDefault: () => {
        e.srcEvent.preventDefault();
      },
      stopImmediatePropagation: null,
      stopPropagation: null,
      handled: !1,
      rootElement: i
    };
  }
}
const nN = {
  // event handlers
  events: null,
  // custom recognizers
  recognizers: null,
  recognizerOptions: {},
  // Manager class
  Manager: Dk,
  // allow browser default touch action
  // https://github.com/uber/react-map-gl/issues/506
  touchAction: "none",
  tabIndex: 0
};
class oN {
  constructor(e = null, i) {
    this._onBasicInput = (o) => {
      const { srcEvent: u } = o, d = kk[u.type];
      d && this.manager.emit(d, o);
    }, this._onOtherEvent = (o) => {
      this.manager.emit(o.type, o);
    }, this.options = { ...nN, ...i }, this.events = /* @__PURE__ */ new Map(), this.setElement(e);
    const { events: s } = this.options;
    s && this.on(s);
  }
  getElement() {
    return this.element;
  }
  setElement(e) {
    if (this.element && this.destroy(), this.element = e, !e)
      return;
    const { options: i } = this, s = i.Manager;
    this.manager = new s(e, {
      touchAction: i.touchAction,
      recognizers: i.recognizers || Ok
    }).on("hammer.input", this._onBasicInput), i.recognizers || Object.keys(yx).forEach((o) => {
      const u = this.manager.get(o);
      u && yx[o].forEach((d) => {
        u.recognizeWith(d);
      });
    });
    for (const o in i.recognizerOptions) {
      const u = this.manager.get(o);
      if (u) {
        const d = i.recognizerOptions[o];
        delete d.enable, u.set(d);
      }
    }
    this.wheelInput = new Hk(e, this._onOtherEvent, {
      enable: !1
    }), this.moveInput = new Gk(e, this._onOtherEvent, {
      enable: !1
    }), this.keyInput = new Xk(e, this._onOtherEvent, {
      enable: !1,
      tabIndex: i.tabIndex
    }), this.contextmenuInput = new qk(e, this._onOtherEvent, {
      enable: !1
    });
    for (const [o, u] of this.events)
      u.isEmpty() || (this._toggleRecognizer(u.recognizerName, !0), this.manager.on(o, u.handleEvent));
  }
  // Tear down internal event management implementations.
  destroy() {
    this.element && (this.wheelInput.destroy(), this.moveInput.destroy(), this.keyInput.destroy(), this.contextmenuInput.destroy(), this.manager.destroy(), this.wheelInput = null, this.moveInput = null, this.keyInput = null, this.contextmenuInput = null, this.manager = null, this.element = null);
  }
  /** Register an event handler function to be called on `event` */
  on(e, i, s) {
    this._addEventHandler(e, i, s, !1);
  }
  once(e, i, s) {
    this._addEventHandler(e, i, s, !0);
  }
  watch(e, i, s) {
    this._addEventHandler(e, i, s, !1, !0);
  }
  off(e, i) {
    this._removeEventHandler(e, i);
  }
  /*
   * Enable/disable recognizer for the given event
   */
  _toggleRecognizer(e, i) {
    const { manager: s } = this;
    if (!s)
      return;
    const o = s.get(e);
    if (o && o.options.enable !== i) {
      o.set({ enable: i });
      const u = Fk[e];
      u && !this.options.recognizers && u.forEach((d) => {
        const a = s.get(d);
        i ? (a.requireFailure(e), o.dropRequireFailure(d)) : a.dropRequireFailure(e);
      });
    }
    this.wheelInput.enableEventType(e, i), this.moveInput.enableEventType(e, i), this.keyInput.enableEventType(e, i), this.contextmenuInput.enableEventType(e, i);
  }
  /**
   * Process the event registration for a single event + handler.
   */
  _addEventHandler(e, i, s, o, u) {
    if (typeof e != "string") {
      s = i;
      for (const M in e)
        this._addEventHandler(M, e[M], s, o, u);
      return;
    }
    const { manager: d, events: a } = this, w = bx[e] || e;
    let S = a.get(w);
    S || (S = new sN(this), a.set(w, S), S.recognizerName = Nk[w] || w, d && d.on(w, S.handleEvent)), S.add(e, i, s, o, u), S.isEmpty() || this._toggleRecognizer(S.recognizerName, !0);
  }
  /**
   * Process the event deregistration for a single event + handler.
   */
  _removeEventHandler(e, i) {
    if (typeof e != "string") {
      for (const d in e)
        this._removeEventHandler(d, e[d]);
      return;
    }
    const { events: s } = this, o = bx[e] || e, u = s.get(o);
    if (u && (u.remove(e, i), u.isEmpty())) {
      const { recognizerName: d } = u;
      let a = !1;
      for (const w of s.values())
        if (w.recognizerName === d && !w.isEmpty()) {
          a = !0;
          break;
        }
      a || this._toggleRecognizer(d, !1);
    }
  }
}
function _a() {
}
const aN = ({ isDragging: t }) => t ? "grabbing" : "grab", YT = {
  id: "",
  width: "100%",
  height: "100%",
  style: null,
  viewState: null,
  initialViewState: null,
  pickingRadius: 0,
  layerFilter: null,
  parameters: {},
  parent: null,
  device: null,
  deviceProps: { type: "webgl" },
  gl: null,
  glOptions: {},
  canvas: null,
  layers: [],
  effects: [],
  views: null,
  controller: null,
  // Rely on external controller, e.g. react-map-gl
  useDevicePixels: !0,
  touchAction: "none",
  eventRecognizerOptions: {},
  _framebuffer: null,
  _animate: !1,
  _pickable: !0,
  _typedArrayManagerProps: {},
  _customRender: null,
  widgets: [],
  onDeviceInitialized: _a,
  onWebGLInitialized: _a,
  onResize: _a,
  onViewStateChange: _a,
  onInteractionStateChange: _a,
  onBeforeRender: _a,
  onAfterRender: _a,
  onLoad: _a,
  onError: (t) => Jt.error(t.message, t.cause)(),
  onHover: null,
  onClick: null,
  onDragStart: null,
  onDrag: null,
  onDragEnd: null,
  _onMetrics: null,
  getCursor: aN,
  getTooltip: null,
  debug: !1,
  drawPickingColors: !1
};
class Qu {
  constructor(e) {
    this.width = 0, this.height = 0, this.userData = {}, this.device = null, this.canvas = null, this.viewManager = null, this.layerManager = null, this.effectManager = null, this.deckRenderer = null, this.deckPicker = null, this.eventManager = null, this.widgetManager = null, this.tooltip = null, this.animationLoop = null, this.cursorState = {
      isHovering: !1,
      isDragging: !1
    }, this.stats = new _h({ id: "deck.gl" }), this.metrics = {
      fps: 0,
      setPropsTime: 0,
      updateAttributesTime: 0,
      framesRedrawn: 0,
      pickTime: 0,
      pickCount: 0,
      gpuTime: 0,
      gpuTimePerFrame: 0,
      cpuTime: 0,
      cpuTimePerFrame: 0,
      bufferMemory: 0,
      textureMemory: 0,
      renderbufferMemory: 0,
      gpuMemory: 0
    }, this._metricsCounter = 0, this._needsRedraw = "Initial render", this._pickRequest = {
      mode: "hover",
      x: -1,
      y: -1,
      radius: 0,
      event: null
    }, this._lastPointerDownInfo = null, this._onPointerMove = (s) => {
      const { _pickRequest: o } = this;
      if (s.type === "pointerleave")
        o.x = -1, o.y = -1, o.radius = 0;
      else {
        if (s.leftButton || s.rightButton)
          return;
        {
          const u = s.offsetCenter;
          if (!u)
            return;
          o.x = u.x, o.y = u.y, o.radius = this.props.pickingRadius;
        }
      }
      this.layerManager && (this.layerManager.context.mousePosition = { x: o.x, y: o.y }), o.event = s;
    }, this._onEvent = (s) => {
      const o = vm[s.type], u = s.offsetCenter;
      if (!o || !u || !this.layerManager)
        return;
      const d = this.layerManager.getLayers(), a = this.deckPicker.getLastPickedObject({
        x: u.x,
        y: u.y,
        layers: d,
        viewports: this.getViewports(u)
      }, this._lastPointerDownInfo), { layer: w } = a, S = w && (w[o.handler] || w.props[o.handler]), M = this.props[o.handler];
      let F = !1;
      S && (F = S.call(w, a, s)), F || (M?.(a, s), this.widgetManager.onEvent(a, s));
    }, this._onPointerDown = (s) => {
      const o = s.offsetCenter, u = this._pick("pickObject", "pickObject Time", {
        x: o.x,
        y: o.y,
        radius: this.props.pickingRadius
      });
      this._lastPointerDownInfo = u.result[0] || u.emptyInfo;
    }, this.props = { ...YT, ...e }, e = this.props, e.viewState && e.initialViewState && Jt.warn("View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.")(), this.viewState = this.props.initialViewState, e.device ? this.device = e.device : e.gl && (e.gl instanceof WebGLRenderingContext && Jt.error("WebGL1 context not supported.")(), this.device = wa.attach(e.gl));
    let i = this.device;
    i || (Yc.registerDevices([wa]), i = Yc.createDevice({
      ...e.deviceProps,
      canvas: this._createCanvas(e)
    })), this.animationLoop = this._createAnimationLoop(i, e), this.setProps(e), e._typedArrayManagerProps && Ku.setOptions(e._typedArrayManagerProps), this.animationLoop.start();
  }
  /** Stop rendering and dispose all resources */
  finalize() {
    this.animationLoop?.stop(), this.animationLoop?.destroy(), this.animationLoop = null, this._lastPointerDownInfo = null, this.layerManager?.finalize(), this.layerManager = null, this.viewManager?.finalize(), this.viewManager = null, this.effectManager?.finalize(), this.effectManager = null, this.deckRenderer?.finalize(), this.deckRenderer = null, this.deckPicker?.finalize(), this.deckPicker = null, this.eventManager?.destroy(), this.eventManager = null, this.widgetManager?.finalize(), this.widgetManager = null, !this.props.canvas && !this.props.device && !this.props.gl && this.canvas && (this.canvas.parentElement?.removeChild(this.canvas), this.canvas = null);
  }
  /** Partially update props */
  setProps(e) {
    this.stats.get("setProps Time").timeStart(), "onLayerHover" in e && Jt.removed("onLayerHover", "onHover")(), "onLayerClick" in e && Jt.removed("onLayerClick", "onClick")(), e.initialViewState && // depth = 3 when comparing viewStates: viewId.position.0
    !Pn(this.props.initialViewState, e.initialViewState, 3) && (this.viewState = e.initialViewState), Object.assign(this.props, e), this._setCanvasSize(this.props);
    const i = Object.create(this.props);
    Object.assign(i, {
      views: this._getViews(),
      width: this.width,
      height: this.height,
      viewState: this._getViewState()
    }), this.animationLoop?.setProps(i), this.layerManager && (this.viewManager.setProps(i), this.layerManager.activateViewport(this.getViewports()[0]), this.layerManager.setProps(i), this.effectManager.setProps(i), this.deckRenderer.setProps(i), this.deckPicker.setProps(i), this.widgetManager.setProps(i)), this.stats.get("setProps Time").timeEnd();
  }
  // Public API
  /**
   * Check if a redraw is needed
   * @returns `false` or a string summarizing the redraw reason
   */
  needsRedraw(e = { clearRedrawFlags: !1 }) {
    if (!this.layerManager)
      return !1;
    if (this.props._animate)
      return "Deck._animate";
    let i = this._needsRedraw;
    e.clearRedrawFlags && (this._needsRedraw = !1);
    const s = this.viewManager.needsRedraw(e), o = this.layerManager.needsRedraw(e), u = this.effectManager.needsRedraw(e), d = this.deckRenderer.needsRedraw(e);
    return i = i || s || o || u || d, i;
  }
  /**
   * Redraw the GL context
   * @param reason If not provided, only redraw if deemed necessary. Otherwise redraw regardless of internal states.
   * @returns
   */
  redraw(e) {
    if (!this.layerManager)
      return;
    let i = this.needsRedraw({ clearRedrawFlags: !0 });
    i = e || i, i && (this.stats.get("Redraw Count").incrementCount(), this.props._customRender ? this.props._customRender(i) : this._drawLayers(i));
  }
  /** Flag indicating that the Deck instance has initialized its resources and it's safe to call public methods. */
  get isInitialized() {
    return this.viewManager !== null;
  }
  /** Get a list of views that are currently rendered */
  getViews() {
    return Tr(this.viewManager), this.viewManager.views;
  }
  /** Get a list of viewports that are currently rendered.
   * @param rect If provided, only returns viewports within the given bounding box.
   */
  getViewports(e) {
    return Tr(this.viewManager), this.viewManager.getViewports(e);
  }
  /** Get the current canvas element. */
  getCanvas() {
    return this.canvas;
  }
  /** Query the object rendered on top at a given point */
  pickObject(e) {
    const i = this._pick("pickObject", "pickObject Time", e).result;
    return i.length ? i[0] : null;
  }
  /* Query all rendered objects at a given point */
  pickMultipleObjects(e) {
    return e.depth = e.depth || 10, this._pick("pickObject", "pickMultipleObjects Time", e).result;
  }
  /* Query all objects rendered on top within a bounding box */
  pickObjects(e) {
    return this._pick("pickObjects", "pickObjects Time", e);
  }
  /** Experimental
   * Add a global resource for sharing among layers
   */
  _addResources(e, i = !1) {
    for (const s in e)
      this.layerManager.resourceManager.add({ resourceId: s, data: e[s], forceUpdate: i });
  }
  /** Experimental
   * Remove a global resource
   */
  _removeResources(e) {
    for (const i of e)
      this.layerManager.resourceManager.remove(i);
  }
  /** Experimental
   * Register a default effect. Effects will be sorted by order, those with a low order will be rendered first
   */
  _addDefaultEffect(e) {
    this.effectManager.addDefaultEffect(e);
  }
  _addDefaultShaderModule(e) {
    this.layerManager.addDefaultShaderModule(e);
  }
  _removeDefaultShaderModule(e) {
    this.layerManager?.removeDefaultShaderModule(e);
  }
  _pick(e, i, s) {
    Tr(this.deckPicker);
    const { stats: o } = this;
    o.get("Pick Count").incrementCount(), o.get(i).timeStart();
    const u = this.deckPicker[e]({
      // layerManager, viewManager and effectManager are always defined if deckPicker is
      layers: this.layerManager.getLayers(s),
      views: this.viewManager.getViews(),
      viewports: this.getViewports(s),
      onViewportActive: this.layerManager.activateViewport,
      effects: this.effectManager.getEffects(),
      ...s
    });
    return o.get(i).timeEnd(), u;
  }
  /** Resolve props.canvas to element */
  _createCanvas(e) {
    let i = e.canvas;
    return typeof i == "string" && (i = document.getElementById(i), Tr(i)), i || (i = document.createElement("canvas"), i.id = e.id || "deckgl-overlay", (e.parent || document.body).appendChild(i)), Object.assign(i.style, e.style), i;
  }
  /** Updates canvas width and/or height, if provided as props */
  _setCanvasSize(e) {
    if (!this.canvas)
      return;
    const { width: i, height: s } = e;
    if (i || i === 0) {
      const o = Number.isFinite(i) ? `${i}px` : i;
      this.canvas.style.width = o;
    }
    if (s || s === 0) {
      const o = Number.isFinite(s) ? `${s}px` : s;
      this.canvas.style.position = e.style?.position || "absolute", this.canvas.style.height = o;
    }
  }
  /** If canvas size has changed, reads out the new size and update */
  _updateCanvasSize() {
    const { canvas: e } = this;
    if (!e)
      return;
    const i = e.clientWidth ?? e.width, s = e.clientHeight ?? e.height;
    (i !== this.width || s !== this.height) && (this.width = i, this.height = s, this.viewManager?.setProps({ width: i, height: s }), this.layerManager?.activateViewport(this.getViewports()[0]), this.props.onResize({ width: i, height: s }));
  }
  _createAnimationLoop(e, i) {
    const {
      // width,
      // height,
      gl: s,
      // deviceProps,
      // glOptions,
      // debug,
      onError: o,
      // onBeforeRender,
      // onAfterRender,
      useDevicePixels: u
    } = i;
    return new RD({
      device: e,
      useDevicePixels: u,
      // TODO v9
      autoResizeDrawingBuffer: !s,
      // do not auto resize external context
      autoResizeViewport: !1,
      // @ts-expect-error luma.gl needs to accept Promise<void> return value
      onInitialize: (d) => this._setDevice(d.device),
      onRender: this._onRenderFrame.bind(this),
      // @ts-expect-error typing mismatch: AnimationLoop does not accept onError:null
      onError: o
      // onBeforeRender,
      // onAfterRender,
    });
  }
  // Get the most relevant view state: props.viewState, if supplied, shadows internal viewState
  // TODO: For backwards compatibility ensure numeric width and height is added to the viewState
  _getViewState() {
    return this.props.viewState || this.viewState;
  }
  // Get the view descriptor list
  _getViews() {
    const { views: e } = this.props, i = Array.isArray(e) ? e : (
      // If null, default to a full screen map view port
      e ? [e] : [new Py({ id: "default-view" })]
    );
    return i.length && this.props.controller && (i[0].props.controller = this.props.controller), i;
  }
  _onContextLost() {
    const { onError: e } = this.props;
    this.animationLoop && e && e(new Error("WebGL context is lost"));
  }
  /** Actually run picking */
  _pickAndCallback() {
    const { _pickRequest: e } = this;
    if (e.event) {
      const { result: i, emptyInfo: s } = this._pick("pickObject", "pickObject Time", e);
      this.cursorState.isHovering = i.length > 0;
      let o = s, u = !1;
      for (const d of i)
        o = d, u = d.layer?.onHover(d, e.event) || u;
      u || (this.props.onHover?.(o, e.event), this.widgetManager.onHover(o, e.event)), e.event = null;
    }
  }
  _updateCursor() {
    const e = this.props.parent || this.canvas;
    e && (e.style.cursor = this.props.getCursor(this.cursorState));
  }
  _setDevice(e) {
    if (this.device = e, !this.animationLoop)
      return;
    this.canvas || (this.canvas = this.device.canvasContext?.canvas), this.device.setParametersWebGL({
      blend: !0,
      blendFunc: [770, 771, 1, 771],
      polygonOffsetFill: !0,
      depthTest: !0,
      depthFunc: 515
    }), this.props.onDeviceInitialized(this.device), this.device instanceof wa && this.props.onWebGLInitialized(this.device.gl);
    const i = new RT();
    i.play(), this.animationLoop.attachTimeline(i), this.eventManager = new oN(this.props.parent || this.canvas, {
      touchAction: this.props.touchAction,
      recognizerOptions: this.props.eventRecognizerOptions,
      events: {
        pointerdown: this._onPointerDown,
        pointermove: this._onPointerMove,
        pointerleave: this._onPointerMove
      }
    });
    for (const o in vm)
      this.eventManager.on(o, this._onEvent);
    this.viewManager = new qD({
      timeline: i,
      eventManager: this.eventManager,
      onViewStateChange: this._onViewStateChange.bind(this),
      onInteractionStateChange: this._onInteractionStateChange.bind(this),
      views: this._getViews(),
      viewState: this._getViewState(),
      width: this.width,
      height: this.height
    });
    const s = this.viewManager.getViewports()[0];
    this.layerManager = new XD(this.device, {
      deck: this,
      stats: this.stats,
      viewport: s,
      timeline: i
    }), this.effectManager = new uO({
      deck: this,
      device: this.device
    }), this.deckRenderer = new pO(this.device), this.deckPicker = new vO(this.device), this.widgetManager = new TO({
      deck: this,
      parentElement: this.canvas?.parentElement
    }), this.widgetManager.addDefault(new EO()), this.setProps(this.props), this._updateCanvasSize(), this.props.onLoad();
  }
  /** Internal only: default render function (redraw all layers and views) */
  _drawLayers(e, i) {
    const { device: s, gl: o } = this.layerManager.context;
    this.props.onBeforeRender({ device: s, gl: o });
    const u = {
      target: this.props._framebuffer,
      layers: this.layerManager.getLayers(),
      viewports: this.viewManager.getViewports(),
      onViewportActive: this.layerManager.activateViewport,
      views: this.viewManager.getViews(),
      pass: "screen",
      effects: this.effectManager.getEffects(),
      ...i
    };
    this.deckRenderer?.renderLayers(u), u.pass === "screen" && this.widgetManager.onRedraw({
      viewports: u.viewports,
      layers: u.layers
    }), this.props.onAfterRender({ device: s, gl: o });
  }
  // Callbacks
  _onRenderFrame() {
    this._getFrameStats(), this._metricsCounter++ % 60 === 0 && (this._getMetrics(), this.stats.reset(), Jt.table(4, this.metrics)(), this.props._onMetrics && this.props._onMetrics(this.metrics)), this._updateCanvasSize(), this._updateCursor(), this.layerManager.updateLayers(), this._pickAndCallback(), this.redraw(), this.viewManager && this.viewManager.updateViewStates();
  }
  // Callbacks
  _onViewStateChange(e) {
    const i = this.props.onViewStateChange(e) || e.viewState;
    this.viewState && (this.viewState = { ...this.viewState, [e.viewId]: i }, this.props.viewState || this.viewManager && this.viewManager.setProps({ viewState: this.viewState }));
  }
  _onInteractionStateChange(e) {
    this.cursorState.isDragging = e.isDragging || !1, this.props.onInteractionStateChange(e);
  }
  _getFrameStats() {
    const { stats: e } = this;
    e.get("frameRate").timeEnd(), e.get("frameRate").timeStart();
    const i = this.animationLoop.stats;
    e.get("GPU Time").addTime(i.get("GPU Time").lastTiming), e.get("CPU Time").addTime(i.get("CPU Time").lastTiming);
  }
  _getMetrics() {
    const { metrics: e, stats: i } = this;
    e.fps = i.get("frameRate").getHz(), e.setPropsTime = i.get("setProps Time").time, e.updateAttributesTime = i.get("Update Attributes").time, e.framesRedrawn = i.get("Redraw Count").count, e.pickTime = i.get("pickObject Time").time + i.get("pickMultipleObjects Time").time + i.get("pickObjects Time").time, e.pickCount = i.get("Pick Count").count, e.gpuTime = i.get("GPU Time").time, e.cpuTime = i.get("CPU Time").time, e.gpuTimePerFrame = i.get("GPU Time").getAverageTime(), e.cpuTimePerFrame = i.get("CPU Time").getAverageTime();
    const s = Yc.stats.get("Memory Usage");
    e.bufferMemory = s.get("Buffer Memory").count, e.textureMemory = s.get("Texture Memory").count, e.renderbufferMemory = s.get("Renderbuffer Memory").count, e.gpuMemory = s.get("GPU Memory").count;
  }
}
Qu.defaultProps = YT;
Qu.VERSION = oM;
function lN(t) {
  switch (t) {
    case "float64":
      return Float64Array;
    case "uint8":
    case "unorm8":
      return Uint8ClampedArray;
    default:
      return Vw(t);
  }
}
const cN = zw;
function kf(t, e) {
  return {
    attribute: t,
    // @ts-expect-error Not all combinations are valid vertex formats; it's up to DataColumn to ensure
    format: e.size > 1 ? `${e.type}x${e.size}` : e.type,
    byteOffset: e.offset || 0
    // Note stride is set on the top level
  };
}
function Tl(t) {
  return t.stride || t.size * t.bytesPerElement;
}
function hN(t, e) {
  return t.type === e.type && t.size === e.size && Tl(t) === Tl(e) && (t.offset || 0) === (e.offset || 0);
}
function Bm(t, e) {
  e.offset && Jt.removed("shaderAttribute.offset", "vertexOffset, elementOffset")();
  const i = Tl(t), s = e.vertexOffset !== void 0 ? e.vertexOffset : t.vertexOffset || 0, o = e.elementOffset || 0, u = (
    // offsets defined by the attribute
    s * i + o * t.bytesPerElement + // offsets defined by external buffers if any
    (t.offset || 0)
  );
  return {
    ...e,
    offset: u,
    stride: i
  };
}
function uN(t, e) {
  const i = Bm(t, e);
  return {
    high: i,
    low: {
      ...i,
      offset: i.offset + t.size * 4
    }
  };
}
class dN {
  /* eslint-disable max-statements */
  constructor(e, i, s) {
    this._buffer = null, this.device = e, this.id = i.id || "", this.size = i.size || 1;
    const o = i.logicalType || i.type, u = o === "float64";
    let { defaultValue: d } = i;
    d = Number.isFinite(d) ? [d] : d || new Array(this.size).fill(0);
    let a;
    u ? a = "float32" : !o && i.isIndexed ? a = "uint32" : a = o || "float32";
    let w = lN(o || a);
    this.doublePrecision = u, u && i.fp64 === !1 && (w = Float32Array), this.value = null, this.settings = {
      ...i,
      defaultType: w,
      defaultValue: d,
      logicalType: o,
      type: a,
      normalized: a.includes("norm"),
      size: this.size,
      bytesPerElement: w.BYTES_PER_ELEMENT
    }, this.state = {
      ...s,
      externalBuffer: null,
      bufferAccessor: this.settings,
      allocatedValue: null,
      numInstances: 0,
      bounds: null,
      constant: !1
    };
  }
  /* eslint-enable max-statements */
  get isConstant() {
    return this.state.constant;
  }
  get buffer() {
    return this._buffer;
  }
  get byteOffset() {
    const e = this.getAccessor();
    return e.vertexOffset ? e.vertexOffset * Tl(e) : 0;
  }
  get numInstances() {
    return this.state.numInstances;
  }
  set numInstances(e) {
    this.state.numInstances = e;
  }
  delete() {
    this._buffer && (this._buffer.delete(), this._buffer = null), Ku.release(this.state.allocatedValue);
  }
  getBuffer() {
    return this.state.constant ? null : this.state.externalBuffer || this._buffer;
  }
  getValue(e = this.id, i = null) {
    const s = {};
    if (this.state.constant) {
      const o = this.value;
      if (i) {
        const u = Bm(this.getAccessor(), i), d = u.offset / o.BYTES_PER_ELEMENT, a = u.size || this.size;
        s[e] = o.subarray(d, d + a);
      } else
        s[e] = o;
    } else
      s[e] = this.getBuffer();
    return this.doublePrecision && (this.value instanceof Float64Array ? s[`${e}64Low`] = s[e] : s[`${e}64Low`] = new Float32Array(this.size)), s;
  }
  _getBufferLayout(e = this.id, i = null) {
    const s = this.getAccessor(), o = [], u = {
      name: this.id,
      byteStride: Tl(s),
      attributes: o
    };
    if (this.doublePrecision) {
      const d = uN(s, i || {});
      o.push(kf(e, { ...s, ...d.high }), kf(`${e}64Low`, {
        ...s,
        ...d.low
      }));
    } else if (i) {
      const d = Bm(s, i);
      o.push(kf(e, { ...s, ...d }));
    } else
      o.push(kf(e, s));
    return u;
  }
  setAccessor(e) {
    this.state.bufferAccessor = e;
  }
  getAccessor() {
    return this.state.bufferAccessor;
  }
  // Returns [min: Array(size), max: Array(size)]
  /* eslint-disable max-depth */
  getBounds() {
    if (this.state.bounds)
      return this.state.bounds;
    let e = null;
    if (this.state.constant && this.value) {
      const i = Array.from(this.value);
      e = [i, i];
    } else {
      const { value: i, numInstances: s, size: o } = this, u = s * o;
      if (i && u && i.length >= u) {
        const d = new Array(o).fill(1 / 0), a = new Array(o).fill(-1 / 0);
        for (let w = 0; w < u; )
          for (let S = 0; S < o; S++) {
            const M = i[w++];
            M < d[S] && (d[S] = M), M > a[S] && (a[S] = M);
          }
        e = [d, a];
      }
    }
    return this.state.bounds = e, e;
  }
  // returns true if success
  // eslint-disable-next-line max-statements
  setData(e) {
    const { state: i } = this;
    let s;
    ArrayBuffer.isView(e) ? s = { value: e } : e instanceof Mi ? s = { buffer: e } : s = e;
    const o = { ...this.settings, ...s };
    if (ArrayBuffer.isView(s.value)) {
      if (!s.type)
        if (this.doublePrecision && s.value instanceof Float64Array)
          o.type = "float32";
        else {
          const d = cN(s.value);
          o.type = o.normalized ? d.replace("int", "norm") : d;
        }
      o.bytesPerElement = s.value.BYTES_PER_ELEMENT, o.stride = Tl(o);
    }
    if (i.bounds = null, s.constant) {
      let u = s.value;
      if (u = this._normalizeValue(u, [], 0), this.settings.normalized && (u = this.normalizeConstant(u)), !(!i.constant || !this._areValuesEqual(u, this.value)))
        return !1;
      i.externalBuffer = null, i.constant = !0, this.value = ArrayBuffer.isView(u) ? u : new Float32Array(u);
    } else if (s.buffer) {
      const u = s.buffer;
      i.externalBuffer = u, i.constant = !1, this.value = s.value || null;
    } else if (s.value) {
      this._checkExternalBuffer(s);
      let u = s.value;
      i.externalBuffer = null, i.constant = !1, this.value = u;
      let { buffer: d } = this;
      const a = Tl(o), w = (o.vertexOffset || 0) * a;
      if (this.doublePrecision && u instanceof Float64Array && (u = gg(u, o)), this.settings.isIndexed) {
        const M = this.settings.defaultType;
        u.constructor !== M && (u = new M(u));
      }
      const S = u.byteLength + w + a * 2;
      (!d || d.byteLength < S) && (d = this._createBuffer(S)), d.write(u, w);
    }
    return this.setAccessor(o), !0;
  }
  updateSubBuffer(e = {}) {
    this.state.bounds = null;
    const i = this.value, { startOffset: s = 0, endOffset: o } = e;
    this.buffer.write(this.doublePrecision && i instanceof Float64Array ? gg(i, {
      size: this.size,
      startIndex: s,
      endIndex: o
    }) : i.subarray(s, o), s * i.BYTES_PER_ELEMENT + this.byteOffset);
  }
  allocate(e, i = !1) {
    const { state: s } = this, o = s.allocatedValue, u = Ku.allocate(o, e + 1, {
      size: this.size,
      type: this.settings.defaultType,
      copy: i
    });
    this.value = u;
    const { byteOffset: d } = this;
    let { buffer: a } = this;
    return (!a || a.byteLength < u.byteLength + d) && (a = this._createBuffer(u.byteLength + d), i && o && a.write(o instanceof Float64Array ? gg(o, this) : o, d)), s.allocatedValue = u, s.constant = !1, s.externalBuffer = null, this.setAccessor(this.settings), !0;
  }
  // PRIVATE HELPER METHODS
  _checkExternalBuffer(e) {
    const { value: i } = e;
    if (!ArrayBuffer.isView(i))
      throw new Error(`Attribute ${this.id} value is not TypedArray`);
    const s = this.settings.defaultType;
    let o = !1;
    if (this.doublePrecision && (o = i.BYTES_PER_ELEMENT < 4), o)
      throw new Error(`Attribute ${this.id} does not support ${i.constructor.name}`);
    !(i instanceof s) && this.settings.normalized && !("normalized" in e) && Jt.warn(`Attribute ${this.id} is normalized`)();
  }
  // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer
  normalizeConstant(e) {
    switch (this.settings.type) {
      case "snorm8":
        return new Float32Array(e).map((i) => (i + 128) / 255 * 2 - 1);
      case "snorm16":
        return new Float32Array(e).map((i) => (i + 32768) / 65535 * 2 - 1);
      case "unorm8":
        return new Float32Array(e).map((i) => i / 255);
      case "unorm16":
        return new Float32Array(e).map((i) => i / 65535);
      default:
        return e;
    }
  }
  /* check user supplied values and apply fallback */
  _normalizeValue(e, i, s) {
    const { defaultValue: o, size: u } = this.settings;
    if (Number.isFinite(e))
      return i[s] = e, i;
    if (!e) {
      let d = u;
      for (; --d >= 0; )
        i[s + d] = o[d];
      return i;
    }
    switch (u) {
      case 4:
        i[s + 3] = Number.isFinite(e[3]) ? e[3] : o[3];
      case 3:
        i[s + 2] = Number.isFinite(e[2]) ? e[2] : o[2];
      case 2:
        i[s + 1] = Number.isFinite(e[1]) ? e[1] : o[1];
      case 1:
        i[s + 0] = Number.isFinite(e[0]) ? e[0] : o[0];
        break;
      default:
        let d = u;
        for (; --d >= 0; )
          i[s + d] = Number.isFinite(e[d]) ? e[d] : o[d];
    }
    return i;
  }
  _areValuesEqual(e, i) {
    if (!e || !i)
      return !1;
    const { size: s } = this;
    for (let o = 0; o < s; o++)
      if (e[o] !== i[o])
        return !1;
    return !0;
  }
  _createBuffer(e) {
    this._buffer && this._buffer.destroy();
    const { isIndexed: i, type: s } = this.settings;
    return this._buffer = this.device.createBuffer({
      ...this._buffer?.props,
      id: this.id,
      usage: i ? Mi.INDEX : Mi.VERTEX,
      indexType: i ? s : void 0,
      byteLength: e
    }), this._buffer;
  }
}
const Bx = [], Dx = [];
function JT(t, e = 0, i = 1 / 0) {
  let s = Bx;
  const o = {
    index: -1,
    data: t,
    // visitor can optionally utilize this to avoid constructing a new array for every object
    target: []
  };
  return t ? typeof t[Symbol.iterator] == "function" ? s = t : t.length > 0 && (Dx.length = t.length, s = Dx) : s = Bx, (e > 0 || Number.isFinite(i)) && (s = (Array.isArray(s) ? s : Array.from(s)).slice(e, i), o.index = e - 1), { iterable: s, objectInfo: o };
}
function QT(t) {
  return t && t[Symbol.asyncIterator];
}
function fN(t, e) {
  const { size: i, stride: s, offset: o, startIndices: u, nested: d } = e, a = t.BYTES_PER_ELEMENT, w = s ? s / a : i, S = o ? o / a : 0, M = Math.floor((t.length - S) / w);
  return (F, { index: N, target: L }) => {
    if (!u) {
      const Se = N * w + S;
      for (let Ee = 0; Ee < i; Ee++)
        L[Ee] = t[Se + Ee];
      return L;
    }
    const re = u[N], ne = u[N + 1] || M;
    let we;
    if (d) {
      we = new Array(ne - re);
      for (let Se = re; Se < ne; Se++) {
        const Ee = Se * w + S;
        L = new Array(i);
        for (let Ce = 0; Ce < i; Ce++)
          L[Ce] = t[Ee + Ce];
        we[Se - re] = L;
      }
    } else if (w === i)
      we = t.subarray(re * i + S, ne * i + S);
    else {
      we = new t.constructor((ne - re) * i);
      let Se = 0;
      for (let Ee = re; Ee < ne; Ee++) {
        const Ce = Ee * w + S;
        for (let Le = 0; Le < i; Le++)
          we[Se++] = t[Ce + Le];
      }
    }
    return we;
  };
}
const pN = [], tp = [[0, 1 / 0]];
function _N(t, e) {
  if (t === tp || (e[0] < 0 && (e[0] = 0), e[0] >= e[1]))
    return t;
  const i = [], s = t.length;
  let o = 0;
  for (let u = 0; u < s; u++) {
    const d = t[u];
    d[1] < e[0] ? (i.push(d), o = u + 1) : d[0] > e[1] ? i.push(d) : e = [Math.min(d[0], e[0]), Math.max(d[1], e[1])];
  }
  return i.splice(o, 0, e), i;
}
const gN = {
  interpolation: {
    duration: 0,
    easing: (t) => t
  },
  spring: {
    stiffness: 0.05,
    damping: 0.5
  }
};
function eA(t, e) {
  if (!t)
    return null;
  Number.isFinite(t) && (t = { type: "interpolation", duration: t });
  const i = t.type || "interpolation";
  return {
    ...gN[i],
    ...e,
    ...t,
    type: i
  };
}
class tA extends dN {
  constructor(e, i) {
    super(e, i, {
      startIndices: null,
      lastExternalBuffer: null,
      binaryValue: null,
      binaryAccessor: null,
      needsUpdate: !0,
      needsRedraw: !1,
      layoutChanged: !1,
      updateRanges: tp
    }), this.constant = !1, this.settings.update = i.update || (i.accessor ? this._autoUpdater : void 0), Object.seal(this.settings), Object.seal(this.state), this._validateAttributeUpdaters();
  }
  get startIndices() {
    return this.state.startIndices;
  }
  set startIndices(e) {
    this.state.startIndices = e;
  }
  needsUpdate() {
    return this.state.needsUpdate;
  }
  needsRedraw({ clearChangedFlags: e = !1 } = {}) {
    const i = this.state.needsRedraw;
    return this.state.needsRedraw = i && !e, i;
  }
  layoutChanged() {
    return this.state.layoutChanged;
  }
  setAccessor(e) {
    var i;
    (i = this.state).layoutChanged || (i.layoutChanged = !hN(e, this.getAccessor())), super.setAccessor(e);
  }
  getUpdateTriggers() {
    const { accessor: e } = this.settings;
    return [this.id].concat(typeof e != "function" && e || []);
  }
  supportsTransition() {
    return !!this.settings.transition;
  }
  // Resolve transition settings object if transition is enabled, otherwise `null`
  getTransitionSetting(e) {
    if (!e || !this.supportsTransition())
      return null;
    const { accessor: i } = this.settings, s = this.settings.transition, o = Array.isArray(i) ? (
      // @ts-ignore
      e[i.find((u) => e[u])]
    ) : (
      // @ts-ignore
      e[i]
    );
    return eA(o, s);
  }
  setNeedsUpdate(e = this.id, i) {
    if (this.state.needsUpdate = this.state.needsUpdate || e, this.setNeedsRedraw(e), i) {
      const { startRow: s = 0, endRow: o = 1 / 0 } = i;
      this.state.updateRanges = _N(this.state.updateRanges, [s, o]);
    } else
      this.state.updateRanges = tp;
  }
  clearNeedsUpdate() {
    this.state.needsUpdate = !1, this.state.updateRanges = pN;
  }
  setNeedsRedraw(e = this.id) {
    this.state.needsRedraw = this.state.needsRedraw || e;
  }
  allocate(e) {
    const { state: i, settings: s } = this;
    return s.noAlloc ? !1 : s.update ? (super.allocate(e, i.updateRanges !== tp), !0) : !1;
  }
  updateBuffer({ numInstances: e, data: i, props: s, context: o }) {
    if (!this.needsUpdate())
      return !1;
    const { state: { updateRanges: u }, settings: { update: d, noAlloc: a } } = this;
    let w = !0;
    if (d) {
      for (const [S, M] of u)
        d.call(o, this, { data: i, startRow: S, endRow: M, props: s, numInstances: e });
      if (this.value) if (this.constant || !this.buffer || this.buffer.byteLength < this.value.byteLength + this.byteOffset)
        this.setData({
          value: this.value,
          constant: this.constant
        }), this.constant = !1;
      else
        for (const [S, M] of u) {
          const F = Number.isFinite(S) ? this.getVertexOffset(S) : 0, N = Number.isFinite(M) ? this.getVertexOffset(M) : a || !Number.isFinite(e) ? this.value.length : e * this.size;
          super.updateSubBuffer({ startOffset: F, endOffset: N });
        }
      this._checkAttributeArray();
    } else
      w = !1;
    return this.clearNeedsUpdate(), this.setNeedsRedraw(), w;
  }
  // Use generic value
  // Returns true if successful
  setConstantValue(e) {
    return e === void 0 || typeof e == "function" ? !1 : (this.setData({ constant: !0, value: e }) && this.setNeedsRedraw(), this.clearNeedsUpdate(), !0);
  }
  // Use external buffer
  // Returns true if successful
  // eslint-disable-next-line max-statements
  setExternalBuffer(e) {
    const { state: i } = this;
    return e ? (this.clearNeedsUpdate(), i.lastExternalBuffer === e || (i.lastExternalBuffer = e, this.setNeedsRedraw(), this.setData(e)), !0) : (i.lastExternalBuffer = null, !1);
  }
  // Binary value is a typed array packed from mapping the source data with the accessor
  // If the returned value from the accessor is the same as the attribute value, set it directly
  // Otherwise use the auto updater for transform/normalization
  setBinaryValue(e, i = null) {
    const { state: s, settings: o } = this;
    if (!e)
      return s.binaryValue = null, s.binaryAccessor = null, !1;
    if (o.noAlloc)
      return !1;
    if (s.binaryValue === e)
      return this.clearNeedsUpdate(), !0;
    if (s.binaryValue = e, this.setNeedsRedraw(), o.transform || i !== this.startIndices) {
      ArrayBuffer.isView(e) && (e = { value: e });
      const d = e;
      Tr(ArrayBuffer.isView(d.value), `invalid ${o.accessor}`);
      const a = !!d.size && d.size !== this.size;
      return s.binaryAccessor = fN(d.value, {
        size: d.size || this.size,
        stride: d.stride,
        offset: d.offset,
        startIndices: i,
        nested: a
      }), !1;
    }
    return this.clearNeedsUpdate(), this.setData(e), !0;
  }
  getVertexOffset(e) {
    const { startIndices: i } = this;
    return (i ? e < i.length ? i[e] : this.numInstances : e) * this.size;
  }
  getValue() {
    const e = this.settings.shaderAttributes, i = super.getValue();
    if (!e)
      return i;
    for (const s in e)
      Object.assign(i, super.getValue(s, e[s]));
    return i;
  }
  /** Generate WebGPU-style buffer layout descriptor from this attribute */
  getBufferLayout(e) {
    this.state.layoutChanged = !1;
    const i = this.settings.shaderAttributes, s = super._getBufferLayout(), { stepMode: o } = this.settings;
    if (o === "dynamic" ? s.stepMode = e ? e.isInstanced ? "instance" : "vertex" : "instance" : s.stepMode = o ?? "vertex", !i)
      return s;
    for (const u in i) {
      const d = super._getBufferLayout(u, i[u]);
      s.attributes.push(...d.attributes);
    }
    return s;
  }
  /* eslint-disable max-depth, max-statements */
  _autoUpdater(e, { data: i, startRow: s, endRow: o, props: u, numInstances: d }) {
    if (e.constant)
      return;
    const { settings: a, state: w, value: S, size: M, startIndices: F } = e, { accessor: N, transform: L } = a, re = w.binaryAccessor || // @ts-ignore
    (typeof N == "function" ? N : u[N]);
    Tr(typeof re == "function", `accessor "${N}" is not a function`);
    let ne = e.getVertexOffset(s);
    const { iterable: we, objectInfo: Se } = JT(i, s, o);
    for (const Ee of we) {
      Se.index++;
      let Ce = re(Ee, Se);
      if (L && (Ce = L.call(this, Ce)), F) {
        const Le = (Se.index < F.length - 1 ? F[Se.index + 1] : d) - F[Se.index];
        if (Ce && Array.isArray(Ce[0])) {
          let Ze = ne;
          for (const Ke of Ce)
            e._normalizeValue(Ke, S, Ze), Ze += M;
        } else Ce && Ce.length > M ? S.set(Ce, ne) : (e._normalizeValue(Ce, Se.target, 0), jD({
          target: S,
          source: Se.target,
          start: ne,
          count: Le
        }));
        ne += Le * M;
      } else
        e._normalizeValue(Ce, S, ne), ne += M;
    }
  }
  /* eslint-enable max-depth, max-statements */
  // Validate deck.gl level fields
  _validateAttributeUpdaters() {
    const { settings: e } = this;
    if (!(e.noAlloc || typeof e.update == "function"))
      throw new Error(`Attribute ${this.id} missing update or accessor`);
  }
  // check that the first few elements of the attribute are reasonable
  /* eslint-disable no-fallthrough */
  _checkAttributeArray() {
    const { value: e } = this, i = Math.min(4, this.size);
    if (e && e.length >= i) {
      let s = !0;
      switch (i) {
        case 4:
          s = s && Number.isFinite(e[3]);
        case 3:
          s = s && Number.isFinite(e[2]);
        case 2:
          s = s && Number.isFinite(e[1]);
        case 1:
          s = s && Number.isFinite(e[0]);
          break;
        default:
          s = !1;
      }
      if (!s)
        throw new Error(`Illegal attribute generated for ${this.id}`);
    }
  }
}
function Pg(t) {
  const { source: e, target: i, start: s = 0, size: o, getData: u } = t, d = t.end || i.length, a = e.length, w = d - s;
  if (a > w) {
    i.set(e.subarray(0, w), s);
    return;
  }
  if (i.set(e, s), !u)
    return;
  let S = a;
  for (; S < w; ) {
    const M = u(S, e);
    for (let F = 0; F < o; F++)
      i[s + S] = M[F] || 0, S++;
  }
}
function mN({ source: t, target: e, size: i, getData: s, sourceStartIndices: o, targetStartIndices: u }) {
  if (!o || !u)
    return Pg({
      source: t,
      target: e,
      size: i,
      getData: s
    }), e;
  let d = 0, a = 0;
  const w = s && ((M, F) => s(M + a, F)), S = Math.min(o.length, u.length);
  for (let M = 1; M < S; M++) {
    const F = o[M] * i, N = u[M] * i;
    Pg({
      source: t.subarray(d, F),
      target: e,
      start: a,
      end: N,
      size: i,
      getData: w
    }), d = F, a = N;
  }
  return a < e.length && Pg({
    // @ts-ignore
    source: [],
    target: e,
    start: a,
    size: i,
    getData: w
  }), e;
}
function yN(t) {
  const { device: e, settings: i, value: s } = t, o = new tA(e, i);
  return o.setData({
    value: s instanceof Float64Array ? new Float64Array(0) : new Float32Array(0),
    normalized: i.normalized
  }), o;
}
function iA(t) {
  switch (t) {
    case 1:
      return "float";
    case 2:
      return "vec2";
    case 3:
      return "vec3";
    case 4:
      return "vec4";
    default:
      throw new Error(`No defined attribute type for size "${t}"`);
  }
}
function rA(t) {
  switch (t) {
    case 1:
      return "float32";
    case 2:
      return "float32x2";
    case 3:
      return "float32x3";
    case 4:
      return "float32x4";
    default:
      throw new Error("invalid type size");
  }
}
function sA(t) {
  t.push(t.shift());
}
function bN(t, e) {
  const { doublePrecision: i, settings: s, value: o, size: u } = t, d = i && o instanceof Float64Array ? 2 : 1;
  let a = 0;
  const { shaderAttributes: w } = t.settings;
  if (w)
    for (const S of Object.values(w))
      a = Math.max(a, S.vertexOffset ?? 0);
  return (s.noAlloc ? o.length : (e + a) * u) * d;
}
function nA({ device: t, source: e, target: i }) {
  return (!i || i.byteLength < e.byteLength) && (i?.destroy(), i = t.createBuffer({
    byteLength: e.byteLength,
    usage: e.usage
  })), i;
}
function oA({ device: t, buffer: e, attribute: i, fromLength: s, toLength: o, fromStartIndices: u, getData: d = (a) => a }) {
  const a = i.doublePrecision && i.value instanceof Float64Array ? 2 : 1, w = i.size * a, S = i.byteOffset, M = i.settings.bytesPerElement < 4 ? S / i.settings.bytesPerElement * 4 : S, F = i.startIndices, N = u && F, L = i.isConstant;
  if (!N && e && s >= o)
    return e;
  const re = i.value instanceof Float64Array ? Float32Array : i.value.constructor, ne = L ? i.value : (
    // TODO(v9.1): Avoid non-portable synchronous reads.
    new re(i.getBuffer().readSyncWebGL(S, o * re.BYTES_PER_ELEMENT).buffer)
  );
  if (i.settings.normalized && !L) {
    const Ce = d;
    d = (Le, Ze) => i.normalizeConstant(Ce(Le, Ze));
  }
  const we = L ? (Ce, Le) => d(ne, Le) : (Ce, Le) => d(ne.subarray(Ce + S, Ce + S + w), Le), Se = e ? new Float32Array(e.readSyncWebGL(M, s * 4).buffer) : new Float32Array(0), Ee = new Float32Array(o);
  return mN({
    source: Se,
    target: Ee,
    sourceStartIndices: u,
    targetStartIndices: F,
    size: w,
    getData: we
  }), (!e || e.byteLength < Ee.byteLength + M) && (e?.destroy(), e = t.createBuffer({
    byteLength: Ee.byteLength + M,
    usage: 35050
  })), e.write(Ee, M), e;
}
class aA {
  constructor({ device: e, attribute: i, timeline: s }) {
    this.buffers = [], this.currentLength = 0, this.device = e, this.transition = new Bp(s), this.attribute = i, this.attributeInTransition = yN(i), this.currentStartIndices = i.startIndices;
  }
  get inProgress() {
    return this.transition.inProgress;
  }
  start(e, i, s = 1 / 0) {
    this.settings = e, this.currentStartIndices = this.attribute.startIndices, this.currentLength = bN(this.attribute, i), this.transition.start({ ...e, duration: s });
  }
  update() {
    const e = this.transition.update();
    return e && this.onUpdate(), e;
  }
  setBuffer(e) {
    this.attributeInTransition.setData({
      buffer: e,
      normalized: this.attribute.settings.normalized,
      // Retain placeholder value to generate correct shader layout
      value: this.attributeInTransition.value
    });
  }
  cancel() {
    this.transition.cancel();
  }
  delete() {
    this.cancel();
    for (const e of this.buffers)
      e.destroy();
    this.buffers.length = 0;
  }
}
class vN extends aA {
  constructor({ device: e, attribute: i, timeline: s }) {
    super({ device: e, attribute: i, timeline: s }), this.type = "interpolation", this.transform = TN(e, i);
  }
  start(e, i) {
    const s = this.currentLength, o = this.currentStartIndices;
    if (super.start(e, i, e.duration), e.duration <= 0) {
      this.transition.cancel();
      return;
    }
    const { buffers: u, attribute: d } = this;
    sA(u), u[0] = oA({
      device: this.device,
      buffer: u[0],
      attribute: d,
      fromLength: s,
      toLength: this.currentLength,
      fromStartIndices: o,
      getData: e.enter
    }), u[1] = nA({
      device: this.device,
      source: u[0],
      target: u[1]
    }), this.setBuffer(u[1]);
    const { transform: a } = this, w = a.model;
    let S = Math.floor(this.currentLength / d.size);
    lA(d) && (S /= 2), w.setVertexCount(S), d.isConstant ? (w.setAttributes({ aFrom: u[0] }), w.setConstantAttributes({ aTo: d.value })) : w.setAttributes({
      aFrom: u[0],
      aTo: d.getBuffer()
    }), a.transformFeedback.setBuffers({ vCurrent: u[1] });
  }
  onUpdate() {
    const { duration: e, easing: i } = this.settings, { time: s } = this.transition;
    let o = s / e;
    i && (o = i(o));
    const { model: u } = this.transform;
    u.setUniforms({ time: o }), this.transform.run({ discard: !0 });
  }
  delete() {
    super.delete(), this.transform.destroy();
  }
}
const xN = `#version 300 es
#define SHADER_NAME interpolation-transition-vertex-shader

uniform float time;
in ATTRIBUTE_TYPE aFrom;
in ATTRIBUTE_TYPE aTo;
out ATTRIBUTE_TYPE vCurrent;

void main(void) {
  vCurrent = mix(aFrom, aTo, time);
  gl_Position = vec4(0.0);
}
`, wN = `#version 300 es
#define SHADER_NAME interpolation-transition-vertex-shader

uniform float time;
in ATTRIBUTE_TYPE aFrom;
in ATTRIBUTE_TYPE aFrom64Low;
in ATTRIBUTE_TYPE aTo;
in ATTRIBUTE_TYPE aTo64Low;
out ATTRIBUTE_TYPE vCurrent;
out ATTRIBUTE_TYPE vCurrent64Low;

vec2 mix_fp64(vec2 a, vec2 b, float x) {
  vec2 range = sub_fp64(b, a);
  return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));
}

void main(void) {
  for (int i=0; i<ATTRIBUTE_SIZE; i++) {
    vec2 value = mix_fp64(vec2(aFrom[i], aFrom64Low[i]), vec2(aTo[i], aTo64Low[i]), time);
    vCurrent[i] = value.x;
    vCurrent64Low[i] = value.y;
  }
  gl_Position = vec4(0.0);
}
`;
function lA(t) {
  return t.doublePrecision && t.value instanceof Float64Array;
}
function TN(t, e) {
  const i = e.size, s = iA(i), o = rA(i), u = e.getBufferLayout();
  return lA(e) ? new Yu(t, {
    vs: wN,
    bufferLayout: [
      {
        name: "aFrom",
        byteStride: 8 * i,
        attributes: [
          { attribute: "aFrom", format: o, byteOffset: 0 },
          { attribute: "aFrom64Low", format: o, byteOffset: 4 * i }
        ]
      },
      {
        name: "aTo",
        byteStride: 8 * i,
        attributes: [
          { attribute: "aTo", format: o, byteOffset: 0 },
          { attribute: "aTo64Low", format: o, byteOffset: 4 * i }
        ]
      }
    ],
    modules: [OP],
    defines: {
      ATTRIBUTE_TYPE: s,
      ATTRIBUTE_SIZE: i
    },
    // Default uniforms are not set without this
    moduleSettings: {},
    varyings: ["vCurrent", "vCurrent64Low"],
    // @ts-expect-error WebGLRenderPipeline only prop TODO - support in RenderPipeline?
    bufferMode: 35980,
    disableWarnings: !0
  }) : new Yu(t, {
    vs: xN,
    bufferLayout: [
      { name: "aFrom", format: o },
      { name: "aTo", format: u.attributes[0].format }
    ],
    defines: {
      ATTRIBUTE_TYPE: s
    },
    varyings: ["vCurrent"],
    disableWarnings: !0
  });
}
class AN extends aA {
  constructor({ device: e, attribute: i, timeline: s }) {
    super({ device: e, attribute: i, timeline: s }), this.type = "spring", this.texture = IN(e), this.framebuffer = MN(e, this.texture), this.transform = CN(e, i);
  }
  start(e, i) {
    const s = this.currentLength, o = this.currentStartIndices;
    super.start(e, i);
    const { buffers: u, attribute: d } = this;
    for (let w = 0; w < 2; w++)
      u[w] = oA({
        device: this.device,
        buffer: u[w],
        attribute: d,
        fromLength: s,
        toLength: this.currentLength,
        fromStartIndices: o,
        getData: e.enter
      });
    u[2] = nA({
      device: this.device,
      source: u[0],
      target: u[2]
    }), this.setBuffer(u[1]);
    const { model: a } = this.transform;
    a.setVertexCount(Math.floor(this.currentLength / d.size)), d.isConstant ? a.setConstantAttributes({ aTo: d.value }) : a.setAttributes({ aTo: d.getBuffer() });
  }
  onUpdate() {
    const { buffers: e, transform: i, framebuffer: s, transition: o } = this, u = this.settings;
    i.model.setAttributes({
      aPrev: e[0],
      aCur: e[1]
    }), i.transformFeedback.setBuffers({ vNext: e[2] }), i.model.setUniforms({
      stiffness: u.stiffness,
      damping: u.damping
    }), i.run({
      framebuffer: s,
      discard: !1,
      parameters: { viewport: [0, 0, 1, 1] },
      clearColor: [0, 0, 0, 0]
    }), sA(e), this.setBuffer(e[1]), this.device.readPixelsToArrayWebGL(s)[0] > 0 || o.end();
  }
  delete() {
    super.delete(), this.transform.destroy(), this.texture.destroy(), this.framebuffer.destroy();
  }
}
const EN = `#version 300 es
#define SHADER_NAME spring-transition-vertex-shader

#define EPSILON 0.00001

uniform float stiffness;
uniform float damping;
in ATTRIBUTE_TYPE aPrev;
in ATTRIBUTE_TYPE aCur;
in ATTRIBUTE_TYPE aTo;
out ATTRIBUTE_TYPE vNext;
out float vIsTransitioningFlag;

ATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {
  ATTRIBUTE_TYPE velocity = cur - prev;
  ATTRIBUTE_TYPE delta = dest - cur;
  ATTRIBUTE_TYPE spring = delta * stiffness;
  ATTRIBUTE_TYPE damper = velocity * -1.0 * damping;
  return spring + damper + velocity + cur;
}

void main(void) {
  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;
  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;

  vNext = getNextValue(aCur, aPrev, aTo);
  gl_Position = vec4(0, 0, 0, 1);
  gl_PointSize = 100.0;
}
`, SN = `#version 300 es
#define SHADER_NAME spring-transition-is-transitioning-fragment-shader

in float vIsTransitioningFlag;

out vec4 fragColor;

void main(void) {
  if (vIsTransitioningFlag == 0.0) {
    discard;
  }
  fragColor = vec4(1.0);
}`;
function CN(t, e) {
  const i = iA(e.size), s = rA(e.size);
  return new Yu(t, {
    vs: EN,
    fs: SN,
    bufferLayout: [
      { name: "aPrev", format: s },
      { name: "aCur", format: s },
      { name: "aTo", format: e.getBufferLayout().attributes[0].format }
    ],
    varyings: ["vNext"],
    defines: { ATTRIBUTE_TYPE: i },
    parameters: {
      depthCompare: "always",
      blendColorOperation: "max",
      blendColorSrcFactor: "one",
      blendColorDstFactor: "one",
      blendAlphaOperation: "max",
      blendAlphaSrcFactor: "one",
      blendAlphaDstFactor: "one"
    }
  });
}
function IN(t) {
  return t.createTexture({
    data: new Uint8Array(4),
    format: "rgba8unorm",
    mipmaps: !1,
    // dataFormat: GL.RGBA,
    width: 1,
    height: 1
  });
}
function MN(t, e) {
  return t.createFramebuffer({
    id: "spring-transition-is-transitioning-framebuffer",
    width: 1,
    height: 1,
    colorAttachments: [e]
  });
}
const RN = {
  interpolation: vN,
  spring: AN
};
class PN {
  constructor(e, { id: i, timeline: s }) {
    if (!e)
      throw new Error("AttributeTransitionManager is constructed without device");
    this.id = i, this.device = e, this.timeline = s, this.transitions = {}, this.needsRedraw = !1, this.numInstances = 1;
  }
  finalize() {
    for (const e in this.transitions)
      this._removeTransition(e);
  }
  /* Public methods */
  // Called when attribute manager updates
  // Check the latest attributes for updates.
  update({ attributes: e, transitions: i, numInstances: s }) {
    this.numInstances = s || 1;
    for (const o in e) {
      const u = e[o], d = u.getTransitionSetting(i);
      d && this._updateAttribute(o, u, d);
    }
    for (const o in this.transitions) {
      const u = e[o];
      (!u || !u.getTransitionSetting(i)) && this._removeTransition(o);
    }
  }
  // Returns `true` if attribute is transition-enabled
  hasAttribute(e) {
    const i = this.transitions[e];
    return i && i.inProgress;
  }
  // Get all the animated attributes
  getAttributes() {
    const e = {};
    for (const i in this.transitions) {
      const s = this.transitions[i];
      s.inProgress && (e[i] = s.attributeInTransition);
    }
    return e;
  }
  /* eslint-disable max-statements */
  // Called every render cycle, run transform feedback
  // Returns `true` if anything changes
  run() {
    if (this.numInstances === 0)
      return !1;
    for (const i in this.transitions)
      this.transitions[i].update() && (this.needsRedraw = !0);
    const e = this.needsRedraw;
    return this.needsRedraw = !1, e;
  }
  /* eslint-enable max-statements */
  /* Private methods */
  _removeTransition(e) {
    this.transitions[e].delete(), delete this.transitions[e];
  }
  // Check an attributes for updates
  // Returns a transition object if a new transition is triggered.
  _updateAttribute(e, i, s) {
    const o = this.transitions[e];
    let u = !o || o.type !== s.type;
    if (u) {
      o && this._removeTransition(e);
      const d = RN[s.type];
      d ? this.transitions[e] = new d({
        attribute: i,
        timeline: this.timeline,
        device: this.device
      }) : (Jt.error(`unsupported transition type '${s.type}'`)(), u = !1);
    }
    (u || i.needsRedraw()) && (this.needsRedraw = !0, this.transitions[e].start(s, this.numInstances));
  }
}
const Ox = "attributeManager.invalidate", BN = "attributeManager.updateStart", DN = "attributeManager.updateEnd", ON = "attribute.updateStart", FN = "attribute.allocate", kN = "attribute.updateEnd";
class NN {
  constructor(e, { id: i = "attribute-manager", stats: s, timeline: o } = {}) {
    this.mergeBoundsMemoized = ld(bD), this.id = i, this.device = e, this.attributes = {}, this.updateTriggers = {}, this.needsRedraw = !0, this.userData = {}, this.stats = s, this.attributeTransitionManager = new PN(e, {
      id: `${i}-transitions`,
      timeline: o
    }), Object.seal(this);
  }
  finalize() {
    for (const e in this.attributes)
      this.attributes[e].delete();
    this.attributeTransitionManager.finalize();
  }
  // Returns the redraw flag, optionally clearing it.
  // Redraw flag will be set if any attributes attributes changed since
  // flag was last cleared.
  //
  // @param {String} [clearRedrawFlags=false] - whether to clear the flag
  // @return {false|String} - reason a redraw is needed.
  getNeedsRedraw(e = { clearRedrawFlags: !1 }) {
    const i = this.needsRedraw;
    return this.needsRedraw = this.needsRedraw && !e.clearRedrawFlags, i && this.id;
  }
  // Sets the redraw flag.
  // @param {Boolean} redraw=true
  setNeedsRedraw() {
    this.needsRedraw = !0;
  }
  // Adds attributes
  add(e) {
    this._add(e);
  }
  // Adds attributes
  addInstanced(e) {
    this._add(e, { stepMode: "instance" });
  }
  /**
   * Removes attributes
   * Takes an array of attribute names and delete them from
   * the attribute map if they exists
   *
   * @example
   * attributeManager.remove(['position']);
   *
   * @param {Object} attributeNameArray - attribute name array (see above)
   */
  remove(e) {
    for (const i of e)
      this.attributes[i] !== void 0 && (this.attributes[i].delete(), delete this.attributes[i]);
  }
  // Marks an attribute for update
  invalidate(e, i) {
    const s = this._invalidateTrigger(e, i);
    Yr(Ox, this, e, s);
  }
  invalidateAll(e) {
    for (const i in this.attributes)
      this.attributes[i].setNeedsUpdate(i, e);
    Yr(Ox, this, "all");
  }
  // Ensure all attribute buffers are updated from props or data.
  // eslint-disable-next-line complexity
  update({ data: e, numInstances: i, startIndices: s = null, transitions: o, props: u = {}, buffers: d = {}, context: a = {} }) {
    let w = !1;
    Yr(BN, this), this.stats && this.stats.get("Update Attributes").timeStart();
    for (const S in this.attributes) {
      const M = this.attributes[S], F = M.settings.accessor;
      M.startIndices = s, M.numInstances = i, u[S] && Jt.removed(`props.${S}`, `data.attributes.${S}`)(), M.setExternalBuffer(d[S]) || M.setBinaryValue(typeof F == "string" ? d[F] : void 0, e.startIndices) || typeof F == "string" && !d[F] && M.setConstantValue(u[F]) || M.needsUpdate() && (w = !0, this._updateAttribute({
        attribute: M,
        numInstances: i,
        data: e,
        props: u,
        context: a
      })), this.needsRedraw = this.needsRedraw || M.needsRedraw();
    }
    w && Yr(DN, this, i), this.stats && this.stats.get("Update Attributes").timeEnd(), this.attributeTransitionManager.update({
      attributes: this.attributes,
      numInstances: i,
      transitions: o
    });
  }
  // Update attribute transition to the current timestamp
  // Returns `true` if any transition is in progress
  updateTransition() {
    const { attributeTransitionManager: e } = this, i = e.run();
    return this.needsRedraw = this.needsRedraw || i, i;
  }
  /**
   * Returns all attribute descriptors
   * Note: Format matches luma.gl Model/Program.setAttributes()
   * @return {Object} attributes - descriptors
   */
  getAttributes() {
    return { ...this.attributes, ...this.attributeTransitionManager.getAttributes() };
  }
  /**
   * Computes the spatial bounds of a given set of attributes
   */
  getBounds(e) {
    const i = e.map((s) => this.attributes[s]?.getBounds());
    return this.mergeBoundsMemoized(i);
  }
  /**
   * Returns changed attribute descriptors
   * This indicates which WebGLBuffers need to be updated
   * @return {Object} attributes - descriptors
   */
  getChangedAttributes(e = { clearChangedFlags: !1 }) {
    const { attributes: i, attributeTransitionManager: s } = this, o = { ...s.getAttributes() };
    for (const u in i) {
      const d = i[u];
      d.needsRedraw(e) && !s.hasAttribute(u) && (o[u] = d);
    }
    return o;
  }
  /** Generate WebGPU-style buffer layout descriptors from all attributes */
  getBufferLayouts(e) {
    return Object.values(this.getAttributes()).map((i) => i.getBufferLayout(e));
  }
  // PRIVATE METHODS
  /** Register new attributes */
  _add(e, i) {
    for (const s in e) {
      const o = e[s], u = {
        ...o,
        id: s,
        size: o.isIndexed && 1 || o.size || 1,
        ...i
      };
      this.attributes[s] = new tA(this.device, u);
    }
    this._mapUpdateTriggersToAttributes();
  }
  // build updateTrigger name to attribute name mapping
  _mapUpdateTriggersToAttributes() {
    const e = {};
    for (const i in this.attributes)
      this.attributes[i].getUpdateTriggers().forEach((o) => {
        e[o] || (e[o] = []), e[o].push(i);
      });
    this.updateTriggers = e;
  }
  _invalidateTrigger(e, i) {
    const { attributes: s, updateTriggers: o } = this, u = o[e];
    return u && u.forEach((d) => {
      const a = s[d];
      a && a.setNeedsUpdate(a.id, i);
    }), u;
  }
  _updateAttribute(e) {
    const { attribute: i, numInstances: s } = e;
    if (Yr(ON, i), i.constant) {
      i.setConstantValue(i.value);
      return;
    }
    i.allocate(s) && Yr(FN, i, s), i.updateBuffer(e) && (this.needsRedraw = !0, Yr(kN, i, s));
  }
}
class LN extends Bp {
  get value() {
    return this._value;
  }
  _onUpdate() {
    const { time: e, settings: { fromValue: i, toValue: s, duration: o, easing: u } } = this, d = u(e / o);
    this._value = dp(i, s, d);
  }
}
const Fx = 1e-5;
function kx(t, e, i, s, o) {
  const u = e - t, a = (i - e) * o, w = -u * s;
  return a + w + u + e;
}
function UN(t, e, i, s, o) {
  if (Array.isArray(i)) {
    const u = [];
    for (let d = 0; d < i.length; d++)
      u[d] = kx(t[d], e[d], i[d], s, o);
    return u;
  }
  return kx(t, e, i, s, o);
}
function Nx(t, e) {
  if (Array.isArray(t)) {
    let i = 0;
    for (let s = 0; s < t.length; s++) {
      const o = t[s] - e[s];
      i += o * o;
    }
    return Math.sqrt(i);
  }
  return Math.abs(t - e);
}
class zN extends Bp {
  get value() {
    return this._currValue;
  }
  _onUpdate() {
    const { fromValue: e, toValue: i, damping: s, stiffness: o } = this.settings, { _prevValue: u = e, _currValue: d = e } = this;
    let a = UN(u, d, i, s, o);
    const w = Nx(a, i), S = Nx(a, d);
    w < Fx && S < Fx && (a = i, this.end()), this._prevValue = d, this._currValue = a;
  }
}
const VN = {
  interpolation: LN,
  spring: zN
};
class jN {
  constructor(e) {
    this.transitions = /* @__PURE__ */ new Map(), this.timeline = e;
  }
  get active() {
    return this.transitions.size > 0;
  }
  add(e, i, s, o) {
    const { transitions: u } = this;
    if (u.has(e)) {
      const w = u.get(e), { value: S = w.settings.fromValue } = w;
      i = S, this.remove(e);
    }
    if (o = eA(o), !o)
      return;
    const d = VN[o.type];
    if (!d) {
      Jt.error(`unsupported transition type '${o.type}'`)();
      return;
    }
    const a = new d(this.timeline);
    a.start({
      ...o,
      fromValue: i,
      toValue: s
    }), u.set(e, a);
  }
  remove(e) {
    const { transitions: i } = this;
    i.has(e) && (i.get(e).cancel(), i.delete(e));
  }
  update() {
    const e = {};
    for (const [i, s] of this.transitions)
      s.update(), e[i] = s.value, s.inProgress || this.remove(i);
    return e;
  }
  clear() {
    for (const e of this.transitions.keys())
      this.remove(e);
  }
}
function HN(t) {
  const e = t[Ta];
  for (const i in e) {
    const s = e[i], { validate: o } = s;
    if (o && !o(t[i], s))
      throw new Error(`Invalid prop ${i}: ${t[i]}`);
  }
}
function $N(t, e) {
  const i = cA({
    newProps: t,
    oldProps: e,
    propTypes: t[Ta],
    ignoreProps: { data: null, updateTriggers: null, extensions: null, transitions: null }
  }), s = WN(t, e);
  let o = !1;
  return s || (o = XN(t, e)), {
    dataChanged: s,
    propsChanged: i,
    updateTriggersChanged: o,
    extensionsChanged: qN(t, e),
    transitionsChanged: GN(t, e)
  };
}
function GN(t, e) {
  if (!t.transitions)
    return !1;
  const i = {}, s = t[Ta];
  let o = !1;
  for (const u in t.transitions) {
    const d = s[u], a = d && d.type;
    (a === "number" || a === "color" || a === "array") && Dm(t[u], e[u], d) && (i[u] = !0, o = !0);
  }
  return o ? i : !1;
}
function cA({ newProps: t, oldProps: e, ignoreProps: i = {}, propTypes: s = {}, triggerName: o = "props" }) {
  if (e === t)
    return !1;
  if (typeof t != "object" || t === null)
    return `${o} changed shallowly`;
  if (typeof e != "object" || e === null)
    return `${o} changed shallowly`;
  for (const u of Object.keys(t))
    if (!(u in i)) {
      if (!(u in e))
        return `${o}.${u} added`;
      const d = Dm(t[u], e[u], s[u]);
      if (d)
        return `${o}.${u} ${d}`;
    }
  for (const u of Object.keys(e))
    if (!(u in i)) {
      if (!(u in t))
        return `${o}.${u} dropped`;
      if (!Object.hasOwnProperty.call(t, u)) {
        const d = Dm(t[u], e[u], s[u]);
        if (d)
          return `${o}.${u} ${d}`;
      }
    }
  return !1;
}
function Dm(t, e, i) {
  let s = i && i.equal;
  return s && !s(t, e, i) || !s && (s = t && e && t.equals, s && !s.call(t, e)) ? "changed deeply" : !s && e !== t ? "changed shallowly" : null;
}
function WN(t, e) {
  if (e === null)
    return "oldProps is null, initial diff";
  let i = !1;
  const { dataComparator: s, _dataDiff: o } = t;
  return s ? s(t.data, e.data) || (i = "Data comparator detected a change") : t.data !== e.data && (i = "A new data container was supplied"), i && o && (i = o(t.data, e.data) || i), i;
}
function XN(t, e) {
  if (e === null)
    return { all: !0 };
  if ("all" in t.updateTriggers && Lx(t, e, "all"))
    return { all: !0 };
  const i = {};
  let s = !1;
  for (const o in t.updateTriggers)
    o !== "all" && Lx(t, e, o) && (i[o] = !0, s = !0);
  return s ? i : !1;
}
function qN(t, e) {
  if (e === null)
    return !0;
  const i = e.extensions, { extensions: s } = t;
  if (s === i)
    return !1;
  if (!i || !s || s.length !== i.length)
    return !0;
  for (let o = 0; o < s.length; o++)
    if (!s[o].equals(i[o]))
      return !0;
  return !1;
}
function Lx(t, e, i) {
  let s = t.updateTriggers[i];
  s = s ?? {};
  let o = e.updateTriggers[i];
  return o = o ?? {}, cA({
    oldProps: o,
    newProps: s,
    triggerName: i
  });
}
const ZN = "count(): argument not an object", KN = "count(): argument not a container";
function YN(t) {
  if (!QN(t))
    throw new Error(ZN);
  if (typeof t.count == "function")
    return t.count();
  if (Number.isFinite(t.size))
    return t.size;
  if (Number.isFinite(t.length))
    return t.length;
  if (JN(t))
    return Object.keys(t).length;
  throw new Error(KN);
}
function JN(t) {
  return t !== null && typeof t == "object" && t.constructor === Object;
}
function QN(t) {
  return t !== null && typeof t == "object";
}
function Ux(t, e) {
  if (!e)
    return t;
  const i = { ...t, ...e };
  if ("defines" in e && (i.defines = { ...t.defines, ...e.defines }), "modules" in e && (i.modules = (t.modules || []).concat(e.modules), e.modules.some((s) => s.name === "project64"))) {
    const s = i.modules.findIndex((o) => o.name === "project32");
    s >= 0 && i.modules.splice(s, 1);
  }
  if ("inject" in e)
    if (!t.inject)
      i.inject = e.inject;
    else {
      const s = { ...t.inject };
      for (const o in e.inject)
        s[o] = (s[o] || "") + e.inject[o];
      i.inject = s;
    }
  return i;
}
const eL = {
  minFilter: "linear",
  mipmapFilter: "linear",
  magFilter: "linear",
  addressModeU: "clamp-to-edge",
  addressModeV: "clamp-to-edge"
}, Om = {};
function tL(t, e, i, s) {
  if (i instanceof qs)
    return i;
  i.constructor && i.constructor.name !== "Object" && (i = { data: i });
  let o = null;
  i.compressed && (o = {
    minFilter: "linear",
    mipmapFilter: i.data.length > 1 ? "nearest" : "linear"
  });
  const u = e.createTexture({
    ...i,
    sampler: {
      ...eL,
      ...o,
      ...s
    }
  });
  return Om[u.id] = t, u;
}
function iL(t, e) {
  !e || !(e instanceof qs) || Om[e.id] === t && (e.delete(), delete Om[e.id]);
}
const rL = {
  boolean: {
    validate(t, e) {
      return !0;
    },
    equal(t, e, i) {
      return !!t == !!e;
    }
  },
  number: {
    validate(t, e) {
      return Number.isFinite(t) && (!("max" in e) || t <= e.max) && (!("min" in e) || t >= e.min);
    }
  },
  color: {
    validate(t, e) {
      return e.optional && !t || Fm(t) && (t.length === 3 || t.length === 4);
    },
    equal(t, e, i) {
      return Pn(t, e, 1);
    }
  },
  accessor: {
    validate(t, e) {
      const i = bp(t);
      return i === "function" || i === bp(e.value);
    },
    equal(t, e, i) {
      return typeof e == "function" ? !0 : Pn(t, e, 1);
    }
  },
  array: {
    validate(t, e) {
      return e.optional && !t || Fm(t);
    },
    equal(t, e, i) {
      const { compare: s } = i, o = Number.isInteger(s) ? s : s ? 1 : 0;
      return s ? Pn(t, e, o) : t === e;
    }
  },
  object: {
    equal(t, e, i) {
      if (i.ignore)
        return !0;
      const { compare: s } = i, o = Number.isInteger(s) ? s : s ? 1 : 0;
      return s ? Pn(t, e, o) : t === e;
    }
  },
  function: {
    validate(t, e) {
      return e.optional && !t || typeof t == "function";
    },
    equal(t, e, i) {
      return !i.compare && i.ignore !== !1 || t === e;
    }
  },
  data: {
    transform: (t, e, i) => {
      if (!t)
        return t;
      const { dataTransform: s } = i.props;
      return s ? s(t) : typeof t.shape == "string" && t.shape.endsWith("-table") && Array.isArray(t.data) ? t.data : t;
    }
  },
  image: {
    transform: (t, e, i) => {
      const s = i.context;
      return !s || !s.device ? null : tL(i.id, s.device, t, {
        ...e.parameters,
        ...i.props.textureParameters
      });
    },
    release: (t, e, i) => {
      iL(i.id, t);
    }
  }
};
function sL(t) {
  const e = {}, i = {}, s = {};
  for (const [o, u] of Object.entries(t)) {
    const d = u?.deprecatedFor;
    if (d)
      s[o] = Array.isArray(d) ? d : [d];
    else {
      const a = nL(o, u);
      e[o] = a, i[o] = a.value;
    }
  }
  return { propTypes: e, defaultProps: i, deprecatedProps: s };
}
function nL(t, e) {
  switch (bp(e)) {
    case "object":
      return Iu(t, e);
    case "array":
      return Iu(t, { type: "array", value: e, compare: !1 });
    case "boolean":
      return Iu(t, { type: "boolean", value: e });
    case "number":
      return Iu(t, { type: "number", value: e });
    case "function":
      return Iu(t, { type: "function", value: e, compare: !0 });
    default:
      return { name: t, type: "unknown", value: e };
  }
}
function Iu(t, e) {
  return "type" in e ? { name: t, ...rL[e.type], ...e } : "value" in e ? { name: t, type: bp(e.value), ...e } : { name: t, type: "object", value: e };
}
function Fm(t) {
  return Array.isArray(t) || ArrayBuffer.isView(t);
}
function bp(t) {
  return Fm(t) ? "array" : t === null ? "null" : typeof t;
}
function oL(t, e) {
  let i;
  for (let u = e.length - 1; u >= 0; u--) {
    const d = e[u];
    "extensions" in d && (i = d.extensions);
  }
  const s = km(t.constructor, i), o = Object.create(s);
  o[mp] = t, o[Ml] = {}, o[va] = {};
  for (let u = 0; u < e.length; ++u) {
    const d = e[u];
    for (const a in d)
      o[a] = d[a];
  }
  return Object.freeze(o), o;
}
const aL = "_mergedDefaultProps";
function km(t, e) {
  if (!(t instanceof kp.constructor))
    return {};
  let i = aL;
  if (e)
    for (const o of e) {
      const u = o.constructor;
      u && (i += `:${u.extensionName || u.name}`);
    }
  const s = hA(t, i);
  return s || (t[i] = lL(t, e || []));
}
function lL(t, e) {
  if (!t.prototype)
    return null;
  const s = Object.getPrototypeOf(t), o = km(s), u = hA(t, "defaultProps") || {}, d = sL(u), a = Object.assign(/* @__PURE__ */ Object.create(null), o, d.defaultProps), w = Object.assign(/* @__PURE__ */ Object.create(null), o?.[Ta], d.propTypes), S = Object.assign(/* @__PURE__ */ Object.create(null), o?.[bg], d.deprecatedProps);
  for (const M of e) {
    const F = km(M.constructor);
    F && (Object.assign(a, F), Object.assign(w, F[Ta]), Object.assign(S, F[bg]));
  }
  return cL(a, t), uL(a, w), hL(a, S), a[Ta] = w, a[bg] = S, e.length === 0 && !Ny(t, "_propTypes") && (t._propTypes = w), a;
}
function cL(t, e) {
  const i = fL(e);
  Object.defineProperties(t, {
    // `id` is treated specially because layer might need to override it
    id: {
      writable: !0,
      value: i
    }
  });
}
function hL(t, e) {
  for (const i in e)
    Object.defineProperty(t, i, {
      enumerable: !1,
      set(s) {
        const o = `${this.id}: ${i}`;
        for (const u of e[i])
          Ny(this, u) || (this[u] = s);
        Jt.deprecated(o, e[i].join("/"))();
      }
    });
}
function uL(t, e) {
  const i = {}, s = {};
  for (const o in e) {
    const u = e[o], { name: d, value: a } = u;
    u.async && (i[d] = a, s[d] = dL(d));
  }
  t[ih] = i, t[Ml] = {}, Object.defineProperties(t, s);
}
function dL(t) {
  return {
    enumerable: !0,
    // Save the provided value for async props in a special map
    set(e) {
      typeof e == "string" || e instanceof Promise || QT(e) ? this[Ml][t] = e : this[va][t] = e;
    },
    // Only the component's state knows the true value of async prop
    get() {
      if (this[va]) {
        if (t in this[va])
          return this[va][t] || this[ih][t];
        if (t in this[Ml]) {
          const e = this[mp] && this[mp].internalState;
          if (e && e.hasAsyncProp(t))
            return e.getAsyncProp(t) || this[ih][t];
        }
      }
      return this[ih][t];
    }
  };
}
function Ny(t, e) {
  return Object.prototype.hasOwnProperty.call(t, e);
}
function hA(t, e) {
  return Ny(t, e) && t[e];
}
function fL(t) {
  const e = t.componentName;
  return e || Jt.warn(`${t.name}.componentName not specified`)(), e || t.name;
}
let pL = 0;
class kp {
  constructor(...e) {
    this.props = oL(this, e), this.id = this.props.id, this.count = pL++;
  }
  // clone this layer with modified props
  clone(e) {
    const { props: i } = this, s = {};
    for (const o in i[ih])
      o in i[va] ? s[o] = i[va][o] : o in i[Ml] && (s[o] = i[Ml][o]);
    return new this.constructor({ ...i, ...s, ...e });
  }
}
kp.componentName = "Component";
kp.defaultProps = {};
const _L = Object.freeze({});
class gL {
  constructor(e) {
    this.component = e, this.asyncProps = {}, this.onAsyncPropUpdated = () => {
    }, this.oldProps = null, this.oldAsyncProps = null;
  }
  finalize() {
    for (const e in this.asyncProps) {
      const i = this.asyncProps[e];
      i && i.type && i.type.release && i.type.release(i.resolvedValue, i.type, this.component);
    }
    this.asyncProps = {}, this.component = null, this.resetOldProps();
  }
  /* Layer-facing props API */
  getOldProps() {
    return this.oldAsyncProps || this.oldProps || _L;
  }
  resetOldProps() {
    this.oldAsyncProps = null, this.oldProps = this.component ? this.component.props : null;
  }
  // Checks if a prop is overridden
  hasAsyncProp(e) {
    return e in this.asyncProps;
  }
  // Returns value of an overriden prop
  getAsyncProp(e) {
    const i = this.asyncProps[e];
    return i && i.resolvedValue;
  }
  isAsyncPropLoading(e) {
    if (e) {
      const i = this.asyncProps[e];
      return !!(i && i.pendingLoadCount > 0 && i.pendingLoadCount !== i.resolvedLoadCount);
    }
    for (const i in this.asyncProps)
      if (this.isAsyncPropLoading(i))
        return !0;
    return !1;
  }
  // Without changing the original prop value, swap out the data resolution under the hood
  reloadAsyncProp(e, i) {
    this._watchPromise(e, Promise.resolve(i));
  }
  // Updates all async/overridden props (when new props come in)
  // Checks if urls have changed, starts loading, or removes override
  setAsyncProps(e) {
    this.component = e[mp] || this.component;
    const i = e[va] || {}, s = e[Ml] || e, o = e[ih] || {};
    for (const u in i) {
      const d = i[u];
      this._createAsyncPropData(u, o[u]), this._updateAsyncProp(u, d), i[u] = this.getAsyncProp(u);
    }
    for (const u in s) {
      const d = s[u];
      this._createAsyncPropData(u, o[u]), this._updateAsyncProp(u, d);
    }
  }
  /* Placeholder methods for subclassing */
  _fetch(e, i) {
    return null;
  }
  _onResolve(e, i) {
  }
  // eslint-disable-line @typescript-eslint/no-empty-function
  _onError(e, i) {
  }
  // eslint-disable-line @typescript-eslint/no-empty-function
  // Intercept strings (URLs) and Promises and activates loading and prop rewriting
  _updateAsyncProp(e, i) {
    if (this._didAsyncInputValueChange(e, i)) {
      if (typeof i == "string" && (i = this._fetch(e, i)), i instanceof Promise) {
        this._watchPromise(e, i);
        return;
      }
      if (QT(i)) {
        this._resolveAsyncIterable(e, i);
        return;
      }
      this._setPropValue(e, i);
    }
  }
  // Whenever async props are changing, we need to make a copy of oldProps
  // otherwise the prop rewriting will affect the value both in props and oldProps.
  // While the copy is relatively expensive, this only happens on load completion.
  _freezeAsyncOldProps() {
    if (!this.oldAsyncProps && this.oldProps) {
      this.oldAsyncProps = Object.create(this.oldProps);
      for (const e in this.asyncProps)
        Object.defineProperty(this.oldAsyncProps, e, {
          enumerable: !0,
          value: this.oldProps[e]
        });
    }
  }
  // Checks if an input value actually changed (to avoid reloading/rewatching promises/urls)
  _didAsyncInputValueChange(e, i) {
    const s = this.asyncProps[e];
    return i === s.resolvedValue || i === s.lastValue ? !1 : (s.lastValue = i, !0);
  }
  // Set normal, non-async value
  _setPropValue(e, i) {
    this._freezeAsyncOldProps();
    const s = this.asyncProps[e];
    s && (i = this._postProcessValue(s, i), s.resolvedValue = i, s.pendingLoadCount++, s.resolvedLoadCount = s.pendingLoadCount);
  }
  // Set a just resolved async value, calling onAsyncPropUpdates if value changes asynchronously
  _setAsyncPropValue(e, i, s) {
    const o = this.asyncProps[e];
    o && s >= o.resolvedLoadCount && i !== void 0 && (this._freezeAsyncOldProps(), o.resolvedValue = i, o.resolvedLoadCount = s, this.onAsyncPropUpdated(e, i));
  }
  // Tracks a promise, sets the prop when loaded, handles load count
  _watchPromise(e, i) {
    const s = this.asyncProps[e];
    if (s) {
      s.pendingLoadCount++;
      const o = s.pendingLoadCount;
      i.then((u) => {
        this.component && (u = this._postProcessValue(s, u), this._setAsyncPropValue(e, u, o), this._onResolve(e, u));
      }).catch((u) => {
        this._onError(e, u);
      });
    }
  }
  async _resolveAsyncIterable(e, i) {
    if (e !== "data") {
      this._setPropValue(e, i);
      return;
    }
    const s = this.asyncProps[e];
    if (!s)
      return;
    s.pendingLoadCount++;
    const o = s.pendingLoadCount;
    let u = [], d = 0;
    for await (const a of i) {
      if (!this.component)
        return;
      const { dataTransform: w } = this.component.props;
      w ? u = w(a, u) : u = u.concat(a), Object.defineProperty(u, "__diff", {
        enumerable: !1,
        value: [{ startRow: d, endRow: u.length }]
      }), d = u.length, this._setAsyncPropValue(e, u, o);
    }
    this._onResolve(e, u);
  }
  // Give the app a chance to post process the loaded data
  _postProcessValue(e, i) {
    const s = e.type;
    return s && this.component && (s.release && s.release(e.resolvedValue, s, this.component), s.transform) ? s.transform(i, s, this.component) : i;
  }
  // Creating an asyncProp record if needed
  _createAsyncPropData(e, i) {
    if (!this.asyncProps[e]) {
      const o = this.component && this.component.props[Ta];
      this.asyncProps[e] = {
        type: o && o[e],
        lastValue: null,
        resolvedValue: i,
        pendingLoadCount: 0,
        resolvedLoadCount: 0
      };
    }
  }
}
class mL extends gL {
  constructor({ attributeManager: e, layer: i }) {
    super(i), this.attributeManager = e, this.needsRedraw = !0, this.needsUpdate = !0, this.subLayers = null, this.usesPickingColorCache = !1;
  }
  get layer() {
    return this.component;
  }
  /* Override base Component methods with Layer-specific handling */
  _fetch(e, i) {
    const s = this.layer, o = s?.props.fetch;
    return o ? o(i, { propName: e, layer: s }) : super._fetch(e, i);
  }
  _onResolve(e, i) {
    const s = this.layer;
    if (s) {
      const o = s.props.onDataLoad;
      e === "data" && o && o(i, { propName: e, layer: s });
    }
  }
  _onError(e, i) {
    const s = this.layer;
    s && s.raiseError(i, `loading ${e} of ${this.layer}`);
  }
}
const yL = "layer.changeFlag", bL = "layer.initialize", vL = "layer.update", xL = "layer.finalize", wL = "layer.matched", zx = 2 ** 24 - 1, TL = Object.freeze([]), AL = ld(({ oldViewport: t, viewport: e }) => t.equals(e));
let io = new Uint8ClampedArray(0);
const EL = {
  // data: Special handling for null, see below
  data: { type: "data", value: TL, async: !0 },
  dataComparator: { type: "function", value: null, optional: !0 },
  _dataDiff: {
    type: "function",
    // @ts-ignore __diff is not defined on data
    value: (t) => t && t.__diff,
    optional: !0
  },
  dataTransform: { type: "function", value: null, optional: !0 },
  onDataLoad: { type: "function", value: null, optional: !0 },
  onError: { type: "function", value: null, optional: !0 },
  fetch: {
    type: "function",
    value: (t, { propName: e, layer: i, loaders: s, loadOptions: o, signal: u }) => {
      const { resourceManager: d } = i.context;
      o = o || i.getLoadOptions(), s = s || i.props.loaders, u && (o = {
        ...o,
        fetch: {
          ...o?.fetch,
          signal: u
        }
      });
      let a = d.contains(t);
      return !a && !o && (d.add({ resourceId: t, data: Ea(t, s), persistent: !1 }), a = !0), a ? d.subscribe({
        resourceId: t,
        onChange: (w) => i.internalState?.reloadAsyncProp(e, w),
        consumerId: i.id,
        requestId: e
      }) : Ea(t, s, o);
    }
  },
  updateTriggers: {},
  // Update triggers: a core change detection mechanism in deck.gl
  visible: !0,
  pickable: !1,
  opacity: { type: "number", min: 0, max: 1, value: 1 },
  operation: "draw",
  onHover: { type: "function", value: null, optional: !0 },
  onClick: { type: "function", value: null, optional: !0 },
  onDragStart: { type: "function", value: null, optional: !0 },
  onDrag: { type: "function", value: null, optional: !0 },
  onDragEnd: { type: "function", value: null, optional: !0 },
  coordinateSystem: Xt.DEFAULT,
  coordinateOrigin: { type: "array", value: [0, 0, 0], compare: !0 },
  modelMatrix: { type: "array", value: null, compare: !0, optional: !0 },
  wrapLongitude: !1,
  positionFormat: "XYZ",
  colorFormat: "RGBA",
  parameters: { type: "object", value: {}, optional: !0, compare: 2 },
  loadOptions: { type: "object", value: null, optional: !0, ignore: !0 },
  transitions: null,
  extensions: [],
  loaders: { type: "array", value: [], optional: !0, ignore: !0 },
  // Offset depth based on layer index to avoid z-fighting.
  // Negative values pull layer towards the camera
  // https://www.opengl.org/archives/resources/faq/technical/polygonoffset.htm
  getPolygonOffset: {
    type: "function",
    value: ({ layerIndex: t }) => [0, -t * 100]
  },
  // Selection/Highlighting
  highlightedObjectIndex: null,
  autoHighlight: !1,
  highlightColor: { type: "accessor", value: [0, 0, 128, 128] }
};
class mh extends kp {
  constructor() {
    super(...arguments), this.internalState = null, this.lifecycle = Vc.NO_STATE, this.parent = null;
  }
  static get componentName() {
    return Object.prototype.hasOwnProperty.call(this, "layerName") ? this.layerName : "";
  }
  get root() {
    let e = this;
    for (; e.parent; )
      e = e.parent;
    return e;
  }
  toString() {
    return `${this.constructor.layerName || this.constructor.name}({id: '${this.props.id}'})`;
  }
  // Public API for users
  /** Projects a point with current view state from the current layer's coordinate system to screen */
  project(e) {
    Tr(this.internalState);
    const i = this.internalState.viewport || this.context.viewport, s = MT(e, {
      viewport: i,
      modelMatrix: this.props.modelMatrix,
      coordinateOrigin: this.props.coordinateOrigin,
      coordinateSystem: this.props.coordinateSystem
    }), [o, u, d] = ST(s, i.pixelProjectionMatrix);
    return e.length === 2 ? [o, u] : [o, u, d];
  }
  /** Unprojects a screen pixel to the current view's default coordinate system
      Note: this does not reverse `project`. */
  unproject(e) {
    return Tr(this.internalState), (this.internalState.viewport || this.context.viewport).unproject(e);
  }
  /** Projects a point with current view state from the current layer's coordinate system to the world space */
  projectPosition(e, i) {
    Tr(this.internalState);
    const s = this.internalState.viewport || this.context.viewport;
    return ED(e, {
      viewport: s,
      modelMatrix: this.props.modelMatrix,
      coordinateOrigin: this.props.coordinateOrigin,
      coordinateSystem: this.props.coordinateSystem,
      ...i
    });
  }
  // Public API for custom layer implementation
  /** `true` if this layer renders other layers */
  get isComposite() {
    return !1;
  }
  /** Updates selected state members and marks the layer for redraw */
  setState(e) {
    this.setChangeFlags({ stateChanged: !0 }), Object.assign(this.state, e), this.setNeedsRedraw();
  }
  /** Sets the redraw flag for this layer, will trigger a redraw next animation frame */
  setNeedsRedraw() {
    this.internalState && (this.internalState.needsRedraw = !0);
  }
  /** Mark this layer as needs a deep update */
  setNeedsUpdate() {
    this.internalState && (this.context.layerManager.setNeedsUpdate(String(this)), this.internalState.needsUpdate = !0);
  }
  /** Returns true if all async resources are loaded */
  get isLoaded() {
    return this.internalState ? !this.internalState.isAsyncPropLoading() : !1;
  }
  /** Returns true if using shader-based WGS84 longitude wrapping */
  get wrapLongitude() {
    return this.props.wrapLongitude;
  }
  /** @deprecated Returns true if the layer is visible in the picking pass */
  isPickable() {
    return this.props.pickable && this.props.visible;
  }
  /** Returns an array of models used by this layer, can be overriden by layer subclass */
  getModels() {
    const e = this.state;
    return e && (e.models || e.model && [e.model]) || [];
  }
  // TODO deprecate in favour of setShaderModuleProps
  /** Update shader module parameters */
  setModuleParameters(e) {
    for (const i of this.getModels())
      i.updateModuleSettings(e);
  }
  /** Update shader input parameters */
  setShaderModuleProps(...e) {
    for (const i of this.getModels())
      i.shaderInputs.setProps(...e);
  }
  /** Returns the attribute manager of this layer */
  getAttributeManager() {
    return this.internalState && this.internalState.attributeManager;
  }
  /** Returns the most recent layer that matched to this state
    (When reacting to an async event, this layer may no longer be the latest) */
  getCurrentLayer() {
    return this.internalState && this.internalState.layer;
  }
  /** Returns the default parse options for async props */
  getLoadOptions() {
    return this.props.loadOptions;
  }
  use64bitPositions() {
    const { coordinateSystem: e } = this.props;
    return e === Xt.DEFAULT || e === Xt.LNGLAT || e === Xt.CARTESIAN;
  }
  // Event handling
  onHover(e, i) {
    return this.props.onHover && this.props.onHover(e, i) || !1;
  }
  onClick(e, i) {
    return this.props.onClick && this.props.onClick(e, i) || !1;
  }
  // Returns the picking color that doesn't match any subfeature
  // Use if some graphics do not belong to any pickable subfeature
  // @return {Array} - a black color
  nullPickingColor() {
    return [0, 0, 0];
  }
  // Returns the picking color that doesn't match any subfeature
  // Use if some graphics do not belong to any pickable subfeature
  encodePickingColor(e, i = []) {
    return i[0] = e + 1 & 255, i[1] = e + 1 >> 8 & 255, i[2] = e + 1 >> 8 >> 8 & 255, i;
  }
  // Returns the index corresponding to a picking color that doesn't match any subfeature
  // @param {Uint8Array} color - color array to be decoded
  // @return {Array} - the decoded picking color
  decodePickingColor(e) {
    Tr(e instanceof Uint8Array);
    const [i, s, o] = e;
    return i + s * 256 + o * 65536 - 1;
  }
  /** Deduces number of instances. Intention is to support:
    - Explicit setting of numInstances
    - Auto-deduction for ES6 containers that define a size member
    - Auto-deduction for Classic Arrays via the built-in length attribute
    - Auto-deduction via arrays */
  getNumInstances() {
    return Number.isFinite(this.props.numInstances) ? this.props.numInstances : this.state && this.state.numInstances !== void 0 ? this.state.numInstances : YN(this.props.data);
  }
  /** Buffer layout describes how many attribute values are packed for each data object
      The default (null) is one value each object.
      Some data formats (e.g. paths, polygons) have various length. Their buffer layout
      is in the form of [L0, L1, L2, ...] */
  getStartIndices() {
    return this.props.startIndices ? this.props.startIndices : this.state && this.state.startIndices ? this.state.startIndices : null;
  }
  // Default implementation
  getBounds() {
    return this.getAttributeManager()?.getBounds(["positions", "instancePositions"]);
  }
  getShaders(e) {
    e = Ux(e, {
      disableWarnings: !0,
      modules: this.context.defaultShaderModules
    });
    for (const i of this.props.extensions)
      e = Ux(e, i.getShaders.call(this, i));
    return e;
  }
  /** Controls if updateState should be called. By default returns true if any prop has changed */
  shouldUpdateState(e) {
    return e.changeFlags.propsOrDataChanged;
  }
  /** Default implementation, all attributes will be invalidated and updated when data changes */
  // eslint-disable-next-line complexity
  updateState(e) {
    const i = this.getAttributeManager(), { dataChanged: s } = e.changeFlags;
    if (s && i)
      if (Array.isArray(s))
        for (const o of s)
          i.invalidateAll(o);
      else
        i.invalidateAll();
    if (i) {
      const { props: o } = e, u = this.internalState.hasPickingBuffer, d = Number.isInteger(o.highlightedObjectIndex) || o.pickable || o.extensions.some((a) => a.getNeedsPickingBuffer.call(this, a));
      if (u !== d) {
        this.internalState.hasPickingBuffer = d;
        const { pickingColors: a, instancePickingColors: w } = i.attributes, S = a || w;
        S && (d && S.constant && (S.constant = !1, i.invalidate(S.id)), !S.value && !d && (S.constant = !0, S.value = [0, 0, 0]));
      }
    }
  }
  /** Called once when layer is no longer matched and state will be discarded. Layers can destroy WebGL resources here. */
  finalizeState(e) {
    for (const s of this.getModels())
      s.destroy();
    const i = this.getAttributeManager();
    i && i.finalize(), this.context && this.context.resourceManager.unsubscribe({ consumerId: this.id }), this.internalState && (this.internalState.uniformTransitions.clear(), this.internalState.finalize());
  }
  // If state has a model, draw it with supplied uniforms
  draw(e) {
    for (const i of this.getModels())
      i.draw(e);
  }
  // called to populate the info object that is passed to the event handler
  // @return null to cancel event
  getPickingInfo({ info: e, mode: i, sourceLayer: s }) {
    const { index: o } = e;
    return o >= 0 && Array.isArray(this.props.data) && (e.object = this.props.data[o]), e;
  }
  // END LIFECYCLE METHODS
  // / INTERNAL METHODS - called by LayerManager, DeckRenderer and DeckPicker
  /** (Internal) Propagate an error event through the system */
  raiseError(e, i) {
    i && (e = new Error(`${i}: ${e.message}`, { cause: e })), this.props.onError?.(e) || this.context?.onError?.(e, this);
  }
  /** (Internal) Checks if this layer needs redraw */
  getNeedsRedraw(e = { clearRedrawFlags: !1 }) {
    return this._getNeedsRedraw(e);
  }
  /** (Internal) Checks if this layer needs a deep update */
  needsUpdate() {
    return this.internalState ? this.internalState.needsUpdate || this.hasUniformTransition() || this.shouldUpdateState(this._getUpdateParams()) : !1;
  }
  /** Checks if this layer has ongoing uniform transition */
  hasUniformTransition() {
    return this.internalState?.uniformTransitions.active || !1;
  }
  /** Called when this layer is rendered into the given viewport */
  activateViewport(e) {
    if (!this.internalState)
      return;
    const i = this.internalState.viewport;
    this.internalState.viewport = e, (!i || !AL({ oldViewport: i, viewport: e })) && (this.setChangeFlags({ viewportChanged: !0 }), this.isComposite ? this.needsUpdate() && this.setNeedsUpdate() : this._update());
  }
  /** Default implementation of attribute invalidation, can be redefined */
  invalidateAttribute(e = "all") {
    const i = this.getAttributeManager();
    i && (e === "all" ? i.invalidateAll() : i.invalidate(e));
  }
  /** Send updated attributes to the WebGL model */
  updateAttributes(e) {
    let i = !1;
    for (const s in e)
      e[s].layoutChanged() && (i = !0);
    for (const s of this.getModels())
      this._setModelAttributes(s, e, i);
  }
  /** Recalculate any attributes if needed */
  _updateAttributes() {
    const e = this.getAttributeManager();
    if (!e)
      return;
    const i = this.props, s = this.getNumInstances(), o = this.getStartIndices();
    e.update({
      data: i.data,
      numInstances: s,
      startIndices: o,
      props: i,
      transitions: i.transitions,
      // @ts-ignore (TS2339) property attribute is not present on some acceptable data types
      buffers: i.data.attributes,
      context: this
    });
    const u = e.getChangedAttributes({ clearChangedFlags: !0 });
    this.updateAttributes(u);
  }
  /** Update attribute transitions. This is called in drawLayer, no model updates required. */
  _updateAttributeTransition() {
    const e = this.getAttributeManager();
    e && e.updateTransition();
  }
  /** Update uniform (prop) transitions. This is called in updateState, may result in model updates. */
  _updateUniformTransition() {
    const { uniformTransitions: e } = this.internalState;
    if (e.active) {
      const i = e.update(), s = Object.create(this.props);
      for (const o in i)
        Object.defineProperty(s, o, { value: i[o] });
      return s;
    }
    return this.props;
  }
  /** Updater for the automatically populated instancePickingColors attribute */
  calculateInstancePickingColors(e, { numInstances: i }) {
    if (e.constant)
      return;
    const s = Math.floor(io.length / 4);
    if (this.internalState.usesPickingColorCache = !0, s < i) {
      i > zx && Jt.warn("Layer has too many data objects. Picking might not be able to distinguish all objects.")(), io = Ku.allocate(io, i, {
        size: 4,
        copy: !0,
        maxCount: Math.max(i, zx)
      });
      const o = Math.floor(io.length / 4), u = [];
      for (let d = s; d < o; d++)
        this.encodePickingColor(d, u), io[d * 4 + 0] = u[0], io[d * 4 + 1] = u[1], io[d * 4 + 2] = u[2];
    }
    e.value = io.subarray(0, i * 4);
  }
  /** Apply changed attributes to model */
  _setModelAttributes(e, i, s = !1) {
    if (!Object.keys(i).length)
      return;
    if (s) {
      const a = this.getAttributeManager();
      e.setBufferLayout(a.getBufferLayouts(e)), i = a.getAttributes();
    }
    const o = e.userData?.excludeAttributes || {}, u = {}, d = {};
    for (const a in i) {
      if (o[a])
        continue;
      const w = i[a].getValue();
      for (const S in w) {
        const M = w[S];
        M instanceof Mi ? i[a].settings.isIndexed ? e.setIndexBuffer(M) : u[S] = M : M && (d[S] = M);
      }
    }
    e.setAttributes(u), e.setConstantAttributes(d);
  }
  /** (Internal) Sets the picking color at the specified index to null picking color. Used for multi-depth picking.
     This method may be overriden by layer implementations */
  disablePickingIndex(e) {
    const i = this.props.data;
    if (!("attributes" in i)) {
      this._disablePickingIndex(e);
      return;
    }
    const { pickingColors: s, instancePickingColors: o } = this.getAttributeManager().attributes, u = s || o, d = u && i.attributes && i.attributes[u.id];
    if (d && d.value) {
      const a = d.value, w = this.encodePickingColor(e);
      for (let S = 0; S < i.length; S++) {
        const M = u.getVertexOffset(S);
        a[M] === w[0] && a[M + 1] === w[1] && a[M + 2] === w[2] && this._disablePickingIndex(S);
      }
    } else
      this._disablePickingIndex(e);
  }
  // TODO - simplify subclassing interface
  _disablePickingIndex(e) {
    const { pickingColors: i, instancePickingColors: s } = this.getAttributeManager().attributes, o = i || s;
    if (!o)
      return;
    const u = o.getVertexOffset(e), d = o.getVertexOffset(e + 1);
    o.buffer.write(new Uint8Array(d - u), u);
  }
  /** (Internal) Re-enable all picking indices after multi-depth picking */
  restorePickingColors() {
    const { pickingColors: e, instancePickingColors: i } = this.getAttributeManager().attributes, s = e || i;
    s && // @ts-ignore (TS2531) this method is only called internally with internalState defined
    (this.internalState.usesPickingColorCache && s.value.buffer !== io.buffer && (s.value = io.subarray(0, s.value.length)), s.updateSubBuffer({ startOffset: 0 }));
  }
  /* eslint-disable max-statements */
  /* (Internal) Called by layer manager when a new layer is found */
  _initialize() {
    Tr(!this.internalState), Tr(Number.isFinite(this.props.coordinateSystem)), Yr(bL, this);
    const e = this._getAttributeManager();
    e && e.addInstanced({
      instancePickingColors: {
        type: "uint8",
        size: 4,
        noAlloc: !0,
        // Updaters are always called with `this` pointing to the layer
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculateInstancePickingColors
      }
    }), this.internalState = new mL({
      attributeManager: e,
      layer: this
    }), this._clearChangeFlags(), this.state = {}, Object.defineProperty(this.state, "attributeManager", {
      get: () => (Jt.deprecated("layer.state.attributeManager", "layer.getAttributeManager()")(), e)
    }), this.internalState.uniformTransitions = new jN(this.context.timeline), this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this), this.internalState.setAsyncProps(this.props), this.initializeState(this.context);
    for (const i of this.props.extensions)
      i.initializeState.call(this, this.context, i);
    this.setChangeFlags({
      dataChanged: "init",
      propsChanged: "init",
      viewportChanged: !0,
      extensionsChanged: !0
    }), this._update();
  }
  /** (Internal) Called by layer manager to transfer state from an old layer */
  _transferState(e) {
    Yr(wL, this, this === e);
    const { state: i, internalState: s } = e;
    this !== e && (this.internalState = s, this.state = i, this.internalState.setAsyncProps(this.props), this._diffProps(this.props, this.internalState.getOldProps()));
  }
  /** (Internal) Called by layer manager when a new layer is added or an existing layer is matched with a new instance */
  _update() {
    const e = this.needsUpdate();
    if (Yr(vL, this, e), !e)
      return;
    const i = this.props, s = this.context, o = this.internalState, u = s.viewport, d = this._updateUniformTransition();
    o.propsInTransition = d, s.viewport = o.viewport || u, this.props = d;
    try {
      const a = this._getUpdateParams(), w = this.getModels();
      if (s.device)
        this.updateState(a);
      else
        try {
          this.updateState(a);
        } catch {
        }
      for (const M of this.props.extensions)
        M.updateState.call(this, a, M);
      const S = this.getModels()[0] !== w[0];
      this._postUpdate(a, S);
    } finally {
      s.viewport = u, this.props = i, this._clearChangeFlags(), o.needsUpdate = !1, o.resetOldProps();
    }
  }
  /* eslint-enable max-statements */
  /** (Internal) Called by manager when layer is about to be disposed
      Note: not guaranteed to be called on application shutdown */
  _finalize() {
    Yr(xL, this), this.finalizeState(this.context);
    for (const e of this.props.extensions)
      e.finalizeState.call(this, this.context, e);
  }
  // Calculates uniforms
  _drawLayer({ renderPass: e, moduleParameters: i = null, uniforms: s = {}, parameters: o = {} }) {
    this._updateAttributeTransition();
    const u = this.props, d = this.context;
    this.props = this.internalState.propsInTransition || u;
    const a = this.props.opacity;
    s.opacity = Math.pow(a, 1 / 2.2);
    try {
      if (i) {
        const { isActive: M, isAttribute: F } = i.picking;
        this.setModuleParameters(i), this.setShaderModuleProps({ picking: { isActive: M, isAttribute: F } });
      }
      const { getPolygonOffset: w } = this.props, S = w && w(s) || [0, 0];
      d.device.setParametersWebGL({ polygonOffset: S });
      for (const M of this.getModels())
        M.setParameters(o);
      d.device.withParametersWebGL(o, () => {
        const M = { renderPass: e, moduleParameters: i, uniforms: s, parameters: o, context: d };
        for (const F of this.props.extensions)
          F.draw.call(this, M, F);
        this.draw(M);
      });
    } finally {
      this.props = u;
    }
  }
  // Helper methods
  /** Returns the current change flags */
  getChangeFlags() {
    return this.internalState?.changeFlags;
  }
  /* eslint-disable complexity */
  /** Dirty some change flags, will be handled by updateLayer */
  setChangeFlags(e) {
    if (!this.internalState)
      return;
    const { changeFlags: i } = this.internalState;
    for (const o in e)
      if (e[o]) {
        let u = !1;
        switch (o) {
          case "dataChanged":
            const d = e[o], a = i[o];
            d && Array.isArray(a) && (i.dataChanged = Array.isArray(d) ? a.concat(d) : d, u = !0);
          default:
            i[o] || (i[o] = e[o], u = !0);
        }
        u && Yr(yL, this, o, e);
      }
    const s = !!(i.dataChanged || i.updateTriggersChanged || i.propsChanged || i.extensionsChanged);
    i.propsOrDataChanged = s, i.somethingChanged = s || i.viewportChanged || i.stateChanged;
  }
  /* eslint-enable complexity */
  /** Clear all changeFlags, typically after an update */
  _clearChangeFlags() {
    this.internalState.changeFlags = {
      dataChanged: !1,
      propsChanged: !1,
      updateTriggersChanged: !1,
      viewportChanged: !1,
      stateChanged: !1,
      extensionsChanged: !1,
      propsOrDataChanged: !1,
      somethingChanged: !1
    };
  }
  /** Compares the layers props with old props from a matched older layer
      and extracts change flags that describe what has change so that state
      can be update correctly with minimal effort */
  _diffProps(e, i) {
    const s = $N(e, i);
    if (s.updateTriggersChanged)
      for (const o in s.updateTriggersChanged)
        s.updateTriggersChanged[o] && this.invalidateAttribute(o);
    if (s.transitionsChanged)
      for (const o in s.transitionsChanged)
        this.internalState.uniformTransitions.add(o, i[o], e[o], e.transitions?.[o]);
    return this.setChangeFlags(s);
  }
  /** (Internal) called by layer manager to perform extra props validation (in development only) */
  validateProps() {
    HN(this.props);
  }
  /** (Internal) Called by deck picker when the hovered object changes to update the auto highlight */
  updateAutoHighlight(e) {
    this.props.autoHighlight && !Number.isInteger(this.props.highlightedObjectIndex) && this._updateAutoHighlight(e);
  }
  // May be overriden by subclasses
  // TODO - simplify subclassing interface
  /** Update picking module parameters to highlight the hovered object */
  _updateAutoHighlight(e) {
    const i = {
      // @ts-expect-error stricter luma gl types
      highlightedObjectColor: e.picked ? e.color : null
    }, { highlightColor: s } = this.props;
    e.picked && typeof s == "function" && (i.highlightColor = s(e)), this.setShaderModuleProps({ picking: i }), this.setNeedsRedraw();
  }
  /** Create new attribute manager */
  _getAttributeManager() {
    const e = this.context;
    return new NN(e.device, {
      id: this.props.id,
      stats: e.stats,
      timeline: e.timeline
    });
  }
  // Private methods
  /** Called after updateState to perform common tasks */
  _postUpdate(e, i) {
    const { props: s, oldProps: o } = e;
    this.setNeedsRedraw(), this._updateAttributes();
    const u = this.state.model;
    u?.isInstanced && u.setInstanceCount(this.getNumInstances());
    const { autoHighlight: d, highlightedObjectIndex: a, highlightColor: w } = s;
    if (i || o.autoHighlight !== d || o.highlightedObjectIndex !== a || o.highlightColor !== w) {
      const S = {};
      Array.isArray(w) && (S.highlightColor = w), (i || o.autoHighlight !== d || a !== o.highlightedObjectIndex) && (S.highlightedObjectColor = Number.isFinite(a) && a >= 0 ? this.encodePickingColor(a) : null), this.setShaderModuleProps({ picking: S });
    }
  }
  _getUpdateParams() {
    return {
      props: this.props,
      // @ts-ignore TS2531 this method can only be called internally with internalState assigned
      oldProps: this.internalState.getOldProps(),
      context: this.context,
      // @ts-ignore TS2531 this method can only be called internally with internalState assigned
      changeFlags: this.internalState.changeFlags
    };
  }
  /** Checks state of attributes and model */
  _getNeedsRedraw(e) {
    if (!this.internalState)
      return !1;
    let i = !1;
    i = i || this.internalState.needsRedraw && this.id;
    const s = this.getAttributeManager(), o = s ? s.getNeedsRedraw(e) : !1;
    if (i = i || o, i)
      for (const u of this.props.extensions)
        u.onNeedsRedraw.call(this, u);
    return this.internalState.needsRedraw = this.internalState.needsRedraw && !e.clearRedrawFlags, i;
  }
  /** Callback when asyn prop is loaded */
  _onAsyncPropUpdated() {
    this._diffProps(this.props, this.internalState.getOldProps()), this.setNeedsUpdate();
  }
}
mh.defaultProps = EL;
mh.layerName = "Layer";
const SL = "compositeLayer.renderLayers";
class uA extends mh {
  /** `true` if this layer renders other layers */
  get isComposite() {
    return !0;
  }
  /** Returns true if all async resources are loaded */
  get isLoaded() {
    return super.isLoaded && this.getSubLayers().every((e) => e.isLoaded);
  }
  /** Return last rendered sub layers */
  getSubLayers() {
    return this.internalState && this.internalState.subLayers || [];
  }
  // initializeState is usually not needed for composite layers
  // Provide empty definition to disable check for missing definition
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  initializeState(e) {
  }
  /** Updates selected state members and marks the composite layer to need rerender */
  setState(e) {
    super.setState(e), this.setNeedsUpdate();
  }
  /** called to augment the info object that is bubbled up from a sublayer
      override Layer.getPickingInfo() because decoding / setting uniform do
      not apply to a composite layer. */
  getPickingInfo({ info: e }) {
    const { object: i } = e;
    return i && i.__source && i.__source.parent && i.__source.parent.id === this.id && (e.object = i.__source.object, e.index = i.__source.index), e;
  }
  /**
   * Filters sub layers at draw time. Return true if the sub layer should be drawn.
   */
  filterSubLayer(e) {
    return !0;
  }
  /** Returns true if sub layer needs to be rendered */
  shouldRenderSubLayer(e, i) {
    return i && i.length;
  }
  /** Returns sub layer class for a specific sublayer */
  getSubLayerClass(e, i) {
    const { _subLayerProps: s } = this.props;
    return s && s[e] && s[e].type || i;
  }
  /** When casting user data into another format to pass to sublayers,
      add reference to the original object and object index */
  getSubLayerRow(e, i, s) {
    return e.__source = {
      parent: this,
      object: i,
      index: s
    }, e;
  }
  /** Some composite layers cast user data into another format before passing to sublayers
    We need to unwrap them before calling the accessor so that they see the original data
    objects */
  getSubLayerAccessor(e) {
    if (typeof e == "function") {
      const i = {
        index: -1,
        // @ts-ignore accessing resolved data
        data: this.props.data,
        target: []
      };
      return (s, o) => s && s.__source ? (i.index = s.__source.index, e(s.__source.object, i)) : e(s, o);
    }
    return e;
  }
  /** Returns sub layer props for a specific sublayer */
  // eslint-disable-next-line complexity
  getSubLayerProps(e = {}) {
    const { opacity: i, pickable: s, visible: o, parameters: u, getPolygonOffset: d, highlightedObjectIndex: a, autoHighlight: w, highlightColor: S, coordinateSystem: M, coordinateOrigin: F, wrapLongitude: N, positionFormat: L, modelMatrix: re, extensions: ne, fetch: we, operation: Se, _subLayerProps: Ee } = this.props, Ce = {
      id: "",
      updateTriggers: {},
      opacity: i,
      pickable: s,
      visible: o,
      parameters: u,
      getPolygonOffset: d,
      highlightedObjectIndex: a,
      autoHighlight: w,
      highlightColor: S,
      coordinateSystem: M,
      coordinateOrigin: F,
      wrapLongitude: N,
      positionFormat: L,
      modelMatrix: re,
      extensions: ne,
      fetch: we,
      operation: Se
    }, Le = Ee && e.id && Ee[e.id], Ze = Le && Le.updateTriggers, Ke = e.id || "sublayer";
    if (Le) {
      const ct = this.props[Ta], _t = e.type ? e.type._propTypes : {};
      for (const st in Le) {
        const ot = _t[st] || ct[st];
        ot && ot.type === "accessor" && (Le[st] = this.getSubLayerAccessor(Le[st]));
      }
    }
    Object.assign(
      Ce,
      e,
      // experimental feature that allows users to override sublayer props via parent layer prop
      Le
    ), Ce.id = `${this.props.id}-${Ke}`, Ce.updateTriggers = {
      all: this.props.updateTriggers?.all,
      ...e.updateTriggers,
      ...Ze
    };
    for (const ct of ne) {
      const _t = ct.getSubLayerProps.call(this, ct);
      _t && Object.assign(Ce, _t, {
        updateTriggers: Object.assign(Ce.updateTriggers, _t.updateTriggers)
      });
    }
    return Ce;
  }
  /** Update sub layers to highlight the hovered object */
  _updateAutoHighlight(e) {
    for (const i of this.getSubLayers())
      i.updateAutoHighlight(e);
  }
  /** Override base Layer method */
  _getAttributeManager() {
    return null;
  }
  /** (Internal) Called after an update to rerender sub layers */
  _postUpdate(e, i) {
    let s = this.internalState.subLayers;
    const o = !s || this.needsUpdate();
    if (o) {
      const u = this.renderLayers();
      s = ch(u, Boolean), this.internalState.subLayers = s;
    }
    Yr(SL, this, o, s);
    for (const u of s)
      u.parent = this;
  }
}
uA.layerName = "CompositeLayer";
const CL = `#version 300 es
#define SHADER_NAME point-cloud-layer-vertex-shader
in vec3 positions;
in vec3 instanceNormals;
in vec4 instanceColors;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec3 instancePickingColors;
uniform float opacity;
uniform float radiusPixels;
uniform int sizeUnits;
out vec4 vColor;
out vec2 unitPosition;
void main(void) {
geometry.worldPosition = instancePositions;
geometry.normal = project_normal(instanceNormals);
unitPosition = positions.xy;
geometry.uv = unitPosition;
geometry.pickingColor = instancePickingColors;
vec3 offset = vec3(positions.xy * project_size_to_pixel(radiusPixels, sizeUnits), 0.0);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
vec3 lightColor = lighting_getLightColor(instanceColors.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);
vColor = vec4(lightColor, instanceColors.a * opacity);
DECKGL_FILTER_COLOR(vColor, geometry);
}
`, IL = `#version 300 es
#define SHADER_NAME point-cloud-layer-fragment-shader
precision highp float;
in vec4 vColor;
in vec2 unitPosition;
out vec4 fragColor;
void main(void) {
geometry.uv = unitPosition;
float distToCenter = length(unitPosition);
if (distToCenter > 1.0) {
discard;
}
fragColor = vColor;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`, dA = [0, 0, 0, 255], fA = [0, 0, 1], ML = {
  sizeUnits: "pixels",
  pointSize: { type: "number", min: 0, value: 10 },
  //  point radius in pixels
  getPosition: { type: "accessor", value: (t) => t.position },
  getNormal: { type: "accessor", value: fA },
  getColor: { type: "accessor", value: dA },
  material: !0,
  // Depreated
  radiusPixels: { deprecatedFor: "pointSize" }
};
function RL(t) {
  const { header: e, attributes: i } = t;
  if (!(!e || !i) && (t.length = e.vertexCount, i.POSITION && (i.instancePositions = i.POSITION), i.NORMAL && (i.instanceNormals = i.NORMAL), i.COLOR_0)) {
    const { size: s, value: o } = i.COLOR_0;
    i.instanceColors = { size: s, type: "unorm8", value: o };
  }
}
class Ly extends mh {
  getShaders() {
    return super.getShaders({ vs: CL, fs: IL, modules: [Ay, uB, Cy] });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: !0,
        accessor: "getPosition"
      },
      instanceNormals: {
        size: 3,
        transition: !0,
        accessor: "getNormal",
        defaultValue: fA
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: !0,
        accessor: "getColor",
        defaultValue: dA
      }
    });
  }
  updateState(e) {
    const { changeFlags: i, props: s } = e;
    super.updateState(e), i.extensionsChanged && (this.state.model?.destroy(), this.state.model = this._getModel(), this.getAttributeManager().invalidateAll()), i.dataChanged && RL(s.data);
  }
  draw({ uniforms: e }) {
    const { pointSize: i, sizeUnits: s } = this.props, o = this.state.model;
    o.setUniforms(e), o.setUniforms({
      sizeUnits: bm[s],
      radiusPixels: i
    }), o.draw(this.context.renderPass);
  }
  _getModel() {
    const e = [];
    for (let i = 0; i < 3; i++) {
      const s = i / 3 * Math.PI * 2;
      e.push(Math.cos(s) * 2, Math.sin(s) * 2, 0);
    }
    return new Ca(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new eh({
        topology: "triangle-list",
        attributes: {
          positions: new Float32Array(e)
        }
      }),
      isInstanced: !0
    });
  }
}
Ly.layerName = "PointCloudLayer";
Ly.defaultProps = ML;
const Xs = {
  OUTSIDE: -1,
  // Represents that an object is not contained within the frustum.
  INTERSECTING: 0,
  // Represents that an object intersects one of the frustum's planes.
  INSIDE: 1
  // Represents that an object is fully within the frustum.
};
new Be();
new Be();
const Mu = new Be(), Vx = new Be();
class ud {
  /** Creates a bounding sphere */
  constructor(e = [0, 0, 0], i = 0) {
    this.radius = -0, this.center = new Be(), this.fromCenterRadius(e, i);
  }
  /** Sets the bounding sphere from `center` and `radius`. */
  fromCenterRadius(e, i) {
    return this.center.from(e), this.radius = i, this;
  }
  /**
   * Computes a bounding sphere from the corner points of an axis-aligned bounding box.  The sphere
   * tightly and fully encompasses the box.
   */
  fromCornerPoints(e, i) {
    return i = Mu.from(i), this.center = new Be().from(e).add(i).scale(0.5), this.radius = this.center.distance(i), this;
  }
  /** Compares the provided BoundingSphere component wise */
  equals(e) {
    return this === e || !!e && this.center.equals(e.center) && this.radius === e.radius;
  }
  /** Duplicates a BoundingSphere instance. */
  clone() {
    return new ud(this.center, this.radius);
  }
  /** Computes a bounding sphere that contains both the left and right bounding spheres. */
  union(e) {
    const i = this.center, s = this.radius, o = e.center, u = e.radius, d = Mu.copy(o).subtract(i), a = d.magnitude();
    if (s >= a + u)
      return this.clone();
    if (u >= a + s)
      return e.clone();
    const w = (s + a + u) * 0.5;
    return Vx.copy(d).scale((-s + w) / a).add(i), this.center.copy(Vx), this.radius = w, this;
  }
  /** Computes a bounding sphere by enlarging the provided sphere to contain the provided point. */
  expand(e) {
    const s = Mu.from(e).subtract(this.center).magnitude();
    return s > this.radius && (this.radius = s), this;
  }
  // BoundingVolume interface
  /**
   * Applies a 4x4 affine transformation matrix to a bounding sphere.
   * @param sphere The bounding sphere to apply the transformation to.
   * @param transform The transformation matrix to apply to the bounding sphere.
   * @returns self.
   */
  transform(e) {
    this.center.transform(e);
    const i = x3(Mu, e);
    return this.radius = Math.max(i[0], Math.max(i[1], i[2])) * this.radius, this;
  }
  /** Computes the estimated distance squared from the closest point on a bounding sphere to a point. */
  distanceSquaredTo(e) {
    const i = this.distanceTo(e);
    return i * i;
  }
  /** Computes the estimated distance from the closest point on a bounding sphere to a point. */
  distanceTo(e) {
    const s = Mu.from(e).subtract(this.center);
    return Math.max(0, s.len() - this.radius);
  }
  /** Determines which side of a plane a sphere is located. */
  intersectPlane(e) {
    const i = this.center, s = this.radius, u = e.normal.dot(i) + e.distance;
    return u < -s ? Xs.OUTSIDE : u < s ? Xs.INTERSECTING : Xs.INSIDE;
  }
}
const PL = new Be(), BL = new Be(), Nf = new Be(), Lf = new Be(), Uf = new Be(), DL = new Be(), OL = new Be(), Ro = {
  COLUMN0ROW0: 0,
  COLUMN0ROW1: 1,
  COLUMN0ROW2: 2,
  COLUMN1ROW0: 3,
  COLUMN1ROW1: 4,
  COLUMN1ROW2: 5,
  COLUMN2ROW0: 6,
  COLUMN2ROW1: 7,
  COLUMN2ROW2: 8
};
class dd {
  constructor(e = [0, 0, 0], i = [0, 0, 0, 0, 0, 0, 0, 0, 0]) {
    this.center = new Be().from(e), this.halfAxes = new Yi(i);
  }
  /** Returns an array with three halfSizes for the bounding box */
  get halfSize() {
    const e = this.halfAxes.getColumn(0), i = this.halfAxes.getColumn(1), s = this.halfAxes.getColumn(2);
    return [new Be(e).len(), new Be(i).len(), new Be(s).len()];
  }
  /** Returns a quaternion describing the orientation of the bounding box */
  get quaternion() {
    const e = this.halfAxes.getColumn(0), i = this.halfAxes.getColumn(1), s = this.halfAxes.getColumn(2), o = new Be(e).normalize(), u = new Be(i).normalize(), d = new Be(s).normalize();
    return new qu().fromMatrix3(new Yi([...o, ...u, ...d]));
  }
  /**
   * Create OrientedBoundingBox from quaternion based OBB,
   */
  fromCenterHalfSizeQuaternion(e, i, s) {
    const o = new qu(s), u = new Yi().fromQuaternion(o);
    return u[0] = u[0] * i[0], u[1] = u[1] * i[0], u[2] = u[2] * i[0], u[3] = u[3] * i[1], u[4] = u[4] * i[1], u[5] = u[5] * i[1], u[6] = u[6] * i[2], u[7] = u[7] * i[2], u[8] = u[8] * i[2], this.center = new Be().from(e), this.halfAxes = u, this;
  }
  /** Duplicates a OrientedBoundingBox instance. */
  clone() {
    return new dd(this.center, this.halfAxes);
  }
  /** Compares the provided OrientedBoundingBox component wise and returns */
  equals(e) {
    return this === e || !!e && this.center.equals(e.center) && this.halfAxes.equals(e.halfAxes);
  }
  /** Computes a tight-fitting bounding sphere enclosing the provided oriented bounding box. */
  getBoundingSphere(e = new ud()) {
    const i = this.halfAxes, s = i.getColumn(0, Nf), o = i.getColumn(1, Lf), u = i.getColumn(2, Uf), d = PL.copy(s).add(o).add(u);
    return e.center.copy(this.center), e.radius = d.magnitude(), e;
  }
  /** Determines which side of a plane the oriented bounding box is located. */
  intersectPlane(e) {
    const i = this.center, s = e.normal, o = this.halfAxes, u = s.x, d = s.y, a = s.z, w = Math.abs(u * o[Ro.COLUMN0ROW0] + d * o[Ro.COLUMN0ROW1] + a * o[Ro.COLUMN0ROW2]) + Math.abs(u * o[Ro.COLUMN1ROW0] + d * o[Ro.COLUMN1ROW1] + a * o[Ro.COLUMN1ROW2]) + Math.abs(u * o[Ro.COLUMN2ROW0] + d * o[Ro.COLUMN2ROW1] + a * o[Ro.COLUMN2ROW2]), S = s.dot(i) + e.distance;
    return S <= -w ? Xs.OUTSIDE : S >= w ? Xs.INSIDE : Xs.INTERSECTING;
  }
  /** Computes the estimated distance from the closest point on a bounding box to a point. */
  distanceTo(e) {
    return Math.sqrt(this.distanceSquaredTo(e));
  }
  /**
   * Computes the estimated distance squared from the closest point
   * on a bounding box to a point.
   * See Geometric Tools for Computer Graphics 10.4.2
   */
  distanceSquaredTo(e) {
    const i = BL.from(e).subtract(this.center), s = this.halfAxes, o = s.getColumn(0, Nf), u = s.getColumn(1, Lf), d = s.getColumn(2, Uf), a = o.magnitude(), w = u.magnitude(), S = d.magnitude();
    o.normalize(), u.normalize(), d.normalize();
    let M = 0, F;
    return F = Math.abs(i.dot(o)) - a, F > 0 && (M += F * F), F = Math.abs(i.dot(u)) - w, F > 0 && (M += F * F), F = Math.abs(i.dot(d)) - S, F > 0 && (M += F * F), M;
  }
  /**
   * The distances calculated by the vector from the center of the bounding box
   * to position projected onto direction.
   *
   * - If you imagine the infinite number of planes with normal direction,
   *   this computes the smallest distance to the closest and farthest planes
   *   from `position` that intersect the bounding box.
   *
   * @param position The position to calculate the distance from.
   * @param direction The direction from position.
   * @param result An Interval (array of length 2) to store the nearest and farthest distances.
   * @returns Interval (array of length 2) with nearest and farthest distances
   *   on the bounding box from position in direction.
   */
  // eslint-disable-next-line max-statements
  computePlaneDistances(e, i, s = [-0, -0]) {
    let o = Number.POSITIVE_INFINITY, u = Number.NEGATIVE_INFINITY;
    const d = this.center, a = this.halfAxes, w = a.getColumn(0, Nf), S = a.getColumn(1, Lf), M = a.getColumn(2, Uf), F = DL.copy(w).add(S).add(M).add(d), N = OL.copy(F).subtract(e);
    let L = i.dot(N);
    return o = Math.min(L, o), u = Math.max(L, u), F.copy(d).add(w).add(S).subtract(M), N.copy(F).subtract(e), L = i.dot(N), o = Math.min(L, o), u = Math.max(L, u), F.copy(d).add(w).subtract(S).add(M), N.copy(F).subtract(e), L = i.dot(N), o = Math.min(L, o), u = Math.max(L, u), F.copy(d).add(w).subtract(S).subtract(M), N.copy(F).subtract(e), L = i.dot(N), o = Math.min(L, o), u = Math.max(L, u), d.copy(F).subtract(w).add(S).add(M), N.copy(F).subtract(e), L = i.dot(N), o = Math.min(L, o), u = Math.max(L, u), d.copy(F).subtract(w).add(S).subtract(M), N.copy(F).subtract(e), L = i.dot(N), o = Math.min(L, o), u = Math.max(L, u), d.copy(F).subtract(w).subtract(S).add(M), N.copy(F).subtract(e), L = i.dot(N), o = Math.min(L, o), u = Math.max(L, u), d.copy(F).subtract(w).subtract(S).subtract(M), N.copy(F).subtract(e), L = i.dot(N), o = Math.min(L, o), u = Math.max(L, u), s[0] = o, s[1] = u, s;
  }
  /**
   * Applies a 4x4 affine transformation matrix to a bounding sphere.
   * @param transform The transformation matrix to apply to the bounding sphere.
   * @returns itself, i.e. the modified BoundingVolume.
   */
  transform(e) {
    this.center.transformAsPoint(e);
    const i = this.halfAxes.getColumn(0, Nf);
    i.transformAsPoint(e);
    const s = this.halfAxes.getColumn(1, Lf);
    s.transformAsPoint(e);
    const o = this.halfAxes.getColumn(2, Uf);
    return o.transformAsPoint(e), this.halfAxes = new Yi([...i, ...s, ...o]), this;
  }
  getTransform() {
    throw new Error("not implemented");
  }
}
const jx = new Be(), Hx = new Be();
class so {
  constructor(e = [0, 0, 1], i = 0) {
    this.normal = new Be(), this.distance = -0, this.fromNormalDistance(e, i);
  }
  /** Creates a plane from a normal and a distance from the origin. */
  fromNormalDistance(e, i) {
    return In(Number.isFinite(i)), this.normal.from(e).normalize(), this.distance = i, this;
  }
  /** Creates a plane from a normal and a point on the plane. */
  fromPointNormal(e, i) {
    e = jx.from(e), this.normal.from(i).normalize();
    const s = -this.normal.dot(e);
    return this.distance = s, this;
  }
  /** Creates a plane from the general equation */
  fromCoefficients(e, i, s, o) {
    return this.normal.set(e, i, s), In(On(this.normal.len(), 1)), this.distance = o, this;
  }
  /** Duplicates a Plane instance. */
  clone() {
    return new so(this.normal, this.distance);
  }
  /** Compares the provided Planes by normal and distance */
  equals(e) {
    return On(this.distance, e.distance) && On(this.normal, e.normal);
  }
  /** Computes the signed shortest distance of a point to a plane.
   * The sign of the distance determines which side of the plane the point is on.
   */
  getPointDistance(e) {
    return this.normal.dot(e) + this.distance;
  }
  /** Transforms the plane by the given transformation matrix. */
  transform(e) {
    const i = Hx.copy(this.normal).transformAsVector(e).normalize(), s = this.normal.scale(-this.distance).transform(e);
    return this.fromPointNormal(s, i);
  }
  projectPointOntoPlane(e, i = [0, 0, 0]) {
    const s = jx.from(e), o = this.getPointDistance(s), u = Hx.copy(this.normal).scale(o);
    return s.subtract(u).to(i);
  }
}
const $x = [new Be([1, 0, 0]), new Be([0, 1, 0]), new Be([0, 0, 1])], Gx = new Be(), FL = new Be();
class cn {
  /**
   * Create a new `CullingVolume` bounded by an array of clipping planed
   * @param planes Array of clipping planes.
   * */
  constructor(e = []) {
    this.planes = e;
  }
  /**
   * Constructs a culling volume from a bounding sphere. Creates six planes that create a box containing the sphere.
   * The planes are aligned to the x, y, and z axes in world coordinates.
   */
  fromBoundingSphere(e) {
    this.planes.length = 2 * $x.length;
    const i = e.center, s = e.radius;
    let o = 0;
    for (const u of $x) {
      let d = this.planes[o], a = this.planes[o + 1];
      d || (d = this.planes[o] = new so()), a || (a = this.planes[o + 1] = new so());
      const w = Gx.copy(u).scale(-s).add(i);
      d.fromPointNormal(w, u);
      const S = Gx.copy(u).scale(s).add(i), M = FL.copy(u).negate();
      a.fromPointNormal(S, M), o += 2;
    }
    return this;
  }
  /** Determines whether a bounding volume intersects the culling volume. */
  computeVisibility(e) {
    let i = Xs.INSIDE;
    for (const s of this.planes)
      switch (e.intersectPlane(s)) {
        case Xs.OUTSIDE:
          return Xs.OUTSIDE;
        case Xs.INTERSECTING:
          i = Xs.INTERSECTING;
          break;
      }
    return i;
  }
  /**
   * Determines whether a bounding volume intersects the culling volume.
   *
   * @param parentPlaneMask A bit mask from the boundingVolume's parent's check against the same culling
   *   volume, such that if (planeMask & (1 << planeIndex) === 0), for k < 31, then
   *   the parent (and therefore this) volume is completely inside plane[planeIndex]
   *   and that plane check can be skipped.
   */
  computeVisibilityWithPlaneMask(e, i) {
    if (In(Number.isFinite(i), "parentPlaneMask is required."), i === cn.MASK_OUTSIDE || i === cn.MASK_INSIDE)
      return i;
    let s = cn.MASK_INSIDE;
    const o = this.planes;
    for (let u = 0; u < this.planes.length; ++u) {
      const d = u < 31 ? 1 << u : 0;
      if (u < 31 && (i & d) === 0)
        continue;
      const a = o[u], w = e.intersectPlane(a);
      if (w === Xs.OUTSIDE)
        return cn.MASK_OUTSIDE;
      w === Xs.INTERSECTING && (s |= d);
    }
    return s;
  }
}
cn.MASK_OUTSIDE = 4294967295;
cn.MASK_INSIDE = 0;
cn.MASK_INDETERMINATE = 2147483647;
new Be();
new Be();
new Be();
new Be();
new Be();
new Be();
new Be();
new Be();
new Be();
new Be();
new Be();
new Be();
new Be();
new Be();
new Be();
new Be();
new Be();
const ro = new Yi(), kL = new Yi(), NL = new Yi(), zf = new Yi(), Wx = new Yi();
function LL(t, e = {}) {
  const i = oB, s = 10;
  let o = 0, u = 0;
  const d = kL, a = NL;
  d.identity(), a.copy(t);
  const w = i * UL(a);
  for (; u < s && zL(a) > w; )
    VL(a, zf), Wx.copy(zf).transpose(), a.multiplyRight(zf), a.multiplyLeft(Wx), d.multiplyRight(zf), ++o > 2 && (++u, o = 0);
  return e.unitary = d.toTarget(e.unitary), e.diagonal = a.toTarget(e.diagonal), e;
}
function UL(t) {
  let e = 0;
  for (let i = 0; i < 9; ++i) {
    const s = t[i];
    e += s * s;
  }
  return Math.sqrt(e);
}
const Nm = [1, 0, 0], Lm = [2, 2, 1];
function zL(t) {
  let e = 0;
  for (let i = 0; i < 3; ++i) {
    const s = t[ro.getElementIndex(Lm[i], Nm[i])];
    e += 2 * s * s;
  }
  return Math.sqrt(e);
}
function VL(t, e) {
  const i = _T;
  let s = 0, o = 1;
  for (let S = 0; S < 3; ++S) {
    const M = Math.abs(t[ro.getElementIndex(Lm[S], Nm[S])]);
    M > s && (o = S, s = M);
  }
  const u = Nm[o], d = Lm[o];
  let a = 1, w = 0;
  if (Math.abs(t[ro.getElementIndex(d, u)]) > i) {
    const S = t[ro.getElementIndex(d, d)], M = t[ro.getElementIndex(u, u)], F = t[ro.getElementIndex(d, u)], N = (S - M) / 2 / F;
    let L;
    N < 0 ? L = -1 / (-N + Math.sqrt(1 + N * N)) : L = 1 / (N + Math.sqrt(1 + N * N)), a = 1 / Math.sqrt(1 + L * L), w = L * a;
  }
  return Yi.IDENTITY.to(e), e[ro.getElementIndex(u, u)] = e[ro.getElementIndex(d, d)] = a, e[ro.getElementIndex(d, u)] = w, e[ro.getElementIndex(u, d)] = -w, e;
}
const ga = new Be(), jL = new Be(), HL = new Be(), $L = new Be(), WL = new Be(), XL = new Yi(), qL = {
  diagonal: new Yi(),
  unitary: new Yi()
};
function ZL(t, e = new dd()) {
  if (!t || t.length === 0)
    return e.halfAxes = new Yi([0, 0, 0, 0, 0, 0, 0, 0, 0]), e.center = new Be(), e;
  const i = t.length, s = new Be(0, 0, 0);
  for (const st of t)
    s.add(st);
  const o = 1 / i;
  s.multiplyByScalar(o);
  let u = 0, d = 0, a = 0, w = 0, S = 0, M = 0;
  for (const st of t) {
    const ot = ga.copy(st).subtract(s);
    u += ot.x * ot.x, d += ot.x * ot.y, a += ot.x * ot.z, w += ot.y * ot.y, S += ot.y * ot.z, M += ot.z * ot.z;
  }
  u *= o, d *= o, a *= o, w *= o, S *= o, M *= o;
  const F = XL;
  F[0] = u, F[1] = d, F[2] = a, F[3] = d, F[4] = w, F[5] = S, F[6] = a, F[7] = S, F[8] = M;
  const { unitary: N } = LL(F, qL), L = e.halfAxes.copy(N);
  let re = L.getColumn(0, HL), ne = L.getColumn(1, $L), we = L.getColumn(2, WL), Se = -Number.MAX_VALUE, Ee = -Number.MAX_VALUE, Ce = -Number.MAX_VALUE, Le = Number.MAX_VALUE, Ze = Number.MAX_VALUE, Ke = Number.MAX_VALUE;
  for (const st of t)
    ga.copy(st), Se = Math.max(ga.dot(re), Se), Ee = Math.max(ga.dot(ne), Ee), Ce = Math.max(ga.dot(we), Ce), Le = Math.min(ga.dot(re), Le), Ze = Math.min(ga.dot(ne), Ze), Ke = Math.min(ga.dot(we), Ke);
  re = re.multiplyByScalar(0.5 * (Le + Se)), ne = ne.multiplyByScalar(0.5 * (Ze + Ee)), we = we.multiplyByScalar(0.5 * (Ke + Ce)), e.center.copy(re).add(ne).add(we);
  const ct = jL.set(Se - Le, Ee - Ze, Ce - Ke).multiplyByScalar(0.5), _t = new Yi([ct[0], 0, 0, 0, ct[1], 0, 0, 0, ct[2]]);
  return e.halfAxes.multiplyRight(_t), e;
}
const Bg = Math.PI / 180, Vf = new Float32Array(16), Xx = new Float32Array(12);
function qx(t, e, i) {
  const s = e[0] * Bg, o = e[1] * Bg, u = e[2] * Bg, d = Math.sin(u), a = Math.sin(s), w = Math.sin(o), S = Math.cos(u), M = Math.cos(s), F = Math.cos(o), N = i[0], L = i[1], re = i[2];
  t[0] = N * F * M, t[1] = N * w * M, t[2] = N * -a, t[3] = L * (-w * S + F * a * d), t[4] = L * (F * S + w * a * d), t[5] = L * M * d, t[6] = re * (w * d + F * a * S), t[7] = re * (-F * d + w * a * S), t[8] = re * M * S;
}
function Zx(t) {
  return t[0] = t[0], t[1] = t[1], t[2] = t[2], t[3] = t[4], t[4] = t[5], t[5] = t[6], t[6] = t[8], t[7] = t[9], t[8] = t[10], t[9] = t[12], t[10] = t[13], t[11] = t[14], t.subarray(0, 12);
}
const pA = {
  size: 12,
  accessor: ["getOrientation", "getScale", "getTranslation", "getTransformMatrix"],
  shaderAttributes: {
    instanceModelMatrixCol0: {
      size: 3,
      elementOffset: 0
    },
    instanceModelMatrixCol1: {
      size: 3,
      elementOffset: 3
    },
    instanceModelMatrixCol2: {
      size: 3,
      elementOffset: 6
    },
    instanceTranslation: {
      size: 3,
      elementOffset: 9
    }
  },
  update(t, { startRow: e, endRow: i }) {
    const { data: s, getOrientation: o, getScale: u, getTranslation: d, getTransformMatrix: a } = this.props, w = Array.isArray(a), S = w && a.length === 16, M = Array.isArray(u), F = Array.isArray(o), N = Array.isArray(d), L = S || !w && !!a(s[0]);
    L ? t.constant = S : t.constant = F && M && N;
    const re = t.value;
    if (t.constant) {
      let ne;
      L ? (Vf.set(a), ne = Zx(Vf)) : (ne = Xx, qx(ne, o, u), ne.set(d, 9)), t.value = new Float32Array(ne);
    } else {
      let ne = e * t.size;
      const { iterable: we, objectInfo: Se } = JT(s, e, i);
      for (const Ee of we) {
        Se.index++;
        let Ce;
        if (L)
          Vf.set(S ? a : a(Ee, Se)), Ce = Zx(Vf);
        else {
          Ce = Xx;
          const Le = F ? o : o(Ee, Se), Ze = M ? u : u(Ee, Se);
          qx(Ce, Le, Ze), Ce.set(N ? d : d(Ee, Se), 9);
        }
        re[ne++] = Ce[0], re[ne++] = Ce[1], re[ne++] = Ce[2], re[ne++] = Ce[3], re[ne++] = Ce[4], re[ne++] = Ce[5], re[ne++] = Ce[6], re[ne++] = Ce[7], re[ne++] = Ce[8], re[ne++] = Ce[9], re[ne++] = Ce[10], re[ne++] = Ce[11];
      }
    }
  }
};
function _A(t, e) {
  return e === Xt.CARTESIAN || e === Xt.METER_OFFSETS || e === Xt.DEFAULT && !t.isGeospatial;
}
const KL = `#version 300 es
#define SHADER_NAME simple-mesh-layer-vs
uniform float sizeScale;
uniform bool composeModelMatrix;
in vec3 positions;
in vec3 normals;
in vec3 colors;
in vec2 texCoords;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec3 instanceModelMatrixCol0;
in vec3 instanceModelMatrixCol1;
in vec3 instanceModelMatrixCol2;
in vec3 instanceTranslation;
out vec2 vTexCoord;
out vec3 cameraPosition;
out vec3 normals_commonspace;
out vec4 position_commonspace;
out vec4 vColor;
void main(void) {
geometry.worldPosition = instancePositions;
geometry.uv = texCoords;
geometry.pickingColor = instancePickingColors;
vTexCoord = texCoords;
cameraPosition = project_uCameraPosition;
vColor = vec4(colors * instanceColors.rgb, instanceColors.a);
mat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);
vec3 pos = (instanceModelMatrix * positions) * sizeScale + instanceTranslation;
if (composeModelMatrix) {
DECKGL_FILTER_SIZE(pos, geometry);
normals_commonspace = project_normal(instanceModelMatrix * normals);
geometry.worldPosition += pos;
gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), position_commonspace);
geometry.position = position_commonspace;
}
else {
pos = project_size(pos);
DECKGL_FILTER_SIZE(pos, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, position_commonspace);
geometry.position = position_commonspace;
normals_commonspace = project_normal(instanceModelMatrix * normals);
}
geometry.normal = normals_commonspace;
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
DECKGL_FILTER_COLOR(vColor, geometry);
}
`, YL = `#version 300 es
#define SHADER_NAME simple-mesh-layer-fs
precision highp float;
uniform bool hasTexture;
uniform sampler2D sampler;
uniform bool flatShading;
uniform float opacity;
in vec2 vTexCoord;
in vec3 cameraPosition;
in vec3 normals_commonspace;
in vec4 position_commonspace;
in vec4 vColor;
out vec4 fragColor;
void main(void) {
geometry.uv = vTexCoord;
vec3 normal;
if (flatShading) {
normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
} else {
normal = normals_commonspace;
}
vec4 color = hasTexture ? texture(sampler, vTexCoord) : vColor;
DECKGL_FILTER_COLOR(color, geometry);
vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);
fragColor = vec4(lightColor, color.a * opacity);
}
`;
function Dg(t) {
  const e = t.positions || t.POSITION;
  Jt.assert(e, 'no "postions" or "POSITION" attribute in mesh');
  const i = e.value.length / e.size;
  let s = t.COLOR_0 || t.colors;
  s || (s = { size: 3, value: new Float32Array(i * 3).fill(1) });
  let o = t.NORMAL || t.normals;
  o || (o = { size: 3, value: new Float32Array(i * 3).fill(0) });
  let u = t.TEXCOORD_0 || t.texCoords;
  return u || (u = { size: 2, value: new Float32Array(i * 2).fill(0) }), {
    positions: e,
    colors: s,
    normals: o,
    texCoords: u
  };
}
function Kx(t) {
  return t instanceof eh ? (t.attributes = Dg(t.attributes), t) : t.attributes ? new eh({
    ...t,
    topology: "triangle-list",
    attributes: Dg(t.attributes)
  }) : new eh({
    topology: "triangle-list",
    attributes: Dg(t)
  });
}
const JL = [0, 0, 0, 255], QL = {
  mesh: { type: "object", value: null, async: !0 },
  texture: { type: "image", value: null, async: !0 },
  sizeScale: { type: "number", value: 1, min: 0 },
  // _instanced is a hack to use world position instead of meter offsets in mesh
  // TODO - formalize API
  _instanced: !0,
  // NOTE(Tarek): Quick and dirty wireframe. Just draws
  // the same mesh with LINE_STRIPS. Won't follow edges
  // of the original mesh.
  wireframe: !1,
  // Optional material for 'lighting' shader module
  material: !0,
  getPosition: { type: "accessor", value: (t) => t.position },
  getColor: { type: "accessor", value: JL },
  // yaw, pitch and roll are in degrees
  // https://en.wikipedia.org/wiki/Euler_angles
  // [pitch, yaw, roll]
  getOrientation: { type: "accessor", value: [0, 0, 0] },
  getScale: { type: "accessor", value: [1, 1, 1] },
  getTranslation: { type: "accessor", value: [0, 0, 0] },
  // 4x4 matrix
  getTransformMatrix: { type: "accessor", value: [] },
  textureParameters: { type: "object", ignore: !0, value: null }
};
class Uy extends mh {
  getShaders() {
    return super.getShaders({
      vs: KL,
      fs: YL,
      modules: [Ay, dB, Cy]
    });
  }
  getBounds() {
    if (this.props._instanced)
      return super.getBounds();
    let e = this.state.positionBounds;
    if (e)
      return e;
    const { mesh: i } = this.props;
    if (!i)
      return null;
    if (e = i.header?.boundingBox, !e) {
      const { attributes: s } = Kx(i);
      s.POSITION = s.POSITION || s.positions, e = ww(s);
    }
    return this.state.positionBounds = e, e;
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        transition: !0,
        type: "float64",
        fp64: this.use64bitPositions(),
        size: 3,
        accessor: "getPosition"
      },
      instanceColors: {
        type: "unorm8",
        transition: !0,
        size: this.props.colorFormat.length,
        accessor: "getColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceModelMatrix: pA
    }), this.setState({
      // Avoid luma.gl's missing uniform warning
      // TODO - add feature to luma.gl to specify ignored uniforms?
      emptyTexture: this.context.device.createTexture({
        data: new Uint8Array(4),
        width: 1,
        height: 1
      })
    });
  }
  updateState(e) {
    super.updateState(e);
    const { props: i, oldProps: s, changeFlags: o } = e;
    if (i.mesh !== s.mesh || o.extensionsChanged) {
      if (this.state.positionBounds = null, this.state.model?.destroy(), i.mesh) {
        this.state.model = this.getModel(i.mesh);
        const u = i.mesh.attributes || i.mesh;
        this.setState({
          hasNormals: !!(u.NORMAL || u.normals)
        });
      }
      this.getAttributeManager().invalidateAll();
    }
    i.texture !== s.texture && i.texture instanceof qs && this.setTexture(i.texture), this.state.model && this.state.model.setTopology(this.props.wireframe ? "line-strip" : "triangle-list");
  }
  finalizeState(e) {
    super.finalizeState(e), this.state.emptyTexture.delete();
  }
  draw({ uniforms: e }) {
    const { model: i } = this.state;
    if (!i)
      return;
    const { viewport: s, renderPass: o } = this.context, { sizeScale: u, coordinateSystem: d, _instanced: a } = this.props;
    i.setUniforms(e), i.setUniforms({
      sizeScale: u,
      composeModelMatrix: !a || _A(s, d),
      flatShading: !this.state.hasNormals
    }), i.draw(o);
  }
  get isLoaded() {
    return !!(this.state?.model && super.isLoaded);
  }
  getModel(e) {
    const i = new Ca(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: Kx(e),
      isInstanced: !0
    }), { texture: s } = this.props, { emptyTexture: o } = this.state;
    return i.setBindings({
      sampler: s || o
    }), i.setUniforms({
      hasTexture: !!s
    }), i;
  }
  setTexture(e) {
    const { emptyTexture: i, model: s } = this.state;
    s && (s.setBindings({
      sampler: e || i
    }), s.setUniforms({
      hasTexture: !!e
    }));
  }
}
Uy.defaultProps = QL;
Uy.layerName = "SimpleMeshLayer";
var Mn;
(function(t) {
  t[t.FUNC_ADD = 32774] = "FUNC_ADD", t[t.ONE = 1] = "ONE", t[t.SRC_ALPHA = 770] = "SRC_ALPHA", t[t.ONE_MINUS_SRC_ALPHA = 771] = "ONE_MINUS_SRC_ALPHA", t[t.TEXTURE_MIN_FILTER = 10241] = "TEXTURE_MIN_FILTER", t[t.LINEAR = 9729] = "LINEAR", t[t.LINEAR_MIPMAP_NEAREST = 9985] = "LINEAR_MIPMAP_NEAREST", t[t.UNPACK_FLIP_Y_WEBGL = 37440] = "UNPACK_FLIP_Y_WEBGL";
})(Mn || (Mn = {}));
function gA(t, e, i, s) {
  const o = {
    defines: {
      // TODO: Use EXT_sRGB if available (Standard in WebGL 2.0)
      MANUAL_SRGB: 1,
      SRGB_FAST_APPROXIMATION: 1
    },
    bindings: {},
    uniforms: {
      // TODO: find better values?
      u_Camera: [0, 0, 0],
      // Model should override
      u_MetallicRoughnessValues: [1, 1]
      // Default is 1 and 1
    },
    parameters: {},
    glParameters: {},
    generatedTextures: []
  };
  o.defines.USE_TEX_LOD = 1;
  const { imageBasedLightingEnvironment: u } = s;
  return u && (o.bindings.u_DiffuseEnvSampler = u.diffuseEnvSampler, o.bindings.u_SpecularEnvSampler = u.specularEnvSampler, o.bindings.u_brdfLUT = u.brdfLutTexture, o.uniforms.u_ScaleIBLAmbient = [1, 1]), s?.pbrDebug && (o.defines.PBR_DEBUG = 1, o.uniforms.u_ScaleDiffBaseMR = [0, 0, 0, 0], o.uniforms.u_ScaleFGDSpec = [0, 0, 0, 0]), i.NORMAL && (o.defines.HAS_NORMALS = 1), i.TANGENT && s?.useTangents && (o.defines.HAS_TANGENTS = 1), i.TEXCOORD_0 && (o.defines.HAS_UV = 1), s?.imageBasedLightingEnvironment && (o.defines.USE_IBL = 1), s?.lights && (o.defines.USE_LIGHTS = 1), e && eU(t, e, o), o;
}
function eU(t, e, i) {
  if (i.uniforms.pbr_uUnlit = !!e.unlit, e.pbrMetallicRoughness && tU(t, e.pbrMetallicRoughness, i), e.normalTexture) {
    Gu(t, e.normalTexture, "u_NormalSampler", "HAS_NORMALMAP", i);
    const { scale: s = 1 } = e.normalTexture;
    i.uniforms.u_NormalScale = s;
  }
  if (e.occlusionTexture) {
    Gu(t, e.occlusionTexture, "u_OcclusionSampler", "HAS_OCCLUSIONMAP", i);
    const { strength: s = 1 } = e.occlusionTexture;
    i.uniforms.u_OcclusionStrength = s;
  }
  switch (e.emissiveTexture && (Gu(t, e.emissiveTexture, "u_EmissiveSampler", "HAS_EMISSIVEMAP", i), i.uniforms.u_EmissiveFactor = e.emissiveFactor || [0, 0, 0]), e.alphaMode) {
    case "MASK":
      const { alphaCutoff: s = 0.5 } = e;
      i.defines.ALPHA_CUTOFF = 1, i.uniforms.u_AlphaCutoff = s;
      break;
    case "BLEND":
      Je.warn("glTF BLEND alphaMode might not work well because it requires mesh sorting")(), i.parameters.blendColorOperation = "add", i.parameters.blendColorSrcFactor = "src-alpha", i.parameters.blendColorDstFactor = "one-minus-src-alpha", i.parameters.blendAlphaOperation = "add", i.parameters.blendAlphaSrcFactor = "one", i.parameters.blendAlphaDstFactor = "one-minus-src-alpha", i.glParameters.blend = !0, i.glParameters.blendEquation = Mn.FUNC_ADD, i.glParameters.blendFunc = [
        Mn.SRC_ALPHA,
        Mn.ONE_MINUS_SRC_ALPHA,
        Mn.ONE,
        Mn.ONE_MINUS_SRC_ALPHA
      ];
      break;
  }
}
function tU(t, e, i) {
  e.baseColorTexture && Gu(t, e.baseColorTexture, "u_BaseColorSampler", "HAS_BASECOLORMAP", i), i.uniforms.u_BaseColorFactor = e.baseColorFactor || [1, 1, 1, 1], e.metallicRoughnessTexture && Gu(t, e.metallicRoughnessTexture, "u_MetallicRoughnessSampler", "HAS_METALROUGHNESSMAP", i);
  const { metallicFactor: s = 1, roughnessFactor: o = 1 } = e;
  i.uniforms.u_MetallicRoughnessValues = [s, o];
}
function Gu(t, e, i, s = null, o) {
  const u = e?.texture?.sampler?.parameters || {}, d = e.texture.source.image;
  let a, w = {};
  d.compressed ? (a = d, w = {
    [Mn.TEXTURE_MIN_FILTER]: d.data.length > 1 ? Mn.LINEAR_MIPMAP_NEAREST : Mn.LINEAR
  }) : a = { data: d };
  const S = t.createTexture({
    id: e.uniformName || e.id,
    parameters: {
      ...u,
      ...w
    },
    pixelStore: {
      [Mn.UNPACK_FLIP_Y_WEBGL]: !1
    },
    ...a
  });
  o.bindings[i] = S, s && (o.defines[s] = 1), o.generatedTextures.push(S);
}
const iU = "4.3.1", vp = {
  /** Basis transcoder, javascript wrapper part */
  TRANSCODER: "basis_transcoder.js",
  /** Basis transcoder, compiled web assembly part */
  TRANSCODER_WASM: "basis_transcoder.wasm",
  /** Basis encoder, javascript wrapper part */
  ENCODER: "basis_encoder.js",
  /** Basis encoder, compiled web assembly part */
  ENCODER_WASM: "basis_encoder.wasm"
};
let Yx;
async function Jx(t) {
  PC(t.modules);
  const e = BC("basis");
  return e || (Yx ||= rU(t), await Yx);
}
async function rU(t) {
  let e = null, i = null;
  return [e, i] = await Promise.all([
    await El(vp.TRANSCODER, "textures", t),
    await El(vp.TRANSCODER_WASM, "textures", t)
  ]), e = e || globalThis.BASIS, await sU(e, i);
}
function sU(t, e) {
  const i = {};
  return e && (i.wasmBinary = e), new Promise((s) => {
    t(i).then((o) => {
      const { BasisFile: u, initializeBasis: d } = o;
      d(), s({ BasisFile: u });
    });
  });
}
let Og;
async function Qx(t) {
  const e = t.modules || {};
  return e.basisEncoder ? e.basisEncoder : (Og = Og || nU(t), await Og);
}
async function nU(t) {
  let e = null, i = null;
  return [e, i] = await Promise.all([
    await El(vp.ENCODER, "textures", t),
    await El(vp.ENCODER_WASM, "textures", t)
  ]), e = e || globalThis.BASIS, await oU(e, i);
}
function oU(t, e) {
  const i = {};
  return e && (i.wasmBinary = e), new Promise((s) => {
    t(i).then((o) => {
      const { BasisFile: u, KTX2File: d, initializeBasis: a, BasisEncoder: w } = o;
      a(), s({ BasisFile: u, KTX2File: d, BasisEncoder: w });
    });
  });
}
const Lc = {
  // WEBGL_compressed_texture_s3tc
  COMPRESSED_RGB_S3TC_DXT1_EXT: 33776,
  COMPRESSED_RGBA_S3TC_DXT5_EXT: 33779,
  // WEBGL_compressed_texture_pvrtc
  COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 35840,
  COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 35842,
  // WEBGL_compressed_texture_etc1
  COMPRESSED_RGB_ETC1_WEBGL: 36196,
  // WEBGL_compressed_texture_astc
  COMPRESSED_RGBA_ASTC_4X4_KHR: 37808
}, aU = ["", "WEBKIT_", "MOZ_"], e1 = {
  /* eslint-disable camelcase */
  WEBGL_compressed_texture_s3tc: "dxt",
  WEBGL_compressed_texture_s3tc_srgb: "dxt-srgb",
  WEBGL_compressed_texture_etc1: "etc1",
  WEBGL_compressed_texture_etc: "etc2",
  WEBGL_compressed_texture_pvrtc: "pvrtc",
  WEBGL_compressed_texture_atc: "atc",
  WEBGL_compressed_texture_astc: "astc",
  EXT_texture_compression_rgtc: "rgtc"
  /* eslint-enable camelcase */
};
let jf = null;
function lU(t) {
  if (!jf) {
    t = t || cU() || void 0, jf = /* @__PURE__ */ new Set();
    for (const e of aU)
      for (const i in e1)
        if (t && t.getExtension(`${e}${i}`)) {
          const s = e1[i];
          jf.add(s);
        }
  }
  return jf;
}
function cU() {
  try {
    return document.createElement("canvas").getContext("webgl");
  } catch {
    return null;
  }
}
const Gs = [
  // '´', 'K', 'T', 'X', '2', '0', 'ª', '\r', '\n', '\x1A', '\n'
  171,
  75,
  84,
  88,
  32,
  50,
  48,
  187,
  13,
  10,
  26,
  10
];
function hU(t) {
  const e = new Uint8Array(t);
  return !(e.byteLength < Gs.length || e[0] !== Gs[0] || // '´'
  e[1] !== Gs[1] || // 'K'
  e[2] !== Gs[2] || // 'T'
  e[3] !== Gs[3] || // 'X'
  e[4] !== Gs[4] || // ' '
  e[5] !== Gs[5] || // '2'
  e[6] !== Gs[6] || // '0'
  e[7] !== Gs[7] || // 'ª'
  e[8] !== Gs[8] || // '\r'
  e[9] !== Gs[9] || // '\n'
  e[10] !== Gs[10] || // '\x1A'
  e[11] !== Gs[11]);
}
const uU = {
  etc1: {
    basisFormat: 0,
    compressed: !0,
    format: Lc.COMPRESSED_RGB_ETC1_WEBGL
  },
  etc2: { basisFormat: 1, compressed: !0 },
  bc1: {
    basisFormat: 2,
    compressed: !0,
    format: Lc.COMPRESSED_RGB_S3TC_DXT1_EXT
  },
  bc3: {
    basisFormat: 3,
    compressed: !0,
    format: Lc.COMPRESSED_RGBA_S3TC_DXT5_EXT
  },
  bc4: { basisFormat: 4, compressed: !0 },
  bc5: { basisFormat: 5, compressed: !0 },
  "bc7-m6-opaque-only": { basisFormat: 6, compressed: !0 },
  "bc7-m5": { basisFormat: 7, compressed: !0 },
  "pvrtc1-4-rgb": {
    basisFormat: 8,
    compressed: !0,
    format: Lc.COMPRESSED_RGB_PVRTC_4BPPV1_IMG
  },
  "pvrtc1-4-rgba": {
    basisFormat: 9,
    compressed: !0,
    format: Lc.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
  },
  "astc-4x4": {
    basisFormat: 10,
    compressed: !0,
    format: Lc.COMPRESSED_RGBA_ASTC_4X4_KHR
  },
  "atc-rgb": { basisFormat: 11, compressed: !0 },
  "atc-rgba-interpolated-alpha": { basisFormat: 12, compressed: !0 },
  rgba32: { basisFormat: 13, compressed: !1 },
  rgb565: { basisFormat: 14, compressed: !1 },
  bgr565: { basisFormat: 15, compressed: !1 },
  rgba4444: { basisFormat: 16, compressed: !1 }
};
async function dU(t, e) {
  if (e.basis.containerFormat === "auto") {
    if (hU(t)) {
      const s = await Qx(e);
      return t1(s.KTX2File, t, e);
    }
    const { BasisFile: i } = await Jx(e);
    return Fg(i, t, e);
  }
  switch (e.basis.module) {
    case "encoder":
      const i = await Qx(e);
      switch (e.basis.containerFormat) {
        case "ktx2":
          return t1(i.KTX2File, t, e);
        case "basis":
        default:
          return Fg(i.BasisFile, t, e);
      }
    case "transcoder":
    default:
      const { BasisFile: s } = await Jx(e);
      return Fg(s, t, e);
  }
}
function Fg(t, e, i) {
  const s = new t(new Uint8Array(e));
  try {
    if (!s.startTranscoding())
      throw new Error("Failed to start basis transcoding");
    const o = s.getNumImages(), u = [];
    for (let d = 0; d < o; d++) {
      const a = s.getNumLevels(d), w = [];
      for (let S = 0; S < a; S++)
        w.push(fU(s, d, S, i));
      u.push(w);
    }
    return u;
  } finally {
    s.close(), s.delete();
  }
}
function fU(t, e, i, s) {
  const o = t.getImageWidth(e, i), u = t.getImageHeight(e, i), d = t.getHasAlpha(
    /* imageIndex, levelIndex */
  ), { compressed: a, format: w, basisFormat: S } = mA(s, d), M = t.getImageTranscodedSizeInBytes(e, i, S), F = new Uint8Array(M);
  if (!t.transcodeImage(F, e, i, S, 0, 0))
    throw new Error("failed to start Basis transcoding");
  return {
    // standard loaders.gl image category payload
    width: o,
    height: u,
    data: F,
    compressed: a,
    format: w,
    // Additional fields
    // Add levelSize field.
    hasAlpha: d
  };
}
function t1(t, e, i) {
  const s = new t(new Uint8Array(e));
  try {
    if (!s.startTranscoding())
      throw new Error("failed to start KTX2 transcoding");
    const o = s.getLevels(), u = [];
    for (let d = 0; d < o; d++)
      u.push(pU(s, d, i));
    return [u];
  } finally {
    s.close(), s.delete();
  }
}
function pU(t, e, i) {
  const { alphaFlag: s, height: o, width: u } = t.getImageLevelInfo(e, 0, 0), { compressed: d, format: a, basisFormat: w } = mA(i, s), S = t.getImageTranscodedSizeInBytes(e, 0, 0, w), M = new Uint8Array(S);
  if (!t.transcodeImage(
    M,
    e,
    0,
    0,
    w,
    0,
    -1,
    -1
    /* channel1 */
  ))
    throw new Error("Failed to transcode KTX2 image");
  return {
    // standard loaders.gl image category payload
    width: u,
    height: o,
    data: M,
    compressed: d,
    // Additional fields
    levelSize: S,
    hasAlpha: s,
    format: a
  };
}
function mA(t, e) {
  let i = t && t.basis && t.basis.format;
  return i === "auto" && (i = yA()), typeof i == "object" && (i = e ? i.alpha : i.noAlpha), i = i.toLowerCase(), uU[i];
}
function yA() {
  const t = lU();
  return t.has("astc") ? "astc-4x4" : t.has("dxt") ? {
    alpha: "bc3",
    noAlpha: "bc1"
  } : t.has("pvrtc") ? {
    alpha: "pvrtc1-4-rgba",
    noAlpha: "pvrtc1-4-rgb"
  } : t.has("etc1") ? "etc1" : t.has("etc2") ? "etc2" : "rgb565";
}
const _U = {
  dataType: null,
  batchType: null,
  name: "Basis",
  id: "basis",
  module: "textures",
  version: iU,
  worker: !0,
  extensions: ["basis", "ktx2"],
  mimeTypes: ["application/octet-stream", "image/ktx2"],
  tests: ["sB"],
  binary: !0,
  options: {
    basis: {
      format: "auto",
      libraryPath: "libs/",
      containerFormat: "auto",
      module: "transcoder"
    }
  }
}, gU = {
  ..._U,
  parse: dU
}, mU = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, yU = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
class bU {
  name;
  startTime = 0;
  playing = !0;
  speed = 1;
  channels = [];
  constructor(e) {
    Object.assign(this, e);
  }
  animate(e) {
    if (!this.playing)
      return;
    const s = (e / 1e3 - this.startTime) * this.speed;
    this.channels.forEach(({ sampler: o, target: u, path: d }) => {
      SU(s, o, u, d), wU(u, u._node);
    });
  }
}
class vU {
  animations;
  constructor(e) {
    this.animations = e.animations.map((i, s) => {
      const o = i.name || `Animation-${s}`, u = i.samplers.map(({ input: a, interpolation: w = "LINEAR", output: S }) => ({
        input: i1(e.accessors[a]),
        interpolation: w,
        output: i1(e.accessors[S])
      })), d = i.channels.map(({ sampler: a, target: w }) => ({
        sampler: u[a],
        target: e.nodes[w.node],
        path: w.path
      }));
      return new bU({ name: o, channels: d });
    });
  }
  /** @deprecated Use .setTime(). Will be removed (deck.gl is using this) */
  animate(e) {
    this.setTime(e);
  }
  setTime(e) {
    this.animations.forEach((i) => i.animate(e));
  }
  getAnimations() {
    return this.animations;
  }
}
function i1(t) {
  if (!t._animation) {
    const e = yU[t.componentType], i = mU[t.type], s = i * t.count, { buffer: o, byteOffset: u } = t.bufferView.data, d = new e(o, u + (t.byteOffset || 0), s);
    if (i === 1)
      t._animation = Array.from(d);
    else {
      const a = [];
      for (let w = 0; w < d.length; w += i)
        a.push(Array.from(d.slice(w, w + i)));
      t._animation = a;
    }
  }
  return t._animation;
}
const xU = new Gt();
function wU(t, e) {
  if (e.matrix.identity(), t.translation && e.matrix.translate(t.translation), t.rotation) {
    const i = xU.fromQuaternion(t.rotation);
    e.matrix.multiplyRight(i);
  }
  t.scale && e.matrix.scale(t.scale);
}
const kg = new qu();
function TU(t, e, i, s, o) {
  if (e === "rotation") {
    kg.slerp({ start: i, target: s, ratio: o });
    for (let u = 0; u < kg.length; u++)
      t[e][u] = kg[u];
  } else
    for (let u = 0; u < i.length; u++)
      t[e][u] = o * s[u] + (1 - o) * i[u];
}
function AU(t, e, { p0: i, outTangent0: s, inTangent1: o, p1: u, tDiff: d, ratio: a }) {
  for (let w = 0; w < t[e].length; w++) {
    const S = s[w] * d, M = o[w] * d;
    t[e][w] = (2 * Math.pow(a, 3) - 3 * Math.pow(a, 2) + 1) * i[w] + (Math.pow(a, 3) - 2 * Math.pow(a, 2) + a) * S + (-2 * Math.pow(a, 3) + 3 * Math.pow(a, 2)) * u[w] + (Math.pow(a, 3) - Math.pow(a, 2)) * M;
  }
}
function EU(t, e, i) {
  for (let s = 0; s < i.length; s++)
    t[e][s] = i[s];
}
function SU(t, { input: e, interpolation: i, output: s }, o, u) {
  const d = e[e.length - 1], a = t % d, w = e.findIndex((N) => N >= a), S = Math.max(0, w - 1);
  if (!Array.isArray(o[u]))
    switch (u) {
      case "translation":
        o[u] = [0, 0, 0];
        break;
      case "rotation":
        o[u] = [0, 0, 0, 1];
        break;
      case "scale":
        o[u] = [1, 1, 1];
        break;
      default:
        Je.warn(`Bad animation path ${u}`)();
    }
  si(o[u].length === s[S].length);
  const M = e[S], F = e[w];
  switch (i) {
    case "STEP":
      EU(o, u, s[S]);
      break;
    case "LINEAR":
      if (F > M) {
        const N = (a - M) / (F - M);
        TU(o, u, s[S], s[w], N);
      }
      break;
    case "CUBICSPLINE":
      if (F > M) {
        const N = (a - M) / (F - M), L = F - M, re = s[3 * S + 1], ne = s[3 * S + 2], we = s[3 * w + 0], Se = s[3 * w + 1];
        AU(o, u, { p0: re, outTangent0: ne, inTangent1: we, p1: Se, tDiff: L, ratio: N });
      }
      break;
    default:
      Je.warn(`Interpolation ${i} not supported`)();
      break;
  }
}
const CU = `
#pragma vscode_glsllint_stage: vert
#if (__VERSION__ < 300)
  #define _attr attribute
#else
  #define _attr in
#endif

  // _attr vec4 POSITION;
  _attr vec4 positions;

  #ifdef HAS_NORMALS
    // _attr vec4 NORMAL;
    _attr vec4 normals;
  #endif

  #ifdef HAS_TANGENTS
    _attr vec4 TANGENT;
  #endif

  #ifdef HAS_UV
    // _attr vec2 TEXCOORD_0;
    _attr vec2 texCoords;
  #endif

  void main(void) {
    vec4 _NORMAL = vec4(0.);
    vec4 _TANGENT = vec4(0.);
    vec2 _TEXCOORD_0 = vec2(0.);

    #ifdef HAS_NORMALS
      _NORMAL = normals;
    #endif

    #ifdef HAS_TANGENTS
      _TANGENT = TANGENT;
    #endif

    #ifdef HAS_UV
      _TEXCOORD_0 = texCoords;
    #endif

    pbr_setPositionNormalTangentUV(positions, _NORMAL, _TANGENT, _TEXCOORD_0);
    gl_Position = u_MVPMatrix * positions;
  }
`, IU = `
#pragma vscode_glsllint_stage: frag
#if (__VERSION__ < 300)
  #define fragmentColor gl_FragColor
#else
  out vec4 fragmentColor;
#endif

  void main(void) {
    vec3 pos = pbr_vPosition;
    fragmentColor = pbr_filterColor(vec4(1.0));
  }
`;
function MU(t, e) {
  const { id: i, geometry: s, material: o, vertexCount: u, materialOptions: d, modelOptions: a } = e, w = gA(t, o, s.attributes, d);
  Je.info(4, "createGLTFModel defines: ", w.defines)();
  const S = [], M = {
    depthWriteEnabled: !0,
    depthCompare: "less",
    depthFormat: "depth24plus",
    cullMode: "back"
  }, F = {
    id: i,
    geometry: s,
    topology: s.topology,
    vertexCount: u,
    modules: [wy],
    vs: r1(t, CU),
    fs: r1(t, IU),
    ...a,
    bindings: { ...w.bindings, ...a.bindings },
    defines: { ...w.defines, ...a.defines },
    parameters: { ...M, ...w.parameters, ...a.parameters },
    uniforms: { ...w.uniforms, ...a.uniforms }
  }, N = new Ca(t, F);
  return new Am({ managedResources: S, model: N });
}
function r1(t, e) {
  return `#version 300 es
${e}`;
}
const RU = {
  modelOptions: {},
  pbrDebug: !1,
  imageBasedLightingEnvironment: null,
  lights: !0,
  useTangents: !1
};
class PU {
  device;
  options;
  gltf;
  constructor(e, i = {}) {
    this.device = e, this.options = { ...RU, ...i };
  }
  instantiate(e) {
    return this.gltf = e, (e.scenes || []).map((s) => this.createScene(s));
  }
  createAnimator() {
    return Array.isArray(this.gltf.animations) ? new vU(this.gltf) : null;
  }
  createScene(e) {
    const s = (e.nodes || []).map((u) => this.createNode(u));
    return new th({
      id: e.name || e.id,
      children: s
    });
  }
  createNode(e) {
    if (!e._node) {
      const s = (e.children || []).map((u) => this.createNode(u));
      e.mesh && s.push(this.createMesh(e.mesh));
      const o = new th({
        id: e.name || e.id,
        children: s
      });
      if (e.matrix)
        o.setMatrix(e.matrix);
      else {
        if (o.matrix.identity(), e.translation && o.matrix.translate(e.translation), e.rotation) {
          const u = new Gt().fromQuaternion(e.rotation);
          o.matrix.multiplyRight(u);
        }
        e.scale && o.matrix.scale(e.scale);
      }
      e._node = o;
    }
    return e._node;
  }
  createMesh(e) {
    if (!e._mesh) {
      const s = (e.primitives || []).map((u, d) => this.createPrimitive(u, d, e)), o = new th({
        id: e.name || e.id,
        children: s
      });
      e._mesh = o;
    }
    return e._mesh;
  }
  createPrimitive(e, i, s) {
    const o = e.name || `${s.name || s.id}-primitive-${i}`, u = BU(e.mode || 4), d = e.indices ? e.indices.count : this.getVertexCount(e.attributes), a = MU(this.device, {
      id: o,
      geometry: this.createGeometry(o, e, u),
      material: e.material,
      materialOptions: this.options,
      modelOptions: this.options.modelOptions,
      vertexCount: d
    });
    return a.bounds = [
      e.attributes.POSITION.min,
      e.attributes.POSITION.max
    ], a;
  }
  getVertexCount(e) {
    throw new Error("getVertexCount not implemented");
  }
  createGeometry(e, i, s) {
    const o = {};
    for (const [u, d] of Object.entries(i.attributes)) {
      const { components: a, size: w, value: S } = d;
      o[u] = { size: w ?? a, value: S };
    }
    return new eh({
      id: e,
      topology: s,
      indices: i.indices.value,
      attributes: o
    });
  }
  createBuffer(e, i) {
    e.bufferView || (e.bufferView = {});
    const { bufferView: s } = e;
    return s.lumaBuffers || (s.lumaBuffers = {}), s.lumaBuffers[i] || (s.lumaBuffers[i] = this.device.createBuffer({
      id: `from-${s.id}`,
      // Draco decoded files have attribute.value
      data: s.data || e.value
    })), s.lumaBuffers[i];
  }
  // TODO - create sampler in WebGL2
  createSampler(e) {
    return e;
  }
  // Helper methods (move to GLTFLoader.resolve...?)
  needsPOT() {
    return !1;
  }
}
var Po;
(function(t) {
  t[t.POINTS = 0] = "POINTS", t[t.LINES = 1] = "LINES", t[t.LINE_LOOP = 2] = "LINE_LOOP", t[t.LINE_STRIP = 3] = "LINE_STRIP", t[t.TRIANGLES = 4] = "TRIANGLES", t[t.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", t[t.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
})(Po || (Po = {}));
function BU(t) {
  switch (t) {
    case Po.POINTS:
      return "point-list";
    case Po.LINES:
      return "line-list";
    case Po.LINE_STRIP:
      return "line-strip";
    case Po.LINE_LOOP:
      return "line-loop-webgl";
    case Po.TRIANGLES:
      return "triangle-list";
    case Po.TRIANGLE_STRIP:
      return "triangle-strip";
    case Po.TRIANGLE_FAN:
      return "triangle-fan-webgl";
    default:
      throw new Error(t);
  }
}
function DU(t, e, i) {
  const s = new PU(t, i), o = s.instantiate(e), u = s.createAnimator();
  return { scenes: o, animator: u };
}
function Zs(t, e) {
  if (!t)
    throw new Error(e || "assert failed: gltf");
}
const bA = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, vA = {
  5120: 1,
  // BYTE
  5121: 1,
  // UNSIGNED_BYTE
  5122: 2,
  // SHORT
  5123: 2,
  // UNSIGNED_SHORT
  5125: 4,
  // UNSIGNED_INT
  5126: 4
  // FLOAT
}, OU = 1.33, s1 = ["SCALAR", "VEC2", "VEC3", "VEC4"], FU = [
  [Int8Array, 5120],
  [Uint8Array, 5121],
  [Int16Array, 5122],
  [Uint16Array, 5123],
  [Uint32Array, 5125],
  [Float32Array, 5126],
  [Float64Array, 5130]
], kU = new Map(FU), NU = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, LU = {
  5120: 1,
  5121: 1,
  5122: 2,
  5123: 2,
  5125: 4,
  5126: 4
}, UU = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
function xA(t) {
  return s1[t - 1] || s1[0];
}
function Np(t) {
  const e = kU.get(t.constructor);
  if (!e)
    throw new Error("Illegal typed array");
  return e;
}
function zy(t, e) {
  const i = UU[t.componentType], s = NU[t.type], o = LU[t.componentType], u = t.count * s, d = t.count * s * o;
  Zs(d >= 0 && d <= e.byteLength);
  const a = vA[t.componentType], w = bA[t.type];
  return { ArrayType: i, length: u, byteLength: d, componentByteSize: a, numberOfComponentsInElement: w };
}
function wA(t) {
  let { images: e, bufferViews: i } = t;
  e = e || [], i = i || [];
  const s = e.map((d) => d.bufferView);
  i = i.filter((d) => !s.includes(d));
  const o = i.reduce((d, a) => d + a.byteLength, 0), u = e.reduce((d, a) => {
    const { width: w, height: S } = a.image;
    return d + w * S;
  }, 0);
  return o + Math.ceil(4 * u * OU);
}
function zU(t, e, i) {
  const s = t.bufferViews[i];
  Zs(s);
  const o = s.buffer, u = e[o];
  Zs(u);
  const d = (s.byteOffset || 0) + u.byteOffset;
  return new Uint8Array(u.arrayBuffer, d, s.byteLength);
}
function VU(t, e, i) {
  const s = typeof i == "number" ? t.accessors?.[i] : i;
  if (!s)
    throw new Error(`No gltf accessor ${JSON.stringify(i)}`);
  const o = t.bufferViews?.[s.bufferView || 0];
  if (!o)
    throw new Error(`No gltf buffer view for accessor ${o}`);
  const { arrayBuffer: u, byteOffset: d } = e[o.buffer], a = (d || 0) + (s.byteOffset || 0) + (o.byteOffset || 0), { ArrayType: w, length: S, componentByteSize: M, numberOfComponentsInElement: F } = zy(s, o), N = M * F, L = o.byteStride || N;
  if (typeof o.byteStride > "u" || o.byteStride === N)
    return new w(u, a, S);
  const re = new w(S);
  for (let ne = 0; ne < s.count; ne++) {
    const we = new w(u, a + ne * L, F);
    re.set(we, ne * F);
  }
  return re;
}
function jU() {
  return {
    asset: {
      version: "2.0",
      generator: "loaders.gl"
    },
    buffers: [],
    extensions: {},
    extensionsRequired: [],
    extensionsUsed: []
  };
}
class Br {
  // internal
  gltf;
  sourceBuffers;
  byteLength;
  // TODO - why is this not GLTFWithBuffers - what happens to images?
  constructor(e) {
    this.gltf = {
      json: e?.json || jU(),
      buffers: e?.buffers || [],
      images: e?.images || []
    }, this.sourceBuffers = [], this.byteLength = 0, this.gltf.buffers && this.gltf.buffers[0] && (this.byteLength = this.gltf.buffers[0].byteLength, this.sourceBuffers = [this.gltf.buffers[0]]);
  }
  // Accessors
  get json() {
    return this.gltf.json;
  }
  getApplicationData(e) {
    return this.json[e];
  }
  getExtraData(e) {
    return (this.json.extras || {})[e];
  }
  hasExtension(e) {
    const i = this.getUsedExtensions().find((o) => o === e), s = this.getRequiredExtensions().find((o) => o === e);
    return typeof i == "string" || typeof s == "string";
  }
  getExtension(e) {
    const i = this.getUsedExtensions().find((o) => o === e), s = this.json.extensions || {};
    return i ? s[e] : null;
  }
  getRequiredExtension(e) {
    return this.getRequiredExtensions().find((s) => s === e) ? this.getExtension(e) : null;
  }
  getRequiredExtensions() {
    return this.json.extensionsRequired || [];
  }
  getUsedExtensions() {
    return this.json.extensionsUsed || [];
  }
  getRemovedExtensions() {
    return this.json.extensionsRemoved || [];
  }
  getObjectExtension(e, i) {
    return (e.extensions || {})[i];
  }
  getScene(e) {
    return this.getObject("scenes", e);
  }
  getNode(e) {
    return this.getObject("nodes", e);
  }
  getSkin(e) {
    return this.getObject("skins", e);
  }
  getMesh(e) {
    return this.getObject("meshes", e);
  }
  getMaterial(e) {
    return this.getObject("materials", e);
  }
  getAccessor(e) {
    return this.getObject("accessors", e);
  }
  // getCamera(index: number): object | null {
  //   return null; // TODO: fix thi: object  as null;
  // }
  getTexture(e) {
    return this.getObject("textures", e);
  }
  getSampler(e) {
    return this.getObject("samplers", e);
  }
  getImage(e) {
    return this.getObject("images", e);
  }
  getBufferView(e) {
    return this.getObject("bufferViews", e);
  }
  getBuffer(e) {
    return this.getObject("buffers", e);
  }
  getObject(e, i) {
    if (typeof i == "object")
      return i;
    const s = this.json[e] && this.json[e][i];
    if (!s)
      throw new Error(`glTF file error: Could not find ${e}[${i}]`);
    return s;
  }
  /**
   * Accepts buffer view index or buffer view object
   * @returns a `Uint8Array`
   */
  getTypedArrayForBufferView(e) {
    e = this.getBufferView(e);
    const i = e.buffer, s = this.gltf.buffers[i];
    Zs(s);
    const o = (e.byteOffset || 0) + s.byteOffset;
    return new Uint8Array(s.arrayBuffer, o, e.byteLength);
  }
  /** Accepts accessor index or accessor object
   * @returns a typed array with type that matches the types
   */
  getTypedArrayForAccessor(e) {
    const i = this.getAccessor(e);
    return VU(this.gltf.json, this.gltf.buffers, i);
  }
  /** accepts accessor index or accessor object
   * returns a `Uint8Array`
   */
  getTypedArrayForImageData(e) {
    e = this.getAccessor(e);
    const i = this.getBufferView(e.bufferView), o = this.getBuffer(i.buffer).data, u = i.byteOffset || 0;
    return new Uint8Array(o, u, i.byteLength);
  }
  // MODIFERS
  /**
   * Add an extra application-defined key to the top-level data structure
   */
  addApplicationData(e, i) {
    return this.json[e] = i, this;
  }
  /**
   * `extras` - Standard GLTF field for storing application specific data
   */
  addExtraData(e, i) {
    return this.json.extras = this.json.extras || {}, this.json.extras[e] = i, this;
  }
  addObjectExtension(e, i, s) {
    return e.extensions = e.extensions || {}, e.extensions[i] = s, this.registerUsedExtension(i), this;
  }
  setObjectExtension(e, i, s) {
    const o = e.extensions || {};
    o[i] = s;
  }
  removeObjectExtension(e, i) {
    const s = e?.extensions || {};
    if (s[i]) {
      this.json.extensionsRemoved = this.json.extensionsRemoved || [];
      const o = this.json.extensionsRemoved;
      o.includes(i) || o.push(i);
    }
    delete s[i];
  }
  /**
   * Add to standard GLTF top level extension object, mark as used
   */
  addExtension(e, i = {}) {
    return Zs(i), this.json.extensions = this.json.extensions || {}, this.json.extensions[e] = i, this.registerUsedExtension(e), i;
  }
  /**
   * Standard GLTF top level extension object, mark as used and required
   */
  addRequiredExtension(e, i = {}) {
    return Zs(i), this.addExtension(e, i), this.registerRequiredExtension(e), i;
  }
  /**
   * Add extensionName to list of used extensions
   */
  registerUsedExtension(e) {
    this.json.extensionsUsed = this.json.extensionsUsed || [], this.json.extensionsUsed.find((i) => i === e) || this.json.extensionsUsed.push(e);
  }
  /**
   * Add extensionName to list of required extensions
   */
  registerRequiredExtension(e) {
    this.registerUsedExtension(e), this.json.extensionsRequired = this.json.extensionsRequired || [], this.json.extensionsRequired.find((i) => i === e) || this.json.extensionsRequired.push(e);
  }
  /**
   * Removes an extension from the top-level list
   */
  removeExtension(e) {
    if (this.json.extensions?.[e]) {
      this.json.extensionsRemoved = this.json.extensionsRemoved || [];
      const i = this.json.extensionsRemoved;
      i.includes(e) || i.push(e);
    }
    this.json.extensions && delete this.json.extensions[e], this.json.extensionsRequired && this._removeStringFromArray(this.json.extensionsRequired, e), this.json.extensionsUsed && this._removeStringFromArray(this.json.extensionsUsed, e);
  }
  /**
   *  Set default scene which is to be displayed at load time
   */
  setDefaultScene(e) {
    this.json.scene = e;
  }
  /**
   * @todo: add more properties for scene initialization:
   *   name`, `extensions`, `extras`
   *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-scene
   */
  addScene(e) {
    const { nodeIndices: i } = e;
    return this.json.scenes = this.json.scenes || [], this.json.scenes.push({ nodes: i }), this.json.scenes.length - 1;
  }
  /**
   * @todo: add more properties for node initialization:
   *   `name`, `extensions`, `extras`, `camera`, `children`, `skin`, `rotation`, `scale`, `translation`, `weights`
   *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#node
   */
  addNode(e) {
    const { meshIndex: i, matrix: s } = e;
    this.json.nodes = this.json.nodes || [];
    const o = { mesh: i };
    return s && (o.matrix = s), this.json.nodes.push(o), this.json.nodes.length - 1;
  }
  /** Adds a mesh to the json part */
  addMesh(e) {
    const { attributes: i, indices: s, material: o, mode: u = 4 } = e, a = {
      primitives: [
        {
          attributes: this._addAttributes(i),
          mode: u
        }
      ]
    };
    if (s) {
      const w = this._addIndices(s);
      a.primitives[0].indices = w;
    }
    return Number.isFinite(o) && (a.primitives[0].material = o), this.json.meshes = this.json.meshes || [], this.json.meshes.push(a), this.json.meshes.length - 1;
  }
  addPointCloud(e) {
    const s = {
      primitives: [
        {
          attributes: this._addAttributes(e),
          mode: 0
          // GL.POINTS
        }
      ]
    };
    return this.json.meshes = this.json.meshes || [], this.json.meshes.push(s), this.json.meshes.length - 1;
  }
  /**
   * Adds a binary image. Builds glTF "JSON metadata" and saves buffer reference
   * Buffer will be copied into BIN chunk during "pack"
   * Currently encodes as glTF image
   * @param imageData
   * @param mimeType
   */
  addImage(e, i) {
    const s = ry(e), o = i || s?.mimeType, d = {
      bufferView: this.addBufferView(e),
      mimeType: o
    };
    return this.json.images = this.json.images || [], this.json.images.push(d), this.json.images.length - 1;
  }
  /**
   * Add one untyped source buffer, create a matching glTF `bufferView`, and return its index
   * @param buffer
   */
  addBufferView(e, i = 0, s = this.byteLength) {
    const o = e.byteLength;
    Zs(Number.isFinite(o)), this.sourceBuffers = this.sourceBuffers || [], this.sourceBuffers.push(e);
    const u = {
      buffer: i,
      // Write offset from the start of the binary body
      byteOffset: s,
      byteLength: o
    };
    return this.byteLength += sd(o, 4), this.json.bufferViews = this.json.bufferViews || [], this.json.bufferViews.push(u), this.json.bufferViews.length - 1;
  }
  /**
   * Adds an accessor to a bufferView
   * @param bufferViewIndex
   * @param accessor
   */
  addAccessor(e, i) {
    const s = {
      bufferView: e,
      // @ts-ignore
      type: xA(i.size),
      // @ts-ignore
      componentType: i.componentType,
      // @ts-ignore
      count: i.count,
      // @ts-ignore
      max: i.max,
      // @ts-ignore
      min: i.min
    };
    return this.json.accessors = this.json.accessors || [], this.json.accessors.push(s), this.json.accessors.length - 1;
  }
  /**
   * Add a binary buffer. Builds glTF "JSON metadata" and saves buffer reference
   * Buffer will be copied into BIN chunk during "pack"
   * Currently encodes buffers as glTF accessors, but this could be optimized
   * @param sourceBuffer
   * @param accessor
   */
  addBinaryBuffer(e, i = { size: 3 }) {
    const s = this.addBufferView(e);
    let o = { min: i.min, max: i.max };
    (!o.min || !o.max) && (o = this._getAccessorMinMax(e, i.size));
    const u = {
      // @ts-ignore
      size: i.size,
      componentType: Np(e),
      // @ts-ignore
      count: Math.round(e.length / i.size),
      min: o.min,
      max: o.max
    };
    return this.addAccessor(s, Object.assign(u, i));
  }
  /**
   * Adds a texture to the json part
   * @todo: add more properties for texture initialization
   * `sampler`, `name`, `extensions`, `extras`
   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#texture
   */
  addTexture(e) {
    const { imageIndex: i } = e, s = {
      source: i
    };
    return this.json.textures = this.json.textures || [], this.json.textures.push(s), this.json.textures.length - 1;
  }
  /** Adds a material to the json part */
  addMaterial(e) {
    return this.json.materials = this.json.materials || [], this.json.materials.push(e), this.json.materials.length - 1;
  }
  /** Pack the binary chunk */
  createBinaryChunk() {
    const e = this.byteLength, i = new ArrayBuffer(e), s = new Uint8Array(i);
    let o = 0;
    for (const u of this.sourceBuffers || [])
      o = r2(u, s, o);
    this.json?.buffers?.[0] ? this.json.buffers[0].byteLength = e : this.json.buffers = [{ byteLength: e }], this.gltf.binary = i, this.sourceBuffers = [i], this.gltf.buffers = [{ arrayBuffer: i, byteOffset: 0, byteLength: i.byteLength }];
  }
  // PRIVATE
  _removeStringFromArray(e, i) {
    let s = !0;
    for (; s; ) {
      const o = e.indexOf(i);
      o > -1 ? e.splice(o, 1) : s = !1;
    }
  }
  /**
   * Add attributes to buffers and create `attributes` object which is part of `mesh`
   */
  _addAttributes(e = {}) {
    const i = {};
    for (const s in e) {
      const o = e[s], u = this._getGltfAttributeName(s), d = this.addBinaryBuffer(o.value, o);
      i[u] = d;
    }
    return i;
  }
  /**
   * Add indices to buffers
   */
  _addIndices(e) {
    return this.addBinaryBuffer(e, { size: 1 });
  }
  /**
   * Deduce gltf specific attribue name from input attribute name
   */
  _getGltfAttributeName(e) {
    switch (e.toLowerCase()) {
      case "position":
      case "positions":
      case "vertices":
        return "POSITION";
      case "normal":
      case "normals":
        return "NORMAL";
      case "color":
      case "colors":
        return "COLOR_0";
      case "texcoord":
      case "texcoords":
        return "TEXCOORD_0";
      default:
        return e;
    }
  }
  /**
   * Calculate `min` and `max` arrays of accessor according to spec:
   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-accessor
   */
  _getAccessorMinMax(e, i) {
    const s = { min: null, max: null };
    if (e.length < i)
      return s;
    s.min = [], s.max = [];
    const o = e.subarray(0, i);
    for (const u of o)
      s.min.push(u), s.max.push(u);
    for (let u = i; u < e.length; u += i)
      for (let d = 0; d < i; d++)
        s.min[0 + d] = Math.min(
          // @ts-ignore
          s.min[0 + d],
          e[u + d]
        ), s.max[0 + d] = Math.max(
          // @ts-ignore
          s.max[0 + d],
          e[u + d]
        );
    return s;
  }
}
function n1(t) {
  return (t % 1 + 1) % 1;
}
const TA = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16,
  BOOLEAN: 1,
  STRING: 1,
  ENUM: 1
}, HU = {
  INT8: Int8Array,
  UINT8: Uint8Array,
  INT16: Int16Array,
  UINT16: Uint16Array,
  INT32: Int32Array,
  UINT32: Uint32Array,
  INT64: BigInt64Array,
  UINT64: BigUint64Array,
  FLOAT32: Float32Array,
  FLOAT64: Float64Array
}, AA = {
  INT8: 1,
  UINT8: 1,
  INT16: 2,
  UINT16: 2,
  INT32: 4,
  UINT32: 4,
  INT64: 8,
  UINT64: 8,
  FLOAT32: 4,
  FLOAT64: 8
};
function Vy(t, e) {
  return AA[e] * TA[t];
}
function Lp(t, e, i, s) {
  if (i !== "UINT8" && i !== "UINT16" && i !== "UINT32" && i !== "UINT64")
    return null;
  const o = t.getTypedArrayForBufferView(e), u = Up(
    o,
    "SCALAR",
    // offsets consist of ONE component
    i,
    s + 1
    // The number of offsets is equal to the property table `count` plus one.
  );
  return u instanceof BigInt64Array || u instanceof BigUint64Array ? null : u;
}
function Up(t, e, i, s = 1) {
  const o = TA[e], u = HU[i], d = AA[i], a = s * o, w = a * d;
  let S = t.buffer, M = t.byteOffset;
  return M % d !== 0 && (S = new Uint8Array(S).slice(M, M + w).buffer, M = 0), new u(S, M, a);
}
function jy(t, e, i) {
  const s = `TEXCOORD_${e.texCoord || 0}`, o = i.attributes[s], u = t.getTypedArrayForAccessor(o), d = t.gltf.json, a = e.index, w = d.textures?.[a]?.source;
  if (typeof w < "u") {
    const S = d.images?.[w]?.mimeType, M = t.gltf.images?.[w];
    if (M && typeof M.width < "u") {
      const F = [];
      for (let N = 0; N < u.length; N += 2) {
        const L = $U(M, S, u, N, e.channels);
        F.push(L);
      }
      return F;
    }
  }
  return [];
}
function EA(t, e, i, s, o) {
  if (!i?.length)
    return;
  const u = [];
  for (const M of i) {
    let F = s.findIndex((N) => N === M);
    F === -1 && (F = s.push(M) - 1), u.push(F);
  }
  const d = new Uint32Array(u), a = t.gltf.buffers.push({
    arrayBuffer: d.buffer,
    byteOffset: d.byteOffset,
    byteLength: d.byteLength
  }) - 1, w = t.addBufferView(d, a, 0), S = t.addAccessor(w, {
    size: 1,
    componentType: Np(d),
    count: d.length
  });
  o.attributes[e] = S;
}
function $U(t, e, i, s, o = [0]) {
  const u = {
    r: { offset: 0, shift: 0 },
    g: { offset: 1, shift: 8 },
    b: { offset: 2, shift: 16 },
    a: { offset: 3, shift: 24 }
  }, d = i[s], a = i[s + 1];
  let w = 1;
  e && (e.indexOf("image/jpeg") !== -1 || e.indexOf("image/png") !== -1) && (w = 4);
  const S = GU(d, a, t, w);
  let M = 0;
  for (const F of o) {
    const N = typeof F == "number" ? Object.values(u)[F] : u[F], L = S + N.offset, re = Tw(t);
    if (re.data.length <= L)
      throw new Error(`${re.data.length} <= ${L}`);
    const ne = re.data[L];
    M |= ne << N.shift;
  }
  return M;
}
function GU(t, e, i, s = 1) {
  const o = i.width, u = n1(t) * (o - 1), d = Math.round(u), a = i.height, w = n1(e) * (a - 1), S = Math.round(w), M = i.components ? i.components : s;
  return (S * o + d) * M;
}
function SA(t, e, i, s, o) {
  const u = [];
  for (let d = 0; d < e; d++) {
    const a = i[d], w = i[d + 1] - i[d];
    if (w + a > s)
      break;
    const S = a / o, M = w / o;
    u.push(t.slice(S, S + M));
  }
  return u;
}
function CA(t, e, i) {
  const s = [];
  for (let o = 0; o < e; o++) {
    const u = o * i;
    s.push(t.slice(u, u + i));
  }
  return s;
}
function IA(t, e, i, s) {
  if (i)
    throw new Error("Not implemented - arrayOffsets for strings is specified");
  if (s) {
    const o = [], u = new TextDecoder("utf8");
    let d = 0;
    for (let a = 0; a < t; a++) {
      const w = s[a + 1] - s[a];
      if (w + d <= e.length) {
        const S = e.subarray(d, w + d), M = u.decode(S);
        o.push(M), d += w;
      }
    }
    return o;
  }
  return [];
}
const rh = "EXT_mesh_features", WU = rh;
async function XU(t, e) {
  const i = new Br(t);
  ZU(i, e);
}
function qU(t, e) {
  const i = new Br(t);
  return YU(i), i.createBinaryChunk(), i.gltf;
}
function ZU(t, e) {
  const i = t.gltf.json;
  if (i.meshes)
    for (const s of i.meshes)
      for (const o of s.primitives)
        KU(t, o, e);
}
function KU(t, e, i) {
  if (!i?.gltf?.loadBuffers)
    return;
  const o = e.extensions?.[rh]?.featureIds;
  if (o)
    for (const u of o) {
      let d;
      if (typeof u.attribute < "u") {
        const a = `_FEATURE_ID_${u.attribute}`, w = e.attributes[a];
        d = t.getTypedArrayForAccessor(w);
      } else typeof u.texture < "u" && i?.gltf?.loadImages ? d = jy(t, u.texture, e) : d = [];
      u.data = d;
    }
}
function YU(t, e) {
  const i = t.gltf.json.meshes;
  if (i)
    for (const s of i)
      for (const o of s.primitives)
        QU(t, o);
}
function JU(t, e, i, s) {
  e.extensions || (e.extensions = {});
  let o = e.extensions[rh];
  o || (o = { featureIds: [] }, e.extensions[rh] = o);
  const { featureIds: u } = o, d = {
    featureCount: i.length,
    propertyTable: s,
    data: i
  };
  u.push(d), t.addObjectExtension(e, rh, o);
}
function QU(t, e) {
  const i = e.extensions?.[rh];
  if (!i)
    return;
  const s = i.featureIds;
  s.forEach((o, u) => {
    if (o.data) {
      const { accessorKey: d, index: a } = ez(e.attributes), w = new Uint32Array(o.data);
      s[u] = {
        featureCount: w.length,
        propertyTable: o.propertyTable,
        attribute: a
      }, t.gltf.buffers.push({
        arrayBuffer: w.buffer,
        byteOffset: w.byteOffset,
        byteLength: w.byteLength
      });
      const S = t.addBufferView(w), M = t.addAccessor(S, {
        size: 1,
        componentType: Np(w),
        count: w.length
      });
      e.attributes[d] = M;
    }
  });
}
function ez(t) {
  const e = "_FEATURE_ID_", i = Object.keys(t).filter((u) => u.indexOf(e) === 0);
  let s = -1;
  for (const u of i) {
    const d = Number(u.substring(e.length));
    d > s && (s = d);
  }
  return s++, { accessorKey: `${e}${s}`, index: s };
}
const tz = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createExtMeshFeatures: JU,
  decode: XU,
  encode: qU,
  name: WU
}, Symbol.toStringTag, { value: "Module" })), hh = "EXT_structural_metadata", iz = hh;
async function rz(t, e) {
  const i = new Br(t);
  nz(i, e);
}
function sz(t, e) {
  const i = new Br(t);
  return xz(i), i.createBinaryChunk(), i.gltf;
}
function nz(t, e) {
  if (!e.gltf?.loadBuffers)
    return;
  const i = t.getExtension(hh);
  i && (e.gltf?.loadImages && oz(t, i), az(t, i));
}
function oz(t, e) {
  const i = e.propertyTextures, s = t.gltf.json;
  if (i && s.meshes)
    for (const o of s.meshes)
      for (const u of o.primitives)
        cz(t, i, u, e);
}
function az(t, e) {
  const i = e.schema;
  if (!i)
    return;
  const s = i.classes, o = e.propertyTables;
  if (s && o)
    for (const u in s) {
      const d = lz(o, u);
      d && uz(t, i, d);
    }
}
function lz(t, e) {
  for (const i of t)
    if (i.class === e)
      return i;
  return null;
}
function cz(t, e, i, s) {
  if (!e)
    return;
  const u = i.extensions?.[hh]?.propertyTextures;
  if (u)
    for (const d of u) {
      const a = e[d];
      hz(t, a, i, s);
    }
}
function hz(t, e, i, s) {
  if (!e.properties)
    return;
  s.dataAttributeNames || (s.dataAttributeNames = []);
  const o = e.class;
  for (const u in e.properties) {
    const d = `${o}_${u}`, a = e.properties?.[u];
    if (!a)
      continue;
    a.data || (a.data = []);
    const w = a.data, S = jy(t, a, i);
    S !== null && (EA(t, d, S, w, i), a.data = w, s.dataAttributeNames.push(d));
  }
}
function uz(t, e, i) {
  const s = e.classes?.[i.class];
  if (!s)
    throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${i.class}`);
  const o = i.count;
  for (const u in s.properties) {
    const d = s.properties[u], a = i.properties?.[u];
    if (a) {
      const w = dz(t, e, d, o, a);
      a.data = w;
    }
  }
}
function dz(t, e, i, s, o) {
  let u = [];
  const d = o.values, a = t.getTypedArrayForBufferView(d), w = fz(t, i, o, s), S = pz(t, o, s);
  switch (i.type) {
    case "SCALAR":
    case "VEC2":
    case "VEC3":
    case "VEC4":
    case "MAT2":
    case "MAT3":
    case "MAT4": {
      u = _z(i, s, a, w);
      break;
    }
    case "BOOLEAN":
      throw new Error(`Not implemented - classProperty.type=${i.type}`);
    case "STRING": {
      u = IA(s, a, w, S);
      break;
    }
    case "ENUM": {
      u = gz(e, i, s, a, w);
      break;
    }
    default:
      throw new Error(`Unknown classProperty type ${i.type}`);
  }
  return u;
}
function fz(t, e, i, s) {
  return e.array && // `count` is a number of array elements. May only be defined when `array` is true.
  // If `count` is NOT defined, it's a VARIABLE-length array
  typeof e.count > "u" && // `arrayOffsets` is an index of the buffer view containing offsets for variable-length arrays.
  typeof i.arrayOffsets < "u" ? Lp(t, i.arrayOffsets, i.arrayOffsetType || "UINT32", s) : null;
}
function pz(t, e, i) {
  return typeof e.stringOffsets < "u" ? Lp(t, e.stringOffsets, e.stringOffsetType || "UINT32", i) : null;
}
function _z(t, e, i, s) {
  const o = t.array, u = t.count, d = Vy(t.type, t.componentType), a = i.byteLength / d;
  let w;
  return t.componentType ? w = Up(
    i,
    t.type,
    // The datatype of the element's components. Only applicable to `SCALAR`, `VECN`, and `MATN` types.
    t.componentType,
    a
  ) : w = i, o ? s ? SA(w, e, s, i.length, d) : u ? CA(w, e, u) : [] : w;
}
function gz(t, e, i, s, o) {
  const u = e.enumType;
  if (!u)
    throw new Error("Incorrect data in the EXT_structural_metadata extension: classProperty.enumType is not set for type ENUM");
  const d = t.enums?.[u];
  if (!d)
    throw new Error(`Incorrect data in the EXT_structural_metadata extension: schema.enums does't contain ${u}`);
  const a = d.valueType || "UINT16", w = Vy(e.type, a), S = s.byteLength / w;
  let M = Up(s, e.type, a, S);
  if (M || (M = s), e.array) {
    if (o)
      return mz({
        valuesData: M,
        numberOfElements: i,
        arrayOffsets: o,
        valuesDataBytesLength: s.length,
        elementSize: w,
        enumEntry: d
      });
    const F = e.count;
    return F ? yz(M, i, F, d) : [];
  }
  return Hy(M, 0, i, d);
}
function mz(t) {
  const { valuesData: e, numberOfElements: i, arrayOffsets: s, valuesDataBytesLength: o, elementSize: u, enumEntry: d } = t, a = [];
  for (let w = 0; w < i; w++) {
    const S = s[w], M = s[w + 1] - s[w];
    if (M + S > o)
      break;
    const F = S / u, N = M / u, L = Hy(e, F, N, d);
    a.push(L);
  }
  return a;
}
function yz(t, e, i, s) {
  const o = [];
  for (let u = 0; u < e; u++) {
    const d = i * u, a = Hy(t, d, i, s);
    o.push(a);
  }
  return o;
}
function Hy(t, e, i, s) {
  const o = [];
  for (let u = 0; u < i; u++)
    if (t instanceof BigInt64Array || t instanceof BigUint64Array)
      o.push("");
    else {
      const d = t[e + u], a = bz(s, d);
      a ? o.push(a.name) : o.push("");
    }
  return o;
}
function bz(t, e) {
  for (const i of t.values)
    if (i.value === e)
      return i;
  return null;
}
const vz = "schemaClassId";
function xz(t, e) {
  const i = t.getExtension(hh);
  if (i && i.propertyTables)
    for (const s of i.propertyTables) {
      const o = s.class, u = i.schema?.classes?.[o];
      s.properties && u && wz(s, u, t);
    }
}
function wz(t, e, i) {
  for (const s in t.properties) {
    const o = t.properties[s].data;
    if (o) {
      const u = e.properties[s];
      if (u) {
        const d = Sz(o, u, i);
        t.properties[s] = d;
      }
    }
  }
}
function Tz(t, e, i = vz) {
  let s = t.getExtension(hh);
  s || (s = t.addExtension(hh)), s.schema = Az(e, i, s.schema);
  const o = Ez(e, i, s.schema);
  return s.propertyTables || (s.propertyTables = []), s.propertyTables.push(o) - 1;
}
function Az(t, e, i) {
  const s = i ?? {
    id: "schema_id"
  }, o = {
    properties: {}
  };
  for (const u of t) {
    const d = {
      type: u.elementType,
      componentType: u.componentType
    };
    o.properties[u.name] = d;
  }
  return s.classes = {}, s.classes[e] = o, s;
}
function Ez(t, e, i) {
  const s = {
    class: e,
    count: 0
  };
  let o = 0;
  const u = i.classes?.[e];
  for (const d of t) {
    if (o === 0 && (o = d.values.length), o !== d.values.length && d.values.length)
      throw new Error("Illegal values in attributes");
    u?.properties[d.name] && (s.properties || (s.properties = {}), s.properties[d.name] = { values: 0, data: d.values });
  }
  return s.count = o, s;
}
function Sz(t, e, i) {
  const s = { values: 0 };
  if (e.type === "STRING") {
    const { stringData: o, stringOffsets: u } = Mz(t);
    s.stringOffsets = Ng(u, i), s.values = Ng(o, i);
  } else if (e.type === "SCALAR" && e.componentType) {
    const o = Iz(t, e.componentType);
    s.values = Ng(o, i);
  }
  return s;
}
const Cz = {
  INT8: Int8Array,
  UINT8: Uint8Array,
  INT16: Int16Array,
  UINT16: Uint16Array,
  INT32: Int32Array,
  UINT32: Uint32Array,
  INT64: Int32Array,
  UINT64: Uint32Array,
  FLOAT32: Float32Array,
  FLOAT64: Float64Array
};
function Iz(t, e) {
  const i = [];
  for (const o of t)
    i.push(Number(o));
  const s = Cz[e];
  if (!s)
    throw new Error("Illegal component type");
  return new s(i);
}
function Mz(t) {
  const e = new TextEncoder(), i = [];
  let s = 0;
  for (const w of t) {
    const S = e.encode(w);
    s += S.length, i.push(S);
  }
  const o = new Uint8Array(s), u = [];
  let d = 0;
  for (const w of i)
    o.set(w, d), u.push(d), d += w.length;
  u.push(d);
  const a = new Uint32Array(u);
  return { stringData: o, stringOffsets: a };
}
function Ng(t, e) {
  return e.gltf.buffers.push({
    arrayBuffer: t.buffer,
    byteOffset: t.byteOffset,
    byteLength: t.byteLength
  }), e.addBufferView(t);
}
const Rz = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createExtStructuralMetadata: Tz,
  decode: rz,
  encode: sz,
  name: iz
}, Symbol.toStringTag, { value: "Module" })), MA = "EXT_feature_metadata", Pz = MA;
async function Bz(t, e) {
  const i = new Br(t);
  Dz(i, e);
}
function Dz(t, e) {
  if (!e.gltf?.loadBuffers)
    return;
  const i = t.getExtension(MA);
  i && (e.gltf?.loadImages && Oz(t, i), Fz(t, i));
}
function Oz(t, e) {
  const i = e.schema;
  if (!i)
    return;
  const s = i.classes, { featureTextures: o } = e;
  if (s && o)
    for (const u in s) {
      const d = s[u], a = Nz(o, u);
      a && Uz(t, a, d);
    }
}
function Fz(t, e) {
  const i = e.schema;
  if (!i)
    return;
  const s = i.classes, o = e.featureTables;
  if (s && o)
    for (const u in s) {
      const d = kz(o, u);
      d && Lz(t, i, d);
    }
}
function kz(t, e) {
  for (const i in t) {
    const s = t[i];
    if (s.class === e)
      return s;
  }
  return null;
}
function Nz(t, e) {
  for (const i in t) {
    const s = t[i];
    if (s.class === e)
      return s;
  }
  return null;
}
function Lz(t, e, i) {
  if (!i.class)
    return;
  const s = e.classes?.[i.class];
  if (!s)
    throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${i.class}`);
  const o = i.count;
  for (const u in s.properties) {
    const d = s.properties[u], a = i.properties?.[u];
    if (a) {
      const w = zz(t, e, d, o, a);
      a.data = w;
    }
  }
}
function Uz(t, e, i) {
  const s = e.class;
  for (const o in i.properties) {
    const u = e?.properties?.[o];
    if (u) {
      const d = Gz(t, u, s);
      u.data = d;
    }
  }
}
function zz(t, e, i, s, o) {
  let u = [];
  const d = o.bufferView, a = t.getTypedArrayForBufferView(d), w = Vz(t, i, o, s), S = jz(t, i, o, s);
  return i.type === "STRING" || i.componentType === "STRING" ? u = IA(s, a, w, S) : Hz(i) && (u = $z(i, s, a, w)), u;
}
function Vz(t, e, i, s) {
  return e.type === "ARRAY" && // `componentCount` is a number of fixed-length array elements.
  // If `componentCount` is NOT defined, it's a VARIABLE-length array
  typeof e.componentCount > "u" && // `arrayOffsetBufferView` is an index of the buffer view containing offsets for variable-length arrays.
  typeof i.arrayOffsetBufferView < "u" ? Lp(
    t,
    i.arrayOffsetBufferView,
    i.offsetType || "UINT32",
    // offsetType is used both for stringOffsetBufferView and arrayOffsetBufferView
    s
  ) : null;
}
function jz(t, e, i, s) {
  return typeof i.stringOffsetBufferView < "u" ? Lp(
    t,
    i.stringOffsetBufferView,
    i.offsetType || "UINT32",
    // offsetType is used both for stringOffsetBufferView and arrayOffsetBufferView
    s
  ) : null;
}
function Hz(t) {
  const e = [
    "UINT8",
    "INT16",
    "UINT16",
    "INT32",
    "UINT32",
    "INT64",
    "UINT64",
    "FLOAT32",
    "FLOAT64"
  ];
  return e.includes(t.type) || typeof t.componentType < "u" && e.includes(t.componentType);
}
function $z(t, e, i, s) {
  const o = t.type === "ARRAY", u = t.componentCount, d = "SCALAR", a = t.componentType || t.type, w = Vy(d, a), S = i.byteLength / w, M = Up(i, d, a, S);
  return o ? s ? SA(M, e, s, i.length, w) : u ? CA(M, e, u) : [] : M;
}
function Gz(t, e, i) {
  const s = t.gltf.json;
  if (!s.meshes)
    return [];
  const o = [];
  for (const u of s.meshes)
    for (const d of u.primitives)
      Wz(t, i, e, o, d);
  return o;
}
function Wz(t, e, i, s, o) {
  const u = {
    channels: i.channels,
    ...i.texture
  }, d = jy(t, u, o);
  d && EA(t, e, d, s, o);
}
const Xz = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: Bz,
  name: Pz
}, Symbol.toStringTag, { value: "Module" })), qz = "4.3.1", uh = !0, o1 = 1735152710, $y = 12, xp = 8, Zz = 1313821514, Kz = 5130562, Yz = 0, Jz = 0, Qz = 1;
function e6(t, e = 0) {
  return `${String.fromCharCode(t.getUint8(e + 0))}${String.fromCharCode(t.getUint8(e + 1))}${String.fromCharCode(t.getUint8(e + 2))}${String.fromCharCode(t.getUint8(e + 3))}`;
}
function t6(t, e = 0, i = {}) {
  const s = new DataView(t), { magic: o = o1 } = i, u = s.getUint32(e, !1);
  return u === o || u === o1;
}
function i6(t, e, i = 0, s = {}) {
  const o = new DataView(e), u = e6(o, i + 0), d = o.getUint32(i + 4, uh), a = o.getUint32(i + 8, uh);
  switch (Object.assign(t, {
    // Put less important stuff in a header, to avoid clutter
    header: {
      byteOffset: i,
      // Byte offset into the initial arrayBuffer
      byteLength: a,
      hasBinChunk: !1
    },
    type: u,
    version: d,
    json: {},
    binChunks: []
  }), i += $y, t.version) {
    case 1:
      return r6(t, o, i);
    case 2:
      return s6(t, o, i, s = {});
    default:
      throw new Error(`Invalid GLB version ${t.version}. Only supports version 1 and 2.`);
  }
}
function r6(t, e, i) {
  mi(t.header.byteLength > $y + xp);
  const s = e.getUint32(i + 0, uh), o = e.getUint32(i + 4, uh);
  return i += xp, mi(o === Yz), Um(t, e, i, s), i += s, i += zm(t, e, i, t.header.byteLength), i;
}
function s6(t, e, i, s) {
  return mi(t.header.byteLength > $y + xp), n6(t, e, i, s), i + t.header.byteLength;
}
function n6(t, e, i, s) {
  for (; i + 8 <= t.header.byteLength; ) {
    const o = e.getUint32(i + 0, uh), u = e.getUint32(i + 4, uh);
    switch (i += xp, u) {
      case Zz:
        Um(t, e, i, o);
        break;
      case Kz:
        zm(t, e, i, o);
        break;
      // Backward compatibility for very old xviz files
      case Jz:
        s.strict || Um(t, e, i, o);
        break;
      case Qz:
        s.strict || zm(t, e, i, o);
        break;
    }
    i += sd(o, 4);
  }
  return i;
}
function Um(t, e, i, s) {
  const o = new Uint8Array(e.buffer, i, s), d = new TextDecoder("utf8").decode(o);
  return t.json = JSON.parse(d), sd(s, 4);
}
function zm(t, e, i, s) {
  return t.header.hasBinChunk = !0, t.binChunks.push({
    byteOffset: i,
    byteLength: s,
    arrayBuffer: e.buffer
    // TODO - copy, or create typed array view?
  }), sd(s, 4);
}
function RA(t, e) {
  if (t.startsWith("data:") || t.startsWith("http:") || t.startsWith("https:"))
    return t;
  const s = e.baseUri || e.uri;
  if (!s)
    throw new Error(`'baseUri' must be provided to resolve relative url ${t}`);
  return s.substr(0, s.lastIndexOf("/") + 1) + t;
}
const o6 = "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB", a6 = "B9h9z9tFBBBF8dL9gBB9gLaaaaaFa9gEaaaB9gGaaB9gFaFaEQSBBFBFFGEGEGIILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBNn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBcI9z9iqlBMc/j9JSIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMkRIbaG97FaK978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAnDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAnDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBRnCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBHiCFD9tAiAPD9OD9hD9RHiDQBTFtGmEYIPLdKeOnH8ZAIAQJDBIBHpCFD9tApAPD9OD9hD9RHpAIASJDBIBHyCFD9tAyAPD9OD9hD9RHyDQBTFtGmEYIPLdKeOnH8cDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAnD9uHnDyBjGBAEAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnA8ZA8cDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNiV8ZcpMyS8cQ8df8eb8fHdApAyDQNiV8ZcpMyS8cQ8df8eb8fHiDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/xLGEaK978jUUUUBCAlHE8kUUUUBGXGXAGCI9HQBGXAFC98ZHI9FQBABRGCBRLEXAGAGDBBBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMBBAGCTJRGALCIJHLAI9JQBMMAIAF9PQFAEAFCEZHLCGWHGqCBCTAGl/8MBAEABAICGWJHIAG/8cBBGXAL9FQBAEAEDBIBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMIBMAIAEAG/8cBBSFMABAFC98ZHGT+HUUUBAGAF9PQBAEAFCEZHICEWHLJCBCAALl/8MBAEABAGCEWJHGAL/8cBBAEAIT+HUUUBAGAEAL/8cBBMAECAJ8kUUUUBM+yEGGaO97GXAF9FQBCBRGEXABCTJHEAEDBBBHICBDtHLCUU98D8cFCUU98D8cEHKD9OABDBBBHOAIDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAOAIDQBFGENVcMTtmYi8ZpyHICTD+sFD/6FHND/gFAICTD+rFCTD+sFD/6FHVD/gFD/kFD/lFHI9DB/+g6DYAVAIALD+2FHLAVCUUUU94DtHcD9OD9RD/kFHVAVD/mFAIAID/mFANALANAcD9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHLD/kFCTD+rFAVAND/mFALD/kFCggEDtD9OD9QHVAIAND/mFALD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHIDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAOAKD9OAVAIDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM94FEa8jUUUUBCAlHE8kUUUUBABAFC98ZHIT+JUUUBGXAIAF9PQBAEAFCEZHLCEWHFJCBCAAFl/8MBAEABAICEWJHBAF/8cBBAEALT+JUUUBABAEAF/8cBBMAECAJ8kUUUUBM/hEIGaF97FaL978jUUUUBCTlRGGXAF9FQBCBREEXAGABDBBBHIABCTJHLDBBBHKDQILKOSQfbPden8c8d8e8fHOCTD+sFHNCID+rFDMIBAB9DBBU8/DY9D/zI818/DYANCEDtD9QD/6FD/nFHNAIAKDQBFGENVcMTtmYi8ZpyHICTD+rFCTD+sFD/6FD/mFHKAKD/mFANAICTD+sFD/6FD/mFHVAVD/mFANAOCTD+rFCTD+sFD/6FD/mFHOAOD/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHND/mF9DBBX9LDYHID/kFCggEDtHcD9OAVAND/mFAID/kFCTD+rFD9QHVAOAND/mFAID/kFCTD+rFAKAND/mFAID/kFAcD9OD9QHNDQBFTtGEmYILPdKOenHID8dBAGDBIBDyB+t+J83EBABCNJAID8dFAGDBIBDyF+t+J83EBALAVANDQNVi8ZcMpySQ8c8dfb8e8fHND8dBAGDBIBDyG+t+J83EBABCiJAND8dFAGDBIBDyE+t+J83EBABCAJRBAECIJHEAF9JQBMMM/3FGEaF978jUUUUBCoBlREGXAGCGrAF9sHIC98ZHL9FQBCBRGABRFEXAFAFDBBBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBAFCTJRFAGCIJHGAL9JQBMMGXALAI9PQBAEAICEZHGCGWHFqCBCoBAFl/8MBAEABALCGWJHLAF/8cBBGXAG9FQBAEAEDBIBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMIBMALAEAF/8cBBMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB", l6 = new Uint8Array([
  0,
  97,
  115,
  109,
  1,
  0,
  0,
  0,
  1,
  4,
  1,
  96,
  0,
  0,
  3,
  3,
  2,
  0,
  0,
  5,
  3,
  1,
  0,
  1,
  12,
  1,
  0,
  10,
  22,
  2,
  12,
  0,
  65,
  0,
  65,
  0,
  65,
  0,
  252,
  10,
  0,
  0,
  11,
  7,
  0,
  65,
  0,
  253,
  15,
  26,
  11
]), c6 = new Uint8Array([
  32,
  0,
  65,
  253,
  3,
  1,
  2,
  34,
  4,
  106,
  6,
  5,
  11,
  8,
  7,
  20,
  13,
  33,
  12,
  16,
  128,
  9,
  116,
  64,
  19,
  113,
  127,
  15,
  10,
  21,
  22,
  14,
  255,
  66,
  24,
  54,
  136,
  107,
  18,
  23,
  192,
  26,
  114,
  118,
  132,
  17,
  77,
  101,
  130,
  144,
  27,
  87,
  131,
  44,
  45,
  74,
  156,
  154,
  70,
  167
]), h6 = {
  // legacy index-based enums for glTF
  0: "",
  1: "meshopt_decodeFilterOct",
  2: "meshopt_decodeFilterQuat",
  3: "meshopt_decodeFilterExp",
  // string-based enums for glTF
  NONE: "",
  OCTAHEDRAL: "meshopt_decodeFilterOct",
  QUATERNION: "meshopt_decodeFilterQuat",
  EXPONENTIAL: "meshopt_decodeFilterExp"
}, u6 = {
  // legacy index-based enums for glTF
  0: "meshopt_decodeVertexBuffer",
  1: "meshopt_decodeIndexBuffer",
  2: "meshopt_decodeIndexSequence",
  // string-based enums for glTF
  ATTRIBUTES: "meshopt_decodeVertexBuffer",
  TRIANGLES: "meshopt_decodeIndexBuffer",
  INDICES: "meshopt_decodeIndexSequence"
};
async function d6(t, e, i, s, o, u = "NONE") {
  const d = await f6();
  g6(d, d.exports[u6[o]], t, e, i, s, d.exports[h6[u || "NONE"]]);
}
let Lg;
async function f6() {
  return Lg || (Lg = p6()), Lg;
}
async function p6() {
  let t = o6;
  WebAssembly.validate(l6) && (t = a6, console.log("Warning: meshopt_decoder is using experimental SIMD support"));
  const e = await WebAssembly.instantiate(_6(t), {});
  return await e.instance.exports.__wasm_call_ctors(), e.instance;
}
function _6(t) {
  const e = new Uint8Array(t.length);
  for (let s = 0; s < t.length; ++s) {
    const o = t.charCodeAt(s);
    e[s] = o > 96 ? o - 71 : o > 64 ? o - 65 : o > 47 ? o + 4 : o > 46 ? 63 : 62;
  }
  let i = 0;
  for (let s = 0; s < t.length; ++s)
    e[i++] = e[s] < 60 ? c6[e[s]] : (e[s] - 60) * 64 + e[++s];
  return e.buffer.slice(0, i);
}
function g6(t, e, i, s, o, u, d) {
  const a = t.exports.sbrk, w = s + 3 & -4, S = a(w * o), M = a(u.length), F = new Uint8Array(t.exports.memory.buffer);
  F.set(u, M);
  const N = e(S, s, o, M, u.length);
  if (N === 0 && d && d(S, w, o), i.set(F.subarray(S, S + s * o)), a(S - a(0)), N !== 0)
    throw new Error(`Malformed buffer data: ${N}`);
}
const wp = "EXT_meshopt_compression", m6 = wp;
async function y6(t, e) {
  const i = new Br(t);
  if (!e?.gltf?.decompressMeshes || !e.gltf?.loadBuffers)
    return;
  const s = [];
  for (const o of t.json.bufferViews || [])
    s.push(b6(i, o));
  await Promise.all(s), i.removeExtension(wp);
}
async function b6(t, e) {
  const i = t.getObjectExtension(e, wp);
  if (i) {
    const { byteOffset: s = 0, byteLength: o = 0, byteStride: u, count: d, mode: a, filter: w = "NONE", buffer: S } = i, M = t.gltf.buffers[S], F = new Uint8Array(M.arrayBuffer, M.byteOffset + s, o), N = new Uint8Array(t.gltf.buffers[e.buffer].arrayBuffer, e.byteOffset, e.byteLength);
    await d6(N, d, u, F, a, w), t.removeObjectExtension(e, wp);
  }
}
const v6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: y6,
  name: m6
}, Symbol.toStringTag, { value: "Module" })), jc = "EXT_texture_webp", x6 = jc;
function w6(t, e) {
  const i = new Br(t);
  if (!JI("image/webp")) {
    if (i.getRequiredExtensions().includes(jc))
      throw new Error(`gltf: Required extension ${jc} not supported by browser`);
    return;
  }
  const { json: s } = i;
  for (const o of s.textures || []) {
    const u = i.getObjectExtension(o, jc);
    u && (o.source = u.source), i.removeObjectExtension(o, jc);
  }
  i.removeExtension(jc);
}
const T6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  name: x6,
  preprocess: w6
}, Symbol.toStringTag, { value: "Module" })), ip = "KHR_texture_basisu", A6 = ip;
function E6(t, e) {
  const i = new Br(t), { json: s } = i;
  for (const o of s.textures || []) {
    const u = i.getObjectExtension(o, ip);
    u && (o.source = u.source, i.removeObjectExtension(o, ip));
  }
  i.removeExtension(ip);
}
const S6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  name: A6,
  preprocess: E6
}, Symbol.toStringTag, { value: "Module" })), C6 = "4.3.1", I6 = {
  dataType: null,
  batchType: null,
  name: "Draco",
  id: "draco",
  module: "draco",
  // shapes: ['mesh'],
  version: C6,
  worker: !0,
  extensions: ["drc"],
  mimeTypes: ["application/octet-stream"],
  binary: !0,
  tests: ["DRACO"],
  options: {
    draco: {
      decoderType: typeof WebAssembly == "object" ? "wasm" : "js",
      // 'js' for IE11
      libraryPath: "libs/",
      extraAttributes: {},
      attributeNameEntry: void 0
    }
  }
};
function M6(t, e, i) {
  const s = PA(e.metadata), o = [], u = R6(e.attributes);
  for (const d in t) {
    const a = t[d], w = a1(d, a, u[d]);
    o.push(w);
  }
  if (i) {
    const d = a1("indices", i);
    o.push(d);
  }
  return { fields: o, metadata: s };
}
function R6(t) {
  const e = {};
  for (const i in t) {
    const s = t[i];
    e[s.name || "undefined"] = s;
  }
  return e;
}
function a1(t, e, i) {
  const s = i ? PA(i.metadata) : void 0;
  return yI(t, e, s);
}
function PA(t) {
  Object.entries(t);
  const e = {};
  for (const i in t)
    e[`${i}.string`] = JSON.stringify(t[i]);
  return e;
}
const l1 = {
  POSITION: "POSITION",
  NORMAL: "NORMAL",
  COLOR: "COLOR_0",
  TEX_COORD: "TEXCOORD_0"
}, P6 = {
  1: Int8Array,
  2: Uint8Array,
  3: Int16Array,
  4: Uint16Array,
  5: Int32Array,
  6: Uint32Array,
  // 7: BigInt64Array,
  // 8: BigUint64Array,
  9: Float32Array
  // 10: Float64Array
  // 11: BOOL - What array type do we use for this?
}, B6 = 4;
class D6 {
  draco;
  decoder;
  metadataQuerier;
  // draco - the draco decoder, either import `draco3d` or load dynamically
  constructor(e) {
    this.draco = e, this.decoder = new this.draco.Decoder(), this.metadataQuerier = new this.draco.MetadataQuerier();
  }
  /**
   * Destroy draco resources
   */
  destroy() {
    this.draco.destroy(this.decoder), this.draco.destroy(this.metadataQuerier);
  }
  /**
   * NOTE: caller must call `destroyGeometry` on the return value after using it
   * @param arrayBuffer
   * @param options
   */
  parseSync(e, i = {}) {
    const s = new this.draco.DecoderBuffer();
    s.Init(new Int8Array(e), e.byteLength), this._disableAttributeTransforms(i);
    const o = this.decoder.GetEncodedGeometryType(s), u = o === this.draco.TRIANGULAR_MESH ? new this.draco.Mesh() : new this.draco.PointCloud();
    try {
      let d;
      switch (o) {
        case this.draco.TRIANGULAR_MESH:
          d = this.decoder.DecodeBufferToMesh(s, u);
          break;
        case this.draco.POINT_CLOUD:
          d = this.decoder.DecodeBufferToPointCloud(s, u);
          break;
        default:
          throw new Error("DRACO: Unknown geometry type.");
      }
      if (!d.ok() || !u.ptr) {
        const N = `DRACO decompression failed: ${d.error_msg()}`;
        throw new Error(N);
      }
      const a = this._getDracoLoaderData(u, o, i), w = this._getMeshData(u, a, i), S = ww(w.attributes), M = M6(w.attributes, a, w.indices);
      return {
        loader: "draco",
        loaderData: a,
        header: {
          vertexCount: u.num_points(),
          boundingBox: S
        },
        ...w,
        schema: M
      };
    } finally {
      this.draco.destroy(s), u && this.draco.destroy(u);
    }
  }
  // Draco specific "loader data"
  /**
   * Extract
   * @param dracoGeometry
   * @param geometry_type
   * @param options
   * @returns
   */
  _getDracoLoaderData(e, i, s) {
    const o = this._getTopLevelMetadata(e), u = this._getDracoAttributes(e, s);
    return {
      geometry_type: i,
      num_attributes: e.num_attributes(),
      num_points: e.num_points(),
      num_faces: e instanceof this.draco.Mesh ? e.num_faces() : 0,
      metadata: o,
      attributes: u
    };
  }
  /**
   * Extract all draco provided information and metadata for each attribute
   * @param dracoGeometry
   * @param options
   * @returns
   */
  _getDracoAttributes(e, i) {
    const s = {};
    for (let o = 0; o < e.num_attributes(); o++) {
      const u = this.decoder.GetAttribute(e, o), d = this._getAttributeMetadata(e, o);
      s[u.unique_id()] = {
        unique_id: u.unique_id(),
        attribute_type: u.attribute_type(),
        data_type: u.data_type(),
        num_components: u.num_components(),
        byte_offset: u.byte_offset(),
        byte_stride: u.byte_stride(),
        normalized: u.normalized(),
        attribute_index: o,
        metadata: d
      };
      const a = this._getQuantizationTransform(u, i);
      a && (s[u.unique_id()].quantization_transform = a);
      const w = this._getOctahedronTransform(u, i);
      w && (s[u.unique_id()].octahedron_transform = w);
    }
    return s;
  }
  /**
   * Get standard loaders.gl mesh category data
   * Extracts the geometry from draco
   * @param dracoGeometry
   * @param options
   */
  _getMeshData(e, i, s) {
    const o = this._getMeshAttributes(i, e, s);
    if (!o.POSITION)
      throw new Error("DRACO: No position attribute found.");
    if (e instanceof this.draco.Mesh)
      switch (s.topology) {
        case "triangle-strip":
          return {
            topology: "triangle-strip",
            mode: 4,
            // GL.TRIANGLES
            attributes: o,
            indices: {
              value: this._getTriangleStripIndices(e),
              size: 1
            }
          };
        case "triangle-list":
        default:
          return {
            topology: "triangle-list",
            mode: 5,
            // GL.TRIANGLE_STRIP
            attributes: o,
            indices: {
              value: this._getTriangleListIndices(e),
              size: 1
            }
          };
      }
    return {
      topology: "point-list",
      mode: 0,
      // GL.POINTS
      attributes: o
    };
  }
  _getMeshAttributes(e, i, s) {
    const o = {};
    for (const u of Object.values(e.attributes)) {
      const d = this._deduceAttributeName(u, s);
      u.name = d;
      const a = this._getAttributeValues(i, u);
      if (a) {
        const { value: w, size: S } = a;
        o[d] = {
          value: w,
          size: S,
          byteOffset: u.byte_offset,
          byteStride: u.byte_stride,
          normalized: u.normalized
        };
      }
    }
    return o;
  }
  // MESH INDICES EXTRACTION
  /**
   * For meshes, we need indices to define the faces.
   * @param dracoGeometry
   */
  _getTriangleListIndices(e) {
    const s = e.num_faces() * 3, o = s * B6, u = this.draco._malloc(o);
    try {
      return this.decoder.GetTrianglesUInt32Array(e, o, u), new Uint32Array(this.draco.HEAPF32.buffer, u, s).slice();
    } finally {
      this.draco._free(u);
    }
  }
  /**
   * For meshes, we need indices to define the faces.
   * @param dracoGeometry
   */
  _getTriangleStripIndices(e) {
    const i = new this.draco.DracoInt32Array();
    try {
      return this.decoder.GetTriangleStripsFromMesh(e, i), k6(i);
    } finally {
      this.draco.destroy(i);
    }
  }
  /**
   *
   * @param dracoGeometry
   * @param dracoAttribute
   * @param attributeName
   */
  _getAttributeValues(e, i) {
    const s = P6[i.data_type];
    if (!s)
      return console.warn(`DRACO: Unsupported attribute type ${i.data_type}`), null;
    const o = i.num_components, d = e.num_points() * o, a = d * s.BYTES_PER_ELEMENT, w = O6(this.draco, s);
    let S;
    const M = this.draco._malloc(a);
    try {
      const F = this.decoder.GetAttribute(e, i.attribute_index);
      this.decoder.GetAttributeDataArrayForAllPoints(e, F, w, a, M), S = new s(this.draco.HEAPF32.buffer, M, d).slice();
    } finally {
      this.draco._free(M);
    }
    return { value: S, size: o };
  }
  // Attribute names
  /**
   * DRACO does not store attribute names - We need to deduce an attribute name
   * for each attribute
  _getAttributeNames(
    dracoGeometry: Mesh | PointCloud,
    options: DracoParseOptions
  ): {[unique_id: number]: string} {
    const attributeNames: {[unique_id: number]: string} = {};
    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {
      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);
      const attributeName = this._deduceAttributeName(dracoAttribute, options);
      attributeNames[attributeName] = attributeName;
    }
    return attributeNames;
  }
   */
  /**
   * Deduce an attribute name.
   * @note DRACO does not save attribute names, just general type (POSITION, COLOR)
   * to help optimize compression. We generate GLTF compatible names for the Draco-recognized
   * types
   * @param attributeData
   */
  _deduceAttributeName(e, i) {
    const s = e.unique_id;
    for (const [d, a] of Object.entries(i.extraAttributes || {}))
      if (a === s)
        return d;
    const o = e.attribute_type;
    for (const d in l1)
      if (this.draco[d] === o)
        return l1[d];
    const u = i.attributeNameEntry || "name";
    return e.metadata[u] ? e.metadata[u].string : `CUSTOM_ATTRIBUTE_${s}`;
  }
  // METADATA EXTRACTION
  /** Get top level metadata */
  _getTopLevelMetadata(e) {
    const i = this.decoder.GetMetadata(e);
    return this._getDracoMetadata(i);
  }
  /** Get per attribute metadata */
  _getAttributeMetadata(e, i) {
    const s = this.decoder.GetAttributeMetadata(e, i);
    return this._getDracoMetadata(s);
  }
  /**
   * Extract metadata field values
   * @param dracoMetadata
   * @returns
   */
  _getDracoMetadata(e) {
    if (!e || !e.ptr)
      return {};
    const i = {}, s = this.metadataQuerier.NumEntries(e);
    for (let o = 0; o < s; o++) {
      const u = this.metadataQuerier.GetEntryName(e, o);
      i[u] = this._getDracoMetadataField(e, u);
    }
    return i;
  }
  /**
   * Extracts possible values for one metadata entry by name
   * @param dracoMetadata
   * @param entryName
   */
  _getDracoMetadataField(e, i) {
    const s = new this.draco.DracoInt32Array();
    try {
      this.metadataQuerier.GetIntEntryArray(e, i, s);
      const o = F6(s);
      return {
        int: this.metadataQuerier.GetIntEntry(e, i),
        string: this.metadataQuerier.GetStringEntry(e, i),
        double: this.metadataQuerier.GetDoubleEntry(e, i),
        intArray: o
      };
    } finally {
      this.draco.destroy(s);
    }
  }
  // QUANTIZED ATTRIBUTE SUPPORT (NO DECOMPRESSION)
  /** Skip transforms for specific attribute types */
  _disableAttributeTransforms(e) {
    const { quantizedAttributes: i = [], octahedronAttributes: s = [] } = e, o = [...i, ...s];
    for (const u of o)
      this.decoder.SkipAttributeTransform(this.draco[u]);
  }
  /**
   * Extract (and apply?) Position Transform
   * @todo not used
   */
  _getQuantizationTransform(e, i) {
    const { quantizedAttributes: s = [] } = i, o = e.attribute_type();
    if (s.map((d) => this.decoder[d]).includes(o)) {
      const d = new this.draco.AttributeQuantizationTransform();
      try {
        if (d.InitFromAttribute(e))
          return {
            quantization_bits: d.quantization_bits(),
            range: d.range(),
            min_values: new Float32Array([1, 2, 3]).map((a) => d.min_value(a))
          };
      } finally {
        this.draco.destroy(d);
      }
    }
    return null;
  }
  _getOctahedronTransform(e, i) {
    const { octahedronAttributes: s = [] } = i, o = e.attribute_type();
    if (s.map((d) => this.decoder[d]).includes(o)) {
      const d = new this.draco.AttributeQuantizationTransform();
      try {
        if (d.InitFromAttribute(e))
          return {
            quantization_bits: d.quantization_bits()
          };
      } finally {
        this.draco.destroy(d);
      }
    }
    return null;
  }
}
function O6(t, e) {
  switch (e) {
    case Float32Array:
      return t.DT_FLOAT32;
    case Int8Array:
      return t.DT_INT8;
    case Int16Array:
      return t.DT_INT16;
    case Int32Array:
      return t.DT_INT32;
    case Uint8Array:
      return t.DT_UINT8;
    case Uint16Array:
      return t.DT_UINT16;
    case Uint32Array:
      return t.DT_UINT32;
    default:
      return t.DT_INVALID;
  }
}
function F6(t) {
  const e = t.size(), i = new Int32Array(e);
  for (let s = 0; s < e; s++)
    i[s] = t.GetValue(s);
  return i;
}
function k6(t) {
  const e = t.size(), i = new Int32Array(e);
  for (let s = 0; s < e; s++)
    i[s] = t.GetValue(s);
  return i;
}
const N6 = "1.5.6", L6 = "1.4.1", Ug = `https://www.gstatic.com/draco/versioned/decoders/${N6}`, vs = {
  /** The primary Draco3D encoder, javascript wrapper part */
  DECODER: "draco_wasm_wrapper.js",
  /** The primary draco decoder, compiled web assembly part */
  DECODER_WASM: "draco_decoder.wasm",
  /** Fallback decoder for non-webassebly environments. Very big bundle, lower performance */
  FALLBACK_DECODER: "draco_decoder.js",
  /** Draco encoder */
  ENCODER: "draco_encoder.js"
}, zg = {
  [vs.DECODER]: `${Ug}/${vs.DECODER}`,
  [vs.DECODER_WASM]: `${Ug}/${vs.DECODER_WASM}`,
  [vs.FALLBACK_DECODER]: `${Ug}/${vs.FALLBACK_DECODER}`,
  [vs.ENCODER]: `https://raw.githubusercontent.com/google/draco/${L6}/javascript/${vs.ENCODER}`
};
let Vg;
async function U6(t) {
  const e = t.modules || {};
  return e.draco3d ? Vg ||= e.draco3d.createDecoderModule({}).then((i) => ({ draco: i })) : Vg ||= z6(t), await Vg;
}
async function z6(t) {
  let e, i;
  switch (t.draco && t.draco.decoderType) {
    case "js":
      e = await El(zg[vs.FALLBACK_DECODER], "draco", t, vs.FALLBACK_DECODER);
      break;
    case "wasm":
    default:
      [e, i] = await Promise.all([
        await El(zg[vs.DECODER], "draco", t, vs.DECODER),
        await El(zg[vs.DECODER_WASM], "draco", t, vs.DECODER_WASM)
      ]);
  }
  return e = e || globalThis.DracoDecoderModule, await V6(e, i);
}
function V6(t, e) {
  const i = {};
  return e && (i.wasmBinary = e), new Promise((s) => {
    t({
      ...i,
      onModuleLoaded: (o) => s({ draco: o })
      // Module is Promise-like. Wrap in object to avoid loop.
    });
  });
}
const BA = {
  ...I6,
  parse: j6
};
async function j6(t, e) {
  const { draco: i } = await U6(e), s = new D6(i);
  try {
    return s.parseSync(t, e?.draco);
  } finally {
    s.destroy();
  }
}
function H6(t) {
  const e = {};
  for (const i in t) {
    const s = t[i];
    if (i !== "indices") {
      const o = DA(s);
      e[i] = o;
    }
  }
  return e;
}
function DA(t) {
  const { buffer: e, size: i, count: s } = $6(t);
  return {
    // glTF Accessor values
    // TODO: Instead of a bufferView index we could have an actual buffer (typed array)
    // bufferView: null,
    // TODO: Deprecate `value` in favor of bufferView?
    // @ts-ignore
    value: e,
    size: i,
    // Decoded `type` (e.g. SCALAR)
    byteOffset: 0,
    count: s,
    type: xA(i),
    componentType: Np(e)
  };
}
function $6(t) {
  let e = t, i = 1, s = 0;
  return t && t.value && (e = t.value, i = t.size || 1), e && (ArrayBuffer.isView(e) || (e = G6(e, Float32Array)), s = e.length / i), { buffer: e, size: i, count: s };
}
function G6(t, e, i = !1) {
  return t ? Array.isArray(t) ? new e(t) : i && !(t instanceof e) ? new e(t) : t : null;
}
const Ma = "KHR_draco_mesh_compression", W6 = Ma;
function X6(t, e, i) {
  const s = new Br(t);
  for (const o of OA(s))
    s.getObjectExtension(o, Ma);
}
async function q6(t, e, i) {
  if (!e?.gltf?.decompressMeshes)
    return;
  const s = new Br(t), o = [];
  for (const u of OA(s))
    s.getObjectExtension(u, Ma) && o.push(K6(s, u, e, i));
  await Promise.all(o), s.removeExtension(Ma);
}
function Z6(t, e = {}) {
  const i = new Br(t);
  for (const s of i.json.meshes || [])
    Y6(s), i.addRequiredExtension(Ma);
}
async function K6(t, e, i, s) {
  const o = t.getObjectExtension(e, Ma);
  if (!o)
    return;
  const u = t.getTypedArrayForBufferView(o.bufferView), d = Km(u.buffer, u.byteOffset), a = { ...i };
  delete a["3d-tiles"];
  const w = await rd(d, BA, a, s), S = H6(w.attributes);
  for (const [M, F] of Object.entries(S))
    if (M in e.attributes) {
      const N = e.attributes[M], L = t.getAccessor(N);
      L?.min && L?.max && (F.min = L.min, F.max = L.max);
    }
  e.attributes = S, w.indices && (e.indices = DA(w.indices)), t.removeObjectExtension(e, Ma), J6(e);
}
function Y6(t, e, i = 4, s, o) {
  if (!s.DracoWriter)
    throw new Error("options.gltf.DracoWriter not provided");
  const u = s.DracoWriter.encodeSync({ attributes: t }), d = o?.parseSync?.({ attributes: t }), a = s._addFauxAttributes(d.attributes), w = s.addBufferView(u);
  return {
    primitives: [
      {
        attributes: a,
        // TODO - verify with spec
        mode: i,
        // GL.POINTS
        extensions: {
          [Ma]: {
            bufferView: w,
            attributes: a
            // TODO - verify with spec
          }
        }
      }
    ]
  };
}
function J6(t) {
  if (!t.attributes && Object.keys(t.attributes).length > 0)
    throw new Error("glTF: Empty primitive detected: Draco decompression failure?");
}
function* OA(t) {
  for (const e of t.json.meshes || [])
    for (const i of e.primitives)
      yield i;
}
const Q6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: q6,
  encode: Z6,
  name: W6,
  preprocess: X6
}, Symbol.toStringTag, { value: "Module" })), zp = "KHR_texture_transform", e4 = zp, Hf = new Be(), t4 = new Yi(), i4 = new Yi();
async function r4(t, e) {
  if (!new Br(t).hasExtension(zp) || !e.gltf?.loadBuffers)
    return;
  const o = t.json.materials || [];
  for (let u = 0; u < o.length; u++)
    s4(u, t);
}
function s4(t, e) {
  const i = e.json.materials?.[t], s = [
    i?.pbrMetallicRoughness?.baseColorTexture,
    i?.emissiveTexture,
    i?.normalTexture,
    i?.occlusionTexture,
    i?.pbrMetallicRoughness?.metallicRoughnessTexture
  ], o = [];
  for (const u of s)
    u && u?.extensions?.[zp] && n4(e, t, u, o);
}
function n4(t, e, i, s) {
  const o = o4(i, s);
  if (!o)
    return;
  const u = t.json.meshes || [];
  for (const d of u)
    for (const a of d.primitives) {
      const w = a.material;
      Number.isFinite(w) && e === w && a4(t, a, o);
    }
}
function o4(t, e) {
  const i = t.extensions?.[zp], { texCoord: s = 0 } = t, { texCoord: o = s } = i;
  if (!(e.findIndex(([d, a]) => d === s && a === o) !== -1)) {
    const d = h4(i);
    return s !== o && (t.texCoord = o), e.push([s, o]), { originalTexCoord: s, texCoord: o, matrix: d };
  }
  return null;
}
function a4(t, e, i) {
  const { originalTexCoord: s, texCoord: o, matrix: u } = i, d = e.attributes[`TEXCOORD_${s}`];
  if (Number.isFinite(d)) {
    const a = t.json.accessors?.[d];
    if (a && a.bufferView) {
      const w = t.json.bufferViews?.[a.bufferView];
      if (w) {
        const { arrayBuffer: S, byteOffset: M } = t.buffers[w.buffer], F = (M || 0) + (a.byteOffset || 0) + (w.byteOffset || 0), { ArrayType: N, length: L } = zy(a, w), re = vA[a.componentType], ne = bA[a.type], we = w.byteStride || re * ne, Se = new Float32Array(L);
        for (let Ee = 0; Ee < a.count; Ee++) {
          const Ce = new N(S, F + Ee * we, 2);
          Hf.set(Ce[0], Ce[1], 1), Hf.transformByMatrix3(u), Se.set([Hf[0], Hf[1]], Ee * ne);
        }
        s === o ? l4(a, w, t.buffers, Se) : c4(o, a, e, t, Se);
      }
    }
  }
}
function l4(t, e, i, s) {
  t.componentType = 5126, i.push({
    arrayBuffer: s.buffer,
    byteOffset: 0,
    byteLength: s.buffer.byteLength
  }), e.buffer = i.length - 1, e.byteLength = s.buffer.byteLength, e.byteOffset = 0, delete e.byteStride;
}
function c4(t, e, i, s, o) {
  s.buffers.push({
    arrayBuffer: o.buffer,
    byteOffset: 0,
    byteLength: o.buffer.byteLength
  });
  const u = s.json.bufferViews;
  if (!u)
    return;
  u.push({
    buffer: s.buffers.length - 1,
    byteLength: o.buffer.byteLength,
    byteOffset: 0
  });
  const d = s.json.accessors;
  d && (d.push({
    bufferView: u?.length - 1,
    byteOffset: 0,
    componentType: 5126,
    count: e.count,
    type: "VEC2"
  }), i.attributes[`TEXCOORD_${t}`] = d.length - 1);
}
function h4(t) {
  const { offset: e = [0, 0], rotation: i = 0, scale: s = [1, 1] } = t, o = new Yi().set(1, 0, 0, 0, 1, 0, e[0], e[1], 1), u = t4.set(Math.cos(i), Math.sin(i), 0, -Math.sin(i), Math.cos(i), 0, 0, 0, 1), d = i4.set(s[0], 0, 0, 0, s[1], 0, 0, 0, 1);
  return o.multiplyRight(u).multiplyRight(d);
}
const u4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: r4,
  name: e4
}, Symbol.toStringTag, { value: "Module" })), Al = "KHR_lights_punctual", d4 = Al;
async function f4(t) {
  const e = new Br(t), { json: i } = e, s = e.getExtension(Al);
  s && (e.json.lights = s.lights, e.removeExtension(Al));
  for (const o of i.nodes || []) {
    const u = e.getObjectExtension(o, Al);
    u && (o.light = u.light), e.removeObjectExtension(o, Al);
  }
}
async function p4(t) {
  const e = new Br(t), { json: i } = e;
  if (i.lights) {
    const s = e.addExtension(Al);
    Zs(!s.lights), s.lights = i.lights, delete i.lights;
  }
  if (e.json.lights) {
    for (const s of e.json.lights) {
      const o = s.node;
      e.addObjectExtension(o, Al, s);
    }
    delete e.json.lights;
  }
}
const _4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: f4,
  encode: p4,
  name: d4
}, Symbol.toStringTag, { value: "Module" })), ed = "KHR_materials_unlit", g4 = ed;
async function m4(t) {
  const e = new Br(t), { json: i } = e;
  for (const s of i.materials || [])
    s.extensions && s.extensions.KHR_materials_unlit && (s.unlit = !0), e.removeObjectExtension(s, ed);
  e.removeExtension(ed);
}
function y4(t) {
  const e = new Br(t), { json: i } = e;
  if (e.materials)
    for (const s of i.materials || [])
      s.unlit && (delete s.unlit, e.addObjectExtension(s, ed, {}), e.addExtension(ed));
}
const b4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: m4,
  encode: y4,
  name: g4
}, Symbol.toStringTag, { value: "Module" })), Lu = "KHR_techniques_webgl", v4 = Lu;
async function x4(t) {
  const e = new Br(t), { json: i } = e, s = e.getExtension(Lu);
  if (s) {
    const o = T4(s, e);
    for (const u of i.materials || []) {
      const d = e.getObjectExtension(u, Lu);
      d && (u.technique = Object.assign(
        {},
        d,
        // @ts-ignore
        o[d.technique]
      ), u.technique.values = A4(u.technique, e)), e.removeObjectExtension(u, Lu);
    }
    e.removeExtension(Lu);
  }
}
async function w4(t, e) {
}
function T4(t, e) {
  const { programs: i = [], shaders: s = [], techniques: o = [] } = t, u = new TextDecoder();
  return s.forEach((d) => {
    if (Number.isFinite(d.bufferView))
      d.code = u.decode(e.getTypedArrayForBufferView(d.bufferView));
    else
      throw new Error("KHR_techniques_webgl: no shader code");
  }), i.forEach((d) => {
    d.fragmentShader = s[d.fragmentShader], d.vertexShader = s[d.vertexShader];
  }), o.forEach((d) => {
    d.program = i[d.program];
  }), o;
}
function A4(t, e) {
  const i = Object.assign({}, t.values);
  return Object.keys(t.uniforms || {}).forEach((s) => {
    t.uniforms[s].value && !(s in i) && (i[s] = t.uniforms[s].value);
  }), Object.keys(i).forEach((s) => {
    typeof i[s] == "object" && i[s].index !== void 0 && (i[s].texture = e.getTexture(i[s].index));
  }), i;
}
const E4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: x4,
  encode: w4,
  name: v4
}, Symbol.toStringTag, { value: "Module" })), FA = [
  // 1.0
  // KHR_binary_gltf is handled separately - must be processed before other parsing starts
  // KHR_binary_gltf,
  // 2.0
  Rz,
  tz,
  v6,
  T6,
  // Basisu should come after webp, we want basisu to be preferred if both are provided
  S6,
  Q6,
  _4,
  b4,
  E4,
  u4,
  Xz
];
function S4(t, e = {}, i) {
  const s = FA.filter((o) => kA(o.name, e));
  for (const o of s)
    o.preprocess?.(t, e, i);
}
async function C4(t, e = {}, i) {
  const s = FA.filter((o) => kA(o.name, e));
  for (const o of s)
    await o.decode?.(t, e, i);
}
function kA(t, e) {
  const i = e?.gltf?.excludeExtensions || {};
  return !(t in i && !i[t]);
}
const jg = "KHR_binary_glTF";
function I4(t) {
  const e = new Br(t), { json: i } = e;
  for (const s of i.images || []) {
    const o = e.getObjectExtension(s, jg);
    o && Object.assign(s, o), e.removeObjectExtension(s, jg);
  }
  i.buffers && i.buffers[0] && delete i.buffers[0].uri, e.removeExtension(jg);
}
const c1 = {
  accessors: "accessor",
  animations: "animation",
  buffers: "buffer",
  bufferViews: "bufferView",
  images: "image",
  materials: "material",
  meshes: "mesh",
  nodes: "node",
  samplers: "sampler",
  scenes: "scene",
  skins: "skin",
  textures: "texture"
}, M4 = {
  accessor: "accessors",
  animations: "animation",
  buffer: "buffers",
  bufferView: "bufferViews",
  image: "images",
  material: "materials",
  mesh: "meshes",
  node: "nodes",
  sampler: "samplers",
  scene: "scenes",
  skin: "skins",
  texture: "textures"
};
class R4 {
  idToIndexMap = {
    animations: {},
    accessors: {},
    buffers: {},
    bufferViews: {},
    images: {},
    materials: {},
    meshes: {},
    nodes: {},
    samplers: {},
    scenes: {},
    skins: {},
    textures: {}
  };
  json;
  // constructor() {}
  /**
   * Convert (normalize) glTF < 2.0 to glTF 2.0
   * @param gltf - object with json and binChunks
   * @param options
   * @param options normalize Whether to actually normalize
   */
  normalize(e, i) {
    this.json = e.json;
    const s = e.json;
    switch (s.asset && s.asset.version) {
      // We are converting to v2 format. Return if there is nothing to do
      case "2.0":
        return;
      // This class is written to convert 1.0
      case void 0:
      case "1.0":
        break;
      default:
        console.warn(`glTF: Unknown version ${s.asset.version}`);
        return;
    }
    if (!i.normalize)
      throw new Error("glTF v1 is not supported.");
    console.warn("Converting glTF v1 to glTF v2 format. This is experimental and may fail."), this._addAsset(s), this._convertTopLevelObjectsToArrays(s), I4(e), this._convertObjectIdsToArrayIndices(s), this._updateObjects(s), this._updateMaterial(s);
  }
  // asset is now required, #642 https://github.com/KhronosGroup/glTF/issues/639
  _addAsset(e) {
    e.asset = e.asset || {}, e.asset.version = "2.0", e.asset.generator = e.asset.generator || "Normalized to glTF 2.0 by loaders.gl";
  }
  _convertTopLevelObjectsToArrays(e) {
    for (const i in c1)
      this._convertTopLevelObjectToArray(e, i);
  }
  /** Convert one top level object to array */
  _convertTopLevelObjectToArray(e, i) {
    const s = e[i];
    if (!(!s || Array.isArray(s))) {
      e[i] = [];
      for (const o in s) {
        const u = s[o];
        u.id = u.id || o;
        const d = e[i].length;
        e[i].push(u), this.idToIndexMap[i][o] = d;
      }
    }
  }
  /** Go through all objects in all top-level arrays and replace ids with indices */
  _convertObjectIdsToArrayIndices(e) {
    for (const i in c1)
      this._convertIdsToIndices(e, i);
    "scene" in e && (e.scene = this._convertIdToIndex(e.scene, "scene"));
    for (const i of e.textures)
      this._convertTextureIds(i);
    for (const i of e.meshes)
      this._convertMeshIds(i);
    for (const i of e.nodes)
      this._convertNodeIds(i);
    for (const i of e.scenes)
      this._convertSceneIds(i);
  }
  _convertTextureIds(e) {
    e.source && (e.source = this._convertIdToIndex(e.source, "image"));
  }
  _convertMeshIds(e) {
    for (const i of e.primitives) {
      const { attributes: s, indices: o, material: u } = i;
      for (const d in s)
        s[d] = this._convertIdToIndex(s[d], "accessor");
      o && (i.indices = this._convertIdToIndex(o, "accessor")), u && (i.material = this._convertIdToIndex(u, "material"));
    }
  }
  _convertNodeIds(e) {
    e.children && (e.children = e.children.map((i) => this._convertIdToIndex(i, "node"))), e.meshes && (e.meshes = e.meshes.map((i) => this._convertIdToIndex(i, "mesh")));
  }
  _convertSceneIds(e) {
    e.nodes && (e.nodes = e.nodes.map((i) => this._convertIdToIndex(i, "node")));
  }
  /** Go through all objects in a top-level array and replace ids with indices */
  _convertIdsToIndices(e, i) {
    e[i] || (console.warn(`gltf v1: json doesn't contain attribute ${i}`), e[i] = []);
    for (const s of e[i])
      for (const o in s) {
        const u = s[o], d = this._convertIdToIndex(u, o);
        s[o] = d;
      }
  }
  _convertIdToIndex(e, i) {
    const s = M4[i];
    if (s in this.idToIndexMap) {
      const o = this.idToIndexMap[s][e];
      if (!Number.isFinite(o))
        throw new Error(`gltf v1: failed to resolve ${i} with id ${e}`);
      return o;
    }
    return e;
  }
  /**
   *
   * @param {*} json
   */
  _updateObjects(e) {
    for (const i of this.json.buffers)
      delete i.type;
  }
  /**
   * Update material (set pbrMetallicRoughness)
   * @param {*} json
   */
  _updateMaterial(e) {
    for (const i of e.materials) {
      i.pbrMetallicRoughness = {
        baseColorFactor: [1, 1, 1, 1],
        metallicFactor: 1,
        roughnessFactor: 1
      };
      const s = i.values?.tex || i.values?.texture2d_0 || i.values?.diffuseTex, o = e.textures.findIndex((u) => u.id === s);
      o !== -1 && (i.pbrMetallicRoughness.baseColorTexture = { index: o });
    }
  }
}
function P4(t, e = {}) {
  return new R4().normalize(t, e);
}
async function B4(t, e, i = 0, s, o) {
  return D4(t, e, i, s), P4(t, { normalize: s?.gltf?.normalize }), S4(t, s, o), s?.gltf?.loadBuffers && t.json.buffers && await O4(t, s, o), s?.gltf?.loadImages && await F4(t, s, o), await C4(t, s, o), t;
}
function D4(t, e, i, s) {
  if (s.uri && (t.baseUri = s.uri), e instanceof ArrayBuffer && !t6(e, i, s) && (e = new TextDecoder().decode(e)), typeof e == "string")
    t.json = QC(e);
  else if (e instanceof ArrayBuffer) {
    const d = {};
    i = i6(d, e, i, s.glb), Zs(d.type === "glTF", `Invalid GLB magic string ${d.type}`), t._glb = d, t.json = d.json;
  } else
    Zs(!1, "GLTF: must be ArrayBuffer or string");
  const o = t.json.buffers || [];
  if (t.buffers = new Array(o.length).fill(null), t._glb && t._glb.header.hasBinChunk) {
    const { binChunks: d } = t._glb;
    t.buffers[0] = {
      arrayBuffer: d[0].arrayBuffer,
      byteOffset: d[0].byteOffset,
      byteLength: d[0].byteLength
    };
  }
  const u = t.json.images || [];
  t.images = new Array(u.length).fill({});
}
async function O4(t, e, i) {
  const s = t.json.buffers || [];
  for (let o = 0; o < s.length; ++o) {
    const u = s[o];
    if (u.uri) {
      const { fetch: d } = i;
      Zs(d);
      const a = RA(u.uri, e), S = await (await i?.fetch?.(a))?.arrayBuffer?.();
      t.buffers[o] = {
        arrayBuffer: S,
        byteOffset: 0,
        byteLength: S.byteLength
      }, delete u.uri;
    } else t.buffers[o] === null && (t.buffers[o] = {
      arrayBuffer: new ArrayBuffer(u.byteLength),
      byteOffset: 0,
      byteLength: u.byteLength
    });
  }
}
async function F4(t, e, i) {
  const s = k4(t), o = t.json.images || [], u = [];
  for (const d of s)
    u.push(N4(t, o[d], d, e, i));
  return await Promise.all(u);
}
function k4(t) {
  const e = /* @__PURE__ */ new Set(), i = t.json.textures || [];
  for (const s of i)
    s.source !== void 0 && e.add(s.source);
  return Array.from(e).sort();
}
async function N4(t, e, i, s, o) {
  let u;
  if (e.uri && !e.hasOwnProperty("bufferView")) {
    const a = RA(e.uri, s), { fetch: w } = o;
    u = await (await w(a)).arrayBuffer(), e.bufferView = {
      data: u
    };
  }
  if (Number.isFinite(e.bufferView)) {
    const a = zU(t.json, t.buffers, e.bufferView);
    u = Km(a.buffer, a.byteOffset, a.byteLength);
  }
  Zs(u, "glTF image has no data");
  let d = await rd(u, [Sw, gU], {
    ...s,
    mimeType: e.mimeType,
    basis: s.basis || { format: yA() }
  }, o);
  d && d[0] && (d = {
    compressed: !0,
    // @ts-expect-error
    mipmaps: !1,
    width: d[0].width,
    height: d[0].height,
    data: d[0]
  }), t.images = t.images || [], t.images[i] = d;
}
const td = {
  dataType: null,
  batchType: null,
  name: "glTF",
  id: "gltf",
  module: "gltf",
  version: qz,
  extensions: ["gltf", "glb"],
  mimeTypes: ["model/gltf+json", "model/gltf-binary"],
  text: !0,
  binary: !0,
  tests: ["glTF"],
  parse: L4,
  options: {
    gltf: {
      normalize: !0,
      // Normalize glTF v1 to glTF v2 format (not yet stable)
      loadBuffers: !0,
      // Fetch any linked .BIN buffers, decode base64
      loadImages: !0,
      // Create image objects
      decompressMeshes: !0
      // Decompress Draco encoded meshes
    },
    // common?
    log: console
    // eslint-disable-line
  }
};
async function L4(t, e = {}, i) {
  e = { ...td.options, ...e }, e.gltf = { ...td.options.gltf, ...e.gltf };
  const { byteOffset: s = 0 } = e;
  return await B4({}, t, s, e, i);
}
const U4 = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, z4 = {
  5120: 1,
  // BYTE
  5121: 1,
  // UNSIGNED_BYTE
  5122: 2,
  // SHORT
  5123: 2,
  // UNSIGNED_SHORT
  5125: 4,
  // UNSIGNED_INT
  5126: 4
  // FLOAT
}, ln = {
  // Sampler parameters
  TEXTURE_MAG_FILTER: 10240,
  TEXTURE_MIN_FILTER: 10241,
  TEXTURE_WRAP_S: 10242,
  TEXTURE_WRAP_T: 10243,
  // Sampler default values
  REPEAT: 10497,
  LINEAR: 9729,
  NEAREST_MIPMAP_LINEAR: 9986
}, V4 = {
  magFilter: ln.TEXTURE_MAG_FILTER,
  minFilter: ln.TEXTURE_MIN_FILTER,
  wrapS: ln.TEXTURE_WRAP_S,
  wrapT: ln.TEXTURE_WRAP_T
}, j4 = {
  [ln.TEXTURE_MAG_FILTER]: ln.LINEAR,
  [ln.TEXTURE_MIN_FILTER]: ln.NEAREST_MIPMAP_LINEAR,
  [ln.TEXTURE_WRAP_S]: ln.REPEAT,
  [ln.TEXTURE_WRAP_T]: ln.REPEAT
};
function H4() {
  return {
    id: "default-sampler",
    parameters: j4
  };
}
function $4(t) {
  return z4[t];
}
function G4(t) {
  return U4[t];
}
class W4 {
  baseUri = "";
  // @ts-expect-error
  jsonUnprocessed;
  // @ts-expect-error
  json;
  buffers = [];
  images = [];
  postProcess(e, i = {}) {
    const { json: s, buffers: o = [], images: u = [] } = e, { baseUri: d = "" } = e;
    return Zs(s), this.baseUri = d, this.buffers = o, this.images = u, this.jsonUnprocessed = s, this.json = this._resolveTree(e.json, i), this.json;
  }
  // Convert indexed glTF structure into tree structure
  // cross-link index resolution, enum lookup, convenience calculations
  // eslint-disable-next-line complexity, max-statements
  _resolveTree(e, i = {}) {
    const s = { ...e };
    return this.json = s, e.bufferViews && (s.bufferViews = e.bufferViews.map((o, u) => this._resolveBufferView(o, u))), e.images && (s.images = e.images.map((o, u) => this._resolveImage(o, u))), e.samplers && (s.samplers = e.samplers.map((o, u) => this._resolveSampler(o, u))), e.textures && (s.textures = e.textures.map((o, u) => this._resolveTexture(o, u))), e.accessors && (s.accessors = e.accessors.map((o, u) => this._resolveAccessor(o, u))), e.materials && (s.materials = e.materials.map((o, u) => this._resolveMaterial(o, u))), e.meshes && (s.meshes = e.meshes.map((o, u) => this._resolveMesh(o, u))), e.nodes && (s.nodes = e.nodes.map((o, u) => this._resolveNode(o, u)), s.nodes = s.nodes.map((o, u) => this._resolveNodeChildren(o))), e.skins && (s.skins = e.skins.map((o, u) => this._resolveSkin(o, u))), e.scenes && (s.scenes = e.scenes.map((o, u) => this._resolveScene(o, u))), typeof this.json.scene == "number" && s.scenes && (s.scene = s.scenes[this.json.scene]), s;
  }
  getScene(e) {
    return this._get(this.json.scenes, e);
  }
  getNode(e) {
    return this._get(this.json.nodes, e);
  }
  getSkin(e) {
    return this._get(this.json.skins, e);
  }
  getMesh(e) {
    return this._get(this.json.meshes, e);
  }
  getMaterial(e) {
    return this._get(this.json.materials, e);
  }
  getAccessor(e) {
    return this._get(this.json.accessors, e);
  }
  getCamera(e) {
    return this._get(this.json.cameras, e);
  }
  getTexture(e) {
    return this._get(this.json.textures, e);
  }
  getSampler(e) {
    return this._get(this.json.samplers, e);
  }
  getImage(e) {
    return this._get(this.json.images, e);
  }
  getBufferView(e) {
    return this._get(this.json.bufferViews, e);
  }
  getBuffer(e) {
    return this._get(this.json.buffers, e);
  }
  _get(e, i) {
    if (typeof i == "object")
      return i;
    const s = e && e[i];
    return s || console.warn(`glTF file error: Could not find ${e}[${i}]`), s;
  }
  // PARSING HELPERS
  _resolveScene(e, i) {
    return {
      ...e,
      // @ts-ignore
      id: e.id || `scene-${i}`,
      nodes: (e.nodes || []).map((s) => this.getNode(s))
    };
  }
  _resolveNode(e, i) {
    const s = {
      ...e,
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: e?.id || `node-${i}`
    };
    return e.mesh !== void 0 && (s.mesh = this.getMesh(e.mesh)), e.camera !== void 0 && (s.camera = this.getCamera(e.camera)), e.skin !== void 0 && (s.skin = this.getSkin(e.skin)), e.meshes !== void 0 && e.meshes.length && (s.mesh = e.meshes.reduce((o, u) => {
      const d = this.getMesh(u);
      return o.id = d.id, o.primitives = o.primitives.concat(d.primitives), o;
    }, { primitives: [] })), s;
  }
  _resolveNodeChildren(e) {
    return e.children && (e.children = e.children.map((i) => this.getNode(i))), e;
  }
  _resolveSkin(e, i) {
    const s = typeof e.inverseBindMatrices == "number" ? this.getAccessor(e.inverseBindMatrices) : void 0;
    return {
      ...e,
      id: e.id || `skin-${i}`,
      inverseBindMatrices: s
    };
  }
  _resolveMesh(e, i) {
    const s = {
      ...e,
      id: e.id || `mesh-${i}`,
      primitives: []
    };
    return e.primitives && (s.primitives = e.primitives.map((o) => {
      const u = {
        ...o,
        attributes: {},
        indices: void 0,
        material: void 0
      }, d = o.attributes;
      for (const a in d)
        u.attributes[a] = this.getAccessor(d[a]);
      return o.indices !== void 0 && (u.indices = this.getAccessor(o.indices)), o.material !== void 0 && (u.material = this.getMaterial(o.material)), u;
    })), s;
  }
  _resolveMaterial(e, i) {
    const s = {
      ...e,
      // @ts-expect-error
      id: e.id || `material-${i}`
    };
    if (s.normalTexture && (s.normalTexture = { ...s.normalTexture }, s.normalTexture.texture = this.getTexture(s.normalTexture.index)), s.occlusionTexture && (s.occlusionTexture = { ...s.occlusionTexture }, s.occlusionTexture.texture = this.getTexture(s.occlusionTexture.index)), s.emissiveTexture && (s.emissiveTexture = { ...s.emissiveTexture }, s.emissiveTexture.texture = this.getTexture(s.emissiveTexture.index)), s.emissiveFactor || (s.emissiveFactor = s.emissiveTexture ? [1, 1, 1] : [0, 0, 0]), s.pbrMetallicRoughness) {
      s.pbrMetallicRoughness = { ...s.pbrMetallicRoughness };
      const o = s.pbrMetallicRoughness;
      o.baseColorTexture && (o.baseColorTexture = { ...o.baseColorTexture }, o.baseColorTexture.texture = this.getTexture(o.baseColorTexture.index)), o.metallicRoughnessTexture && (o.metallicRoughnessTexture = { ...o.metallicRoughnessTexture }, o.metallicRoughnessTexture.texture = this.getTexture(o.metallicRoughnessTexture.index));
    }
    return s;
  }
  _resolveAccessor(e, i) {
    const s = $4(e.componentType), o = G4(e.type), u = s * o, d = {
      ...e,
      // @ts-expect-error
      id: e.id || `accessor-${i}`,
      bytesPerComponent: s,
      components: o,
      bytesPerElement: u,
      value: void 0,
      bufferView: void 0,
      sparse: void 0
    };
    if (e.bufferView !== void 0 && (d.bufferView = this.getBufferView(e.bufferView)), d.bufferView) {
      const a = d.bufferView.buffer, { ArrayType: w, byteLength: S } = zy(d, d.bufferView), M = (d.bufferView.byteOffset || 0) + (d.byteOffset || 0) + a.byteOffset;
      let F = a.arrayBuffer.slice(M, M + S);
      d.bufferView.byteStride && (F = this._getValueFromInterleavedBuffer(a, M, d.bufferView.byteStride, d.bytesPerElement, d.count)), d.value = new w(F);
    }
    return d;
  }
  /**
   * Take values of particular accessor from interleaved buffer
   * various parts of the buffer
   * @param buffer
   * @param byteOffset
   * @param byteStride
   * @param bytesPerElement
   * @param count
   * @returns
   */
  _getValueFromInterleavedBuffer(e, i, s, o, u) {
    const d = new Uint8Array(u * o);
    for (let a = 0; a < u; a++) {
      const w = i + a * s;
      d.set(new Uint8Array(e.arrayBuffer.slice(w, w + o)), a * o);
    }
    return d.buffer;
  }
  _resolveTexture(e, i) {
    return {
      ...e,
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: e.id || `texture-${i}`,
      sampler: typeof e.sampler == "number" ? this.getSampler(e.sampler) : H4(),
      source: typeof e.source == "number" ? this.getImage(e.source) : void 0
    };
  }
  _resolveSampler(e, i) {
    const s = {
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: e.id || `sampler-${i}`,
      ...e,
      parameters: {}
    };
    for (const o in s) {
      const u = this._enumSamplerParameter(o);
      u !== void 0 && (s.parameters[u] = s[o]);
    }
    return s;
  }
  _enumSamplerParameter(e) {
    return V4[e];
  }
  _resolveImage(e, i) {
    const s = {
      ...e,
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: e.id || `image-${i}`,
      image: null,
      bufferView: e.bufferView !== void 0 ? this.getBufferView(e.bufferView) : void 0
    }, o = this.images[i];
    return o && (s.image = o), s;
  }
  _resolveBufferView(e, i) {
    const s = e.buffer, o = this.buffers[s].arrayBuffer;
    let u = this.buffers[s].byteOffset || 0;
    return e.byteOffset && (u += e.byteOffset), {
      // // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: `bufferView-${i}`,
      ...e,
      // ...this.buffers[bufferIndex],
      buffer: this.buffers[s],
      data: new Uint8Array(o, u, e.byteLength)
    };
  }
  _resolveCamera(e, i) {
    const s = {
      ...e,
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: e.id || `camera-${i}`
    };
    return s.perspective, s.orthographic, s;
  }
}
function Gy(t, e) {
  return new W4().postProcess(t, e);
}
async function X4(t) {
  const e = [];
  return t.scenes.forEach((i) => {
    i.traverse((s) => {
      Object.values(s.model.uniforms).forEach((o) => {
        o.loaded === !1 && e.push(o);
      });
    });
  }), await q4(() => e.some((i) => !i.loaded));
}
async function q4(t) {
  for (; t(); )
    await new Promise((e) => requestAnimationFrame(e));
}
const Z4 = `#version 300 es
#define SHADER_NAME scenegraph-layer-vertex-shader
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec3 instanceModelMatrixCol0;
in vec3 instanceModelMatrixCol1;
in vec3 instanceModelMatrixCol2;
in vec3 instanceTranslation;
uniform float sizeScale;
uniform float sizeMinPixels;
uniform float sizeMaxPixels;
uniform mat4 sceneModelMatrix;
uniform bool composeModelMatrix;
in vec3 positions;
#ifdef HAS_UV
in vec2 texCoords;
#endif
#ifdef MODULE_PBR
#ifdef HAS_NORMALS
in vec3 normals;
#endif
#endif
out vec4 vColor;
#ifndef MODULE_PBR
#ifdef HAS_UV
out vec2 vTEXCOORD_0;
#endif
#endif
void main(void) {
#if defined(HAS_UV) && !defined(MODULE_PBR)
vTEXCOORD_0 = texCoords;
geometry.uv = texCoords;
#endif
geometry.worldPosition = instancePositions;
geometry.pickingColor = instancePickingColors;
mat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);
vec3 normal = vec3(0.0, 0.0, 1.0);
#ifdef MODULE_PBR
#ifdef HAS_NORMALS
normal = instanceModelMatrix * (sceneModelMatrix * vec4(normals, 0.0)).xyz;
#endif
#endif
float originalSize = project_size_to_pixel(sizeScale);
float clampedSize = clamp(originalSize, sizeMinPixels, sizeMaxPixels);
vec3 pos = (instanceModelMatrix * (sceneModelMatrix * vec4(positions, 1.0)).xyz) * sizeScale * (clampedSize / originalSize) + instanceTranslation;
if(composeModelMatrix) {
DECKGL_FILTER_SIZE(pos, geometry);
geometry.normal = project_normal(normal);
geometry.worldPosition += pos;
gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
}
else {
pos = project_size(pos);
DECKGL_FILTER_SIZE(pos, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, geometry.position);
geometry.normal = project_normal(normal);
}
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
#ifdef MODULE_PBR
pbr_vPosition = geometry.position.xyz;
#ifdef HAS_NORMALS
pbr_vNormal = geometry.normal;
#endif
#ifdef HAS_UV
pbr_vUV = texCoords;
#else
pbr_vUV = vec2(0., 0.);
#endif
geometry.uv = pbr_vUV;
#endif
vColor = instanceColors;
DECKGL_FILTER_COLOR(vColor, geometry);
}
`, K4 = `#version 300 es
#define SHADER_NAME scenegraph-layer-fragment-shader
uniform float opacity;
in vec4 vColor;
out vec4 fragColor;
#ifndef MODULE_PBR
#if defined(HAS_UV) && defined(HAS_BASECOLORMAP)
in vec2 vTEXCOORD_0;
uniform sampler2D u_BaseColorSampler;
#endif
#endif
void main(void) {
#ifdef MODULE_PBR
fragColor = vColor * pbr_filterColor(vec4(0));
geometry.uv = pbr_vUV;
#else
#if defined(HAS_UV) && defined(HAS_BASECOLORMAP)
fragColor = vColor * texture(u_BaseColorSampler, vTEXCOORD_0);
geometry.uv = vTEXCOORD_0;
#else
fragColor = vColor;
#endif
#endif
fragColor.a *= opacity;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`, NA = [255, 255, 255, 255], Y4 = {
  scenegraph: { type: "object", value: null, async: !0 },
  getScene: (t) => t && t.scenes ? typeof t.scene == "object" ? t.scene : t.scenes[t.scene || 0] : t,
  getAnimator: (t) => t && t.animator,
  _animations: null,
  sizeScale: { type: "number", value: 1, min: 0 },
  sizeMinPixels: { type: "number", min: 0, value: 0 },
  sizeMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
  getPosition: { type: "accessor", value: (t) => t.position },
  getColor: { type: "accessor", value: NA },
  // flat or pbr
  _lighting: "flat",
  // _lighting must be pbr for this to work
  _imageBasedLightingEnvironment: void 0,
  // yaw, pitch and roll are in degrees
  // https://en.wikipedia.org/wiki/Euler_angles
  // [pitch, yaw, roll]
  getOrientation: { type: "accessor", value: [0, 0, 0] },
  getScale: { type: "accessor", value: [1, 1, 1] },
  getTranslation: { type: "accessor", value: [0, 0, 0] },
  // 4x4 matrix
  getTransformMatrix: { type: "accessor", value: [] },
  loaders: [td]
};
class Wy extends mh {
  getShaders() {
    const e = [Ay, Cy];
    return this.props._lighting === "pbr" && e.push(wy), super.getShaders({ vs: Z4, fs: K4, modules: e });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        accessor: "getPosition",
        transition: !0
      },
      instanceColors: {
        type: "unorm8",
        size: this.props.colorFormat.length,
        accessor: "getColor",
        defaultValue: NA,
        transition: !0
      },
      instanceModelMatrix: pA
    });
  }
  updateState(e) {
    super.updateState(e);
    const { props: i, oldProps: s } = e;
    i.scenegraph !== s.scenegraph ? this._updateScenegraph() : i._animations !== s._animations && this._applyAnimationsProp(this.state.animator, i._animations);
  }
  finalizeState(e) {
    super.finalizeState(e), this.state.scenegraph?.destroy();
  }
  get isLoaded() {
    return !!(this.state?.scenegraph && super.isLoaded);
  }
  _updateScenegraph() {
    const e = this.props, { device: i } = this.context;
    let s = null;
    if (e.scenegraph instanceof gp)
      s = { scenes: [e.scenegraph] };
    else if (e.scenegraph && typeof e.scenegraph == "object") {
      const a = e.scenegraph, w = a.json ? Gy(a) : a, S = DU(i, w, this._getModelOptions());
      s = { gltf: w, ...S }, X4(S).then(() => {
        this.setNeedsRedraw();
      }).catch((M) => {
        this.raiseError(M, "loading glTF");
      });
    }
    const o = { layer: this, device: this.context.device }, u = e.getScene(s, o), d = e.getAnimator(s, o);
    if (u instanceof th) {
      this.state.scenegraph?.destroy(), this._applyAnimationsProp(d, e._animations);
      const a = [];
      u.traverse((w) => {
        w instanceof Am && a.push(w.model);
      }), this.setState({ scenegraph: u, animator: d, models: a }), this.getAttributeManager().invalidateAll();
    } else u !== null && Jt.warn("invalid scenegraph:", u)();
  }
  _applyAnimationsProp(e, i) {
    if (!e || !i)
      return;
    const s = e.getAnimations();
    Object.keys(i).sort().forEach((o) => {
      const u = i[o];
      if (o === "*")
        s.forEach((d) => {
          Object.assign(d, u);
        });
      else if (Number.isFinite(Number(o))) {
        const d = Number(o);
        d >= 0 && d < s.length ? Object.assign(s[d], u) : Jt.warn(`animation ${o} not found`)();
      } else {
        const d = s.find(({ name: a }) => a === o);
        d ? Object.assign(d, u) : Jt.warn(`animation ${o} not found`)();
      }
    });
  }
  _getModelOptions() {
    const { _imageBasedLightingEnvironment: e } = this.props;
    let i;
    return e && (typeof e == "function" ? i = e({ gl: this.context.gl, layer: this }) : i = e), {
      imageBasedLightingEnvironment: i,
      modelOptions: {
        id: this.props.id,
        isInstanced: !0,
        bufferLayout: this.getAttributeManager().getBufferLayouts(),
        ...this.getShaders()
      },
      // tangents are not supported
      useTangents: !1
    };
  }
  draw({ context: e }) {
    if (!this.state.scenegraph)
      return;
    this.props._animations && this.state.animator && (this.state.animator.animate(e.timeline.getTime()), this.setNeedsRedraw());
    const { viewport: i, renderPass: s } = this.context, { sizeScale: o, sizeMinPixels: u, sizeMaxPixels: d, opacity: a, coordinateSystem: w } = this.props, S = this.getNumInstances();
    this.state.scenegraph.traverse((M, { worldMatrix: F }) => {
      if (M instanceof Am) {
        const { model: N } = M;
        N.setInstanceCount(S), N.setUniforms({
          sizeScale: o,
          opacity: a,
          sizeMinPixels: u,
          sizeMaxPixels: d,
          composeModelMatrix: _A(i, w),
          sceneModelMatrix: F,
          // Needed for PBR (TODO: find better way to get it)
          // eslint-disable-next-line camelcase
          u_Camera: N.uniforms.project_uCameraPosition
        }), N.draw(s);
      }
    });
  }
}
Wy.defaultProps = Y4;
Wy.layerName = "ScenegraphLayer";
const J4 = `#version 300 es
#define SHADER_NAME simple-mesh-layer-vs
uniform float sizeScale;
uniform bool composeModelMatrix;
uniform bool pickFeatureIds;
in vec3 positions;
in vec3 normals;
in vec3 colors;
in vec2 texCoords;
in vec4 uvRegions;
in vec3 featureIdsPickingColors;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec3 instanceModelMatrixCol0;
in vec3 instanceModelMatrixCol1;
in vec3 instanceModelMatrixCol2;
out vec2 vTexCoord;
out vec3 cameraPosition;
out vec3 normals_commonspace;
out vec4 position_commonspace;
out vec4 vColor;
vec2 applyUVRegion(vec2 uv) {
#ifdef HAS_UV_REGIONS
return fract(uv) * (uvRegions.zw - uvRegions.xy) + uvRegions.xy;
#else
return uv;
#endif
}
void main(void) {
vec2 uv = applyUVRegion(texCoords);
geometry.uv = uv;
if (pickFeatureIds) {
geometry.pickingColor = featureIdsPickingColors;
} else {
geometry.pickingColor = instancePickingColors;
}
mat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);
vTexCoord = uv;
cameraPosition = project_uCameraPosition;
vColor = vec4(colors * instanceColors.rgb, instanceColors.a);
vec3 pos = (instanceModelMatrix * positions) * sizeScale;
vec3 projectedPosition = project_position(positions);
position_commonspace = vec4(projectedPosition, 1.0);
gl_Position = project_common_position_to_clipspace(position_commonspace);
geometry.position = position_commonspace;
normals_commonspace = project_normal(instanceModelMatrix * normals);
geometry.normal = normals_commonspace;
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
#ifdef MODULE_PBR
pbr_vPosition = geometry.position.xyz;
#ifdef HAS_NORMALS
pbr_vNormal = geometry.normal;
#endif
#ifdef HAS_UV
pbr_vUV = uv;
#else
pbr_vUV = vec2(0., 0.);
#endif
geometry.uv = pbr_vUV;
#endif
DECKGL_FILTER_COLOR(vColor, geometry);
}
`, Q4 = `#version 300 es
#define SHADER_NAME simple-mesh-layer-fs
precision highp float;
uniform bool hasTexture;
uniform sampler2D sampler;
uniform bool flatShading;
uniform float opacity;
in vec2 vTexCoord;
in vec3 cameraPosition;
in vec3 normals_commonspace;
in vec4 position_commonspace;
in vec4 vColor;
out vec4 fragColor;
void main(void) {
#ifdef MODULE_PBR
fragColor = vColor * pbr_filterColor(vec4(0));
geometry.uv = pbr_vUV;
fragColor.a *= opacity;
#else
geometry.uv = vTexCoord;
vec3 normal;
if (flatShading) {
normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
} else {
normal = normals_commonspace;
}
vec4 color = hasTexture ? texture(sampler, vTexCoord) : vColor;
vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);
fragColor = vec4(lightColor, color.a * opacity);
#endif
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;
function e5(t) {
  const e = t.positions || t.POSITION, i = e.value.length / e.size;
  t.COLOR_0 || t.colors || (t.colors = {
    size: 4,
    value: new Uint8Array(i * 4).fill(255),
    normalized: !0
  });
}
const t5 = {
  pbrMaterial: { type: "object", value: null },
  featureIds: { type: "array", value: null, optional: !0 }
};
class Xy extends Uy {
  getShaders() {
    const e = super.getShaders();
    return e.modules.push(wy), { ...e, vs: J4, fs: Q4 };
  }
  initializeState() {
    const { featureIds: e } = this.props;
    super.initializeState();
    const i = this.getAttributeManager();
    e && i.add({
      featureIdsPickingColors: {
        type: "uint8",
        size: 3,
        noAlloc: !0,
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculateFeatureIdsPickingColors
      }
    });
  }
  updateState(e) {
    super.updateState(e);
    const { props: i, oldProps: s } = e;
    i.pbrMaterial !== s.pbrMaterial && this.updatePbrMaterialUniforms(i.pbrMaterial);
  }
  draw(e) {
    const { featureIds: i } = this.props;
    this.state.model && (this.state.model.setUniforms({
      // Needed for PBR (TODO: find better way to get it)
      // eslint-disable-next-line camelcase
      u_Camera: this.state.model.uniforms.project_uCameraPosition,
      pickFeatureIds: !!i
    }), super.draw(e));
  }
  getModel(e) {
    const { id: i, pbrMaterial: s } = this.props, o = this.parseMaterial(s, e);
    this.setState({ parsedPBRMaterial: o });
    const u = this.getShaders();
    return e5(e.attributes), new Ca(this.context.device, {
      ...this.getShaders(),
      id: i,
      geometry: e,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      defines: {
        ...u.defines,
        ...o?.defines,
        HAS_UV_REGIONS: e.attributes.uvRegions ? 1 : 0
      },
      parameters: o?.parameters,
      isInstanced: !0
    });
  }
  updatePbrMaterialUniforms(e) {
    const { model: i } = this.state;
    if (i) {
      const { mesh: s } = this.props, o = this.parseMaterial(e, s);
      this.setState({ parsedPBRMaterial: o }), i.setBindings(o.bindings), i.setUniforms(o.uniforms);
    }
  }
  parseMaterial(e, i) {
    const s = !!(e.pbrMetallicRoughness && e.pbrMetallicRoughness.baseColorTexture);
    return gA(this.context.device, { unlit: s, ...e }, { NORMAL: i.attributes.normals, TEXCOORD_0: i.attributes.texCoords }, {
      pbrDebug: !1,
      lights: !0,
      useTangents: !1
    });
  }
  calculateFeatureIdsPickingColors(e) {
    const i = this.props.featureIds, s = new Uint8ClampedArray(i.length * e.size), o = [];
    for (let u = 0; u < i.length; u++)
      this.encodePickingColor(i[u], o), s[u * 3] = o[0], s[u * 3 + 1] = o[1], s[u * 3 + 2] = o[2];
    e.value = s;
  }
  finalizeState(e) {
    super.finalizeState(e), this.state.parsedPBRMaterial?.generatedTextures.forEach((i) => i.destroy()), this.setState({ parsedPBRMaterial: null });
  }
}
Xy.layerName = "MeshLayer";
Xy.defaultProps = t5;
const i5 = 6378137, r5 = 6378137, s5 = 6356752314245179e-9;
function Vp(t) {
  return t;
}
new Be();
function n5(t, e = [], i = Vp) {
  return "longitude" in t ? (e[0] = i(t.longitude), e[1] = i(t.latitude), e[2] = t.height) : "x" in t ? (e[0] = i(t.x), e[1] = i(t.y), e[2] = t.z) : (e[0] = i(t[0]), e[1] = i(t[1]), e[2] = t[2]), e;
}
function o5(t, e = []) {
  return n5(t, e, Ar._cartographicRadians ? Vp : UP);
}
function a5(t, e, i = Vp) {
  return "longitude" in e ? (e.longitude = i(t[0]), e.latitude = i(t[1]), e.height = t[2]) : "x" in e ? (e.x = i(t[0]), e.y = i(t[1]), e.z = t[2]) : (e[0] = i(t[0]), e[1] = i(t[1]), e[2] = t[2]), e;
}
function l5(t, e) {
  return a5(t, e, Ar._cartographicRadians ? Vp : zP);
}
const h1 = 1e-14, c5 = new Be(), u1 = {
  up: {
    south: "east",
    north: "west",
    west: "south",
    east: "north"
  },
  down: {
    south: "west",
    north: "east",
    west: "north",
    east: "south"
  },
  south: {
    up: "west",
    down: "east",
    west: "down",
    east: "up"
  },
  north: {
    up: "east",
    down: "west",
    west: "up",
    east: "down"
  },
  west: {
    up: "north",
    down: "south",
    north: "down",
    south: "up"
  },
  east: {
    up: "south",
    down: "north",
    north: "up",
    south: "down"
  }
}, Hg = {
  north: [-1, 0, 0],
  east: [0, 1, 0],
  up: [0, 0, 1],
  south: [1, 0, 0],
  west: [0, -1, 0],
  down: [0, 0, -1]
}, Ru = {
  east: new Be(),
  north: new Be(),
  up: new Be(),
  west: new Be(),
  south: new Be(),
  down: new Be()
}, h5 = new Be(), u5 = new Be(), d5 = new Be();
function d1(t, e, i, s, o, u) {
  const d = u1[e] && u1[e][i];
  In(d && (!s || s === d));
  let a, w, S;
  const M = c5.copy(o);
  if (On(M.x, 0, h1) && On(M.y, 0, h1)) {
    const N = Math.sign(M.z);
    a = h5.fromArray(Hg[e]), e !== "east" && e !== "west" && a.scale(N), w = u5.fromArray(Hg[i]), i !== "east" && i !== "west" && w.scale(N), S = d5.fromArray(Hg[s]), s !== "east" && s !== "west" && S.scale(N);
  } else {
    const { up: N, east: L, north: re } = Ru;
    L.set(-M.y, M.x, 0).normalize(), t.geodeticSurfaceNormal(M, N), re.copy(N).cross(L);
    const { down: ne, west: we, south: Se } = Ru;
    ne.copy(N).scale(-1), we.copy(L).scale(-1), Se.copy(re).scale(-1), a = Ru[e], w = Ru[i], S = Ru[s];
  }
  return u[0] = a.x, u[1] = a.y, u[2] = a.z, u[3] = 0, u[4] = w.x, u[5] = w.y, u[6] = w.z, u[7] = 0, u[8] = S.x, u[9] = S.y, u[10] = S.z, u[11] = 0, u[12] = M.x, u[13] = M.y, u[14] = M.z, u[15] = 1, u;
}
const Uc = new Be(), f5 = new Be(), p5 = new Be();
function _5(t, e, i = []) {
  const { oneOverRadii: s, oneOverRadiiSquared: o, centerToleranceSquared: u } = e;
  Uc.from(t);
  const d = Uc.x, a = Uc.y, w = Uc.z, S = s.x, M = s.y, F = s.z, N = d * d * S * S, L = a * a * M * M, re = w * w * F * F, ne = N + L + re, we = Math.sqrt(1 / ne);
  if (!Number.isFinite(we))
    return;
  const Se = f5;
  if (Se.copy(t).scale(we), ne < u)
    return Se.to(i);
  const Ee = o.x, Ce = o.y, Le = o.z, Ze = p5;
  Ze.set(Se.x * Ee * 2, Se.y * Ce * 2, Se.z * Le * 2);
  let Ke = (1 - we) * Uc.len() / (0.5 * Ze.len()), ct = 0, _t, st, ot, bt;
  do {
    Ke -= ct, _t = 1 / (1 + Ke * Ee), st = 1 / (1 + Ke * Ce), ot = 1 / (1 + Ke * Le);
    const Ft = _t * _t, jt = st * st, Et = ot * ot, bi = Ft * _t, Dr = jt * st, gr = Et * ot;
    bt = N * Ft + L * jt + re * Et - 1;
    const Ht = -2 * (N * bi * Ee + L * Dr * Ce + re * gr * Le);
    ct = bt / Ht;
  } while (Math.abs(bt) > nB);
  return Uc.scale([_t, st, ot]).to(i);
}
const $f = new Be(), f1 = new Be(), g5 = new Be(), Sn = new Be(), m5 = new Be(), Gf = new Be();
class yi {
  constructor(e = 0, i = 0, s = 0) {
    this.centerToleranceSquared = sB, In(e >= 0), In(i >= 0), In(s >= 0), this.radii = new Be(e, i, s), this.radiiSquared = new Be(e * e, i * i, s * s), this.radiiToTheFourth = new Be(e * e * e * e, i * i * i * i, s * s * s * s), this.oneOverRadii = new Be(e === 0 ? 0 : 1 / e, i === 0 ? 0 : 1 / i, s === 0 ? 0 : 1 / s), this.oneOverRadiiSquared = new Be(e === 0 ? 0 : 1 / (e * e), i === 0 ? 0 : 1 / (i * i), s === 0 ? 0 : 1 / (s * s)), this.minimumRadius = Math.min(e, i, s), this.maximumRadius = Math.max(e, i, s), this.radiiSquared.z !== 0 && (this.squaredXOverSquaredZ = this.radiiSquared.x / this.radiiSquared.z), Object.freeze(this);
  }
  /** Compares this Ellipsoid against the provided Ellipsoid componentwise */
  equals(e) {
    return this === e || !!(e && this.radii.equals(e.radii));
  }
  /** Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'. */
  toString() {
    return this.radii.toString();
  }
  cartographicToCartesian(e, i = [0, 0, 0]) {
    const s = f1, o = g5, [, , u] = e;
    this.geodeticSurfaceNormalCartographic(e, s), o.copy(this.radiiSquared).scale(s);
    const d = Math.sqrt(s.dot(o));
    return o.scale(1 / d), s.scale(u), o.add(s), o.to(i);
  }
  cartesianToCartographic(e, i = [0, 0, 0]) {
    Gf.from(e);
    const s = this.scaleToGeodeticSurface(Gf, Sn);
    if (!s)
      return;
    const o = this.geodeticSurfaceNormal(s, f1), u = m5;
    u.copy(Gf).subtract(s);
    const d = Math.atan2(o.y, o.x), a = Math.asin(o.z), w = Math.sign(my(u, Gf)) * nT(u);
    return l5([d, a, w], i);
  }
  eastNorthUpToFixedFrame(e, i = new Gt()) {
    return d1(this, "east", "north", "up", e, i);
  }
  // Computes a 4x4 transformation matrix from a reference frame centered at
  // the provided origin to the ellipsoid's fixed reference frame.
  localFrameToFixedFrame(e, i, s, o, u = new Gt()) {
    return d1(this, e, i, s, o, u);
  }
  geocentricSurfaceNormal(e, i = [0, 0, 0]) {
    return $f.from(e).normalize().to(i);
  }
  geodeticSurfaceNormalCartographic(e, i = [0, 0, 0]) {
    const s = o5(e), o = s[0], u = s[1], d = Math.cos(u);
    return $f.set(d * Math.cos(o), d * Math.sin(o), Math.sin(u)).normalize(), $f.to(i);
  }
  geodeticSurfaceNormal(e, i = [0, 0, 0]) {
    return $f.from(e).scale(this.oneOverRadiiSquared).normalize().to(i);
  }
  /** Scales the provided Cartesian position along the geodetic surface normal
   * so that it is on the surface of this ellipsoid.  If the position is
   * at the center of the ellipsoid, this function returns undefined. */
  scaleToGeodeticSurface(e, i) {
    return _5(e, this, i);
  }
  /** Scales the provided Cartesian position along the geocentric surface normal
   * so that it is on the surface of this ellipsoid. */
  scaleToGeocentricSurface(e, i = [0, 0, 0]) {
    Sn.from(e);
    const s = Sn.x, o = Sn.y, u = Sn.z, d = this.oneOverRadiiSquared, a = 1 / Math.sqrt(s * s * d.x + o * o * d.y + u * u * d.z);
    return Sn.multiplyScalar(a).to(i);
  }
  /** Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying
   * its components by the result of `Ellipsoid#oneOverRadii` */
  transformPositionToScaledSpace(e, i = [0, 0, 0]) {
    return Sn.from(e).scale(this.oneOverRadii).to(i);
  }
  /** Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying
   * its components by the result of `Ellipsoid#radii`. */
  transformPositionFromScaledSpace(e, i = [0, 0, 0]) {
    return Sn.from(e).scale(this.radii).to(i);
  }
  /** Computes a point which is the intersection of the surface normal with the z-axis. */
  getSurfaceNormalIntersectionWithZAxis(e, i = 0, s = [0, 0, 0]) {
    In(On(this.radii.x, this.radii.y, _T)), In(this.radii.z > 0), Sn.from(e);
    const o = Sn.z * (1 - this.squaredXOverSquaredZ);
    if (!(Math.abs(o) >= this.radii.z - i))
      return Sn.set(0, 0, o).to(s);
  }
}
yi.WGS84 = new yi(i5, r5, s5);
class y5 {
  item;
  previous;
  next;
  constructor(e, i, s) {
    this.item = e, this.previous = i, this.next = s;
  }
}
class b5 {
  head = null;
  tail = null;
  _length = 0;
  get length() {
    return this._length;
  }
  /**
   * Adds the item to the end of the list
   * @param {*} [item]
   * @return {DoublyLinkedListNode}
   */
  add(e) {
    const i = new y5(e, this.tail, null);
    return this.tail ? (this.tail.next = i, this.tail = i) : (this.head = i, this.tail = i), ++this._length, i;
  }
  /**
   * Removes the given node from the list
   * @param {DoublyLinkedListNode} node
   */
  remove(e) {
    e && (e.previous && e.next ? (e.previous.next = e.next, e.next.previous = e.previous) : e.previous ? (e.previous.next = null, this.tail = e.previous) : e.next ? (e.next.previous = null, this.head = e.next) : (this.head = null, this.tail = null), e.next = null, e.previous = null, --this._length);
  }
  /**
   * Moves nextNode after node
   * @param {DoublyLinkedListNode} node
   * @param {DoublyLinkedListNode} nextNode
   */
  splice(e, i) {
    e !== i && (this.remove(i), this._insert(e, i));
  }
  _insert(e, i) {
    const s = e.next;
    e.next = i, this.tail === e ? this.tail = i : s.previous = i, i.next = s, i.previous = e, ++this._length;
  }
}
class v5 {
  _list;
  _sentinel;
  _trimTiles;
  constructor() {
    this._list = new b5(), this._sentinel = this._list.add("sentinel"), this._trimTiles = !1;
  }
  reset() {
    this._list.splice(this._list.tail, this._sentinel);
  }
  touch(e) {
    const i = e._cacheNode;
    i && this._list.splice(this._sentinel, i);
  }
  add(e, i, s) {
    i._cacheNode || (i._cacheNode = this._list.add(i), s && s(e, i));
  }
  unloadTile(e, i, s) {
    const o = i._cacheNode;
    o && (this._list.remove(o), i._cacheNode = null, s && s(e, i));
  }
  unloadTiles(e, i) {
    const s = this._trimTiles;
    this._trimTiles = !1;
    const o = this._list, u = e.maximumMemoryUsage * 1024 * 1024, d = this._sentinel;
    let a = o.head;
    for (; a !== d && (e.gpuMemoryUsageInBytes > u || s); ) {
      const w = a.item;
      a = a.next, this.unloadTile(e, w, i);
    }
  }
  trim() {
    this._trimTiles = !0;
  }
}
function x5(t, e) {
  mi(t), mi(e);
  const { rtcCenter: i, gltfUpAxis: s } = e, { computedTransform: o, boundingVolume: { center: u } } = t;
  let d = new Gt(o);
  switch (i && d.translate(i), s) {
    case "Z":
      break;
    case "Y":
      const F = new Gt().rotateX(Math.PI / 2);
      d = d.multiplyRight(F);
      break;
    case "X":
      const N = new Gt().rotateY(-Math.PI / 2);
      d = d.multiplyRight(N);
      break;
  }
  e.isQuantized && d.translate(e.quantizedVolumeOffset).scale(e.quantizedVolumeScale);
  const a = new Be(u);
  e.cartesianModelMatrix = d, e.cartesianOrigin = a;
  const w = yi.WGS84.cartesianToCartographic(a, new Be()), M = yi.WGS84.eastNorthUpToFixedFrame(a).invert();
  e.cartographicModelMatrix = M.multiplyRight(d), e.cartographicOrigin = w, e.coordinateSystem || (e.modelMatrix = e.cartographicModelMatrix);
}
const p1 = new Be(), $g = new Be(), Vm = new cn([
  new so(),
  new so(),
  new so(),
  new so(),
  new so(),
  new so()
]);
function w5(t, e) {
  const { cameraDirection: i, cameraUp: s, height: o } = t, { metersPerUnit: u } = t.distanceScales, d = rp(t, t.center), a = yi.WGS84.eastNorthUpToFixedFrame(d), w = t.unprojectPosition(t.cameraPosition), S = yi.WGS84.cartographicToCartesian(w, new Be()), M = new Be(
    // @ts-ignore
    a.transformAsVector(new Be(i).scale(u))
  ).normalize(), F = new Be(
    // @ts-ignore
    a.transformAsVector(new Be(s).scale(u))
  ).normalize();
  A5(t);
  const N = t.constructor, { longitude: L, latitude: re, width: ne, bearing: we, zoom: Se } = t, Ee = new N({
    longitude: L,
    latitude: re,
    height: o,
    width: ne,
    bearing: we,
    zoom: Se,
    pitch: 0
  });
  return {
    camera: {
      position: S,
      direction: M,
      up: F
    },
    viewport: t,
    topDownViewport: Ee,
    height: o,
    cullingVolume: Vm,
    frameNumber: e,
    // TODO: This can be the same between updates, what number is unique for between updates?
    sseDenominator: 1.15
    // Assumes fovy = 60 degrees
  };
}
function T5(t, e, i) {
  if (i === 0 || t.length <= i)
    return [t, []];
  const s = [], { longitude: o, latitude: u } = e.viewport;
  for (const [S, M] of t.entries()) {
    const [F, N] = M.header.mbs, L = Math.abs(o - F), re = Math.abs(u - N), ne = Math.sqrt(re * re + L * L);
    s.push([S, ne]);
  }
  const d = s.sort((S, M) => S[1] - M[1]), a = [];
  for (let S = 0; S < i; S++)
    a.push(t[d[S][0]]);
  const w = [];
  for (let S = i; S < d.length; S++)
    w.push(t[d[S][0]]);
  return [a, w];
}
function A5(t) {
  const e = t.getFrustumPlanes(), i = _1(e.near, t.cameraPosition), s = rp(t, i), o = rp(t, t.cameraPosition, $g);
  let u = 0;
  Vm.planes[u++].fromPointNormal(s, p1.copy(s).subtract(o));
  for (const d in e) {
    if (d === "near")
      continue;
    const a = e[d], w = _1(a, i, $g), S = rp(t, w, $g);
    Vm.planes[u++].fromPointNormal(
      S,
      // Want the normal to point into the frustum since that's what culling expects
      p1.copy(s).subtract(S)
    );
  }
}
function _1(t, e, i = new Be()) {
  const s = t.normal.dot(e);
  return i.copy(t.normal).scale(t.distance - s).add(e), i;
}
function rp(t, e, i = new Be()) {
  const s = t.unprojectPosition(e);
  return yi.WGS84.cartographicToCartesian(s, i);
}
const E5 = 6378137, S5 = 6378137, jm = 6356752314245179e-9, Zc = new Be();
function C5(t, e) {
  if (t instanceof dd) {
    const { halfAxes: i } = t, s = M5(i);
    return Math.log2(jm / (s + e[2]));
  } else if (t instanceof ud) {
    const { radius: i } = t;
    return Math.log2(jm / (i + e[2]));
  } else if (t.width && t.height) {
    const { width: i, height: s } = t, o = Math.log2(E5 / i), u = Math.log2(S5 / s);
    return (o + u) / 2;
  }
  return 1;
}
function LA(t, e, i) {
  yi.WGS84.cartographicToCartesian([t.xmax, t.ymax, t.zmax], Zc);
  const s = Math.sqrt(Math.pow(Zc[0] - i[0], 2) + Math.pow(Zc[1] - i[1], 2) + Math.pow(Zc[2] - i[2], 2));
  return Math.log2(jm / (s + e[2]));
}
function I5(t, e, i) {
  const [s, o, u, d] = t;
  return LA({ xmax: u, ymax: d, zmax: 0 }, e, i);
}
function M5(t) {
  t.getColumn(0, Zc);
  const e = t.getColumn(1), i = t.getColumn(2);
  return Zc.add(e).add(i).len();
}
const Ws = {
  UNLOADED: 0,
  // Has never been requested
  LOADING: 1,
  // Is waiting on a pending request
  PROCESSING: 2,
  // Request received.  Contents are being processed for rendering.  Depending on the content, it might make its own requests for external data.
  READY: 3,
  // Ready to render.
  EXPIRED: 4,
  // Is expired and will be unloaded once new content is loaded.
  FAILED: 5
  // Request failed.
};
var Fn;
(function(t) {
  t[t.ADD = 1] = "ADD", t[t.REPLACE = 2] = "REPLACE";
})(Fn || (Fn = {}));
var Oo;
(function(t) {
  t.EMPTY = "empty", t.SCENEGRAPH = "scenegraph", t.POINTCLOUD = "pointcloud", t.MESH = "mesh";
})(Oo || (Oo = {}));
var bs;
(function(t) {
  t.I3S = "I3S", t.TILES3D = "TILES3D";
})(bs || (bs = {}));
var dh;
(function(t) {
  t.GEOMETRIC_ERROR = "geometricError", t.MAX_SCREEN_THRESHOLD = "maxScreenThreshold";
})(dh || (dh = {}));
const R5 = {
  USE_OPTIMIZATION: 1
};
function UA(t) {
  return t != null;
}
const Jr = new Be(), sp = new Be(), P5 = new Be(), B5 = new Be(), gl = new Be(), g1 = new Be(), m1 = new Be(), y1 = new Be();
function Gg(t, e, i) {
  if (mi(t, "3D Tile: boundingVolume must be defined"), t.box)
    return zA(t.box, e, i);
  if (t.region)
    return F5(t.region);
  if (t.sphere)
    return O5(t.sphere, e, i);
  throw new Error("3D Tile: boundingVolume must contain a sphere, region, or box");
}
function D5(t, e) {
  if (t.box)
    return k5(e);
  if (t.region) {
    const [i, s, o, u, d, a] = t.region;
    return [
      [Cn(i), Cn(s), d],
      [Cn(o), Cn(u), a]
    ];
  }
  if (t.sphere)
    return N5(e);
  throw new Error("Unkown boundingVolume type");
}
function zA(t, e, i) {
  const s = new Be(t[0], t[1], t[2]);
  e.transform(s, s);
  let o = [];
  if (t.length === 10) {
    const S = t.slice(3, 6), M = new qu();
    M.fromArray(t, 6);
    const F = new Be([1, 0, 0]), N = new Be([0, 1, 0]), L = new Be([0, 0, 1]);
    F.transformByQuaternion(M), F.scale(S[0]), N.transformByQuaternion(M), N.scale(S[1]), L.transformByQuaternion(M), L.scale(S[2]), o = [...F.toArray(), ...N.toArray(), ...L.toArray()];
  } else
    o = [...t.slice(3, 6), ...t.slice(6, 9), ...t.slice(9, 12)];
  const u = e.transformAsVector(o.slice(0, 3)), d = e.transformAsVector(o.slice(3, 6)), a = e.transformAsVector(o.slice(6, 9)), w = new Yi([
    u[0],
    u[1],
    u[2],
    d[0],
    d[1],
    d[2],
    a[0],
    a[1],
    a[2]
  ]);
  return UA(i) ? (i.center = s, i.halfAxes = w, i) : new dd(s, w);
}
function O5(t, e, i) {
  const s = new Be(t[0], t[1], t[2]);
  e.transform(s, s);
  const o = e.getScale(sp), u = Math.max(Math.max(o[0], o[1]), o[2]), d = t[3] * u;
  return UA(i) ? (i.center = s, i.radius = d, i) : new ud(s, d);
}
function F5(t) {
  const [e, i, s, o, u, d] = t, a = yi.WGS84.cartographicToCartesian([Cn(e), Cn(o), u], P5), w = yi.WGS84.cartographicToCartesian([Cn(s), Cn(i), d], B5), S = new Be().addVectors(a, w).multiplyByScalar(0.5);
  return yi.WGS84.cartesianToCartographic(S, gl), yi.WGS84.cartographicToCartesian([Cn(s), gl[1], gl[2]], g1), yi.WGS84.cartographicToCartesian([gl[0], Cn(o), gl[2]], m1), yi.WGS84.cartographicToCartesian([gl[0], gl[1], d], y1), zA([
    ...S,
    ...g1.subtract(S),
    ...m1.subtract(S),
    ...y1.subtract(S)
  ], new Gt());
}
function k5(t) {
  const e = VA(), { halfAxes: i } = t, s = new Be(i.getColumn(0)), o = new Be(i.getColumn(1)), u = new Be(i.getColumn(2));
  for (let d = 0; d < 2; d++) {
    for (let a = 0; a < 2; a++) {
      for (let w = 0; w < 2; w++)
        Jr.copy(t.center), Jr.add(s), Jr.add(o), Jr.add(u), jA(e, Jr), u.negate();
      o.negate();
    }
    s.negate();
  }
  return e;
}
function N5(t) {
  const e = VA(), { center: i, radius: s } = t, o = yi.WGS84.scaleToGeodeticSurface(i, Jr);
  let u;
  o ? u = yi.WGS84.geodeticSurfaceNormal(o) : u = new Be(0, 0, 1);
  let d = new Be(u[2], -u[1], 0);
  d.len() > 0 ? d.normalize() : d = new Be(0, 1, 0);
  const a = d.clone().cross(u);
  for (const w of [d, a, u]) {
    sp.copy(w).scale(s);
    for (let S = 0; S < 2; S++)
      Jr.copy(i), Jr.add(sp), jA(e, Jr), sp.negate();
  }
  return e;
}
function VA() {
  return [
    [1 / 0, 1 / 0, 1 / 0],
    [-1 / 0, -1 / 0, -1 / 0]
  ];
}
function jA(t, e) {
  yi.WGS84.cartesianToCartographic(e, Jr), t[0][0] = Math.min(t[0][0], Jr[0]), t[0][1] = Math.min(t[0][1], Jr[1]), t[0][2] = Math.min(t[0][2], Jr[2]), t[1][0] = Math.max(t[1][0], Jr[0]), t[1][1] = Math.max(t[1][1], Jr[1]), t[1][2] = Math.max(t[1][2], Jr[2]);
}
new Be();
new Be();
new Gt();
new Be();
new Be();
new Be();
function L5(t, e) {
  const i = t * e;
  return 1 - Math.exp(-(i * i));
}
function U5(t, e) {
  if (t.dynamicScreenSpaceError && t.dynamicScreenSpaceErrorComputedDensity) {
    const i = t.dynamicScreenSpaceErrorComputedDensity, s = t.dynamicScreenSpaceErrorFactor;
    return L5(e, i) * s;
  }
  return 0;
}
function z5(t, e, i) {
  const s = t.tileset, o = t.parent && t.parent.lodMetricValue || t.lodMetricValue, u = i ? o : t.lodMetricValue;
  if (u === 0)
    return 0;
  const d = Math.max(t._distanceToCamera, 1e-7), { height: a, sseDenominator: w } = e, { viewDistanceScale: S } = s.options;
  let M = u * a * (S || 1) / (d * w);
  return M -= U5(s, d), M;
}
const Wg = new Be(), b1 = new Be(), ma = new Be(), v1 = new Be(), V5 = new Be(), Xg = new Gt(), x1 = new Gt();
function j5(t, e) {
  if (t.lodMetricValue === 0 || isNaN(t.lodMetricValue))
    return "DIG";
  const i = 2 * HA(t, e);
  return i < 2 ? "OUT" : !t.header.children || i <= t.lodMetricValue ? "DRAW" : t.header.children ? "DIG" : "OUT";
}
function HA(t, e) {
  const { topDownViewport: i } = e, s = t.header.mbs[1], o = t.header.mbs[0], u = t.header.mbs[2], d = t.header.mbs[3], a = [...t.boundingVolume.center], w = i.unprojectPosition(i.cameraPosition);
  yi.WGS84.cartographicToCartesian(w, Wg), b1.copy(Wg).subtract(a).normalize(), yi.WGS84.eastNorthUpToFixedFrame(a, Xg), x1.copy(Xg).invert(), ma.copy(Wg).transform(x1);
  const S = Math.sqrt(ma[0] * ma[0] + ma[1] * ma[1]), M = S * S / ma[2];
  v1.copy([ma[0], ma[1], M]);
  const N = v1.transform(Xg).subtract(a).normalize(), re = b1.cross(N).normalize().scale(d).add(a), ne = yi.WGS84.cartesianToCartographic(re), we = i.project([o, s, u]), Se = i.project(ne);
  return V5.copy(we).subtract(Se).magnitude();
}
function H5(t) {
  return {
    assetGltfUpAxis: t.asset && t.asset.gltfUpAxis || "Y"
  };
}
class w1 {
  _map = /* @__PURE__ */ new Map();
  _array;
  _length;
  constructor(e = 0) {
    this._array = new Array(e), this._length = e;
  }
  /**
   * Gets or sets the length of the array.
   * If the set length is greater than the length of the internal array, the internal array is resized.
   *
   * @memberof ManagedArray.prototype
   * @type Number
   */
  get length() {
    return this._length;
  }
  set length(e) {
    this._length = e, e > this._array.length && (this._array.length = e);
  }
  /**
   * Gets the internal array.
   *
   * @memberof ManagedArray.prototype
   * @type Array
   * @readonly
   */
  get values() {
    return this._array;
  }
  /**
   * Gets the element at an index.
   *
   * @param {Number} index The index to get.
   */
  get(e) {
    return mi(e < this._array.length), this._array[e];
  }
  /**
   * Sets the element at an index. Resizes the array if index is greater than the length of the array.
   *
   * @param {Number} index The index to set.
   * @param {*} element The element to set at index.
   */
  set(e, i) {
    mi(e >= 0), e >= this.length && (this.length = e + 1), this._map.has(this._array[e]) && this._map.delete(this._array[e]), this._array[e] = i, this._map.set(i, e);
  }
  delete(e) {
    const i = this._map.get(e);
    i >= 0 && (this._array.splice(i, 1), this._map.delete(e), this.length--);
  }
  /**
   * Returns the last element in the array without modifying the array.
   *
   * @returns {*} The last element in the array.
   */
  peek() {
    return this._array[this._length - 1];
  }
  /**
   * Push an element into the array.
   *
   * @param {*} element The element to push.
   */
  push(e) {
    if (!this._map.has(e)) {
      const i = this.length++;
      this._array[i] = e, this._map.set(e, i);
    }
  }
  /**
   * Pop an element from the array.
   *
   * @returns {*} The last element in the array.
   */
  pop() {
    const e = this._array[--this.length];
    return this._map.delete(e), e;
  }
  /**
   * Resize the internal array if length > _array.length.
   *
   * @param {Number} length The length.
   */
  reserve(e) {
    mi(e >= 0), e > this._array.length && (this._array.length = e);
  }
  /**
   * Resize the array.
   *
   * @param {Number} length The length.
   */
  resize(e) {
    mi(e >= 0), this.length = e;
  }
  /**
   * Trim the internal array to the specified length. Defaults to the current length.
   *
   * @param {Number} [length] The length.
   */
  trim(e) {
    e == null && (e = this.length), this._array.length = e;
  }
  reset() {
    this._array = [], this._map = /* @__PURE__ */ new Map(), this._length = 0;
  }
  find(e) {
    return this._map.has(e);
  }
}
const $5 = {
  loadSiblings: !1,
  skipLevelOfDetail: !1,
  updateTransforms: !0,
  onTraversalEnd: () => {
  },
  viewportTraversersMap: {},
  basePath: ""
};
class jp {
  options;
  // fulfill in traverse call
  root = null;
  // tiles should be rendered
  selectedTiles = {};
  // tiles should be loaded from server
  requestedTiles = {};
  // tiles does not have render content
  emptyTiles = {};
  lastUpdate = (/* @__PURE__ */ new Date()).getTime();
  updateDebounceTime = 1e3;
  /** temporary storage to hold the traversed tiles during a traversal */
  _traversalStack = new w1();
  _emptyTraversalStack = new w1();
  /** set in every traverse cycle */
  _frameNumber = null;
  // RESULT
  traversalFinished(e) {
    return !0;
  }
  // TODO nested props
  constructor(e) {
    this.options = { ...$5, ...e };
  }
  // tiles should be visible
  traverse(e, i, s) {
    this.root = e, this.options = { ...this.options, ...s }, this.reset(), this.updateTile(e, i), this._frameNumber = i.frameNumber, this.executeTraversal(e, i);
  }
  reset() {
    this.requestedTiles = {}, this.selectedTiles = {}, this.emptyTiles = {}, this._traversalStack.reset(), this._emptyTraversalStack.reset();
  }
  /**
   * Execute traverse
   * Depth-first traversal that traverses all visible tiles and marks tiles for selection.
   * If skipLevelOfDetail is off then a tile does not refine until all children are loaded.
   * This is the traditional replacement refinement approach and is called the base traversal.
   * Tiles that have a greater screen space error than the base screen space error are part of the base traversal,
   * all other tiles are part of the skip traversal. The skip traversal allows for skipping levels of the tree
   * and rendering children and parent tiles simultaneously.
   */
  /* eslint-disable-next-line complexity, max-statements */
  executeTraversal(e, i) {
    const s = this._traversalStack;
    for (e._selectionDepth = 1, s.push(e); s.length > 0; ) {
      const u = s.pop();
      let d = !1;
      this.canTraverse(u, i) && (this.updateChildTiles(u, i), d = this.updateAndPushChildren(u, i, s, u.hasRenderContent ? u._selectionDepth + 1 : u._selectionDepth));
      const a = u.parent, w = !!(!a || a._shouldRefine), S = !d;
      u.hasRenderContent ? u.refine === Fn.ADD ? (this.loadTile(u, i), this.selectTile(u, i)) : u.refine === Fn.REPLACE && (this.loadTile(u, i), S && this.selectTile(u, i)) : (this.emptyTiles[u.id] = u, this.loadTile(u, i), S && this.selectTile(u, i)), this.touchTile(u, i), u._shouldRefine = d && w;
    }
    const o = (/* @__PURE__ */ new Date()).getTime();
    (this.traversalFinished(i) || o - this.lastUpdate > this.updateDebounceTime) && (this.lastUpdate = o, this.options.onTraversalEnd(i));
  }
  updateChildTiles(e, i) {
    const s = e.children;
    for (const o of s)
      this.updateTile(o, i);
  }
  /* eslint-disable complexity, max-statements */
  updateAndPushChildren(e, i, s, o) {
    const { loadSiblings: u, skipLevelOfDetail: d } = this.options, a = e.children;
    a.sort(this.compareDistanceToCamera.bind(this));
    const w = e.refine === Fn.REPLACE && e.hasRenderContent && !d;
    let S = !1, M = !0;
    for (const F of a)
      if (F._selectionDepth = o, F.isVisibleAndInRequestVolume ? (s.find(F) && s.delete(F), s.push(F), S = !0) : (w || u) && (this.loadTile(F, i), this.touchTile(F, i)), w) {
        let N;
        if (F._inRequestVolume ? F.hasRenderContent ? N = F.contentAvailable : N = this.executeEmptyTraversal(F, i) : N = !1, M = M && N, !M)
          return !1;
      }
    return S || (M = !1), M;
  }
  /* eslint-enable complexity, max-statements */
  updateTile(e, i) {
    this.updateTileVisibility(e, i);
  }
  // tile to render in the browser
  selectTile(e, i) {
    this.shouldSelectTile(e) && (e._selectedFrame = i.frameNumber, this.selectedTiles[e.id] = e);
  }
  // tile to load from server
  loadTile(e, i) {
    this.shouldLoadTile(e) && (e._requestedFrame = i.frameNumber, e._priority = e._getPriority(), this.requestedTiles[e.id] = e);
  }
  // cache tile
  touchTile(e, i) {
    e.tileset._cache.touch(e), e._touchedFrame = i.frameNumber;
  }
  // tile should be visible
  // tile should have children
  // tile LoD (level of detail) is not sufficient under current viewport
  canTraverse(e, i) {
    return e.hasChildren ? e.hasTilesetContent ? !e.contentExpired : this.shouldRefine(e, i) : !1;
  }
  shouldLoadTile(e) {
    return e.hasUnloadedContent || e.contentExpired;
  }
  shouldSelectTile(e) {
    return e.contentAvailable && !this.options.skipLevelOfDetail;
  }
  /** Decide if tile LoD (level of detail) is not sufficient under current viewport */
  shouldRefine(e, i, s = !1) {
    let o = e._screenSpaceError;
    return s && (o = e.getScreenSpaceError(i, !0)), o > e.tileset.memoryAdjustedScreenSpaceError;
  }
  updateTileVisibility(e, i) {
    const s = [];
    if (this.options.viewportTraversersMap)
      for (const o in this.options.viewportTraversersMap)
        this.options.viewportTraversersMap[o] === i.viewport.id && s.push(o);
    else
      s.push(i.viewport.id);
    e.updateVisibility(i, s);
  }
  // UTILITIES
  compareDistanceToCamera(e, i) {
    return e._distanceToCamera - i._distanceToCamera;
  }
  anyChildrenVisible(e, i) {
    let s = !1;
    for (const o of e.children)
      o.updateVisibility(i), s = s || o.isVisibleAndInRequestVolume;
    return s;
  }
  // Depth-first traversal that checks if all nearest descendants with content are loaded.
  // Ignores visibility.
  executeEmptyTraversal(e, i) {
    let s = !0;
    const o = this._emptyTraversalStack;
    for (o.push(e); o.length > 0; ) {
      const u = o.pop(), d = !u.hasRenderContent && this.canTraverse(u, i), a = !u.hasRenderContent && u.children.length === 0;
      if (!d && !u.contentAvailable && !a && (s = !1), this.updateTile(u, i), u.isVisibleAndInRequestVolume || (this.loadTile(u, i), this.touchTile(u, i)), d) {
        const w = u.children;
        for (const S of w)
          o.push(S);
      }
    }
    return s;
  }
}
const T1 = new Be();
function G5(t) {
  return t != null;
}
class Hm {
  tileset;
  header;
  id;
  url;
  parent;
  /* Specifies the type of refine that is used when traversing this tile for rendering. */
  refine;
  type;
  contentUrl;
  /** Different refinement algorithms used by I3S and 3D tiles */
  lodMetricType = "geometricError";
  /** The error, in meters, introduced if this tile is rendered and its children are not. */
  lodMetricValue = 0;
  /** @todo math.gl is not exporting BoundingVolume base type? */
  boundingVolume = null;
  /**
   * The tile's content.  This represents the actual tile's payload,
   * not the content's metadata in the tileset JSON file.
   */
  content = null;
  contentState = Ws.UNLOADED;
  gpuMemoryUsageInBytes = 0;
  /** The tile's children - an array of Tile3D objects. */
  children = [];
  depth = 0;
  viewportIds = [];
  transform = new Gt();
  extensions = null;
  /** TODO Cesium 3d tiles specific */
  implicitTiling = null;
  /** Container to store application specific data */
  userData = {};
  computedTransform;
  hasEmptyContent = !1;
  hasTilesetContent = !1;
  traverser = new jp({});
  /** Used by TilesetCache */
  _cacheNode = null;
  _frameNumber = null;
  // TODO Cesium 3d tiles specific
  _expireDate = null;
  _expiredContent = null;
  _boundingBox = void 0;
  /** updated every frame for tree traversal and rendering optimizations: */
  _distanceToCamera = 0;
  _screenSpaceError = 0;
  _visibilityPlaneMask;
  _visible = void 0;
  _contentBoundingVolume;
  _viewerRequestVolume;
  _initialTransform = new Gt();
  // Used by traverser, cannot be marked private
  _priority = 0;
  _selectedFrame = 0;
  _requestedFrame = 0;
  _selectionDepth = 0;
  _touchedFrame = 0;
  _centerZDepth = 0;
  _shouldRefine = !1;
  _stackLength = 0;
  _visitedFrame = 0;
  _inRequestVolume = !1;
  _lodJudge = null;
  // TODO i3s specific, needs to remove
  /**
   * @constructs
   * Create a Tile3D instance
   * @param tileset - Tileset3D instance
   * @param header - tile header - JSON loaded from a dataset
   * @param parentHeader - parent Tile3D instance
   * @param extendedId - optional ID to separate copies of a tile for different viewports.
   *    const extendedId = `${tile.id}-${frameState.viewport.id}`;
   */
  // eslint-disable-next-line max-statements
  constructor(e, i, s, o = "") {
    this.header = i, this.tileset = e, this.id = o || i.id, this.url = i.url, this.parent = s, this.refine = this._getRefine(i.refine), this.type = i.type, this.contentUrl = i.contentUrl, this._initializeLodMetric(i), this._initializeTransforms(i), this._initializeBoundingVolumes(i), this._initializeContent(i), this._initializeRenderingState(i), Object.seal(this);
  }
  destroy() {
    this.header = null;
  }
  isDestroyed() {
    return this.header === null;
  }
  get selected() {
    return this._selectedFrame === this.tileset._frameNumber;
  }
  get isVisible() {
    return this._visible;
  }
  get isVisibleAndInRequestVolume() {
    return this._visible && this._inRequestVolume;
  }
  /** Returns true if tile is not an empty tile and not an external tileset */
  get hasRenderContent() {
    return !this.hasEmptyContent && !this.hasTilesetContent;
  }
  /** Returns true if tile has children */
  get hasChildren() {
    return this.children.length > 0 || this.header.children && this.header.children.length > 0;
  }
  /**
   * Determines if the tile's content is ready. This is automatically `true` for
   * tiles with empty content.
   */
  get contentReady() {
    return this.contentState === Ws.READY || this.hasEmptyContent;
  }
  /**
   * Determines if the tile has available content to render.  `true` if the tile's
   * content is ready or if it has expired content this renders while new content loads; otherwise,
   */
  get contentAvailable() {
    return !!(this.contentReady && this.hasRenderContent || this._expiredContent && !this.contentFailed);
  }
  /** Returns true if tile has renderable content but it's unloaded */
  get hasUnloadedContent() {
    return this.hasRenderContent && this.contentUnloaded;
  }
  /**
   * Determines if the tile's content has not be requested. `true` if tile's
   * content has not be requested; otherwise, `false`.
   */
  get contentUnloaded() {
    return this.contentState === Ws.UNLOADED;
  }
  /**
   * Determines if the tile's content is expired. `true` if tile's
   * content is expired; otherwise, `false`.
   */
  get contentExpired() {
    return this.contentState === Ws.EXPIRED;
  }
  // Determines if the tile's content failed to load.  `true` if the tile's
  // content failed to load; otherwise, `false`.
  get contentFailed() {
    return this.contentState === Ws.FAILED;
  }
  /**
   * Distance from the tile's bounding volume center to the camera
   */
  get distanceToCamera() {
    return this._distanceToCamera;
  }
  /**
   * Screen space error for LOD selection
   */
  get screenSpaceError() {
    return this._screenSpaceError;
  }
  /**
   * Get bounding box in cartographic coordinates
   * @returns [min, max] each in [longitude, latitude, altitude]
   */
  get boundingBox() {
    return this._boundingBox || (this._boundingBox = D5(this.header.boundingVolume, this.boundingVolume)), this._boundingBox;
  }
  /** Get the tile's screen space error. */
  getScreenSpaceError(e, i) {
    switch (this.tileset.type) {
      case bs.I3S:
        return HA(this, e);
      case bs.TILES3D:
        return z5(this, e, i);
      default:
        throw new Error("Unsupported tileset type");
    }
  }
  /**
   * Make tile unselected than means it won't be shown
   * but it can be still loaded in memory
   */
  unselect() {
    this._selectedFrame = 0;
  }
  /**
   * Memory usage of tile on GPU
   */
  _getGpuMemoryUsageInBytes() {
    return this.content.gpuMemoryUsageInBytes || this.content.byteLength || 0;
  }
  /*
   * If skipLevelOfDetail is off try to load child tiles as soon as possible so that their parent can refine sooner.
   * Tiles are prioritized by screen space error.
   */
  // eslint-disable-next-line complexity
  _getPriority() {
    const e = this.tileset._traverser, { skipLevelOfDetail: i } = e.options, s = this.refine === Fn.ADD || i;
    if (s && !this.isVisible && this._visible !== void 0 || this.tileset._frameNumber - this._touchedFrame >= 1 || this.contentState === Ws.UNLOADED)
      return -1;
    const o = this.parent, d = o && (!s || this._screenSpaceError === 0 || o.hasTilesetContent) ? o._screenSpaceError : this._screenSpaceError, a = e.root ? e.root._screenSpaceError : 0;
    return Math.max(a - d, 0);
  }
  /**
   *  Requests the tile's content.
   * The request may not be made if the Request Scheduler can't prioritize it.
   */
  // eslint-disable-next-line max-statements, complexity
  async loadContent() {
    if (this.hasEmptyContent)
      return !1;
    if (this.content)
      return !0;
    this.contentExpired && (this._expireDate = null), this.contentState = Ws.LOADING;
    const i = await this.tileset._requestScheduler.scheduleRequest(this.id, this._getPriority.bind(this));
    if (!i)
      return this.contentState = Ws.UNLOADED, !1;
    try {
      const s = this.tileset.getTileUrl(this.contentUrl), o = this.tileset.loader, u = {
        ...this.tileset.loadOptions,
        [o.id]: {
          // @ts-expect-error
          ...this.tileset.loadOptions[o.id],
          isTileset: this.type === "json",
          ...this._getLoaderSpecificOptions(o.id)
        }
      };
      return this.content = await Ea(s, o, u), this.tileset.options.contentLoader && await this.tileset.options.contentLoader(this), this._isTileset() && this.tileset._initializeTileHeaders(this.content, this), this.contentState = Ws.READY, this._onContentLoaded(), !0;
    } catch (s) {
      throw this.contentState = Ws.FAILED, s;
    } finally {
      i.done();
    }
  }
  // Unloads the tile's content.
  unloadContent() {
    return this.content && this.content.destroy && this.content.destroy(), this.content = null, this.header.content && this.header.content.destroy && this.header.content.destroy(), this.header.content = null, this.contentState = Ws.UNLOADED, !0;
  }
  /**
   * Update the tile's visibility
   * @param {Object} frameState - frame state for tile culling
   * @param {string[]} viewportIds - a list of viewport ids that show this tile
   * @return {void}
   */
  updateVisibility(e, i) {
    if (this._frameNumber === e.frameNumber)
      return;
    const s = this.parent, o = s ? s._visibilityPlaneMask : cn.MASK_INDETERMINATE;
    if (this.tileset._traverser.options.updateTransforms) {
      const u = s ? s.computedTransform : this.tileset.modelMatrix;
      this._updateTransform(u);
    }
    this._distanceToCamera = this.distanceToTile(e), this._screenSpaceError = this.getScreenSpaceError(e, !1), this._visibilityPlaneMask = this.visibility(e, o), this._visible = this._visibilityPlaneMask !== cn.MASK_OUTSIDE, this._inRequestVolume = this.insideViewerRequestVolume(e), this._frameNumber = e.frameNumber, this.viewportIds = i;
  }
  // Determines whether the tile's bounding volume intersects the culling volume.
  // @param {FrameState} frameState The frame state.
  // @param {Number} parentVisibilityPlaneMask The parent's plane mask to speed up the visibility check.
  // @returns {Number} A plane mask as described above in {@link CullingVolume#computeVisibilityWithPlaneMask}.
  visibility(e, i) {
    const { cullingVolume: s } = e, { boundingVolume: o } = this;
    return s.computeVisibilityWithPlaneMask(o, i);
  }
  // Assuming the tile's bounding volume intersects the culling volume, determines
  // whether the tile's content's bounding volume intersects the culling volume.
  // @param {FrameState} frameState The frame state.
  // @returns {Intersect} The result of the intersection: the tile's content is completely outside, completely inside, or intersecting the culling volume.
  contentVisibility() {
    return !0;
  }
  /**
   * Computes the (potentially approximate) distance from the closest point of the tile's bounding volume to the camera.
   * @param frameState The frame state.
   * @returns {Number} The distance, in meters, or zero if the camera is inside the bounding volume.
   */
  distanceToTile(e) {
    const i = this.boundingVolume;
    return Math.sqrt(Math.max(i.distanceSquaredTo(e.camera.position), 0));
  }
  /**
   * Computes the tile's camera-space z-depth.
   * @param frameState The frame state.
   * @returns The distance, in meters.
   */
  cameraSpaceZDepth({ camera: e }) {
    const i = this.boundingVolume;
    return T1.subVectors(i.center, e.position), e.direction.dot(T1);
  }
  /**
   * Checks if the camera is inside the viewer request volume.
   * @param {FrameState} frameState The frame state.
   * @returns {Boolean} Whether the camera is inside the volume.
   */
  insideViewerRequestVolume(e) {
    const i = this._viewerRequestVolume;
    return !i || i.distanceSquaredTo(e.camera.position) <= 0;
  }
  // TODO Cesium specific
  // Update whether the tile has expired.
  updateExpiration() {
    if (G5(this._expireDate) && this.contentReady && !this.hasEmptyContent) {
      const e = Date.now();
      Date.lessThan(this._expireDate, e) && (this.contentState = Ws.EXPIRED, this._expiredContent = this.content);
    }
  }
  get extras() {
    return this.header.extras;
  }
  // INTERNAL METHODS
  _initializeLodMetric(e) {
    "lodMetricType" in e ? this.lodMetricType = e.lodMetricType : (this.lodMetricType = this.parent && this.parent.lodMetricType || this.tileset.lodMetricType, console.warn("3D Tile: Required prop lodMetricType is undefined. Using parent lodMetricType")), "lodMetricValue" in e ? this.lodMetricValue = e.lodMetricValue : (this.lodMetricValue = this.parent && this.parent.lodMetricValue || this.tileset.lodMetricValue, console.warn("3D Tile: Required prop lodMetricValue is undefined. Using parent lodMetricValue"));
  }
  _initializeTransforms(e) {
    this.transform = e.transform ? new Gt(e.transform) : new Gt();
    const i = this.parent, s = this.tileset, o = i && i.computedTransform ? i.computedTransform.clone() : s.modelMatrix.clone();
    this.computedTransform = new Gt(o).multiplyRight(this.transform);
    const u = i && i._initialTransform ? i._initialTransform.clone() : new Gt();
    this._initialTransform = new Gt(u).multiplyRight(this.transform);
  }
  _initializeBoundingVolumes(e) {
    this._contentBoundingVolume = null, this._viewerRequestVolume = null, this._updateBoundingVolume(e);
  }
  _initializeContent(e) {
    this.content = { _tileset: this.tileset, _tile: this }, this.hasEmptyContent = !0, this.contentState = Ws.UNLOADED, this.hasTilesetContent = !1, e.contentUrl && (this.content = null, this.hasEmptyContent = !1);
  }
  // TODO - remove anything not related to basic visibility detection
  _initializeRenderingState(e) {
    this.depth = e.level || (this.parent ? this.parent.depth + 1 : 0), this._shouldRefine = !1, this._distanceToCamera = 0, this._centerZDepth = 0, this._screenSpaceError = 0, this._visibilityPlaneMask = cn.MASK_INDETERMINATE, this._visible = void 0, this._inRequestVolume = !1, this._stackLength = 0, this._selectionDepth = 0, this._frameNumber = 0, this._touchedFrame = 0, this._visitedFrame = 0, this._selectedFrame = 0, this._requestedFrame = 0, this._priority = 0;
  }
  _getRefine(e) {
    return e || this.parent && this.parent.refine || Fn.REPLACE;
  }
  _isTileset() {
    return this.contentUrl.indexOf(".json") !== -1;
  }
  _onContentLoaded() {
    switch (this.content && this.content.type) {
      case "vctr":
      case "geom":
        this.tileset._traverser.disableSkipLevelOfDetail = !0;
        break;
    }
    this._isTileset() ? this.hasTilesetContent = !0 : this.gpuMemoryUsageInBytes = this._getGpuMemoryUsageInBytes();
  }
  _updateBoundingVolume(e) {
    this.boundingVolume = Gg(e.boundingVolume, this.computedTransform, this.boundingVolume);
    const i = e.content;
    i && (i.boundingVolume && (this._contentBoundingVolume = Gg(i.boundingVolume, this.computedTransform, this._contentBoundingVolume)), e.viewerRequestVolume && (this._viewerRequestVolume = Gg(e.viewerRequestVolume, this.computedTransform, this._viewerRequestVolume)));
  }
  // Update the tile's transform. The transform is applied to the tile's bounding volumes.
  _updateTransform(e = new Gt()) {
    const i = e.clone().multiplyRight(this.transform);
    i.equals(this.computedTransform) || (this.computedTransform = i, this._updateBoundingVolume(this.header));
  }
  // Get options which are applicable only for the particular loader
  _getLoaderSpecificOptions(e) {
    switch (e) {
      case "i3s":
        return {
          ...this.tileset.options.i3s,
          _tileOptions: {
            attributeUrls: this.header.attributeUrls,
            textureUrl: this.header.textureUrl,
            textureFormat: this.header.textureFormat,
            textureLoaderOptions: this.header.textureLoaderOptions,
            materialDefinition: this.header.materialDefinition,
            isDracoGeometry: this.header.isDracoGeometry,
            mbs: this.header.mbs
          },
          _tilesetOptions: {
            store: this.tileset.tileset.store,
            attributeStorageInfo: this.tileset.tileset.attributeStorageInfo,
            fields: this.tileset.tileset.fields
          },
          isTileHeader: !1
        };
      case "3d-tiles":
      case "cesium-ion":
      default:
        return H5(this.tileset.tileset);
    }
  }
}
class W5 extends jp {
  compareDistanceToCamera(e, i) {
    return i._distanceToCamera === 0 && e._distanceToCamera === 0 ? i._centerZDepth - e._centerZDepth : i._distanceToCamera - e._distanceToCamera;
  }
  updateTileVisibility(e, i) {
    if (super.updateTileVisibility(e, i), !e.isVisibleAndInRequestVolume)
      return;
    const s = e.children.length > 0;
    if (e.hasTilesetContent && s) {
      const d = e.children[0];
      this.updateTileVisibility(d, i), e._visible = d._visible;
      return;
    }
    if (this.meetsScreenSpaceErrorEarly(e, i)) {
      e._visible = !1;
      return;
    }
    const o = e.refine === Fn.REPLACE, u = e._optimChildrenWithinParent === R5.USE_OPTIMIZATION;
    if (o && u && s && !this.anyChildrenVisible(e, i)) {
      e._visible = !1;
      return;
    }
  }
  meetsScreenSpaceErrorEarly(e, i) {
    const { parent: s } = e;
    return !s || s.hasTilesetContent || s.refine !== Fn.ADD ? !1 : !this.shouldRefine(e, i, !0);
  }
}
class X5 {
  frameNumberMap = /* @__PURE__ */ new Map();
  /**
   * Register a new pending tile header for the particular frameNumber
   * @param viewportId
   * @param frameNumber
   */
  register(e, i) {
    const s = this.frameNumberMap.get(e) || /* @__PURE__ */ new Map(), o = s.get(i) || 0;
    s.set(i, o + 1), this.frameNumberMap.set(e, s);
  }
  /**
   * Deregister a pending tile header for the particular frameNumber
   * @param viewportId
   * @param frameNumber
   */
  deregister(e, i) {
    const s = this.frameNumberMap.get(e);
    if (!s)
      return;
    const o = s.get(i) || 1;
    s.set(i, o - 1);
  }
  /**
   * Check is there are no pending tile headers registered for the particular frameNumber
   * @param viewportId
   * @param frameNumber
   * @returns
   */
  isZero(e, i) {
    return (this.frameNumberMap.get(e)?.get(i) || 0) === 0;
  }
}
const qg = {
  REQUESTED: "REQUESTED",
  COMPLETED: "COMPLETED",
  ERROR: "ERROR"
};
class q5 {
  _statusMap;
  pendingTilesRegister = new X5();
  constructor() {
    this._statusMap = {};
  }
  /**
   * Add request to map
   * @param request - node metadata request
   * @param key - unique key
   * @param callback - callback after request completed
   * @param frameState - frameState data
   */
  add(e, i, s, o) {
    if (!this._statusMap[i]) {
      const { frameNumber: u, viewport: { id: d } } = o;
      this._statusMap[i] = { request: e, callback: s, key: i, frameState: o, status: qg.REQUESTED }, this.pendingTilesRegister.register(d, u), e().then((a) => {
        this._statusMap[i].status = qg.COMPLETED;
        const { frameNumber: w, viewport: { id: S } } = this._statusMap[i].frameState;
        this.pendingTilesRegister.deregister(S, w), this._statusMap[i].callback(a, o);
      }).catch((a) => {
        this._statusMap[i].status = qg.ERROR;
        const { frameNumber: w, viewport: { id: S } } = this._statusMap[i].frameState;
        this.pendingTilesRegister.deregister(S, w), s(a);
      });
    }
  }
  /**
   * Update request if it is still actual for the new frameState
   * @param key - unique key
   * @param frameState - frameState data
   */
  update(e, i) {
    if (this._statusMap[e]) {
      const { frameNumber: s, viewport: { id: o } } = this._statusMap[e].frameState;
      this.pendingTilesRegister.deregister(o, s);
      const { frameNumber: u, viewport: { id: d } } = i;
      this.pendingTilesRegister.register(d, u), this._statusMap[e].frameState = i;
    }
  }
  /**
   * Find request in the map
   * @param key - unique key
   * @returns
   */
  find(e) {
    return this._statusMap[e];
  }
  /**
   * Check it there are pending tile headers for the particular frameNumber
   * @param viewportId
   * @param frameNumber
   * @returns
   */
  hasPendingTiles(e, i) {
    return !this.pendingTilesRegister.isZero(e, i);
  }
}
class Z5 extends jp {
  _tileManager;
  constructor(e) {
    super(e), this._tileManager = new q5();
  }
  /**
   * Check if there are no penging tile header requests,
   * that means the traversal is finished and we can call
   * following-up callbacks.
   */
  traversalFinished(e) {
    return !this._tileManager.hasPendingTiles(e.viewport.id, this._frameNumber || 0);
  }
  shouldRefine(e, i) {
    return e._lodJudge = j5(e, i), e._lodJudge === "DIG";
  }
  updateChildTiles(e, i) {
    const s = e.header.children || [], o = e.children, u = e.tileset;
    for (const d of s) {
      const a = `${d.id}-${i.viewport.id}`, w = o && o.find((S) => S.id === a);
      if (w)
        w && this.updateTile(w, i);
      else {
        let S = () => this._loadTile(d.id, u);
        this._tileManager.find(a) ? this._tileManager.update(a, i) : (u.tileset.nodePages && (S = () => u.tileset.nodePagesTile.formTileFromNodePages(d.id)), this._tileManager.add(S, a, (F) => this._onTileLoad(F, e, a), i));
      }
    }
    return !1;
  }
  async _loadTile(e, i) {
    const { loader: s } = i, o = i.getTileUrl(`${i.url}/nodes/${e}`), u = {
      ...i.loadOptions,
      i3s: {
        ...i.loadOptions.i3s,
        isTileHeader: !0
      }
    };
    return await Ea(o, s, u);
  }
  /**
   * The callback to init Tile3D instance after loading the tile JSON
   * @param {Object} header - the tile JSON from a dataset
   * @param {Tile3D} tile - the parent Tile3D instance
   * @param {string} extendedId - optional ID to separate copies of a tile for different viewports.
   *                              const extendedId = `${tile.id}-${frameState.viewport.id}`;
   * @return {void}
   */
  _onTileLoad(e, i, s) {
    const o = new Hm(i.tileset, e, i, s);
    i.children.push(o);
    const u = this._tileManager.find(o.id).frameState;
    this.updateTile(o, u), this._frameNumber === u.frameNumber && (this.traversalFinished(u) || (/* @__PURE__ */ new Date()).getTime() - this.lastUpdate > this.updateDebounceTime) && this.executeTraversal(o, u);
  }
}
const K5 = {
  description: "",
  ellipsoid: yi.WGS84,
  modelMatrix: new Gt(),
  throttleRequests: !0,
  maxRequests: 64,
  /** Default memory values optimized for viewing mesh-based 3D Tiles on both mobile and desktop devices */
  maximumMemoryUsage: 32,
  memoryCacheOverflow: 1,
  maximumTilesSelected: 0,
  debounceTime: 0,
  onTileLoad: () => {
  },
  onTileUnload: () => {
  },
  onTileError: () => {
  },
  onTraversalComplete: (t) => t,
  contentLoader: void 0,
  viewDistanceScale: 1,
  maximumScreenSpaceError: 8,
  memoryAdjustedScreenSpaceError: !1,
  loadTiles: !0,
  updateTransforms: !0,
  viewportTraversersMap: null,
  loadOptions: { fetch: {} },
  attributions: [],
  basePath: "",
  i3s: {}
}, Wf = "Tiles In Tileset(s)", Zg = "Tiles In Memory", A1 = "Tiles In View", E1 = "Tiles To Render", S1 = "Tiles Loaded", Kg = "Tiles Loading", C1 = "Tiles Unloaded", I1 = "Failed Tile Loads", M1 = "Points/Vertices", Yg = "Tile Memory Use", R1 = "Maximum Screen Space Error";
class Y5 {
  // props: Tileset3DProps;
  options;
  loadOptions;
  type;
  tileset;
  loader;
  url;
  basePath;
  modelMatrix;
  ellipsoid;
  lodMetricType;
  lodMetricValue;
  refine;
  root = null;
  roots = {};
  /** @todo any->unknown */
  asset = {};
  // Metadata for the entire tileset
  description = "";
  properties;
  extras = null;
  attributions = {};
  credits = {};
  stats;
  /** flags that contain information about data types in nested tiles */
  contentFormats = { draco: !1, meshopt: !1, dds: !1, ktx2: !1 };
  // view props
  cartographicCenter = null;
  cartesianCenter = null;
  zoom = 1;
  boundingVolume = null;
  /** Updated based on the camera position and direction */
  dynamicScreenSpaceErrorComputedDensity = 0;
  // METRICS
  /**
   * The maximum amount of GPU memory (in MB) that may be used to cache tiles
   * Tiles not in view are unloaded to enforce private
   */
  maximumMemoryUsage = 32;
  /** The total amount of GPU memory in bytes used by the tileset. */
  gpuMemoryUsageInBytes = 0;
  /**
   * If loading the level of detail required by maximumScreenSpaceError
   * results in the memory usage exceeding maximumMemoryUsage (GPU), level of detail refinement
   * will instead use this (larger) adjusted screen space error to achieve the
   * best possible visual quality within the available memory.
   */
  memoryAdjustedScreenSpaceError = 0;
  _cacheBytes = 0;
  _cacheOverflowBytes = 0;
  /** Update tracker. increase in each update cycle. */
  _frameNumber = 0;
  _queryParams = {};
  _extensionsUsed = [];
  _tiles = {};
  /** counter for tracking tiles requests */
  _pendingCount = 0;
  /** Hold traversal results */
  selectedTiles = [];
  // TRAVERSAL
  traverseCounter = 0;
  geometricError = 0;
  lastUpdatedVieports = null;
  _requestedTiles = [];
  _emptyTiles = [];
  frameStateData = {};
  _traverser;
  _cache = new v5();
  _requestScheduler;
  // Promise tracking
  updatePromise = null;
  tilesetInitializationPromise;
  /**
   * Create a new Tileset3D
   * @param json
   * @param props
   */
  // eslint-disable-next-line max-statements
  constructor(e, i) {
    this.options = { ...K5, ...i }, this.tileset = e, this.loader = e.loader, this.type = e.type, this.url = e.url, this.basePath = e.basePath || Ym(this.url), this.modelMatrix = this.options.modelMatrix, this.ellipsoid = this.options.ellipsoid, this.lodMetricType = e.lodMetricType, this.lodMetricValue = e.lodMetricValue, this.refine = e.root.refine, this.loadOptions = this.options.loadOptions || {}, this._traverser = this._initializeTraverser(), this._requestScheduler = new u2({
      throttleRequests: this.options.throttleRequests,
      maxRequests: this.options.maxRequests
    }), this.memoryAdjustedScreenSpaceError = this.options.maximumScreenSpaceError, this._cacheBytes = this.options.maximumMemoryUsage * 1024 * 1024, this._cacheOverflowBytes = this.options.memoryCacheOverflow * 1024 * 1024, this.stats = new _h({ id: this.url }), this._initializeStats(), this.tilesetInitializationPromise = this._initializeTileSet(e);
  }
  /** Release resources */
  destroy() {
    this._destroy();
  }
  /** Is the tileset loaded (update needs to have been called at least once) */
  isLoaded() {
    return this._pendingCount === 0 && this._frameNumber !== 0 && this._requestedTiles.length === 0;
  }
  get tiles() {
    return Object.values(this._tiles);
  }
  get frameNumber() {
    return this._frameNumber;
  }
  get queryParams() {
    return new URLSearchParams(this._queryParams).toString();
  }
  setProps(e) {
    this.options = { ...this.options, ...e };
  }
  /** @deprecated */
  // setOptions(options: Tileset3DProps): void {
  //   this.options = {...this.options, ...options};
  // }
  /**
   * Return a loadable tile url for a specific tile subpath
   * @param tilePath a tile subpath
   */
  getTileUrl(e) {
    if (e.startsWith("data:"))
      return e;
    let s = e;
    return this.queryParams.length && (s = `${e}${e.includes("?") ? "&" : "?"}${this.queryParams}`), s;
  }
  // TODO CESIUM specific
  hasExtension(e) {
    return this._extensionsUsed.indexOf(e) > -1;
  }
  /**
   * Update visible tiles relying on a list of viewports
   * @param viewports - list of viewports
   * @deprecated
   */
  update(e = null) {
    this.tilesetInitializationPromise.then(() => {
      !e && this.lastUpdatedVieports ? e = this.lastUpdatedVieports : this.lastUpdatedVieports = e, e && this.doUpdate(e);
    });
  }
  /**
   * Update visible tiles relying on a list of viewports.
   * Do it with debounce delay to prevent update spam
   * @param viewports viewports
   * @returns Promise of new frameNumber
   */
  async selectTiles(e = null) {
    return await this.tilesetInitializationPromise, e && (this.lastUpdatedVieports = e), this.updatePromise || (this.updatePromise = new Promise((i) => {
      setTimeout(() => {
        this.lastUpdatedVieports && this.doUpdate(this.lastUpdatedVieports), i(this._frameNumber), this.updatePromise = null;
      }, this.options.debounceTime);
    })), this.updatePromise;
  }
  adjustScreenSpaceError() {
    this.gpuMemoryUsageInBytes < this._cacheBytes ? this.memoryAdjustedScreenSpaceError = Math.max(this.memoryAdjustedScreenSpaceError / 1.02, this.options.maximumScreenSpaceError) : this.gpuMemoryUsageInBytes > this._cacheBytes + this._cacheOverflowBytes && (this.memoryAdjustedScreenSpaceError *= 1.02);
  }
  /**
   * Update visible tiles relying on a list of viewports
   * @param viewports viewports
   */
  // eslint-disable-next-line max-statements, complexity
  doUpdate(e) {
    if ("loadTiles" in this.options && !this.options.loadTiles || this.traverseCounter > 0)
      return;
    const i = e instanceof Array ? e : [e];
    this._cache.reset(), this._frameNumber++, this.traverseCounter = i.length;
    const s = [];
    for (const o of i) {
      const u = o.id;
      this._needTraverse(u) ? s.push(u) : this.traverseCounter--;
    }
    for (const o of i) {
      const u = o.id;
      if (this.roots[u] || (this.roots[u] = this._initializeTileHeaders(this.tileset, null)), !s.includes(u))
        continue;
      const d = w5(o, this._frameNumber);
      this._traverser.traverse(this.roots[u], d, this.options);
    }
  }
  /**
   * Check if traversal is needed for particular viewport
   * @param {string} viewportId - id of a viewport
   * @return {boolean}
   */
  _needTraverse(e) {
    let i = e;
    return this.options.viewportTraversersMap && (i = this.options.viewportTraversersMap[e]), i === e;
  }
  /**
   * The callback to post-process tiles after traversal procedure
   * @param frameState - frame state for tile culling
   */
  _onTraversalEnd(e) {
    const i = e.viewport.id;
    this.frameStateData[i] || (this.frameStateData[i] = { selectedTiles: [], _requestedTiles: [], _emptyTiles: [] });
    const s = this.frameStateData[i], o = Object.values(this._traverser.selectedTiles), [u, d] = T5(o, e, this.options.maximumTilesSelected);
    s.selectedTiles = u;
    for (const a of d)
      a.unselect();
    s._requestedTiles = Object.values(this._traverser.requestedTiles), s._emptyTiles = Object.values(this._traverser.emptyTiles), this.traverseCounter--, !(this.traverseCounter > 0) && this._updateTiles();
  }
  /**
   * Update tiles relying on data from all traversers
   */
  _updateTiles() {
    this.selectedTiles = [], this._requestedTiles = [], this._emptyTiles = [];
    for (const e in this.frameStateData) {
      const i = this.frameStateData[e];
      this.selectedTiles = this.selectedTiles.concat(i.selectedTiles), this._requestedTiles = this._requestedTiles.concat(i._requestedTiles), this._emptyTiles = this._emptyTiles.concat(i._emptyTiles);
    }
    this.selectedTiles = this.options.onTraversalComplete(this.selectedTiles);
    for (const e of this.selectedTiles)
      this._tiles[e.id] = e;
    this._loadTiles(), this._unloadTiles(), this._updateStats();
  }
  _tilesChanged(e, i) {
    if (e.length !== i.length)
      return !0;
    const s = new Set(e.map((d) => d.id)), o = new Set(i.map((d) => d.id));
    let u = e.filter((d) => !o.has(d.id)).length > 0;
    return u = u || i.filter((d) => !s.has(d.id)).length > 0, u;
  }
  _loadTiles() {
    for (const e of this._requestedTiles)
      e.contentUnloaded && this._loadTile(e);
  }
  _unloadTiles() {
    this._cache.unloadTiles(this, (e, i) => e._unloadTile(i));
  }
  _updateStats() {
    let e = 0, i = 0;
    for (const s of this.selectedTiles)
      s.contentAvailable && s.content && (e++, s.content.pointCount ? i += s.content.pointCount : i += s.content.vertexCount);
    this.stats.get(A1).count = this.selectedTiles.length, this.stats.get(E1).count = e, this.stats.get(M1).count = i, this.stats.get(R1).count = this.memoryAdjustedScreenSpaceError;
  }
  async _initializeTileSet(e) {
    this.type === bs.I3S && (this.calculateViewPropsI3S(), e.root = await e.root), this.root = this._initializeTileHeaders(e, null), this.type === bs.TILES3D && (this._initializeTiles3DTileset(e), this.calculateViewPropsTiles3D()), this.type === bs.I3S && this._initializeI3STileset();
  }
  /**
   * Called during initialize Tileset to initialize the tileset's cartographic center (longitude, latitude) and zoom.
   * These metrics help apps center view on tileset
   * For I3S there is extent (<1.8 version) or fullExtent (>=1.8 version) to calculate view props
   * @returns
   */
  calculateViewPropsI3S() {
    const e = this.tileset.fullExtent;
    if (e) {
      const { xmin: s, xmax: o, ymin: u, ymax: d, zmin: a, zmax: w } = e;
      this.cartographicCenter = new Be(s + (o - s) / 2, u + (d - u) / 2, a + (w - a) / 2), this.cartesianCenter = new Be(), yi.WGS84.cartographicToCartesian(this.cartographicCenter, this.cartesianCenter), this.zoom = LA(e, this.cartographicCenter, this.cartesianCenter);
      return;
    }
    const i = this.tileset.store?.extent;
    if (i) {
      const [s, o, u, d] = i;
      this.cartographicCenter = new Be(s + (u - s) / 2, o + (d - o) / 2, 0), this.cartesianCenter = new Be(), yi.WGS84.cartographicToCartesian(this.cartographicCenter, this.cartesianCenter), this.zoom = I5(i, this.cartographicCenter, this.cartesianCenter);
      return;
    }
    console.warn("Extent is not defined in the tileset header"), this.cartographicCenter = new Be(), this.zoom = 1;
  }
  /**
   * Called during initialize Tileset to initialize the tileset's cartographic center (longitude, latitude) and zoom.
   * These metrics help apps center view on tileset.
   * For 3DTiles the root tile data is used to calculate view props.
   * @returns
   */
  calculateViewPropsTiles3D() {
    const e = this.root, { center: i } = e.boundingVolume;
    if (!i) {
      console.warn("center was not pre-calculated for the root tile"), this.cartographicCenter = new Be(), this.zoom = 1;
      return;
    }
    i[0] !== 0 || i[1] !== 0 || i[2] !== 0 ? (this.cartographicCenter = new Be(), yi.WGS84.cartesianToCartographic(i, this.cartographicCenter)) : this.cartographicCenter = new Be(0, 0, -yi.WGS84.radii[0]), this.cartesianCenter = i, this.zoom = C5(e.boundingVolume, this.cartographicCenter);
  }
  _initializeStats() {
    this.stats.get(Wf), this.stats.get(Kg), this.stats.get(Zg), this.stats.get(A1), this.stats.get(E1), this.stats.get(S1), this.stats.get(C1), this.stats.get(I1), this.stats.get(M1), this.stats.get(Yg, "memory"), this.stats.get(R1);
  }
  // Installs the main tileset JSON file or a tileset JSON file referenced from a tile.
  // eslint-disable-next-line max-statements
  _initializeTileHeaders(e, i) {
    const s = new Hm(this, e.root, i);
    if (i && (i.children.push(s), s.depth = i.depth + 1), this.type === bs.TILES3D) {
      const o = [];
      for (o.push(s); o.length > 0; ) {
        const u = o.pop();
        this.stats.get(Wf).incrementCount();
        const d = u.header.children || [];
        for (const a of d) {
          const w = new Hm(this, a, u);
          if (w.contentUrl?.includes("?session=")) {
            const M = new URL(w.contentUrl).searchParams.get("session");
            M && (this._queryParams.session = M);
          }
          u.children.push(w), w.depth = u.depth + 1, o.push(w);
        }
      }
    }
    return s;
  }
  _initializeTraverser() {
    let e;
    switch (this.type) {
      case bs.TILES3D:
        e = W5;
        break;
      case bs.I3S:
        e = Z5;
        break;
      default:
        e = jp;
    }
    return new e({
      basePath: this.basePath,
      onTraversalEnd: this._onTraversalEnd.bind(this)
    });
  }
  _destroyTileHeaders(e) {
    this._destroySubtree(e);
  }
  async _loadTile(e) {
    let i;
    try {
      this._onStartTileLoading(), i = await e.loadContent();
    } catch (s) {
      this._onTileLoadError(e, s instanceof Error ? s : new Error("load failed"));
    } finally {
      this._onEndTileLoading(), this._onTileLoad(e, i);
    }
  }
  _onTileLoadError(e, i) {
    this.stats.get(I1).incrementCount();
    const s = i.message || i.toString(), o = e.url;
    console.error(`A 3D tile failed to load: ${e.url} ${s}`), this.options.onTileError(e, s, o);
  }
  _onTileLoad(e, i) {
    if (i) {
      if (this.type === bs.I3S) {
        const s = this.tileset?.nodePagesTile?.nodesInNodePages || 0;
        this.stats.get(Wf).reset(), this.stats.get(Wf).addCount(s);
      }
      e && e.content && x5(e, e.content), this.updateContentTypes(e), this._addTileToCache(e), this.options.onTileLoad(e);
    }
  }
  /**
   * Update information about data types in nested tiles
   * @param tile instance of a nested Tile3D
   */
  updateContentTypes(e) {
    if (this.type === bs.I3S)
      switch (e.header.isDracoGeometry && (this.contentFormats.draco = !0), e.header.textureFormat) {
        case "dds":
          this.contentFormats.dds = !0;
          break;
        case "ktx2":
          this.contentFormats.ktx2 = !0;
          break;
      }
    else if (this.type === bs.TILES3D) {
      const { extensionsRemoved: i = [] } = e.content?.gltf || {};
      i.includes("KHR_draco_mesh_compression") && (this.contentFormats.draco = !0), i.includes("EXT_meshopt_compression") && (this.contentFormats.meshopt = !0), i.includes("KHR_texture_basisu") && (this.contentFormats.ktx2 = !0);
    }
  }
  _onStartTileLoading() {
    this._pendingCount++, this.stats.get(Kg).incrementCount();
  }
  _onEndTileLoading() {
    this._pendingCount--, this.stats.get(Kg).decrementCount();
  }
  _addTileToCache(e) {
    this._cache.add(this, e, (i) => i._updateCacheStats(e));
  }
  _updateCacheStats(e) {
    this.stats.get(S1).incrementCount(), this.stats.get(Zg).incrementCount(), this.gpuMemoryUsageInBytes += e.gpuMemoryUsageInBytes || 0, this.stats.get(Yg).count = this.gpuMemoryUsageInBytes, this.options.memoryAdjustedScreenSpaceError && this.adjustScreenSpaceError();
  }
  _unloadTile(e) {
    this.gpuMemoryUsageInBytes -= e.gpuMemoryUsageInBytes || 0, this.stats.get(Zg).decrementCount(), this.stats.get(C1).incrementCount(), this.stats.get(Yg).count = this.gpuMemoryUsageInBytes, this.options.onTileUnload(e), e.unloadContent();
  }
  // Traverse the tree and destroy all tiles
  _destroy() {
    const e = [];
    for (this.root && e.push(this.root); e.length > 0; ) {
      const i = e.pop();
      for (const s of i.children)
        e.push(s);
      this._destroyTile(i);
    }
    this.root = null;
  }
  // Traverse the tree and destroy all sub tiles
  _destroySubtree(e) {
    const i = e, s = [];
    for (s.push(i); s.length > 0; ) {
      e = s.pop();
      for (const o of e.children)
        s.push(o);
      e !== i && this._destroyTile(e);
    }
    i.children = [];
  }
  _destroyTile(e) {
    this._cache.unloadTile(this, e), this._unloadTile(e), e.destroy();
  }
  _initializeTiles3DTileset(e) {
    if (e.queryString) {
      const i = new URLSearchParams(e.queryString), s = Object.fromEntries(i.entries());
      this._queryParams = { ...this._queryParams, ...s };
    }
    if (this.asset = e.asset, !this.asset)
      throw new Error("Tileset must have an asset property.");
    if (this.asset.version !== "0.0" && this.asset.version !== "1.0" && this.asset.version !== "1.1")
      throw new Error("The tileset must be 3D Tiles version either 0.0 or 1.0 or 1.1.");
    "tilesetVersion" in this.asset && (this._queryParams.v = this.asset.tilesetVersion), this.credits = {
      attributions: this.options.attributions || []
    }, this.description = this.options.description || "", this.properties = e.properties, this.geometricError = e.geometricError, this._extensionsUsed = e.extensionsUsed || [], this.extras = e.extras;
  }
  _initializeI3STileset() {
    this.loadOptions.i3s && "token" in this.loadOptions.i3s && (this._queryParams.token = this.loadOptions.i3s.token);
  }
}
const $A = "4.3.1", Pu = {
  COMPOSITE: "cmpt",
  POINT_CLOUD: "pnts",
  BATCHED_3D_MODEL: "b3dm",
  INSTANCED_3D_MODEL: "i3dm",
  GLTF: "glTF"
};
function GA(t, e, i) {
  mi(t instanceof ArrayBuffer);
  const s = new TextDecoder("utf8"), o = new Uint8Array(t, e, i);
  return s.decode(o);
}
function J5(t, e = 0) {
  const i = new DataView(t);
  return `${String.fromCharCode(i.getUint8(e + 0))}${String.fromCharCode(i.getUint8(e + 1))}${String.fromCharCode(i.getUint8(e + 2))}${String.fromCharCode(i.getUint8(e + 3))}`;
}
const Q5 = {
  POINTS: 0,
  // Points. single points.
  LINES: 1,
  // Lines. Each vertex connects to the one after it.
  LINE_LOOP: 2,
  // Lines. Each set of two vertices is treated as a separate line segment.
  LINE_STRIP: 3,
  // Lines/ a connected group of line segments from the first vertex to the last
  TRIANGLES: 4,
  // Triangles. Each set of three vertices creates a separate triangle.
  TRIANGLE_STRIP: 5,
  // Triangles. A connected group of triangles.
  TRIANGLE_FAN: 6
  // Triangles. A connected group of triangles.
  // Each vertex connects to the previous and the first vertex in the fan.
}, _r = {
  BYTE: 5120,
  UNSIGNED_BYTE: 5121,
  SHORT: 5122,
  UNSIGNED_SHORT: 5123,
  INT: 5124,
  UNSIGNED_INT: 5125,
  FLOAT: 5126,
  DOUBLE: 5130
}, Zt = {
  ...Q5,
  ..._r
}, Jg = {
  [_r.DOUBLE]: Float64Array,
  [_r.FLOAT]: Float32Array,
  [_r.UNSIGNED_SHORT]: Uint16Array,
  [_r.UNSIGNED_INT]: Uint32Array,
  [_r.UNSIGNED_BYTE]: Uint8Array,
  [_r.BYTE]: Int8Array,
  [_r.SHORT]: Int16Array,
  [_r.INT]: Int32Array
}, e8 = {
  DOUBLE: _r.DOUBLE,
  FLOAT: _r.FLOAT,
  UNSIGNED_SHORT: _r.UNSIGNED_SHORT,
  UNSIGNED_INT: _r.UNSIGNED_INT,
  UNSIGNED_BYTE: _r.UNSIGNED_BYTE,
  BYTE: _r.BYTE,
  SHORT: _r.SHORT,
  INT: _r.INT
}, Qg = "Failed to convert GL type";
class lo {
  // Signature: fromTypedArray(new Uint8Array())
  // Signature: fromTypedArray(Uint8Array)
  /**
   * Returns the size, in bytes, of the corresponding datatype
   * @param arrayOrType
   * @returns glType a a string
   */
  static fromTypedArray(e) {
    e = ArrayBuffer.isView(e) ? e.constructor : e;
    for (const i in Jg)
      if (Jg[i] === e)
        return i;
    throw new Error(Qg);
  }
  /**
   * Extracts name for glType from array NAME_TO_GL_TYPE
   * @param name
   * @returns glType as a number
   */
  static fromName(e) {
    const i = e8[e];
    if (!i)
      throw new Error(Qg);
    return i;
  }
  // Converts GL constant to corresponding typed array type
  // eslint-disable-next-line complexity
  static getArrayType(e) {
    switch (e) {
      /*eslint-disable*/
      // @ts-ignore
      case _r.UNSIGNED_SHORT_5_6_5:
      // @ts-ignore
      case _r.UNSIGNED_SHORT_4_4_4_4:
      // @ts-ignore
      case _r.UNSIGNED_SHORT_5_5_5_1:
        return Uint16Array;
      default:
        const i = Jg[e];
        if (!i)
          throw new Error(Qg);
        return i;
    }
  }
  /**
   * Returns the size in bytes of one element of the provided WebGL type
   * @param glType
   * @returns size of glType
   */
  static getByteSize(e) {
    return lo.getArrayType(e).BYTES_PER_ELEMENT;
  }
  /**
   * Returns `true` if `glType` is a valid WebGL data type.
   * @param glType
   * @returns boolean
   */
  static validate(e) {
    return !!lo.getArrayType(e);
  }
  /**
   * Creates a typed view of an array of bytes
   * @param glType The type of typed array (ArrayBuffer view) to create
   * @param buffer The buffer storage to use for the view.
   * @param byteOffset The offset, in bytes, to the first element in the view
   * @param length The number of elements in the view. Defaults to buffer length
   * @returns A typed array view of the buffer
   */
  static createTypedArray(e, i, s = 0, o) {
    o === void 0 && (o = (i.byteLength - s) / lo.getByteSize(e));
    const u = lo.getArrayType(e);
    return new u(i, s, o);
  }
}
function t8(t, e) {
  if (!t)
    throw new Error(`math.gl assertion failed. ${e}`);
}
function i8(t, e = [0, 0, 0]) {
  const i = t >> 11 & 31, s = t >> 5 & 63, o = t & 31;
  return e[0] = i << 3, e[1] = s << 2, e[2] = o << 3, e;
}
new gy();
new Be();
new gy();
new gy();
function P1(t, e = 255) {
  return Do(t, 0, e) / e * 2 - 1;
}
function B1(t) {
  return t < 0 ? -1 : 1;
}
function r8(t, e, i, s) {
  if (t8(s), t < 0 || t > i || e < 0 || e > i)
    throw new Error(`x and y must be unsigned normalized integers between 0 and ${i}`);
  if (s.x = P1(t, i), s.y = P1(e, i), s.z = 1 - (Math.abs(s.x) + Math.abs(s.y)), s.z < 0) {
    const o = s.x;
    s.x = (1 - Math.abs(s.y)) * B1(o), s.y = (1 - Math.abs(o)) * B1(s.y);
  }
  return s.normalize();
}
function s8(t, e, i) {
  return r8(t, e, 255, i);
}
class qy {
  json;
  buffer;
  featuresLength = 0;
  _cachedTypedArrays = {};
  constructor(e, i) {
    this.json = e, this.buffer = i;
  }
  getExtension(e) {
    return this.json.extensions && this.json.extensions[e];
  }
  hasProperty(e) {
    return !!this.json[e];
  }
  getGlobalProperty(e, i = Zt.UNSIGNED_INT, s = 1) {
    const o = this.json[e];
    return o && Number.isFinite(o.byteOffset) ? this._getTypedArrayFromBinary(e, i, s, 1, o.byteOffset) : o;
  }
  getPropertyArray(e, i, s) {
    const o = this.json[e];
    return o && Number.isFinite(o.byteOffset) ? ("componentType" in o && (i = lo.fromName(o.componentType)), this._getTypedArrayFromBinary(e, i, s, this.featuresLength, o.byteOffset)) : this._getTypedArrayFromArray(e, i, o);
  }
  getProperty(e, i, s, o, u) {
    const d = this.json[e];
    if (!d)
      return d;
    const a = this.getPropertyArray(e, i, s);
    if (s === 1)
      return a[o];
    for (let w = 0; w < s; ++w)
      u[w] = a[s * o + w];
    return u;
  }
  // HELPERS
  _getTypedArrayFromBinary(e, i, s, o, u) {
    const d = this._cachedTypedArrays;
    let a = d[e];
    return a || (a = lo.createTypedArray(i, this.buffer.buffer, this.buffer.byteOffset + u, o * s), d[e] = a), a;
  }
  _getTypedArrayFromArray(e, i, s) {
    const o = this._cachedTypedArrays;
    let u = o[e];
    return u || (u = lo.createTypedArray(i, s), o[e] = u), u;
  }
}
const n8 = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, o8 = {
  SCALAR: (t, e) => t[e],
  VEC2: (t, e) => [t[2 * e + 0], t[2 * e + 1]],
  VEC3: (t, e) => [t[3 * e + 0], t[3 * e + 1], t[3 * e + 2]],
  VEC4: (t, e) => [t[4 * e + 0], t[4 * e + 1], t[4 * e + 2], t[4 * e + 3]],
  // TODO: check column major
  MAT2: (t, e) => [
    t[4 * e + 0],
    t[4 * e + 1],
    t[4 * e + 2],
    t[4 * e + 3]
  ],
  MAT3: (t, e) => [
    t[9 * e + 0],
    t[9 * e + 1],
    t[9 * e + 2],
    t[9 * e + 3],
    t[9 * e + 4],
    t[9 * e + 5],
    t[9 * e + 6],
    t[9 * e + 7],
    t[9 * e + 8]
  ],
  MAT4: (t, e) => [
    t[16 * e + 0],
    t[16 * e + 1],
    t[16 * e + 2],
    t[16 * e + 3],
    t[16 * e + 4],
    t[16 * e + 5],
    t[16 * e + 6],
    t[16 * e + 7],
    t[16 * e + 8],
    t[16 * e + 9],
    t[16 * e + 10],
    t[16 * e + 11],
    t[16 * e + 12],
    t[16 * e + 13],
    t[16 * e + 14],
    t[16 * e + 15]
  ]
}, a8 = {
  SCALAR: (t, e, i) => {
    e[i] = t;
  },
  VEC2: (t, e, i) => {
    e[2 * i + 0] = t[0], e[2 * i + 1] = t[1];
  },
  VEC3: (t, e, i) => {
    e[3 * i + 0] = t[0], e[3 * i + 1] = t[1], e[3 * i + 2] = t[2];
  },
  VEC4: (t, e, i) => {
    e[4 * i + 0] = t[0], e[4 * i + 1] = t[1], e[4 * i + 2] = t[2], e[4 * i + 3] = t[3];
  },
  // TODO: check column major correctness
  MAT2: (t, e, i) => {
    e[4 * i + 0] = t[0], e[4 * i + 1] = t[1], e[4 * i + 2] = t[2], e[4 * i + 3] = t[3];
  },
  MAT3: (t, e, i) => {
    e[9 * i + 0] = t[0], e[9 * i + 1] = t[1], e[9 * i + 2] = t[2], e[9 * i + 3] = t[3], e[9 * i + 4] = t[4], e[9 * i + 5] = t[5], e[9 * i + 6] = t[6], e[9 * i + 7] = t[7], e[9 * i + 8] = t[8], e[9 * i + 9] = t[9];
  },
  MAT4: (t, e, i) => {
    e[16 * i + 0] = t[0], e[16 * i + 1] = t[1], e[16 * i + 2] = t[2], e[16 * i + 3] = t[3], e[16 * i + 4] = t[4], e[16 * i + 5] = t[5], e[16 * i + 6] = t[6], e[16 * i + 7] = t[7], e[16 * i + 8] = t[8], e[16 * i + 9] = t[9], e[16 * i + 10] = t[10], e[16 * i + 11] = t[11], e[16 * i + 12] = t[12], e[16 * i + 13] = t[13], e[16 * i + 14] = t[14], e[16 * i + 15] = t[15];
  }
};
function l8(t, e, i, s) {
  const { componentType: o } = t;
  mi(t.componentType);
  const u = typeof o == "string" ? lo.fromName(o) : o, d = n8[t.type], a = o8[t.type], w = a8[t.type];
  return i += t.byteOffset, {
    values: lo.createTypedArray(u, e, i, d * s),
    type: u,
    size: d,
    unpacker: a,
    packer: w
  };
}
const oo = (t) => t !== void 0;
function c8(t, e, i) {
  if (!e)
    return null;
  let s = t.getExtension("3DTILES_batch_table_hierarchy");
  const o = e.HIERARCHY;
  return o && (console.warn("3D Tile Parser: HIERARCHY is deprecated. Use 3DTILES_batch_table_hierarchy."), e.extensions = e.extensions || {}, e.extensions["3DTILES_batch_table_hierarchy"] = o, s = o), s ? h8(s, i) : null;
}
function h8(t, e) {
  let i, s, o;
  const u = t.instancesLength, d = t.classes;
  let a = t.classIds, w = t.parentCounts, S = t.parentIds, M = u;
  oo(a.byteOffset) && (a.componentType = defaultValue(a.componentType, GL.UNSIGNED_SHORT), a.type = AttributeType.SCALAR, o = getBinaryAccessor(a), a = o.createArrayBufferView(e.buffer, e.byteOffset + a.byteOffset, u));
  let F;
  if (oo(w))
    for (oo(w.byteOffset) && (w.componentType = defaultValue(w.componentType, GL.UNSIGNED_SHORT), w.type = AttributeType.SCALAR, o = getBinaryAccessor(w), w = o.createArrayBufferView(e.buffer, e.byteOffset + w.byteOffset, u)), F = new Uint16Array(u), M = 0, i = 0; i < u; ++i)
      F[i] = M, M += w[i];
  oo(S) && oo(S.byteOffset) && (S.componentType = defaultValue(S.componentType, GL.UNSIGNED_SHORT), S.type = AttributeType.SCALAR, o = getBinaryAccessor(S), S = o.createArrayBufferView(e.buffer, e.byteOffset + S.byteOffset, M));
  const N = d.length;
  for (i = 0; i < N; ++i) {
    const we = d[i].length, Se = d[i].instances, Ee = getBinaryProperties(we, Se, e);
    d[i].instances = combine(Ee, Se);
  }
  const L = new Array(N).fill(0), re = new Uint16Array(u);
  for (i = 0; i < u; ++i)
    s = a[i], re[i] = L[s], ++L[s];
  const ne = {
    classes: d,
    classIds: a,
    classIndexes: re,
    parentCounts: w,
    parentIndexes: F,
    parentIds: S
  };
  return f8(ne), ne;
}
function Bu(t, e, i) {
  if (!t)
    return;
  const s = t.parentCounts;
  return t.parentIds ? i(t, e) : s > 0 ? u8(t, e, i) : d8(t, e, i);
}
function u8(t, e, i) {
  const s = t.classIds, o = t.parentCounts, u = t.parentIds, d = t.parentIndexes, a = s.length, w = scratchVisited;
  w.length = Math.max(w.length, a);
  const S = ++marker, M = scratchStack;
  for (M.length = 0, M.push(e); M.length > 0; ) {
    if (e = M.pop(), w[e] === S)
      continue;
    w[e] = S;
    const F = i(t, e);
    if (oo(F))
      return F;
    const N = o[e], L = d[e];
    for (let re = 0; re < N; ++re) {
      const ne = u[L + re];
      ne !== e && M.push(ne);
    }
  }
  return null;
}
function d8(t, e, i) {
  let s = !0;
  for (; s; ) {
    const o = i(t, e);
    if (oo(o))
      return o;
    const u = t.parentIds[e];
    s = u !== e, e = u;
  }
  throw new Error("traverseHierarchySingleParent");
}
function f8(t) {
  const i = t.classIds.length;
  for (let s = 0; s < i; ++s)
    WA(t, s, stack);
}
function WA(t, e, i) {
  const s = t.parentCounts, o = t.parentIds, u = t.parentIndexes, a = t.classIds.length;
  if (!oo(o))
    return;
  assert(e < a, `Parent index ${e} exceeds the total number of instances: ${a}`), assert(i.indexOf(e) === -1, "Circular dependency detected in the batch table hierarchy."), i.push(e);
  const w = oo(s) ? s[e] : 1, S = oo(s) ? u[e] : e;
  for (let M = 0; M < w; ++M) {
    const F = o[S + M];
    F !== e && WA(t, F, i);
  }
  i.pop(e);
}
function ys(t) {
  return t != null;
}
const Xf = (t, e) => t, p8 = {
  HIERARCHY: !0,
  // Deprecated HIERARCHY property
  extensions: !0,
  extras: !0
};
class XA {
  json;
  binary;
  featureCount;
  _extensions;
  // Copy all top-level property fields from the json object, ignoring special fields
  _properties;
  _binaryProperties;
  // TODO: hierarchy support is only partially implemented and not tested
  _hierarchy;
  constructor(e, i, s, o = {}) {
    mi(s >= 0), this.json = e || {}, this.binary = i, this.featureCount = s, this._extensions = this.json?.extensions || {}, this._properties = {};
    for (const u in this.json)
      p8[u] || (this._properties[u] = this.json[u]);
    this._binaryProperties = this._initializeBinaryProperties(), o["3DTILES_batch_table_hierarchy"] && (this._hierarchy = c8(this, this.json, this.binary));
  }
  getExtension(e) {
    return this.json && this.json.extensions && this.json.extensions[e];
  }
  memorySizeInBytes() {
    return 0;
  }
  isClass(e, i) {
    if (this._checkBatchId(e), mi(typeof i == "string", i), this._hierarchy) {
      const s = Bu(this._hierarchy, e, (o, u) => {
        const d = o.classIds[u];
        return o.classes[d].name === i;
      });
      return ys(s);
    }
    return !1;
  }
  isExactClass(e, i) {
    return mi(typeof i == "string", i), this.getExactClassName(e) === i;
  }
  getExactClassName(e) {
    if (this._checkBatchId(e), this._hierarchy) {
      const i = this._hierarchy.classIds[e];
      return this._hierarchy.classes[i].name;
    }
  }
  hasProperty(e, i) {
    return this._checkBatchId(e), mi(typeof i == "string", i), ys(this._properties[i]) || this._hasPropertyInHierarchy(e, i);
  }
  getPropertyNames(e, i) {
    this._checkBatchId(e), i = ys(i) ? i : [], i.length = 0;
    const s = Object.keys(this._properties);
    return i.push(...s), this._hierarchy && this._getPropertyNamesInHierarchy(e, i), i;
  }
  getProperty(e, i) {
    if (this._checkBatchId(e), mi(typeof i == "string", i), this._binaryProperties) {
      const o = this._binaryProperties[i];
      if (ys(o))
        return this._getBinaryProperty(o, e);
    }
    const s = this._properties[i];
    if (ys(s))
      return Xf(s[e]);
    if (this._hierarchy) {
      const o = this._getHierarchyProperty(e, i);
      if (ys(o))
        return o;
    }
  }
  setProperty(e, i, s) {
    const o = this.featureCount;
    if (this._checkBatchId(e), mi(typeof i == "string", i), this._binaryProperties) {
      const d = this._binaryProperties[i];
      if (d) {
        this._setBinaryProperty(d, e, s);
        return;
      }
    }
    if (this._hierarchy && this._setHierarchyProperty(this, e, i, s))
      return;
    let u = this._properties[i];
    ys(u) || (this._properties[i] = new Array(o), u = this._properties[i]), u[e] = Xf(s);
  }
  // PRIVATE METHODS
  _checkBatchId(e) {
    if (!(e >= 0 && e < this.featureCount))
      throw new Error("batchId not in range [0, featureCount - 1].");
  }
  _getBinaryProperty(e, i) {
    return e.unpack(e.typedArray, i);
  }
  _setBinaryProperty(e, i, s) {
    e.pack(s, e.typedArray, i);
  }
  _initializeBinaryProperties() {
    let e = null;
    for (const i in this._properties) {
      const s = this._properties[i], o = this._initializeBinaryProperty(i, s);
      o && (e = e || {}, e[i] = o);
    }
    return e;
  }
  _initializeBinaryProperty(e, i) {
    if ("byteOffset" in i) {
      const s = i;
      mi(this.binary, `Property ${e} requires a batch table binary.`), mi(s.type, `Property ${e} requires a type.`);
      const o = l8(s, this.binary.buffer, this.binary.byteOffset | 0, this.featureCount);
      return {
        typedArray: o.values,
        componentCount: o.size,
        unpack: o.unpacker,
        pack: o.packer
      };
    }
    return null;
  }
  //  EXTENSION SUPPORT: 3DTILES_batch_table_hierarchy
  _hasPropertyInHierarchy(e, i) {
    if (!this._hierarchy)
      return !1;
    const s = Bu(this._hierarchy, e, (o, u) => {
      const d = o.classIds[u], a = o.classes[d].instances;
      return ys(a[i]);
    });
    return ys(s);
  }
  _getPropertyNamesInHierarchy(e, i) {
    Bu(this._hierarchy, e, (s, o) => {
      const u = s.classIds[o], d = s.classes[u].instances;
      for (const a in d)
        d.hasOwnProperty(a) && i.indexOf(a) === -1 && i.push(a);
    });
  }
  _getHierarchyProperty(e, i) {
    return Bu(this._hierarchy, e, (s, o) => {
      const u = s.classIds[o], d = s.classes[u], a = s.classIndexes[o], w = d.instances[i];
      return ys(w) ? ys(w.typedArray) ? this._getBinaryProperty(w, a) : Xf(w[a]) : null;
    });
  }
  _setHierarchyProperty(e, i, s, o) {
    const u = Bu(this._hierarchy, i, (d, a) => {
      const w = d.classIds[a], S = d.classes[w], M = d.classIndexes[a], F = S.instances[s];
      return ys(F) ? (mi(a === i, `Inherited property "${s}" is read-only.`), ys(F.typedArray) ? this._setBinaryProperty(F, M, o) : F[M] = Xf(o), !0) : !1;
    });
    return ys(u);
  }
}
const em = 4;
function Hp(t, e, i = 0) {
  const s = new DataView(e);
  if (t.magic = s.getUint32(i, !0), i += em, t.version = s.getUint32(i, !0), i += em, t.byteLength = s.getUint32(i, !0), i += em, t.version !== 1)
    throw new Error(`3D Tile Version ${t.version} not supported`);
  return i;
}
const zc = 4, D1 = "b3dm tile in legacy format.";
function Zy(t, e, i) {
  const s = new DataView(e);
  let o;
  t.header = t.header || {};
  let u = s.getUint32(i, !0);
  i += zc;
  let d = s.getUint32(i, !0);
  i += zc;
  let a = s.getUint32(i, !0);
  i += zc;
  let w = s.getUint32(i, !0);
  return i += zc, a >= 570425344 ? (i -= zc * 2, o = u, a = d, w = 0, u = 0, d = 0, console.warn(D1)) : w >= 570425344 && (i -= zc, o = a, a = u, w = d, u = 0, d = 0, console.warn(D1)), t.header.featureTableJsonByteLength = u, t.header.featureTableBinaryByteLength = d, t.header.batchTableJsonByteLength = a, t.header.batchTableBinaryByteLength = w, t.header.batchLength = o, i;
}
function Ky(t, e, i, s) {
  return i = _8(t, e, i), i = g8(t, e, i), i;
}
function _8(t, e, i, s) {
  const { featureTableJsonByteLength: o, featureTableBinaryByteLength: u, batchLength: d } = t.header || {};
  if (t.featureTableJson = {
    BATCH_LENGTH: d || 0
  }, o && o > 0) {
    const a = GA(e, i, o);
    t.featureTableJson = JSON.parse(a);
  }
  return i += o || 0, t.featureTableBinary = new Uint8Array(e, i, u), i += u || 0, i;
}
function g8(t, e, i, s) {
  const { batchTableJsonByteLength: o, batchTableBinaryByteLength: u } = t.header || {};
  if (o && o > 0) {
    const d = GA(e, i, o);
    t.batchTableJson = JSON.parse(d), i += o, u && u > 0 && (t.batchTableBinary = new Uint8Array(e, i, u), t.batchTableBinary = new Uint8Array(t.batchTableBinary), i += u);
  }
  return i;
}
function qA(t, e, i) {
  if (!e && (!t || !t.batchIds || !i))
    return null;
  const { batchIds: s, isRGB565: o, pointCount: u = 0 } = t;
  if (s && i) {
    const d = new Uint8ClampedArray(u * 3);
    for (let a = 0; a < u; a++) {
      const w = s[a], M = i.getProperty(w, "dimensions").map((F) => F * 255);
      d[a * 3] = M[0], d[a * 3 + 1] = M[1], d[a * 3 + 2] = M[2];
    }
    return {
      type: Zt.UNSIGNED_BYTE,
      value: d,
      size: 3,
      normalized: !0
    };
  }
  if (e && o) {
    const d = new Uint8ClampedArray(u * 3);
    for (let a = 0; a < u; a++) {
      const w = i8(e[a]);
      d[a * 3] = w[0], d[a * 3 + 1] = w[1], d[a * 3 + 2] = w[2];
    }
    return {
      type: Zt.UNSIGNED_BYTE,
      value: d,
      size: 3,
      normalized: !0
    };
  }
  return e && e.length === u * 3 ? {
    type: Zt.UNSIGNED_BYTE,
    value: e,
    size: 3,
    normalized: !0
  } : {
    type: Zt.UNSIGNED_BYTE,
    value: e || new Uint8ClampedArray(),
    size: 4,
    normalized: !0
  };
}
const O1 = new Be();
function m8(t, e) {
  if (!e)
    return null;
  if (t.isOctEncoded16P) {
    const i = new Float32Array((t.pointsLength || 0) * 3);
    for (let s = 0; s < (t.pointsLength || 0); s++)
      s8(e[s * 2], e[s * 2 + 1], O1), O1.toArray(i, s * 3);
    return {
      type: Zt.FLOAT,
      size: 2,
      value: i
    };
  }
  return {
    type: Zt.FLOAT,
    size: 2,
    value: e
  };
}
function y8(t, e, i) {
  return t.isQuantized ? i["3d-tiles"] && i["3d-tiles"].decodeQuantizedPositions ? (t.isQuantized = !1, b8(t, e)) : {
    type: Zt.UNSIGNED_SHORT,
    value: e,
    size: 3,
    normalized: !0
  } : e;
}
function b8(t, e) {
  const i = new Be(), s = new Float32Array(t.pointCount * 3);
  for (let o = 0; o < t.pointCount; o++)
    i.set(e[o * 3], e[o * 3 + 1], e[o * 3 + 2]).scale(1 / t.quantizedRange).multiply(t.quantizedVolumeScale).add(t.quantizedVolumeOffset).toArray(s, o * 3);
  return s;
}
async function v8(t, e, i, s, o) {
  i = Hp(t, e, i), i = Zy(t, e, i), i = Ky(t, e, i), x8(t);
  const { featureTable: u, batchTable: d } = w8(t);
  return await C8(t, u, d, s, o), T8(t, u, s), A8(t, u, d), E8(t, u), i;
}
function x8(t) {
  t.attributes = {
    positions: null,
    colors: null,
    normals: null,
    batchIds: null
  }, t.isQuantized = !1, t.isTranslucent = !1, t.isRGB565 = !1, t.isOctEncoded16P = !1;
}
function w8(t) {
  const e = new qy(t.featureTableJson, t.featureTableBinary), i = e.getGlobalProperty("POINTS_LENGTH");
  if (!Number.isFinite(i))
    throw new Error("POINTS_LENGTH must be defined");
  e.featuresLength = i, t.featuresLength = i, t.pointsLength = i, t.pointCount = i, t.rtcCenter = e.getGlobalProperty("RTC_CENTER", Zt.FLOAT, 3);
  const s = S8(t, e);
  return { featureTable: e, batchTable: s };
}
function T8(t, e, i) {
  if (t.attributes = t.attributes || {
    positions: null,
    colors: null,
    normals: null,
    batchIds: null
  }, !t.attributes.positions) {
    if (e.hasProperty("POSITION"))
      t.attributes.positions = e.getPropertyArray("POSITION", Zt.FLOAT, 3);
    else if (e.hasProperty("POSITION_QUANTIZED")) {
      const s = e.getPropertyArray("POSITION_QUANTIZED", Zt.UNSIGNED_SHORT, 3);
      if (t.isQuantized = !0, t.quantizedRange = 65535, t.quantizedVolumeScale = e.getGlobalProperty("QUANTIZED_VOLUME_SCALE", Zt.FLOAT, 3), !t.quantizedVolumeScale)
        throw new Error("QUANTIZED_VOLUME_SCALE must be defined for quantized positions.");
      if (t.quantizedVolumeOffset = e.getGlobalProperty("QUANTIZED_VOLUME_OFFSET", Zt.FLOAT, 3), !t.quantizedVolumeOffset)
        throw new Error("QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.");
      t.attributes.positions = y8(t, s, i);
    }
  }
  if (!t.attributes.positions)
    throw new Error("Either POSITION or POSITION_QUANTIZED must be defined.");
}
function A8(t, e, i) {
  if (t.attributes = t.attributes || {
    positions: null,
    colors: null,
    normals: null,
    batchIds: null
  }, !t.attributes.colors) {
    let s = null;
    e.hasProperty("RGBA") ? (s = e.getPropertyArray("RGBA", Zt.UNSIGNED_BYTE, 4), t.isTranslucent = !0) : e.hasProperty("RGB") ? s = e.getPropertyArray("RGB", Zt.UNSIGNED_BYTE, 3) : e.hasProperty("RGB565") && (s = e.getPropertyArray("RGB565", Zt.UNSIGNED_SHORT, 1), t.isRGB565 = !0), t.attributes.colors = qA(t, s, i);
  }
  e.hasProperty("CONSTANT_RGBA") && (t.constantRGBA = e.getGlobalProperty("CONSTANT_RGBA", Zt.UNSIGNED_BYTE, 4));
}
function E8(t, e) {
  if (t.attributes = t.attributes || {
    positions: null,
    colors: null,
    normals: null,
    batchIds: null
  }, !t.attributes.normals) {
    let i = null;
    e.hasProperty("NORMAL") ? i = e.getPropertyArray("NORMAL", Zt.FLOAT, 3) : e.hasProperty("NORMAL_OCT16P") && (i = e.getPropertyArray("NORMAL_OCT16P", Zt.UNSIGNED_BYTE, 2), t.isOctEncoded16P = !0), t.attributes.normals = m8(t, i);
  }
}
function S8(t, e) {
  let i = null;
  if (!t.batchIds && e.hasProperty("BATCH_ID") && (t.batchIds = e.getPropertyArray("BATCH_ID", Zt.UNSIGNED_SHORT, 1), t.batchIds)) {
    const s = e.getGlobalProperty("BATCH_LENGTH");
    if (!s)
      throw new Error("Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.");
    const { batchTableJson: o, batchTableBinary: u } = t;
    i = new XA(o, u, s);
  }
  return i;
}
async function C8(t, e, i, s, o) {
  let u, d, a;
  const w = t.batchTableJson && t.batchTableJson.extensions && t.batchTableJson.extensions["3DTILES_draco_point_compression"];
  w && (a = w.properties);
  const S = e.getExtension("3DTILES_draco_point_compression");
  if (S) {
    d = S.properties;
    const F = S.byteOffset, N = S.byteLength;
    if (!d || !Number.isFinite(F) || !N)
      throw new Error("Draco properties, byteOffset, and byteLength must be defined");
    u = (t.featureTableBinary || []).slice(F, F + N), t.hasPositions = Number.isFinite(d.POSITION), t.hasColors = Number.isFinite(d.RGB) || Number.isFinite(d.RGBA), t.hasNormals = Number.isFinite(d.NORMAL), t.hasBatchIds = Number.isFinite(d.BATCH_ID), t.isTranslucent = Number.isFinite(d.RGBA);
  }
  if (!u)
    return !0;
  const M = {
    buffer: u,
    properties: { ...d, ...a },
    batchTableProperties: a
  };
  return await I8(t, M, s, o);
}
async function I8(t, e, i, s) {
  if (!s)
    return;
  const o = {
    ...i,
    draco: {
      ...i?.draco,
      extraAttributes: e.batchTableProperties || {}
    }
  };
  delete o["3d-tiles"];
  const u = await rd(e.buffer, BA, o, s), d = u.attributes.POSITION && u.attributes.POSITION.value, a = u.attributes.COLOR_0 && u.attributes.COLOR_0.value, w = u.attributes.NORMAL && u.attributes.NORMAL.value, S = u.attributes.BATCH_ID && u.attributes.BATCH_ID.value, M = d && u.attributes.POSITION.value.quantization, F = w && u.attributes.NORMAL.value.quantization;
  if (M) {
    const L = u.POSITION.data.quantization, re = L.range;
    t.quantizedVolumeScale = new Be(re, re, re), t.quantizedVolumeOffset = new Be(L.minValues), t.quantizedRange = (1 << L.quantizationBits) - 1, t.isQuantizedDraco = !0;
  }
  F && (t.octEncodedRange = (1 << u.NORMAL.data.quantization.quantizationBits) - 1, t.isOctEncodedDraco = !0);
  const N = {};
  if (e.batchTableProperties)
    for (const L of Object.keys(e.batchTableProperties))
      u.attributes[L] && u.attributes[L].value && (N[L.toLowerCase()] = u.attributes[L].value);
  t.attributes = {
    // @ts-expect-error
    positions: d,
    // @ts-expect-error
    colors: qA(t, a, void 0),
    // @ts-expect-error
    normals: w,
    // @ts-expect-error
    batchIds: S,
    ...N
  };
}
const $m = {
  URI: 0,
  EMBEDDED: 1
};
function ZA(t, e, i, s) {
  t.rotateYtoZ = !0;
  const o = (t.byteOffset || 0) + (t.byteLength || 0) - i;
  if (o === 0)
    throw new Error("glTF byte length must be greater than 0.");
  return t.gltfUpAxis = s?.["3d-tiles"] && s["3d-tiles"].assetGltfUpAxis ? s["3d-tiles"].assetGltfUpAxis : "Y", t.gltfArrayBuffer = Km(e, i, o), t.gltfByteOffset = 0, t.gltfByteLength = o, i % 4 === 0 || console.warn(`${t.type}: embedded glb is not aligned to a 4-byte boundary.`), (t.byteOffset || 0) + (t.byteLength || 0);
}
async function KA(t, e, i, s) {
  const o = i?.["3d-tiles"] || {};
  if (M8(t, e), o.loadGLTF) {
    if (!s)
      return;
    if (t.gltfUrl) {
      const { fetch: u } = s, d = await u(t.gltfUrl, i);
      t.gltfArrayBuffer = await d.arrayBuffer(), t.gltfByteOffset = 0;
    }
    if (t.gltfArrayBuffer) {
      const u = await rd(t.gltfArrayBuffer, td, i, s);
      t.gltf = Gy(u), t.gpuMemoryUsageInBytes = wA(t.gltf), delete t.gltfArrayBuffer, delete t.gltfByteOffset, delete t.gltfByteLength;
    }
  }
}
function M8(t, e, i) {
  switch (e) {
    case $m.URI:
      if (t.gltfArrayBuffer) {
        const s = new Uint8Array(t.gltfArrayBuffer, t.gltfByteOffset), u = new TextDecoder().decode(s);
        t.gltfUrl = u.replace(/[\s\0]+$/, "");
      }
      delete t.gltfArrayBuffer, delete t.gltfByteOffset, delete t.gltfByteLength;
      break;
    case $m.EMBEDDED:
      break;
    default:
      throw new Error("b3dm: Illegal glTF format field");
  }
}
async function R8(t, e, i, s, o) {
  i = P8(t, e, i, s), await KA(t, $m.EMBEDDED, s, o);
  const u = t?.gltf?.extensions;
  return u && u.CESIUM_RTC && (t.rtcCenter = u.CESIUM_RTC.center), i;
}
function P8(t, e, i, s, o) {
  i = Hp(t, e, i), i = Zy(t, e, i), i = Ky(t, e, i), i = ZA(t, e, i, s);
  const u = new qy(t.featureTableJson, t.featureTableBinary);
  return t.rtcCenter = u.getGlobalProperty("RTC_CENTER", Zt.FLOAT, 3), i;
}
async function B8(t, e, i, s, o) {
  return i = D8(t, e, i, s), await KA(t, t.gltfFormat || 0, s, o), i;
}
function D8(t, e, i, s, o) {
  if (i = Hp(t, e, i), t.version !== 1)
    throw new Error(`Instanced 3D Model version ${t.version} is not supported`);
  i = Zy(t, e, i);
  const u = new DataView(e);
  if (t.gltfFormat = u.getUint32(i, !0), i += 4, i = Ky(t, e, i), i = ZA(t, e, i, s), !t?.header?.featureTableJsonByteLength || t.header.featureTableJsonByteLength === 0)
    throw new Error("i3dm parser: featureTableJsonByteLength is zero.");
  const d = new qy(t.featureTableJson, t.featureTableBinary), a = d.getGlobalProperty("INSTANCES_LENGTH");
  if (d.featuresLength = a, !Number.isFinite(a))
    throw new Error("i3dm parser: INSTANCES_LENGTH must be defined");
  t.eastNorthUp = d.getGlobalProperty("EAST_NORTH_UP"), t.rtcCenter = d.getGlobalProperty("RTC_CENTER", Zt.FLOAT, 3);
  const w = new XA(t.batchTableJson, t.batchTableBinary, a);
  return O8(t, d, w, a), i;
}
function O8(t, e, i, s) {
  const o = new Array(s), u = new Be();
  new Be(), new Be(), new Be();
  const d = new Yi(), a = new qu(), w = new Be(), S = {}, M = new Gt(), F = [], N = [], L = [], re = [];
  for (let ne = 0; ne < s; ne++) {
    let we;
    if (e.hasProperty("POSITION"))
      we = e.getProperty("POSITION", Zt.FLOAT, 3, ne, u);
    else if (e.hasProperty("POSITION_QUANTIZED")) {
      we = e.getProperty("POSITION_QUANTIZED", Zt.UNSIGNED_SHORT, 3, ne, u);
      const Ke = e.getGlobalProperty("QUANTIZED_VOLUME_OFFSET", Zt.FLOAT, 3);
      if (!Ke)
        throw new Error("i3dm parser: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.");
      const ct = e.getGlobalProperty("QUANTIZED_VOLUME_SCALE", Zt.FLOAT, 3);
      if (!ct)
        throw new Error("i3dm parser: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.");
      const _t = 65535;
      for (let st = 0; st < 3; st++)
        we[st] = we[st] / _t * ct[st] + Ke[st];
    }
    if (!we)
      throw new Error("i3dm: POSITION or POSITION_QUANTIZED must be defined for each instance.");
    if (u.copy(we), S.translation = u, t.normalUp = e.getProperty("NORMAL_UP", Zt.FLOAT, 3, ne, F), t.normalRight = e.getProperty("NORMAL_RIGHT", Zt.FLOAT, 3, ne, N), t.normalUp) {
      if (!t.normalRight)
        throw new Error("i3dm: Custom orientation requires both NORMAL_UP and NORMAL_RIGHT.");
      t.hasCustomOrientation = !0;
    } else {
      if (t.octNormalUp = e.getProperty("NORMAL_UP_OCT32P", Zt.UNSIGNED_SHORT, 2, ne, F), t.octNormalRight = e.getProperty("NORMAL_RIGHT_OCT32P", Zt.UNSIGNED_SHORT, 2, ne, N), t.octNormalUp)
        throw t.octNormalRight ? new Error("i3dm: oct-encoded orientation not implemented") : new Error("i3dm: oct-encoded orientation requires NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P");
      t.eastNorthUp ? (yi.WGS84.eastNorthUpToFixedFrame(u, M), M.getRotationMatrix3(d)) : d.identity();
    }
    a.fromMatrix3(d), S.rotation = a, w.set(1, 1, 1);
    const Se = e.getProperty("SCALE", Zt.FLOAT, 1, ne, L);
    Number.isFinite(Se) && w.multiplyByScalar(Se);
    const Ee = e.getProperty("SCALE_NON_UNIFORM", Zt.FLOAT, 3, ne, F);
    Ee && w.scale(Ee), S.scale = w;
    let Ce = e.getProperty("BATCH_ID", Zt.UNSIGNED_SHORT, 1, ne, re);
    Ce === void 0 && (Ce = ne);
    const Le = new Gt().fromQuaternion(S.rotation);
    M.identity(), M.translate(S.translation), M.multiplyRight(Le), M.scale(S.scale);
    const Ze = M.clone();
    o[ne] = {
      modelMatrix: Ze,
      batchId: Ce
    };
  }
  t.instances = o;
}
async function F8(t, e, i, s, o, u) {
  i = Hp(t, e, i);
  const d = new DataView(e);
  for (t.tilesLength = d.getUint32(i, !0), i += 4, t.tiles = []; t.tiles.length < t.tilesLength && (t.byteLength || 0) - i > 12; ) {
    const a = { shape: "tile3d" };
    t.tiles.push(a), i = await u(e, i, s, o, a);
  }
  return i;
}
async function k8(t, e, i, s) {
  if (t.rotateYtoZ = !0, t.gltfUpAxis = i?.["3d-tiles"]?.assetGltfUpAxis ? i["3d-tiles"].assetGltfUpAxis : "Y", i?.["3d-tiles"]?.loadGLTF) {
    if (!s)
      return e.byteLength;
    const o = await rd(e, td, i, s);
    t.gltf = Gy(o), t.gpuMemoryUsageInBytes = wA(t.gltf);
  } else
    t.gltfArrayBuffer = e;
  return e.byteLength;
}
async function YA(t, e = 0, i, s, o = { shape: "tile3d" }) {
  switch (o.byteOffset = e, o.type = J5(t, e), o.type) {
    case Pu.COMPOSITE:
      return await F8(o, t, e, i, s, YA);
    case Pu.BATCHED_3D_MODEL:
      return await R8(o, t, e, i, s);
    case Pu.GLTF:
      return await k8(o, t, i, s);
    case Pu.INSTANCED_3D_MODEL:
      return await B8(o, t, e, i, s);
    case Pu.POINT_CLOUD:
      return await v8(o, t, e, i, s);
    default:
      throw new Error(`3DTileLoader: unknown type ${o.type}`);
  }
}
const N8 = 1952609651, L8 = 1;
async function U8(t, e, i) {
  if (new Uint32Array(t.slice(0, 4))[0] !== N8)
    throw new Error("Wrong subtree file magic number");
  if (new Uint32Array(t.slice(4, 8))[0] !== L8)
    throw new Error("Wrong subtree file verson, must be 1");
  const u = F1(t.slice(8, 16)), d = new Uint8Array(t, 24, u), w = new TextDecoder("utf8").decode(d), S = JSON.parse(w), M = F1(t.slice(16, 24));
  let F = new ArrayBuffer(0);
  if (M && (F = t.slice(24 + u)), await qf(S, S.tileAvailability, F, i), Array.isArray(S.contentAvailability))
    for (const N of S.contentAvailability)
      await qf(S, N, F, i);
  else
    await qf(S, S.contentAvailability, F, i);
  return await qf(S, S.childSubtreeAvailability, F, i), S;
}
async function qf(t, e, i, s) {
  const o = Number.isFinite(e.bitstream) ? e.bitstream : e.bufferView;
  if (typeof o != "number")
    return;
  const u = t.bufferViews[o], d = t.buffers[u.buffer];
  if (!s?.baseUrl)
    throw new Error("Url is not provided");
  if (!s.fetch)
    throw new Error("fetch is not provided");
  if (d.uri) {
    const w = `${s?.baseUrl || ""}/${d.uri}`, M = await (await s.fetch(w)).arrayBuffer();
    e.explicitBitstream = new Uint8Array(M, u.byteOffset, u.byteLength);
    return;
  }
  const a = t.buffers.slice(0, u.buffer).reduce((w, S) => w + S.byteLength, 0);
  e.explicitBitstream = new Uint8Array(i.slice(a, a + d.byteLength), u.byteOffset, u.byteLength);
}
function F1(t) {
  const e = new DataView(t), i = e.getUint32(0, !0), s = e.getUint32(4, !0);
  return i + 2 ** 32 * s;
}
const JA = {
  dataType: null,
  batchType: null,
  id: "3d-tiles-subtree",
  name: "3D Tiles Subtree",
  module: "3d-tiles",
  version: $A,
  extensions: ["subtree"],
  mimeTypes: ["application/octet-stream"],
  tests: ["subtree"],
  parse: U8,
  options: {}
};
/**
 * @license
 * Copyright 2009 The Closure Library Authors
 * Copyright 2020 Daniel Wirtz / The long.js Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
var hn = null;
try {
  hn = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0,
    97,
    115,
    109,
    1,
    0,
    0,
    0,
    1,
    13,
    2,
    96,
    0,
    1,
    127,
    96,
    4,
    127,
    127,
    127,
    127,
    1,
    127,
    3,
    7,
    6,
    0,
    1,
    1,
    1,
    1,
    1,
    6,
    6,
    1,
    127,
    1,
    65,
    0,
    11,
    7,
    50,
    6,
    3,
    109,
    117,
    108,
    0,
    1,
    5,
    100,
    105,
    118,
    95,
    115,
    0,
    2,
    5,
    100,
    105,
    118,
    95,
    117,
    0,
    3,
    5,
    114,
    101,
    109,
    95,
    115,
    0,
    4,
    5,
    114,
    101,
    109,
    95,
    117,
    0,
    5,
    8,
    103,
    101,
    116,
    95,
    104,
    105,
    103,
    104,
    0,
    0,
    10,
    191,
    1,
    6,
    4,
    0,
    35,
    0,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    126,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    127,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    128,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    129,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    130,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11
  ])), {}).exports;
} catch {
}
function ci(t, e, i) {
  this.low = t | 0, this.high = e | 0, this.unsigned = !!i;
}
ci.prototype.__isLong__;
Object.defineProperty(ci.prototype, "__isLong__", { value: !0 });
function Qr(t) {
  return (t && t.__isLong__) === !0;
}
function k1(t) {
  var e = Math.clz32(t & -t);
  return t ? 31 - e : e;
}
ci.isLong = Qr;
var N1 = {}, L1 = {};
function Ol(t, e) {
  var i, s, o;
  return e ? (t >>>= 0, (o = 0 <= t && t < 256) && (s = L1[t], s) ? s : (i = Qt(t, 0, !0), o && (L1[t] = i), i)) : (t |= 0, (o = -128 <= t && t < 128) && (s = N1[t], s) ? s : (i = Qt(t, t < 0 ? -1 : 0, !1), o && (N1[t] = i), i));
}
ci.fromInt = Ol;
function un(t, e) {
  if (isNaN(t))
    return e ? Fo : Dn;
  if (e) {
    if (t < 0)
      return Fo;
    if (t >= QA)
      return iE;
  } else {
    if (t <= -z1)
      return xs;
    if (t + 1 >= z1)
      return tE;
  }
  return t < 0 ? un(-t, e).neg() : Qt(t % fh | 0, t / fh | 0, e);
}
ci.fromNumber = un;
function Qt(t, e, i) {
  return new ci(t, e, i);
}
ci.fromBits = Qt;
var Tp = Math.pow;
function Yy(t, e, i) {
  if (t.length === 0)
    throw Error("empty string");
  if (typeof e == "number" ? (i = e, e = !1) : e = !!e, t === "NaN" || t === "Infinity" || t === "+Infinity" || t === "-Infinity")
    return e ? Fo : Dn;
  if (i = i || 10, i < 2 || 36 < i)
    throw RangeError("radix");
  var s;
  if ((s = t.indexOf("-")) > 0)
    throw Error("interior hyphen");
  if (s === 0)
    return Yy(t.substring(1), e, i).neg();
  for (var o = un(Tp(i, 8)), u = Dn, d = 0; d < t.length; d += 8) {
    var a = Math.min(8, t.length - d), w = parseInt(t.substring(d, d + a), i);
    if (a < 8) {
      var S = un(Tp(i, a));
      u = u.mul(S).add(un(w));
    } else
      u = u.mul(o), u = u.add(un(w));
  }
  return u.unsigned = e, u;
}
ci.fromString = Yy;
function Nn(t, e) {
  return typeof t == "number" ? un(t, e) : typeof t == "string" ? Yy(t, e) : Qt(t.low, t.high, typeof e == "boolean" ? e : t.unsigned);
}
ci.fromValue = Nn;
var U1 = 65536, z8 = 1 << 24, fh = U1 * U1, QA = fh * fh, z1 = QA / 2, V1 = Ol(z8), Dn = Ol(0);
ci.ZERO = Dn;
var Fo = Ol(0, !0);
ci.UZERO = Fo;
var Kc = Ol(1);
ci.ONE = Kc;
var eE = Ol(1, !0);
ci.UONE = eE;
var Gm = Ol(-1);
ci.NEG_ONE = Gm;
var tE = Qt(-1, 2147483647, !1);
ci.MAX_VALUE = tE;
var iE = Qt(-1, -1, !0);
ci.MAX_UNSIGNED_VALUE = iE;
var xs = Qt(0, -2147483648, !1);
ci.MIN_VALUE = xs;
var rt = ci.prototype;
rt.toInt = function() {
  return this.unsigned ? this.low >>> 0 : this.low;
};
rt.toNumber = function() {
  return this.unsigned ? (this.high >>> 0) * fh + (this.low >>> 0) : this.high * fh + (this.low >>> 0);
};
rt.toString = function(e) {
  if (e = e || 10, e < 2 || 36 < e)
    throw RangeError("radix");
  if (this.isZero())
    return "0";
  if (this.isNegative())
    if (this.eq(xs)) {
      var i = un(e), s = this.div(i), o = s.mul(i).sub(this);
      return s.toString(e) + o.toInt().toString(e);
    } else
      return "-" + this.neg().toString(e);
  for (var u = un(Tp(e, 6), this.unsigned), d = this, a = ""; ; ) {
    var w = d.div(u), S = d.sub(w.mul(u)).toInt() >>> 0, M = S.toString(e);
    if (d = w, d.isZero())
      return M + a;
    for (; M.length < 6; )
      M = "0" + M;
    a = "" + M + a;
  }
};
rt.getHighBits = function() {
  return this.high;
};
rt.getHighBitsUnsigned = function() {
  return this.high >>> 0;
};
rt.getLowBits = function() {
  return this.low;
};
rt.getLowBitsUnsigned = function() {
  return this.low >>> 0;
};
rt.getNumBitsAbs = function() {
  if (this.isNegative())
    return this.eq(xs) ? 64 : this.neg().getNumBitsAbs();
  for (var e = this.high != 0 ? this.high : this.low, i = 31; i > 0 && (e & 1 << i) == 0; i--)
    ;
  return this.high != 0 ? i + 33 : i + 1;
};
rt.isZero = function() {
  return this.high === 0 && this.low === 0;
};
rt.eqz = rt.isZero;
rt.isNegative = function() {
  return !this.unsigned && this.high < 0;
};
rt.isPositive = function() {
  return this.unsigned || this.high >= 0;
};
rt.isOdd = function() {
  return (this.low & 1) === 1;
};
rt.isEven = function() {
  return (this.low & 1) === 0;
};
rt.equals = function(e) {
  return Qr(e) || (e = Nn(e)), this.unsigned !== e.unsigned && this.high >>> 31 === 1 && e.high >>> 31 === 1 ? !1 : this.high === e.high && this.low === e.low;
};
rt.eq = rt.equals;
rt.notEquals = function(e) {
  return !this.eq(
    /* validates */
    e
  );
};
rt.neq = rt.notEquals;
rt.ne = rt.notEquals;
rt.lessThan = function(e) {
  return this.comp(
    /* validates */
    e
  ) < 0;
};
rt.lt = rt.lessThan;
rt.lessThanOrEqual = function(e) {
  return this.comp(
    /* validates */
    e
  ) <= 0;
};
rt.lte = rt.lessThanOrEqual;
rt.le = rt.lessThanOrEqual;
rt.greaterThan = function(e) {
  return this.comp(
    /* validates */
    e
  ) > 0;
};
rt.gt = rt.greaterThan;
rt.greaterThanOrEqual = function(e) {
  return this.comp(
    /* validates */
    e
  ) >= 0;
};
rt.gte = rt.greaterThanOrEqual;
rt.ge = rt.greaterThanOrEqual;
rt.compare = function(e) {
  if (Qr(e) || (e = Nn(e)), this.eq(e))
    return 0;
  var i = this.isNegative(), s = e.isNegative();
  return i && !s ? -1 : !i && s ? 1 : this.unsigned ? e.high >>> 0 > this.high >>> 0 || e.high === this.high && e.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(e).isNegative() ? -1 : 1;
};
rt.comp = rt.compare;
rt.negate = function() {
  return !this.unsigned && this.eq(xs) ? xs : this.not().add(Kc);
};
rt.neg = rt.negate;
rt.add = function(e) {
  Qr(e) || (e = Nn(e));
  var i = this.high >>> 16, s = this.high & 65535, o = this.low >>> 16, u = this.low & 65535, d = e.high >>> 16, a = e.high & 65535, w = e.low >>> 16, S = e.low & 65535, M = 0, F = 0, N = 0, L = 0;
  return L += u + S, N += L >>> 16, L &= 65535, N += o + w, F += N >>> 16, N &= 65535, F += s + a, M += F >>> 16, F &= 65535, M += i + d, M &= 65535, Qt(N << 16 | L, M << 16 | F, this.unsigned);
};
rt.subtract = function(e) {
  return Qr(e) || (e = Nn(e)), this.add(e.neg());
};
rt.sub = rt.subtract;
rt.multiply = function(e) {
  if (this.isZero())
    return this;
  if (Qr(e) || (e = Nn(e)), hn) {
    var i = hn.mul(
      this.low,
      this.high,
      e.low,
      e.high
    );
    return Qt(i, hn.get_high(), this.unsigned);
  }
  if (e.isZero())
    return this.unsigned ? Fo : Dn;
  if (this.eq(xs))
    return e.isOdd() ? xs : Dn;
  if (e.eq(xs))
    return this.isOdd() ? xs : Dn;
  if (this.isNegative())
    return e.isNegative() ? this.neg().mul(e.neg()) : this.neg().mul(e).neg();
  if (e.isNegative())
    return this.mul(e.neg()).neg();
  if (this.lt(V1) && e.lt(V1))
    return un(this.toNumber() * e.toNumber(), this.unsigned);
  var s = this.high >>> 16, o = this.high & 65535, u = this.low >>> 16, d = this.low & 65535, a = e.high >>> 16, w = e.high & 65535, S = e.low >>> 16, M = e.low & 65535, F = 0, N = 0, L = 0, re = 0;
  return re += d * M, L += re >>> 16, re &= 65535, L += u * M, N += L >>> 16, L &= 65535, L += d * S, N += L >>> 16, L &= 65535, N += o * M, F += N >>> 16, N &= 65535, N += u * S, F += N >>> 16, N &= 65535, N += d * w, F += N >>> 16, N &= 65535, F += s * M + o * S + u * w + d * a, F &= 65535, Qt(L << 16 | re, F << 16 | N, this.unsigned);
};
rt.mul = rt.multiply;
rt.divide = function(e) {
  if (Qr(e) || (e = Nn(e)), e.isZero())
    throw Error("division by zero");
  if (hn) {
    if (!this.unsigned && this.high === -2147483648 && e.low === -1 && e.high === -1)
      return this;
    var i = (this.unsigned ? hn.div_u : hn.div_s)(
      this.low,
      this.high,
      e.low,
      e.high
    );
    return Qt(i, hn.get_high(), this.unsigned);
  }
  if (this.isZero())
    return this.unsigned ? Fo : Dn;
  var s, o, u;
  if (this.unsigned) {
    if (e.unsigned || (e = e.toUnsigned()), e.gt(this))
      return Fo;
    if (e.gt(this.shru(1)))
      return eE;
    u = Fo;
  } else {
    if (this.eq(xs)) {
      if (e.eq(Kc) || e.eq(Gm))
        return xs;
      if (e.eq(xs))
        return Kc;
      var d = this.shr(1);
      return s = d.div(e).shl(1), s.eq(Dn) ? e.isNegative() ? Kc : Gm : (o = this.sub(e.mul(s)), u = s.add(o.div(e)), u);
    } else if (e.eq(xs))
      return this.unsigned ? Fo : Dn;
    if (this.isNegative())
      return e.isNegative() ? this.neg().div(e.neg()) : this.neg().div(e).neg();
    if (e.isNegative())
      return this.div(e.neg()).neg();
    u = Dn;
  }
  for (o = this; o.gte(e); ) {
    s = Math.max(1, Math.floor(o.toNumber() / e.toNumber()));
    for (var a = Math.ceil(Math.log(s) / Math.LN2), w = a <= 48 ? 1 : Tp(2, a - 48), S = un(s), M = S.mul(e); M.isNegative() || M.gt(o); )
      s -= w, S = un(s, this.unsigned), M = S.mul(e);
    S.isZero() && (S = Kc), u = u.add(S), o = o.sub(M);
  }
  return u;
};
rt.div = rt.divide;
rt.modulo = function(e) {
  if (Qr(e) || (e = Nn(e)), hn) {
    var i = (this.unsigned ? hn.rem_u : hn.rem_s)(
      this.low,
      this.high,
      e.low,
      e.high
    );
    return Qt(i, hn.get_high(), this.unsigned);
  }
  return this.sub(this.div(e).mul(e));
};
rt.mod = rt.modulo;
rt.rem = rt.modulo;
rt.not = function() {
  return Qt(~this.low, ~this.high, this.unsigned);
};
rt.countLeadingZeros = function() {
  return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
};
rt.clz = rt.countLeadingZeros;
rt.countTrailingZeros = function() {
  return this.low ? k1(this.low) : k1(this.high) + 32;
};
rt.ctz = rt.countTrailingZeros;
rt.and = function(e) {
  return Qr(e) || (e = Nn(e)), Qt(this.low & e.low, this.high & e.high, this.unsigned);
};
rt.or = function(e) {
  return Qr(e) || (e = Nn(e)), Qt(this.low | e.low, this.high | e.high, this.unsigned);
};
rt.xor = function(e) {
  return Qr(e) || (e = Nn(e)), Qt(this.low ^ e.low, this.high ^ e.high, this.unsigned);
};
rt.shiftLeft = function(e) {
  return Qr(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e < 32 ? Qt(this.low << e, this.high << e | this.low >>> 32 - e, this.unsigned) : Qt(0, this.low << e - 32, this.unsigned);
};
rt.shl = rt.shiftLeft;
rt.shiftRight = function(e) {
  return Qr(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e < 32 ? Qt(this.low >>> e | this.high << 32 - e, this.high >> e, this.unsigned) : Qt(this.high >> e - 32, this.high >= 0 ? 0 : -1, this.unsigned);
};
rt.shr = rt.shiftRight;
rt.shiftRightUnsigned = function(e) {
  return Qr(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e < 32 ? Qt(this.low >>> e | this.high << 32 - e, this.high >>> e, this.unsigned) : e === 32 ? Qt(this.high, 0, this.unsigned) : Qt(this.high >>> e - 32, 0, this.unsigned);
};
rt.shru = rt.shiftRightUnsigned;
rt.shr_u = rt.shiftRightUnsigned;
rt.rotateLeft = function(e) {
  var i;
  return Qr(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e === 32 ? Qt(this.high, this.low, this.unsigned) : e < 32 ? (i = 32 - e, Qt(this.low << e | this.high >>> i, this.high << e | this.low >>> i, this.unsigned)) : (e -= 32, i = 32 - e, Qt(this.high << e | this.low >>> i, this.low << e | this.high >>> i, this.unsigned));
};
rt.rotl = rt.rotateLeft;
rt.rotateRight = function(e) {
  var i;
  return Qr(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e === 32 ? Qt(this.high, this.low, this.unsigned) : e < 32 ? (i = 32 - e, Qt(this.high << i | this.low >>> e, this.low << i | this.high >>> e, this.unsigned)) : (e -= 32, i = 32 - e, Qt(this.low << i | this.high >>> e, this.high << i | this.low >>> e, this.unsigned));
};
rt.rotr = rt.rotateRight;
rt.toSigned = function() {
  return this.unsigned ? Qt(this.low, this.high, !1) : this;
};
rt.toUnsigned = function() {
  return this.unsigned ? this : Qt(this.low, this.high, !0);
};
rt.toBytes = function(e) {
  return e ? this.toBytesLE() : this.toBytesBE();
};
rt.toBytesLE = function() {
  var e = this.high, i = this.low;
  return [
    i & 255,
    i >>> 8 & 255,
    i >>> 16 & 255,
    i >>> 24,
    e & 255,
    e >>> 8 & 255,
    e >>> 16 & 255,
    e >>> 24
  ];
};
rt.toBytesBE = function() {
  var e = this.high, i = this.low;
  return [
    e >>> 24,
    e >>> 16 & 255,
    e >>> 8 & 255,
    e & 255,
    i >>> 24,
    i >>> 16 & 255,
    i >>> 8 & 255,
    i & 255
  ];
};
ci.fromBytes = function(e, i, s) {
  return s ? ci.fromBytesLE(e, i) : ci.fromBytesBE(e, i);
};
ci.fromBytesLE = function(e, i) {
  return new ci(
    e[0] | e[1] << 8 | e[2] << 16 | e[3] << 24,
    e[4] | e[5] << 8 | e[6] << 16 | e[7] << 24,
    i
  );
};
ci.fromBytesBE = function(e, i) {
  return new ci(
    e[4] << 24 | e[5] << 16 | e[6] << 8 | e[7],
    e[0] << 24 | e[1] << 16 | e[2] << 8 | e[3],
    i
  );
};
const V8 = 16;
function rE(t) {
  t === "X" && (t = "");
  const e = t.padEnd(V8, "0");
  return ci.fromString(e, !0, 16);
}
function j8(t) {
  if (t.isZero())
    return "X";
  let e = t.countTrailingZeros();
  const i = e % 4;
  e = (e - i) / 4;
  const s = e;
  e *= 4;
  const u = t.shiftRightUnsigned(e).toString(16).replace(/0+$/, "");
  return Array(17 - s - u.length).join("0") + u;
}
function H8(t, e) {
  const i = $8(t).shiftRightUnsigned(2);
  return t.add(ci.fromNumber(2 * e + 1 - 4).multiply(i));
}
function $8(t) {
  return t.and(t.not().add(1));
}
const G8 = 3, W8 = 30, X8 = 2 * W8 + 1, j1 = 180 / Math.PI;
function q8(t) {
  if (t.length === 0)
    throw new Error(`Invalid Hilbert quad key ${t}`);
  const e = t.split("/"), i = parseInt(e[0], 10), s = e[1], o = s.length;
  let u = 0;
  const d = [0, 0];
  for (let a = o - 1; a >= 0; a--) {
    u = o - a;
    const w = s[a];
    let S = 0, M = 0;
    w === "1" ? M = 1 : w === "2" ? (S = 1, M = 1) : w === "3" && (S = 1);
    const F = Math.pow(2, u - 1);
    K8(F, d, S, M), d[0] += F * S, d[1] += F * M;
  }
  if (i % 2 === 1) {
    const a = d[0];
    d[0] = d[1], d[1] = a;
  }
  return { face: i, ij: d, level: u };
}
function Z8(t) {
  if (t.isZero())
    return "";
  let e = t.toString(2);
  for (; e.length < G8 + X8; )
    e = "0" + e;
  const i = e.lastIndexOf("1"), s = e.substring(0, 3), o = e.substring(3, i), u = o.length / 2, d = ci.fromString(s, !0, 2).toString(10);
  let a = "";
  if (u !== 0)
    for (a = ci.fromString(o, !0, 2).toString(4); a.length < u; )
      a = "0" + a;
  return `${d}/${a}`;
}
function sE(t, e, i) {
  const s = 1 << e;
  return [(t[0] + i[0]) / s, (t[1] + i[1]) / s];
}
function H1(t) {
  return t >= 0.5 ? 1 / 3 * (4 * t * t - 1) : 1 / 3 * (1 - 4 * (1 - t) * (1 - t));
}
function nE(t) {
  return [H1(t[0]), H1(t[1])];
}
function oE(t, [e, i]) {
  switch (t) {
    case 0:
      return [1, e, i];
    case 1:
      return [-e, 1, i];
    case 2:
      return [-e, -i, 1];
    case 3:
      return [-1, -i, -e];
    case 4:
      return [i, -1, -e];
    case 5:
      return [i, e, -1];
    default:
      throw new Error("Invalid face");
  }
}
function aE([t, e, i]) {
  const s = Math.atan2(i, Math.sqrt(t * t + e * e));
  return [Math.atan2(e, t) * j1, s * j1];
}
function K8(t, e, i, s) {
  if (s === 0) {
    i === 1 && (e[0] = t - 1 - e[0], e[1] = t - 1 - e[1]);
    const o = e[0];
    e[0] = e[1], e[1] = o;
  }
}
function Y8(t) {
  const e = sE(t.ij, t.level, [0.5, 0.5]), i = nE(e), s = oE(t.face, i);
  return aE(s);
}
const J8 = 100;
function $1(t) {
  const { face: e, ij: i, level: s } = t, o = [
    [0, 0],
    [0, 1],
    [1, 1],
    [1, 0],
    [0, 0]
  ], u = Math.max(1, Math.ceil(J8 * Math.pow(2, -s))), d = new Float64Array(4 * u * 2 + 2);
  let a = 0, w = 0;
  for (let S = 0; S < 4; S++) {
    const M = o[S].slice(0), F = o[S + 1], N = (F[0] - M[0]) / u, L = (F[1] - M[1]) / u;
    for (let re = 0; re < u; re++) {
      M[0] += N, M[1] += L;
      const ne = sE(i, s, M), we = nE(ne), Se = oE(e, we), Ee = aE(Se);
      Math.abs(Ee[1]) > 89.999 && (Ee[0] = w);
      const Ce = Ee[0] - w;
      Ee[0] += Ce > 180 ? -360 : Ce < -180 ? 360 : 0, d[a++] = Ee[0], d[a++] = Ee[1], w = Ee[0];
    }
  }
  return d[a++] = d[0], d[a++] = d[1], d;
}
function Jy(t) {
  const e = Q8(t);
  return q8(e);
}
function Q8(t) {
  if (t.indexOf("/") > 0)
    return t;
  const e = rE(t);
  return Z8(e);
}
function eV(t) {
  const e = Jy(t);
  return Y8(e);
}
function tV(t) {
  let e;
  if (t.face === 2 || t.face === 5) {
    let i = null, s = 0;
    for (let o = 0; o < 4; o++) {
      const u = `${t.face}/${o}`, d = Jy(u), a = $1(d);
      (typeof i > "u" || i === null) && (i = new Float64Array(4 * a.length)), i.set(a, s), s += a.length;
    }
    e = G1(i);
  } else {
    const i = $1(t);
    e = G1(i);
  }
  return e;
}
function G1(t) {
  if (t.length % 2 !== 0)
    throw new Error("Invalid corners");
  const e = [], i = [];
  for (let s = 0; s < t.length; s += 2)
    e.push(t[s]), i.push(t[s + 1]);
  return e.sort((s, o) => s - o), i.sort((s, o) => s - o), {
    west: e[0],
    east: e[e.length - 1],
    north: i[i.length - 1],
    south: i[0]
  };
}
function iV(t, e) {
  const i = e?.minimumHeight || 0, s = e?.maximumHeight || 0, o = Jy(t), u = tV(o), d = u.west, a = u.south, w = u.east, S = u.north, M = [];
  return M.push(new Be(d, S, i)), M.push(new Be(w, S, i)), M.push(new Be(w, a, i)), M.push(new Be(d, a, i)), M.push(new Be(d, S, s)), M.push(new Be(w, S, s)), M.push(new Be(w, a, s)), M.push(new Be(d, a, s)), M;
}
function lE(t) {
  const e = t.token, i = {
    minimumHeight: t.minimumHeight,
    maximumHeight: t.maximumHeight
  }, s = iV(e, i), o = eV(e), u = o[0], d = o[1], a = yi.WGS84.cartographicToCartesian([
    u,
    d,
    i.maximumHeight
  ]), w = new Be(a[0], a[1], a[2]);
  s.push(w);
  const S = ZL(s);
  return [...S.center, ...S.halfAxes];
}
const rV = 4, sV = 8, nV = {
  QUADTREE: rV,
  OCTREE: sV
};
function oV(t, e, i) {
  if (t?.box) {
    const s = rE(t.s2VolumeInfo.token), o = H8(s, e), u = j8(o), d = { ...t.s2VolumeInfo };
    switch (d.token = u, i) {
      case "OCTREE":
        const S = t.s2VolumeInfo, M = S.maximumHeight - S.minimumHeight, F = M / 2, N = S.minimumHeight + M / 2;
        S.minimumHeight = N - F, S.maximumHeight = N + F;
        break;
    }
    return {
      box: lE(d),
      s2VolumeInfo: d
    };
  }
}
async function cE(t) {
  const { subtree: e, subtreeData: i = {
    level: 0,
    x: 0,
    y: 0,
    z: 0
  }, parentData: s = {
    mortonIndex: 0,
    localLevel: -1,
    localX: 0,
    localY: 0,
    localZ: 0
  }, childIndex: o = 0, implicitOptions: u, loaderOptions: d, s2VolumeBox: a } = t, { subdivisionScheme: w, subtreeLevels: S, maximumLevel: M, contentUrlTemplate: F, subtreesUriTemplate: N, basePath: L } = u, re = { children: [], lodMetricValue: 0, contentUrl: "" };
  if (!M)
    return rw.once(`Missing 'maximumLevel' or 'availableLevels' property. The subtree ${F} won't be loaded...`), re;
  const ne = s.localLevel + 1, we = i.level + ne;
  if (we > M)
    return re;
  const Se = nV[w], Ee = Math.log2(Se), Ce = o & 1, Le = o >> 1 & 1, Ze = o >> 2 & 1, Ke = ml(s.localX, Ce, 1), ct = ml(s.localY, Le, 1), _t = ml(s.localZ, Ze, 1), st = ml(i.x, Ke, ne), ot = ml(i.y, ct, ne), bt = ml(i.z, _t, ne), Ft = ml(s.mortonIndex, o, Ee), jt = ne === S && tm(e.childSubtreeAvailability, Ft);
  let Et, bi, Dr, gr;
  if (jt) {
    const rr = `${L}/${N}`, wi = Wm(rr, we, st, ot, bt);
    Et = await Ea(wi, JA, d), gr = 0, bi = { level: we, x: st, y: ot, z: bt }, Dr = { mortonIndex: 0, localLevel: 0, localX: 0, localY: 0, localZ: 0 };
  } else
    Et = e, gr = (Se ** ne - 1) / (Se - 1) + Ft, bi = i, Dr = { mortonIndex: Ft, localLevel: ne, localX: Ke, localY: ct, localZ: _t };
  if (!tm(Et.tileAvailability, gr))
    return re;
  tm(Et.contentAvailability, gr) && (re.contentUrl = Wm(F, we, st, ot, bt));
  for (let rr = 0; rr < Se; rr++) {
    const wi = oV(a, rr, w), sr = await cE({
      subtree: Et,
      subtreeData: bi,
      parentData: Dr,
      childIndex: rr,
      implicitOptions: u,
      loaderOptions: d,
      s2VolumeBox: wi
    });
    (sr.contentUrl || sr.children.length) && re.children.push(sr);
  }
  return re.contentUrl || re.children.length ? aV(re, { level: we, x: st, y: ot, z: bt }, u, a) : re;
}
function tm(t, e) {
  let i;
  return Array.isArray(t) ? (i = t[0], t.length > 1 && rw.once('Not supported extension "3DTILES_multiple_contents" has been detected')) : i = t, "constant" in i ? !!i.constant : i.explicitBitstream ? hV(e, i.explicitBitstream) : !1;
}
function aV(t, e, i, s) {
  const { basePath: o, refine: u, getRefine: d, lodMetricType: a, getTileType: w, rootLodMetricValue: S, rootBoundingVolume: M } = i, F = t.contentUrl && t.contentUrl.replace(`${o}/`, ""), N = S / 2 ** e.level, L = s?.box ? { box: s.box } : M, re = lV(L, e, i.subdivisionScheme);
  return {
    children: t.children,
    contentUrl: t.contentUrl,
    content: { uri: F },
    id: t.contentUrl,
    refine: d(u),
    type: w(t),
    lodMetricType: a,
    lodMetricValue: N,
    geometricError: N,
    transform: t.transform,
    boundingVolume: re
  };
}
function lV(t, e, i) {
  if (t.region) {
    const { level: s, x: o, y: u, z: d } = e, [a, w, S, M, F, N] = t.region, L = 2 ** s, re = (S - a) / L, [ne, we] = [a + re * o, a + re * (o + 1)], Se = (M - w) / L, [Ee, Ce] = [w + Se * u, w + Se * (u + 1)];
    let Le, Ze;
    if (i === "OCTREE") {
      const Ke = (N - F) / L;
      [Le, Ze] = [
        F + Ke * d,
        F + Ke * (d + 1)
      ];
    } else
      [Le, Ze] = [F, N];
    return {
      region: [ne, Ee, we, Ce, Le, Ze]
    };
  }
  if (t.box)
    return t;
  throw new Error(`Unsupported bounding volume type ${JSON.stringify(t)}`);
}
function ml(t, e, i) {
  return (t << i) + e;
}
function Wm(t, e, i, s, o) {
  const u = cV({ level: e, x: i, y: s, z: o });
  return t.replace(/{level}|{x}|{y}|{z}/gi, (d) => u[d]);
}
function cV(t) {
  const e = {};
  for (const i in t)
    e[`{${i}}`] = t[i];
  return e;
}
function hV(t, e) {
  const i = Math.floor(t / 8), s = t % 8;
  return (e[i] >> s & 1) === 1;
}
function Qy(t, e = "") {
  if (!e)
    return Oo.EMPTY;
  const s = e.split("?")[0].split(".").pop();
  switch (s) {
    case "pnts":
      return Oo.POINTCLOUD;
    case "i3dm":
    case "b3dm":
    case "glb":
    case "gltf":
      return Oo.SCENEGRAPH;
    default:
      return s || Oo.EMPTY;
  }
}
function eb(t) {
  switch (t) {
    case "REPLACE":
    case "replace":
      return Fn.REPLACE;
    case "ADD":
    case "add":
      return Fn.ADD;
    default:
      return t;
  }
}
function Xm(t, e) {
  if (/^[a-z][0-9a-z+.-]*:/i.test(e)) {
    const s = new URL(t, `${e}/`);
    return decodeURI(s.toString());
  } else if (t.startsWith("/"))
    return t;
  return g2(e, t);
}
function W1(t, e) {
  if (!t)
    return null;
  let i;
  if (t.content) {
    const o = t.content.uri || t.content?.url;
    typeof o < "u" && (i = Xm(o, e));
  }
  return {
    ...t,
    id: i,
    contentUrl: i,
    lodMetricType: dh.GEOMETRIC_ERROR,
    lodMetricValue: t.geometricError,
    transformMatrix: t.transform,
    type: Qy(t, i),
    refine: eb(t.refine)
  };
}
async function uV(t, e, i) {
  let s = null;
  const o = q1(t.root);
  o && t.root ? s = await X1(t.root, t, e, o, i) : s = W1(t.root, e);
  const u = [];
  for (u.push(s); u.length > 0; ) {
    const d = u.pop() || {}, a = d.children || [], w = [];
    for (const S of a) {
      const M = q1(S);
      let F;
      M ? F = await X1(S, t, e, M, i) : F = W1(S, e), F && (w.push(F), u.push(F));
    }
    d.children = w;
  }
  return s;
}
async function X1(t, e, i, s, o) {
  const { subdivisionScheme: u, maximumLevel: d, availableLevels: a, subtreeLevels: w, subtrees: { uri: S } } = s, M = Wm(S, 0, 0, 0, 0), F = Xm(M, i), N = await Ea(F, JA, o), L = t.content?.uri, re = L ? Xm(L, i) : "", ne = e?.root?.refine, we = t.geometricError, Se = t.boundingVolume.extensions?.["3DTILES_bounding_volume_S2"];
  if (Se) {
    const Ze = { box: lE(Se), s2VolumeInfo: Se };
    t.boundingVolume = Ze;
  }
  const Ee = t.boundingVolume, Ce = {
    contentUrlTemplate: re,
    subtreesUriTemplate: S,
    subdivisionScheme: u,
    subtreeLevels: w,
    maximumLevel: Number.isFinite(a) ? a - 1 : d,
    refine: ne,
    basePath: i,
    lodMetricType: dh.GEOMETRIC_ERROR,
    rootLodMetricValue: we,
    rootBoundingVolume: Ee,
    getTileType: Qy,
    getRefine: eb
  };
  return await dV(t, i, N, Ce, o);
}
async function dV(t, e, i, s, o) {
  if (!t)
    return null;
  const { children: u, contentUrl: d } = await cE({
    subtree: i,
    implicitOptions: s,
    loaderOptions: o
  });
  let a, w = null;
  return d && (a = d, w = { uri: d.replace(`${e}/`, "") }), {
    ...t,
    id: a,
    contentUrl: a,
    lodMetricType: dh.GEOMETRIC_ERROR,
    lodMetricValue: t.geometricError,
    transformMatrix: t.transform,
    type: Qy(t, a),
    refine: eb(t.refine),
    content: w || t.content,
    children: u
  };
}
function q1(t) {
  return t?.extensions?.["3DTILES_implicit_tiling"] || t?.implicitTiling;
}
const hE = {
  dataType: null,
  batchType: null,
  id: "3d-tiles",
  name: "3D Tiles",
  module: "3d-tiles",
  version: $A,
  extensions: ["cmpt", "pnts", "b3dm", "i3dm"],
  mimeTypes: ["application/octet-stream"],
  tests: ["cmpt", "pnts", "b3dm", "i3dm"],
  parse: fV,
  options: {
    "3d-tiles": {
      loadGLTF: !0,
      decodeQuantizedPositions: !1,
      isTileset: "auto",
      assetGltfUpAxis: null
    }
  }
};
async function fV(t, e = {}, i) {
  const s = e["3d-tiles"] || {};
  let o;
  return s.isTileset === "auto" ? o = i?.url && i.url.indexOf(".json") !== -1 : o = s.isTileset, o ? pV(t, e, i) : _V(t, e, i);
}
async function pV(t, e, i) {
  const s = JSON.parse(new TextDecoder().decode(t)), o = i?.url || "", u = gV(o), d = await uV(s, u, e || {});
  return {
    ...s,
    shape: "tileset3d",
    loader: hE,
    url: o,
    queryString: i?.queryString || "",
    basePath: u,
    root: d || s.root,
    type: bs.TILES3D,
    lodMetricType: dh.GEOMETRIC_ERROR,
    lodMetricValue: s.root?.geometricError || 0
  };
}
async function _V(t, e, i) {
  const s = {
    content: {
      shape: "tile3d",
      featureIds: null
    }
  };
  return await YA(t, 0, e, i, s.content), s.content;
}
function gV(t) {
  return Ym(t);
}
const Z1 = [0], mV = {
  getPointColor: { type: "accessor", value: [0, 0, 0, 255] },
  pointSize: 1,
  // Disable async data loading (handling it in _loadTileSet)
  data: "",
  loader: hE,
  onTilesetLoad: { type: "function", value: (t) => {
  } },
  onTileLoad: { type: "function", value: (t) => {
  } },
  onTileUnload: { type: "function", value: (t) => {
  } },
  onTileError: { type: "function", value: (t, e, i) => {
  } },
  _getMeshColor: { type: "function", value: (t) => [255, 255, 255] }
};
class tb extends uA {
  initializeState() {
    "onTileLoadFail" in this.props && Jt.removed("onTileLoadFail", "onTileError")(), this.state = {
      layerMap: {},
      tileset3d: null,
      activeViewports: {},
      lastUpdatedViewports: null
    };
  }
  get isLoaded() {
    return !!(this.state?.tileset3d?.isLoaded() && super.isLoaded);
  }
  shouldUpdateState({ changeFlags: e }) {
    return e.somethingChanged;
  }
  updateState({ props: e, oldProps: i, changeFlags: s }) {
    if (e.data && e.data !== i.data && this._loadTileset(e.data), s.viewportChanged) {
      const { activeViewports: o } = this.state;
      Object.keys(o).length && (this._updateTileset(o), this.state.lastUpdatedViewports = o, this.state.activeViewports = {});
    }
    if (s.propsChanged) {
      const { layerMap: o } = this.state;
      for (const u in o)
        o[u].needsUpdate = !0;
    }
  }
  activateViewport(e) {
    const { activeViewports: i, lastUpdatedViewports: s } = this.state;
    this.internalState.viewport = e, i[e.id] = e;
    const o = s?.[e.id];
    (!o || !e.equals(o)) && (this.setChangeFlags({ viewportChanged: !0 }), this.setNeedsUpdate());
  }
  getPickingInfo({ info: e, sourceLayer: i }) {
    const s = i && i.props.tile;
    return e.picked && (e.object = s), e.sourceTile = s, e;
  }
  filterSubLayer({ layer: e, viewport: i }) {
    const { tile: s } = e.props, { id: o } = i;
    return s.selected && s.viewportIds.includes(o);
  }
  _updateAutoHighlight(e) {
    const i = e.sourceTile, s = this.state.layerMap[i?.id];
    s && s.layer && s.layer.updateAutoHighlight(e);
  }
  async _loadTileset(e) {
    const { loadOptions: i = {} } = this.props, s = this.props.loader || this.props.loaders, o = Array.isArray(s) ? s[0] : s, u = { loadOptions: { ...i } };
    let d = e;
    if (o.preload) {
      const S = await o.preload(e, i);
      S.url && (d = S.url), S.headers && (u.loadOptions.fetch = {
        ...u.loadOptions.fetch,
        headers: S.headers
      }), Object.assign(u, S);
    }
    const a = await Ea(d, o, u.loadOptions), w = new Y5(a, {
      onTileLoad: this._onTileLoad.bind(this),
      onTileUnload: this._onTileUnload.bind(this),
      onTileError: this.props.onTileError,
      ...u
    });
    this.setState({
      tileset3d: w,
      layerMap: {}
    }), this._updateTileset(this.state.activeViewports), this.props.onTilesetLoad(w);
  }
  _onTileLoad(e) {
    const { lastUpdatedViewports: i } = this.state;
    this.props.onTileLoad(e), this._updateTileset(i), this.setNeedsUpdate();
  }
  _onTileUnload(e) {
    delete this.state.layerMap[e.id], this.props.onTileUnload(e);
  }
  _updateTileset(e) {
    if (!e)
      return;
    const { tileset3d: i } = this.state, { timeline: s } = this.context, o = Object.keys(e).length;
    !s || !o || !i || i.selectTiles(Object.values(e)).then((u) => {
      this.state.frameNumber !== u && this.setState({ frameNumber: u });
    });
  }
  _getSubLayer(e, i) {
    if (!e.content)
      return null;
    switch (e.type) {
      case Oo.POINTCLOUD:
        return this._makePointCloudLayer(e, i);
      case Oo.SCENEGRAPH:
        return this._make3DModelLayer(e);
      case Oo.MESH:
        return this._makeSimpleMeshLayer(e, i);
      default:
        throw new Error(`Tile3DLayer: Failed to render layer of type ${e.content.type}`);
    }
  }
  _makePointCloudLayer(e, i) {
    const { attributes: s, pointCount: o, constantRGBA: u, cartographicOrigin: d, modelMatrix: a } = e.content, { positions: w, normals: S, colors: M } = s;
    if (!w)
      return null;
    const F = i && i.props.data || {
      header: {
        vertexCount: o
      },
      attributes: {
        POSITION: w,
        NORMAL: S,
        COLOR_0: M
      }
    }, { pointSize: N, getPointColor: L } = this.props, re = this.getSubLayerClass("pointcloud", Ly);
    return new re({
      pointSize: N
    }, this.getSubLayerProps({
      id: "pointcloud"
    }), {
      id: `${this.id}-pointcloud-${e.id}`,
      tile: e,
      data: F,
      coordinateSystem: Xt.METER_OFFSETS,
      coordinateOrigin: d,
      modelMatrix: a,
      getColor: u || L,
      _offset: 0
    });
  }
  _make3DModelLayer(e) {
    const { gltf: i, instances: s, cartographicOrigin: o, modelMatrix: u } = e.content, d = this.getSubLayerClass("scenegraph", Wy);
    return new d({
      _lighting: "pbr"
    }, this.getSubLayerProps({
      id: "scenegraph"
    }), {
      id: `${this.id}-scenegraph-${e.id}`,
      tile: e,
      data: s || Z1,
      scenegraph: i,
      coordinateSystem: Xt.METER_OFFSETS,
      coordinateOrigin: o,
      modelMatrix: u,
      getTransformMatrix: (a) => a.modelMatrix,
      getPosition: [0, 0, 0],
      _offset: 0
    });
  }
  _makeSimpleMeshLayer(e, i) {
    const s = e.content, { attributes: o, indices: u, modelMatrix: d, cartographicOrigin: a, coordinateSystem: w = Xt.METER_OFFSETS, material: S, featureIds: M } = s, { _getMeshColor: F } = this.props, N = i && i.props.mesh || new eh({
      topology: "triangle-list",
      attributes: yV(o),
      indices: u
    }), L = this.getSubLayerClass("mesh", Xy);
    return new L(this.getSubLayerProps({
      id: "mesh"
    }), {
      id: `${this.id}-mesh-${e.id}`,
      tile: e,
      mesh: N,
      data: Z1,
      getColor: F(e),
      pbrMaterial: S,
      modelMatrix: d,
      coordinateOrigin: a,
      coordinateSystem: w,
      featureIds: M,
      _offset: 0
    });
  }
  renderLayers() {
    const { tileset3d: e, layerMap: i } = this.state;
    return e ? e.tiles.map((s) => {
      const o = i[s.id] = i[s.id] || { tile: s };
      let { layer: u } = o;
      return s.selected && (u ? o.needsUpdate && (u = this._getSubLayer(s, u), o.needsUpdate = !1) : u = this._getSubLayer(s)), o.layer = u, u;
    }).filter(Boolean) : null;
  }
}
tb.defaultProps = mV;
tb.layerName = "Tile3DLayer";
function yV(t) {
  const e = {};
  return e.positions = {
    ...t.positions,
    value: new Float32Array(t.positions.value)
  }, t.normals && (e.normals = t.normals), t.texCoords && (e.texCoords = t.texCoords), t.colors && (e.colors = t.colors), t.uvRegions && (e.uvRegions = t.uvRegions), e;
}
const im = 512, bV = Math.PI / 180;
function uE({ map: t, gl: e, deck: i }) {
  if (t.__deck)
    return t.__deck;
  const s = i?.props._customRender, o = i?.props.onLoad, u = fE({
    ...i?.props,
    _customRender: () => {
      t.triggerRepaint(), s?.("");
    }
  });
  let d;
  return (!i || i.props.gl === e) && (Object.assign(u, {
    gl: e,
    width: null,
    height: null,
    touchAction: "unset",
    viewState: id(t)
  }), i?.isInitialized ? K1(i, t) : u.onLoad = () => {
    o?.(), K1(d, t);
  }), i ? (d = i, i.setProps(u), i.userData.isExternal = !0) : (d = new Qu(u), t.on("remove", () => {
    dE(t);
  })), d.userData.mapboxLayers = /* @__PURE__ */ new Set(), t.__deck = d, t.on("render", () => {
    d.isInitialized && EV(d, t);
  }), d;
}
function K1(t, e) {
  const i = () => {
    t.isInitialized ? SV(t, e) : e.off("move", i);
  };
  e.on("move", i);
}
function dE(t) {
  t.__deck?.finalize(), t.__deck = null;
}
function fE(t) {
  return {
    ...t,
    // TODO: remove with withParametersWebGL
    parameters: {
      depthMask: !0,
      depthTest: !0,
      blend: !0,
      blendFunc: [770, 771, 1, 771],
      polygonOffsetFill: !0,
      depthFunc: 515,
      blendEquation: 32774,
      ...t.parameters
    },
    // @ts-ignore views prop is hidden by the types because it is not expected to work the same way as in standalone Deck, see documentation
    views: t.views || [new Py({ id: "mapbox" })]
  };
}
function vV(t, e) {
  t.userData.mapboxLayers.add(e), ib(t);
}
function xV(t, e) {
  t.userData.mapboxLayers.delete(e), ib(t);
}
function wV(t, e) {
  ib(t);
}
function TV(t, e, i) {
  let { currentViewport: s } = t.userData, o = !1;
  s || (s = pE(t, e, !0), t.userData.currentViewport = s, o = !0), t.isInitialized && t._drawLayers("mapbox-repaint", {
    viewports: [s],
    layerFilter: ({ layer: u }) => i.id === u.id || u.props.operation.includes("terrain"),
    clearStack: o,
    clearCanvas: !1
  });
}
function id(t) {
  const { lng: e, lat: i } = t.getCenter(), s = {
    // Longitude returned by getCenter can be outside of [-180, 180] when zooming near the anti meridian
    // https://github.com/visgl/deck.gl/issues/6894
    longitude: (e + 540) % 360 - 180,
    latitude: i,
    zoom: t.getZoom(),
    bearing: t.getBearing(),
    pitch: t.getPitch(),
    padding: t.getPadding(),
    repeat: t.getRenderWorldCopies()
  };
  return t.getTerrain?.() && AV(t, s), s;
}
function AV(t, e) {
  if (t.getFreeCameraOptions) {
    const { position: i } = t.getFreeCameraOptions();
    if (!i || i.z === void 0)
      return;
    const s = t.transform.height, { longitude: o, latitude: u, pitch: d } = e, a = i.x * im, w = (1 - i.y) * im, S = i.z * im, M = Zu([o, u]), F = a - M[0], N = w - M[1], L = Math.sqrt(F * F + N * N), re = d * bV, ne = 1.5 * s, we = re < 1e-3 ? (
      // Pitch angle too small to deduce the look at point, assume elevation is 0
      ne * Math.cos(re) / S
    ) : ne * Math.sin(re) / L;
    e.zoom = Math.log2(we);
    const Se = ne * Math.cos(re) / we, Ee = S - Se;
    e.position = [0, 0, Ee / ep(u)];
  } else typeof t.transform.elevation == "number" && (e.position = [0, 0, t.transform.elevation]);
}
function pE(t, e, i = !0) {
  return new Il({
    id: "mapbox",
    x: 0,
    y: 0,
    width: t.width,
    height: t.height,
    ...id(e),
    nearZMultiplier: i ? (
      // match mapbox-gl@>=1.3.0's projection matrix
      0.02
    ) : (
      // use deck.gl's own default
      0.1
    ),
    nearZ: e.transform._nearZ / e.transform.height,
    farZ: e.transform._farZ / e.transform.height
  });
}
function EV(t, e) {
  const { mapboxLayers: i, isExternal: s } = t.userData;
  if (s) {
    const o = Array.from(i, (M) => M.id), d = ch(t.props.layers, Boolean).some((M) => M && !o.includes(M.id));
    let a = t.getViewports();
    const w = a.findIndex((M) => M.id === "mapbox"), S = a.length > 1 || w < 0;
    (d || S) && (w >= 0 && (a = a.slice(), a[w] = pE(t, e, !1)), t._drawLayers("mapbox-repaint", {
      viewports: a,
      layerFilter: (M) => (!t.props.layerFilter || t.props.layerFilter(M)) && (M.viewport.id !== "mapbox" || !o.includes(M.layer.id)),
      clearCanvas: !1
    }));
  }
  t.userData.currentViewport = null;
}
function SV(t, e) {
  t.setProps({
    viewState: id(e)
  }), t.needsRedraw({ clearRedrawFlags: !0 });
}
function ib(t) {
  if (t.userData.isExternal)
    return;
  const e = [];
  t.userData.mapboxLayers.forEach((i) => {
    const s = i.props.type, o = new s(i.props);
    e.push(o);
  }), t.setProps({ layers: e });
}
class CV {
  /* eslint-disable no-this-before-super */
  constructor(e) {
    if (!e.id)
      throw new Error("Layer must have an unique id");
    this.id = e.id, this.type = "custom", this.renderingMode = e.renderingMode || "3d", this.map = null, this.deck = null, this.props = e;
  }
  /* Mapbox custom layer methods */
  onAdd(e, i) {
    this.map = e, this.deck = uE({ map: e, gl: i, deck: this.props.deck }), vV(this.deck, this);
  }
  onRemove() {
    this.deck && xV(this.deck, this);
  }
  setProps(e) {
    Object.assign(this.props, e, { id: this.id }), this.deck && wV(this.deck);
  }
  render() {
    TV(this.deck, this.map, this);
  }
}
const rm = "__UNDEFINED__";
function Zf(t, e, i, s) {
  if (!t || !e || !t.style || !t.style._loaded)
    return;
  const o = ch(s, Boolean);
  if (i !== s) {
    const a = ch(i, Boolean), w = new Set(a.map((S) => S.id));
    for (const S of o)
      w.delete(S.id);
    for (const S of w)
      t.getLayer(S) && t.removeLayer(S);
  }
  for (const a of o) {
    const w = t.getLayer(a.id);
    w ? (w.implementation || w).setProps(a.props) : t.addLayer(
      new CV({ id: a.id, deck: e }),
      // @ts-expect-error beforeId is not defined in LayerProps
      a.props.beforeId
    );
  }
  const u = t.style._order, d = {};
  for (const a of o) {
    let { beforeId: w } = a.props;
    (!w || !u.includes(w)) && (w = rm), d[w] = d[w] || [], d[w].push(a.id);
  }
  for (const a in d) {
    const w = d[a];
    let S = a === rm ? u.length : u.indexOf(a), M = a === rm ? void 0 : a;
    for (let F = w.length - 1; F >= 0; F--) {
      const N = w[F], L = u.indexOf(N);
      L !== S - 1 && (t.moveLayer(N, M), L > S && S++), S--, M = N;
    }
  }
}
class IV {
  constructor(e) {
    this._handleStyleChange = () => {
      Zf(this._map, this._deck, this._props.layers, this._props.layers);
    }, this._updateContainerSize = () => {
      if (this._map && this._container) {
        const { clientWidth: o, clientHeight: u } = this._map.getContainer();
        Object.assign(this._container.style, {
          width: `${o}px`,
          height: `${u}px`
        });
      }
    }, this._updateViewState = () => {
      const o = this._deck;
      o && (o.setProps({ viewState: id(this._map) }), o.isInitialized && o.redraw());
    }, this._handleMouseEvent = (o) => {
      const u = this._deck;
      if (!u || !u.isInitialized)
        return;
      const d = {
        type: o.type,
        offsetCenter: o.point,
        srcEvent: o
      }, a = this._lastMouseDownPoint;
      switch (!o.point && a && (d.deltaX = o.originalEvent.clientX - a.clientX, d.deltaY = o.originalEvent.clientY - a.clientY, d.offsetCenter = {
        x: a.x + d.deltaX,
        y: a.y + d.deltaY
      }), d.type) {
        case "mousedown":
          u._onPointerDown(d), this._lastMouseDownPoint = {
            ...o.point,
            clientX: o.originalEvent.clientX,
            clientY: o.originalEvent.clientY
          };
          break;
        case "dragstart":
          d.type = "panstart", u._onEvent(d);
          break;
        case "drag":
          d.type = "panmove", u._onEvent(d);
          break;
        case "dragend":
          d.type = "panend", u._onEvent(d);
          break;
        case "click":
          d.tapCount = 1, u._onEvent(d);
          break;
        case "dblclick":
          d.type = "click", d.tapCount = 2, u._onEvent(d);
          break;
        case "mousemove":
          d.type = "pointermove", u._onPointerMove(d);
          break;
        case "mouseout":
          d.type = "pointerleave", u._onPointerMove(d);
          break;
        default:
          return;
      }
    };
    const { interleaved: i = !1, ...s } = e;
    this._interleaved = i, this._props = s;
  }
  /** Update (partial) props of the underlying Deck instance. */
  setProps(e) {
    this._interleaved && e.layers && Zf(this._map, this._deck, this._props.layers, e.layers), Object.assign(this._props, e), this._deck && this._deck.setProps(this._interleaved ? fE(this._props) : this._props);
  }
  /** Called when the control is added to a map */
  onAdd(e) {
    return this._map = e, this._interleaved ? this._onAddInterleaved(e) : this._onAddOverlaid(e);
  }
  _onAddOverlaid(e) {
    const i = document.createElement("div");
    return Object.assign(i.style, {
      position: "absolute",
      left: 0,
      top: 0,
      textAlign: "initial",
      pointerEvents: "none"
    }), this._container = i, this._deck = new Qu({
      ...this._props,
      parent: i,
      viewState: id(e)
    }), e.on("resize", this._updateContainerSize), e.on("render", this._updateViewState), e.on("mousedown", this._handleMouseEvent), e.on("dragstart", this._handleMouseEvent), e.on("drag", this._handleMouseEvent), e.on("dragend", this._handleMouseEvent), e.on("mousemove", this._handleMouseEvent), e.on("mouseout", this._handleMouseEvent), e.on("click", this._handleMouseEvent), e.on("dblclick", this._handleMouseEvent), this._updateContainerSize(), i;
  }
  _onAddInterleaved(e) {
    const i = e.painter.context.gl;
    return i instanceof WebGLRenderingContext && Jt.warn("Incompatible basemap library. See: https://deck.gl/docs/api-reference/mapbox/overview#compatibility")(), this._deck = uE({
      map: e,
      gl: i,
      deck: new Qu({
        ...this._props,
        gl: i
      })
    }), e.on("styledata", this._handleStyleChange), Zf(e, this._deck, [], this._props.layers), document.createElement("div");
  }
  /** Called when the control is removed from a map */
  onRemove() {
    const e = this._map;
    e && (this._interleaved ? this._onRemoveInterleaved(e) : this._onRemoveOverlaid(e)), this._deck = void 0, this._map = void 0, this._container = void 0;
  }
  _onRemoveOverlaid(e) {
    e.off("resize", this._updateContainerSize), e.off("render", this._updateViewState), e.off("mousedown", this._handleMouseEvent), e.off("dragstart", this._handleMouseEvent), e.off("drag", this._handleMouseEvent), e.off("dragend", this._handleMouseEvent), e.off("mousemove", this._handleMouseEvent), e.off("mouseout", this._handleMouseEvent), e.off("click", this._handleMouseEvent), e.off("dblclick", this._handleMouseEvent), this._deck?.finalize();
  }
  _onRemoveInterleaved(e) {
    e.off("styledata", this._handleStyleChange), Zf(e, this._deck, this._props.layers, []), dE(e);
  }
  getDefaultPosition() {
    return "top-left";
  }
  /** Forwards the Deck.pickObject method */
  pickObject(e) {
    return Tr(this._deck), this._deck.pickObject(e);
  }
  /** Forwards the Deck.pickMultipleObjects method */
  pickMultipleObjects(e) {
    return Tr(this._deck), this._deck.pickMultipleObjects(e);
  }
  /** Forwards the Deck.pickObjects method */
  pickObjects(e) {
    return Tr(this._deck), this._deck.pickObjects(e);
  }
  /** Remove from map and releases all resources */
  finalize() {
    this._map && this._map.removeControl(this);
  }
  /** If interleaved: true, returns base map's canvas, otherwise forwards the Deck.getCanvas method. */
  getCanvas() {
    return this._map ? this._interleaved ? this._map.getCanvas() : this._deck.getCanvas() : null;
  }
}
class MV {
  olaMaps;
  apiKey;
  accessToken;
  mode;
  threedTileset;
  // Static properties to expose MapLibre GL components through OlaMaps
  static Marker = Ii.Marker;
  static Popup = Ii.Popup;
  static NavigationControl = Ii.NavigationControl;
  static GeolocateControl = Ii.GeolocateControl;
  static ScaleControl = Ii.ScaleControl;
  static FullscreenControl = Ii.FullscreenControl;
  static AttributionControl = Ii.AttributionControl;
  static TerrainControl = Ii.TerrainControl;
  // Static utility classes
  static LngLat = Ii.LngLat;
  static LngLatBounds = Ii.LngLatBounds;
  static Point = Ii.Point;
  static MercatorCoordinate = Ii.MercatorCoordinate;
  // Static event classes
  static MapMouseEvent = Ii.MapMouseEvent;
  static MapTouchEvent = Ii.MapTouchEvent;
  static MapWheelEvent = Ii.MapWheelEvent;
  // Static error classes
  static AJAXError = Ii.AJAXError;
  constructor({ apiKey: e, accessToken: i = "", mode: s = "2d", threedTileset: o = fC }) {
    this.apiKey = e, this.mode = s, this.threedTileset = o, this.accessToken = i;
  }
  addOlaLogo(e) {
    if (typeof window > "u") return;
    const i = document.getElementsByClassName("maplibregl-ctrl-bottom-left");
    let s = "#000";
    e.style?.includes("dark") && (s = "#FFF");
    for (let o = 0; o < i.length; o++) {
      const u = document.createElement("div");
      u.style.position = "absolute", u.style.bottom = "4px", u.style.left = "10px", u.style.zIndex = "1000", u.innerHTML = pC(s), i[o].appendChild(u);
    }
  }
  addAttribution() {
    document.querySelectorAll(".maplibregl-ctrl-bottom-right .maplibregl-ctrl-attrib-inner")?.forEach((i) => {
      const s = i.querySelector("a");
      s && (s.style.display = "none");
      const o = "ola-maps-link";
      if (!i.querySelector(`#${o}`)) {
        const d = document.createElement("a");
        d.id = o, d.href = "https://maps.olakrutrim.com/", d.target = "_blank", d.textContent = "Ola Maps ", i.appendChild(d);
      }
      const u = "osm-link";
      if (!i.querySelector(`#${u}`)) {
        const d = document.createElement("a");
        d.id = u, d.href = "https://www.openstreetmap.org/copyright", d.target = "_blank", d.textContent = "| © OpenStreetMap contributors", i.appendChild(d);
      }
    });
  }
  fetchStaticMap(e) {
    try {
      return fetch(e).then((i) => i.blob());
    } catch (i) {
      console.log(i);
    }
  }
  async add3dLayer() {
    if (!this.threedTileset)
      throw new Error("3d Tileset is not initialized");
    const e = new tb({
      id: "tile-3d-layer",
      data: `${this.threedTileset}?api_key=${this.apiKey}`,
      beforeId: "poi_railway"
    }), i = new IV({
      interleaved: !0,
      layers: [e]
    });
    i && this.olaMaps.on("style.load", () => {
      this.olaMaps.setFilter("building-3d", [
        "all",
        [
          "!has",
          "hide_3d"
        ],
        [
          "!=",
          "render_as_3d",
          !0
        ]
      ]), this.olaMaps.addControl(i);
    });
  }
  init(e) {
    this.olaMaps = new Ii.Map({
      container: e?.container || "map",
      center: e?.center || [0, 0],
      zoom: e?.zoom || 9,
      hash: e?.hash || !1,
      style: e?.style || dC,
      transformRequest: (o, u) => {
        if (this.accessToken)
          return {
            url: o,
            headers: { Authorization: `Bearer ${this.accessToken}` }
          };
        {
          const d = new URL(o);
          return u !== "Image" && d.searchParams.append("api_key", this.apiKey), {
            url: d.toString()
          };
        }
      },
      ...e
    }), this.mode === "3d" && this.add3dLayer(), this.addOlaLogo(e), this.addAttribution();
    const i = {};
    return Object.getOwnPropertyNames(Ii.Map.prototype).forEach((o) => {
      typeof this.olaMaps[o] == "function" && (i[o] = this.olaMaps[o].bind(this.olaMaps));
    }), Object.keys(vf).forEach((o) => {
      typeof vf[o] == "function" ? i[o] = (...u) => new vf[o](...u) : i[o] = vf[o];
    }), Object.getOwnPropertyNames(this.olaMaps).forEach((o) => {
      o in i || (i[o] = this.olaMaps[o]);
    }), Object.assign(this.olaMaps, i);
  }
  addNavigationControls(e) {
    return new Ii.NavigationControl(e);
  }
  addGeolocateControls(e) {
    return new Ii.GeolocateControl(e);
  }
  getMercatorCoordinate() {
    return Ii.MercatorCoordinate;
  }
  addMarker(e) {
    return new Ii.Marker(e);
  }
  addPopup(e) {
    return new Ii.Popup(e);
  }
  getStaticMap(e, i) {
    this.fetchStaticMap(e)?.then((o) => {
      const u = URL.createObjectURL(o), d = document.createElement("img");
      d.src = u;
      const a = document.getElementById(i);
      a && !a.querySelector("img") ? a?.appendChild(d) : console.log("An image already exists in the element.");
    }).catch((o) => console.error(o));
  }
}
typeof window < "u" && (window.OlaMaps = MV);
const BV = (t) => {
  const i = decodeURIComponent(document.cookie).split(";");
  for (let s = 0; s < i.length; s++) {
    const o = i[s].trim();
    if (o.indexOf(t) === 0)
      return o.substring(t.length, o.length);
  }
  return "";
}, DV = (t, e, i) => {
  let s = "";
  if (i) {
    const o = /* @__PURE__ */ new Date();
    o.setTime(o.getTime() + i * 24 * 60 * 60 * 1e3), s = `; expires=${o.toUTCString()}`;
  }
  document.cookie = `${t}=${e || ""}${s}; path=/`;
};
export {
  MV as OlaMaps,
  fC as default3dTIleset,
  dC as defaultStyleJson,
  BV as getCookie,
  pC as getOlaMapIcon,
  DV as setCookie
};
